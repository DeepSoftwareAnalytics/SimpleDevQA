[
    {
        "link": "https://swapi.dev/documentation",
        "document": "Welcome to the swapi, the Star Wars API! This documentation should help you familiarise yourself with the resources available and how to consume them with HTTP requests. If you're after a native helper library then I suggest you scroll down and check out what's available. Read through the getting started section before you dive in. Most of your problems should be solved just by reading through it.\n\nLet's make our first API request to the Star Wars API!\n\nOpen up a terminal and use curl or httpie to make an API request for a resource. In the example below, we're trying to get the first planet, Tatooine:\n\nWe'll use httpie for our examples as it displays responses nicely and gives us a whole lot more useful information. If you don't want to download httpie, just use the curl command instead.\n\nHere is the response we get:\n\nIf your response looks slightly different don't panic. This is probably because more data has been added to swapi since we made this documentation.\n\nThe Base URL is the root URL for all of the API, if you ever make a request to swapi and you get back a 404 NOT FOUND response then check the Base URL first.\n\nThe Base URL for swapi is:\n\nThe documentation below assumes you are prepending the Base URL to the endpoints in order to make requests.\n\nSwapi has rate limiting to prevent malicious abuse (as if anyone would abuse Star Wars data!) and to make sure our service can handle a potentially large amount of traffic. Rate limiting is done via IP address and is currently limited to 10,000 API request per day. This is enough to request all the data on the website at least ten times over. There should be no reason for hitting the rate limit.\n\nSwapi is a completely open API. No authentication is required to query and get data. This also means that we've limited what you can do to just GET-ing the data. If you find a mistake in the data, then tweet the author or email him.\n\nAll resources support JSON Schema. Making a request to will give you the details of that resource. This will allow you to programmatically inspect the attributes of that resource and their types.\n\nAll resources support a parameter that filters the set of resources returned. This allows you to make queries like:\n\nAll searches will use case-insensitive partial matches on the set of search fields. To see the set of search fields for each resource, check out the individual resource documentation. For more information on advanced search terms see here.\n\nSWAPI provides two encodings for you to render the data with:\n\nJSON is the standard data format provided by SWAPI by default.\n\nWookiee is for our tall hairy allies who speak Wookiee, this encoding is identical to JSON except with wookiee translations.\n\nUsing the wookiee renderer is easy, just append to your urls:\n\nThe Root resource provides information on all available resources within the API.\n\nA People resource is an individual person or character within the Star Wars universe.\nâ€¢ -- get all the people resources\nâ€¢ -- view the JSON schema for this resource\nâ€¢ string -- The name of this person.\nâ€¢ string -- The birth year of the person, using the in-universe standard of BBY or ABY - Before the Battle of Yavin or After the Battle of Yavin. The Battle of Yavin is a battle that occurs at the end of Star Wars episode IV: A New Hope.\nâ€¢ string -- The eye color of this person. Will be \"unknown\" if not known or \"n/a\" if the person does not have an eye.\nâ€¢ string -- The gender of this person. Either \"Male\", \"Female\" or \"unknown\", \"n/a\" if the person does not have a gender.\nâ€¢ string -- The hair color of this person. Will be \"unknown\" if not known or \"n/a\" if the person does not have hair.\nâ€¢ string -- The height of the person in centimeters.\nâ€¢ string -- The mass of the person in kilograms.\nâ€¢ string -- The skin color of this person.\nâ€¢ string -- The URL of a planet resource, a planet that this person was born on or inhabits.\nâ€¢ array -- An array of film resource URLs that this person has been in.\nâ€¢ array -- An array of species resource URLs that this person belongs to.\nâ€¢ array -- An array of starship resource URLs that this person has piloted.\nâ€¢ array -- An array of vehicle resource URLs that this person has piloted.\nâ€¢ string -- the hypermedia URL of this resource.\nâ€¢ string -- the ISO 8601 date format of the time that this resource was created.\nâ€¢ string -- the ISO 8601 date format of the time that this resource was edited.\nâ€¢ -- get all the film resources\nâ€¢ -- view the JSON schema for this resource\nâ€¢ string -- The title of this film\nâ€¢ integer -- The episode number of this film.\nâ€¢ string -- The opening paragraphs at the beginning of this film.\nâ€¢ string -- The name of the director of this film.\nâ€¢ string -- The name(s) of the producer(s) of this film. Comma separated.\nâ€¢ date -- The ISO 8601 date format of film release at original creator country.\nâ€¢ array -- An array of species resource URLs that are in this film.\nâ€¢ array -- An array of starship resource URLs that are in this film.\nâ€¢ array -- An array of vehicle resource URLs that are in this film.\nâ€¢ array -- An array of people resource URLs that are in this film.\nâ€¢ array -- An array of planet resource URLs that are in this film.\nâ€¢ string -- the hypermedia URL of this resource.\nâ€¢ string -- the ISO 8601 date format of the time that this resource was created.\nâ€¢ string -- the ISO 8601 date format of the time that this resource was edited.\n\nA Starship resource is a single transport craft that has hyperdrive capability.\nâ€¢ -- get all the starship resources\nâ€¢ -- view the JSON schema for this resource\nâ€¢ string -- The name of this starship. The common name, such as \"Death Star\".\nâ€¢ string -- The model or official name of this starship. Such as \"T-65 X-wing\" or \"DS-1 Orbital Battle Station\".\nâ€¢ string -- The class of this starship, such as \"Starfighter\" or \"Deep Space Mobile Battlestation\"\nâ€¢ string -- The manufacturer of this starship. Comma separated if more than one.\nâ€¢ string -- The cost of this starship new, in galactic credits.\nâ€¢ string -- The length of this starship in meters.\nâ€¢ string -- The number of personnel needed to run or pilot this starship.\nâ€¢ string -- The number of non-essential people this starship can transport.\nâ€¢ string -- The maximum speed of this starship in the atmosphere. \"N/A\" if this starship is incapable of atmospheric flight.\nâ€¢ string -- The class of this starships hyperdrive.\nâ€¢ string -- The Maximum number of Megalights this starship can travel in a standard hour. A \"Megalight\" is a standard unit of distance and has never been defined before within the Star Wars universe. This figure is only really useful for measuring the difference in speed of starships. We can assume it is similar to AU, the distance between our Sun (Sol) and Earth.\nâ€¢ string -- The maximum number of kilograms that this starship can transport.\nâ€¢ The maximum length of time that this starship can provide consumables for its entire crew without having to resupply.\nâ€¢ array -- An array of Film URL Resources that this starship has appeared in.\nâ€¢ array -- An array of People URL Resources that this starship has been piloted by.\nâ€¢ string -- the hypermedia URL of this resource.\nâ€¢ string -- the ISO 8601 date format of the time that this resource was created.\nâ€¢ string -- the ISO 8601 date format of the time that this resource was edited.\n\nA Vehicle resource is a single transport craft that does not have hyperdrive capability.\nâ€¢ -- get all the vehicle resources\nâ€¢ -- view the JSON schema for this resource\nâ€¢ string -- The name of this vehicle. The common name, such as \"Sand Crawler\" or \"Speeder bike\".\nâ€¢ string -- The model or official name of this vehicle. Such as \"All-Terrain Attack Transport\".\nâ€¢ string -- The class of this vehicle, such as \"Wheeled\" or \"Repulsorcraft\".\nâ€¢ string -- The manufacturer of this vehicle. Comma separated if more than one.\nâ€¢ string -- The length of this vehicle in meters.\nâ€¢ string -- The cost of this vehicle new, in Galactic Credits.\nâ€¢ string -- The number of personnel needed to run or pilot this vehicle.\nâ€¢ string -- The number of non-essential people this vehicle can transport.\nâ€¢ string -- The maximum speed of this vehicle in the atmosphere.\nâ€¢ string -- The maximum number of kilograms that this vehicle can transport.\nâ€¢ The maximum length of time that this vehicle can provide consumables for its entire crew without having to resupply.\nâ€¢ array -- An array of Film URL Resources that this vehicle has appeared in.\nâ€¢ array -- An array of People URL Resources that this vehicle has been piloted by.\nâ€¢ string -- the hypermedia URL of this resource.\nâ€¢ string -- the ISO 8601 date format of the time that this resource was created.\nâ€¢ string -- the ISO 8601 date format of the time that this resource was edited.\n\nA Species resource is a type of person or character within the Star Wars Universe.\nâ€¢ -- get all the species resources\nâ€¢ -- view the JSON schema for this resource\nâ€¢ string -- The name of this species.\nâ€¢ string -- The classification of this species, such as \"mammal\" or \"reptile\".\nâ€¢ string -- The designation of this species, such as \"sentient\".\nâ€¢ string -- The average height of this species in centimeters.\nâ€¢ string -- The average lifespan of this species in years.\nâ€¢ string -- A comma-separated string of common eye colors for this species, \"none\" if this species does not typically have eyes.\nâ€¢ string -- A comma-separated string of common hair colors for this species, \"none\" if this species does not typically have hair.\nâ€¢ string -- A comma-separated string of common skin colors for this species, \"none\" if this species does not typically have skin.\nâ€¢ string -- The language commonly spoken by this species.\nâ€¢ string -- The URL of a planet resource, a planet that this species originates from.\nâ€¢ array -- An array of People URL Resources that are a part of this species.\nâ€¢ array -- An array of Film URL Resources that this species has appeared in.\nâ€¢ string -- the hypermedia URL of this resource.\nâ€¢ string -- the ISO 8601 date format of the time that this resource was created.\nâ€¢ string -- the ISO 8601 date format of the time that this resource was edited.\n\nA Planet resource is a large mass, planet or planetoid in the Star Wars Universe, at the time of 0 ABY.\nâ€¢ -- get all the planets resources\nâ€¢ -- view the JSON schema for this resource\nâ€¢ string -- The name of this planet.\nâ€¢ string -- The diameter of this planet in kilometers.\nâ€¢ string -- The number of standard hours it takes for this planet to complete a single rotation on its axis.\nâ€¢ string -- The number of standard days it takes for this planet to complete a single orbit of its local star.\nâ€¢ string -- A number denoting the gravity of this planet, where \"1\" is normal or 1 standard G. \"2\" is twice or 2 standard Gs. \"0.5\" is half or 0.5 standard Gs.\nâ€¢ string -- The average population of sentient beings inhabiting this planet.\nâ€¢ string -- The climate of this planet. Comma separated if diverse.\nâ€¢ string -- The terrain of this planet. Comma separated if diverse.\nâ€¢ string -- The percentage of the planet surface that is naturally occurring water or bodies of water.\nâ€¢ array -- An array of People URL Resources that live on this planet.\nâ€¢ array -- An array of Film URL Resources that this planet has appeared in.\nâ€¢ string -- the hypermedia URL of this resource.\nâ€¢ string -- the ISO 8601 date format of the time that this resource was created.\nâ€¢ string -- the ISO 8601 date format of the time that this resource was edited.\n\nThere are a bunch of helper libraries available for consuming the Star Wars API in a native programming language.\nâ€¢ swapi-python is built by the author of swapi, Paul Hallett."
    },
    {
        "link": "https://swapi.dev",
        "document": "Need a hint? try people/1/ or planets/3/ or starships/9/\n\nWhat is this? The Star Wars API, or \"swapi\" (Swah-pee) is the world's first quantified and programmatically-accessible data source for all the data from the Star Wars canon universe! We've taken all the rich contextual stuff from the universe and formatted into something easier to consume with software. Then we went and stuck an API on the front so you can access it all!\n\nHow can I use it? All the data is accessible through our HTTP web API. Consult our documentation if you'd like to get started. Helper libraries for popular programming languages are also provided so you can consume swapi in your favourite programming language, in a style that suits you.\n\nWhat happened with old swapi.co? swapi.co is not supported and maintained anymore. But since so many projects and tutorials used it as their educational playground, this is an \"unofficial\" branch. This project is open source and you can contribute on GitHub."
    },
    {
        "link": "https://swapi.py4e.com/documentation",
        "document": "Welcome to the swapi, the Star Wars API! This documentation should help you familiarise yourself with the resources available and how to consume them with HTTP requests. If you're after a native helper library then I suggest you scroll down and check out what's available. Read through the getting started section before you dive in. Most of your problems should be solved just by reading through it.\n\nLet's make our first API request to the Star Wars API!\n\nOpen up a terminal and use curl or httpie to make an API request for a resource. In the example below, we're trying to get the first planet, Tatooine:\n\nWe'll use httpie for our examples as it displays responses nicely and gives us a whole lot more useful information. If you don't want to download httpie, just use the curl command instead.\n\nHere is the response we get:\n\nIf your response looks slightly different don't panic. This is probably because more data has been added to swapi since we made this documentation.\n\nThe Base URL is the root URL for all of the API, if you ever make a request to swapi and you get back a 404 NOT FOUND response then check the Base URL first.\n\nThe Base URL for swapi is:\n\nThe documentation below assumes you are prepending the Base URL to the endpoints in order to make requests.\n\nSwapi has rate limiting to prevent malicious abuse (as if anyone would abuse Star Wars data!) and to make sure our service can handle a potentially large amount of traffic. Rate limiting is done via IP address and is currently limited to 10,000 API request per day. This is enough to request all the data on the website at least ten times over. There should be no reason for hitting the rate limit.\n\nSwapi is a completely open API. No authentication is required to query and get data. This also means that we've limited what you can do to just GET-ing the data. If you find a mistake in the data, then tweet the person supporting the site.\n\nAll resources support JSON Schema. Making a request to will give you the details of that resource. This will allow you to programmatically inspect the attributes of that resource and their types.\n\nAll resources support a parameter that filters the set of resources returned. This allows you to make queries like:\n\nAll searches will use case-insensitive partial matches on the set of search fields. To see the set of search fields for each resource, check out the individual resource documentation. For more information on advanced search terms see here.\n\nSWAPI provides two encodings for you to render the data with:\n\nJSON is the standard data format provided by SWAPI by default.\n\nWookiee is for our tall hairy allies who speak Wookiee, this encoding is identical to JSON except with wookiee translations.\n\nUsing the wookiee renderer is easy, just append to your urls:\n\nThe Root resource provides information on all available resources within the API.\n\nA People resource is an individual person or character within the Star Wars universe.\nâ€¢ -- get all the people resources\nâ€¢ -- view the JSON schema for this resource\nâ€¢ string -- The name of this person.\nâ€¢ string -- The birth year of the person, using the in-universe standard of BBY or ABY - Before the Battle of Yavin or After the Battle of Yavin. The Battle of Yavin is a battle that occurs at the end of Star Wars episode IV: A New Hope.\nâ€¢ string -- The eye color of this person. Will be \"unknown\" if not known or \"n/a\" if the person does not have an eye.\nâ€¢ string -- The gender of this person. Either \"Male\", \"Female\" or \"unknown\", \"n/a\" if the person does not have a gender.\nâ€¢ string -- The hair color of this person. Will be \"unknown\" if not known or \"n/a\" if the person does not have hair.\nâ€¢ string -- The height of the person in centimeters.\nâ€¢ string -- The mass of the person in kilograms.\nâ€¢ string -- The skin color of this person.\nâ€¢ string -- The URL of a planet resource, a planet that this person was born on or inhabits.\nâ€¢ array -- An array of film resource URLs that this person has been in.\nâ€¢ array -- An array of species resource URLs that this person belongs to.\nâ€¢ array -- An array of starship resource URLs that this person has piloted.\nâ€¢ array -- An array of vehicle resource URLs that this person has piloted.\nâ€¢ string -- the hypermedia URL of this resource.\nâ€¢ string -- the ISO 8601 date format of the time that this resource was created.\nâ€¢ string -- the ISO 8601 date format of the time that this resource was edited.\nâ€¢ -- get all the film resources\nâ€¢ -- view the JSON schema for this resource\nâ€¢ string -- The title of this film\nâ€¢ integer -- The episode number of this film.\nâ€¢ string -- The opening paragraphs at the beginning of this film.\nâ€¢ string -- The name of the director of this film.\nâ€¢ string -- The name(s) of the producer(s) of this film. Comma separated.\nâ€¢ date -- The ISO 8601 date format of film release at original creator country.\nâ€¢ array -- An array of species resource URLs that are in this film.\nâ€¢ array -- An array of starship resource URLs that are in this film.\nâ€¢ array -- An array of vehicle resource URLs that are in this film.\nâ€¢ array -- An array of people resource URLs that are in this film.\nâ€¢ array -- An array of planet resource URLs that are in this film.\nâ€¢ string -- the hypermedia URL of this resource.\nâ€¢ string -- the ISO 8601 date format of the time that this resource was created.\nâ€¢ string -- the ISO 8601 date format of the time that this resource was edited.\n\nA Starship resource is a single transport craft that has hyperdrive capability.\nâ€¢ -- get all the starship resources\nâ€¢ -- view the JSON schema for this resource\nâ€¢ string -- The name of this starship. The common name, such as \"Death Star\".\nâ€¢ string -- The model or official name of this starship. Such as \"T-65 X-wing\" or \"DS-1 Orbital Battle Station\".\nâ€¢ string -- The class of this starship, such as \"Starfighter\" or \"Deep Space Mobile Battlestation\"\nâ€¢ string -- The manufacturer of this starship. Comma separated if more than one.\nâ€¢ string -- The cost of this starship new, in galactic credits.\nâ€¢ string -- The length of this starship in meters.\nâ€¢ string -- The number of personnel needed to run or pilot this starship.\nâ€¢ string -- The number of non-essential people this starship can transport.\nâ€¢ string -- The maximum speed of this starship in the atmosphere. \"N/A\" if this starship is incapable of atmospheric flight.\nâ€¢ string -- The class of this starships hyperdrive.\nâ€¢ string -- The Maximum number of Megalights this starship can travel in a standard hour. A \"Megalight\" is a standard unit of distance and has never been defined before within the Star Wars universe. This figure is only really useful for measuring the difference in speed of starships. We can assume it is similar to AU, the distance between our Sun (Sol) and Earth.\nâ€¢ string -- The maximum number of kilograms that this starship can transport.\nâ€¢ The maximum length of time that this starship can provide consumables for its entire crew without having to resupply.\nâ€¢ array -- An array of Film URL Resources that this starship has appeared in.\nâ€¢ array -- An array of People URL Resources that this starship has been piloted by.\nâ€¢ string -- the hypermedia URL of this resource.\nâ€¢ string -- the ISO 8601 date format of the time that this resource was created.\nâ€¢ string -- the ISO 8601 date format of the time that this resource was edited.\n\nA Vehicle resource is a single transport craft that does not have hyperdrive capability.\nâ€¢ -- get all the vehicle resources\nâ€¢ -- view the JSON schema for this resource\nâ€¢ string -- The name of this vehicle. The common name, such as \"Sand Crawler\" or \"Speeder bike\".\nâ€¢ string -- The model or official name of this vehicle. Such as \"All-Terrain Attack Transport\".\nâ€¢ string -- The class of this vehicle, such as \"Wheeled\" or \"Repulsorcraft\".\nâ€¢ string -- The manufacturer of this vehicle. Comma separated if more than one.\nâ€¢ string -- The length of this vehicle in meters.\nâ€¢ string -- The cost of this vehicle new, in Galactic Credits.\nâ€¢ string -- The number of personnel needed to run or pilot this vehicle.\nâ€¢ string -- The number of non-essential people this vehicle can transport.\nâ€¢ string -- The maximum speed of this vehicle in the atmosphere.\nâ€¢ string -- The maximum number of kilograms that this vehicle can transport.\nâ€¢ The maximum length of time that this vehicle can provide consumables for its entire crew without having to resupply.\nâ€¢ array -- An array of Film URL Resources that this vehicle has appeared in.\nâ€¢ array -- An array of People URL Resources that this vehicle has been piloted by.\nâ€¢ string -- the hypermedia URL of this resource.\nâ€¢ string -- the ISO 8601 date format of the time that this resource was created.\nâ€¢ string -- the ISO 8601 date format of the time that this resource was edited.\n\nA Species resource is a type of person or character within the Star Wars Universe.\nâ€¢ -- get all the species resources\nâ€¢ -- view the JSON schema for this resource\nâ€¢ string -- The name of this species.\nâ€¢ string -- The classification of this species, such as \"mammal\" or \"reptile\".\nâ€¢ string -- The designation of this species, such as \"sentient\".\nâ€¢ string -- The average height of this species in centimeters.\nâ€¢ string -- The average lifespan of this species in years.\nâ€¢ string -- A comma-separated string of common eye colors for this species, \"none\" if this species does not typically have eyes.\nâ€¢ string -- A comma-separated string of common hair colors for this species, \"none\" if this species does not typically have hair.\nâ€¢ string -- A comma-separated string of common skin colors for this species, \"none\" if this species does not typically have skin.\nâ€¢ string -- The language commonly spoken by this species.\nâ€¢ string -- The URL of a planet resource, a planet that this species originates from.\nâ€¢ array -- An array of People URL Resources that are a part of this species.\nâ€¢ array -- An array of Film URL Resources that this species has appeared in.\nâ€¢ string -- the hypermedia URL of this resource.\nâ€¢ string -- the ISO 8601 date format of the time that this resource was created.\nâ€¢ string -- the ISO 8601 date format of the time that this resource was edited.\n\nA Planet resource is a large mass, planet or planetoid in the Star Wars Universe, at the time of 0 ABY.\nâ€¢ -- get all the planets resources\nâ€¢ -- view the JSON schema for this resource\nâ€¢ string -- The name of this planet.\nâ€¢ string -- The diameter of this planet in kilometers.\nâ€¢ string -- The number of standard hours it takes for this planet to complete a single rotation on its axis.\nâ€¢ string -- The number of standard days it takes for this planet to complete a single orbit of its local star.\nâ€¢ string -- A number denoting the gravity of this planet, where \"1\" is normal or 1 standard G. \"2\" is twice or 2 standard Gs. \"0.5\" is half or 0.5 standard Gs.\nâ€¢ string -- The average population of sentient beings inhabiting this planet.\nâ€¢ string -- The climate of this planet. Comma separated if diverse.\nâ€¢ string -- The terrain of this planet. Comma separated if diverse.\nâ€¢ string -- The percentage of the planet surface that is naturally occurring water or bodies of water.\nâ€¢ array -- An array of People URL Resources that live on this planet.\nâ€¢ array -- An array of Film URL Resources that this planet has appeared in.\nâ€¢ string -- the hypermedia URL of this resource.\nâ€¢ string -- the ISO 8601 date format of the time that this resource was created.\nâ€¢ string -- the ISO 8601 date format of the time that this resource was edited.\n\nThere are a bunch of helper libraries available for consuming the Star Wars API in a native programming language.\nâ€¢ swapi-python is built by the author of swapi, Paul Hallett."
    },
    {
        "link": "https://swapi.tech/documentation",
        "document": ""
    },
    {
        "link": "https://swapi-api.hbtn.io/documentation",
        "document": "Welcome to the swapi, the Star Wars API! This documentation should help you familiarise yourself with the resources available and how to consume them with HTTP requests. If you're after a native helper library then I suggest you scroll down and check out what's available. Read through the getting started section before you dive in. Most of your problems should be solved just by reading through it.\n\nLet's make our first API request to the Star Wars API!\n\nOpen up a terminal and use curl or httpie to make an API request for a resource. In the example below, we're trying to get the first planet, Tatooine:\n\nWe'll use httpie for our examples as it displays responses nicely and gives us a whole lot more useful information. If you don't want to download httpie, just use the curl command instead.\n\nHere is the response we get:\n\nIf your response looks slightly different don't panic. This is probably because more data has been added to swapi since we made this documentation.\n\nThe Base URL is the root URL for all of the API, if you ever make a request to swapi and you get back a 404 NOT FOUND response then check the Base URL first.\n\nThe Base URL for swapi is:\n\nThe documentation below assumes you are prepending the Base URL to the endpoints in order to make requests.\n\nSwapi has rate limiting to prevent malicious abuse (as if anyone would abuse Star Wars data!) and to make sure our service can handle a potentially large amount of traffic. Rate limiting is done via IP address and is currently limited to 10,000 API request per day. This is enough to request all the data on the website at least ten times over. There should be no reason for hitting the rate limit.\n\nSwapi is a completely open API. No authentication is required to query and get data. This also means that we've limited what you can do to just GET-ing the data.\n\nAll resources support JSON Schema. Making a request to will give you the details of that resource. This will allow you to programmatically inspect the attributes of that resource and their types.\n\nAll resources support a parameter that filters the set of resources returned. This allows you to make queries like:\n\nAll searches will use case-insensitive partial matches on the set of search fields. To see the set of search fields for each resource, check out the individual resource documentation. For more information on advanced search terms see here.\n\nSWAPI provides two encodings for you to render the data with:\n\nJSON is the standard data format provided by SWAPI by default.\n\nWookiee is for our tall hairy allies who speak Wookiee, this encoding is identical to JSON except with wookiee translations.\n\nUsing the wookiee renderer is easy, just append to your urls:\n\nThe Root resource provides information on all available resources within the API.\n\nA People resource is an individual person or character within the Star Wars universe.\nâ€¢ -- get all the people resources\nâ€¢ -- view the JSON schema for this resource\nâ€¢ string -- The name of this person.\nâ€¢ string -- The birth year of the person, using the in-universe standard of BBY or ABY - Before the Battle of Yavin or After the Battle of Yavin. The Battle of Yavin is a battle that occurs at the end of Star Wars episode IV: A New Hope.\nâ€¢ string -- The eye color of this person. Will be \"unknown\" if not known or \"n/a\" if the person does not have an eye.\nâ€¢ string -- The gender of this person. Either \"Male\", \"Female\" or \"unknown\", \"n/a\" if the person does not have a gender.\nâ€¢ string -- The hair color of this person. Will be \"unknown\" if not known or \"n/a\" if the person does not have hair.\nâ€¢ string -- The height of the person in centimeters.\nâ€¢ string -- The mass of the person in kilograms.\nâ€¢ string -- The skin color of this person.\nâ€¢ string -- The URL of a planet resource, a planet that this person was born on or inhabits.\nâ€¢ array -- An array of film resource URLs that this person has been in.\nâ€¢ array -- An array of species resource URLs that this person belongs to.\nâ€¢ array -- An array of starship resource URLs that this person has piloted.\nâ€¢ array -- An array of vehicle resource URLs that this person has piloted.\nâ€¢ string -- the hypermedia URL of this resource.\nâ€¢ string -- the ISO 8601 date format of the time that this resource was created.\nâ€¢ string -- the ISO 8601 date format of the time that this resource was edited.\nâ€¢ -- get all the film resources\nâ€¢ -- view the JSON schema for this resource\nâ€¢ string -- The title of this film\nâ€¢ integer -- The episode number of this film.\nâ€¢ string -- The opening paragraphs at the beginning of this film.\nâ€¢ string -- The name of the director of this film.\nâ€¢ string -- The name(s) of the producer(s) of this film. Comma separated.\nâ€¢ date -- The ISO 8601 date format of film release at original creator country.\nâ€¢ array -- An array of species resource URLs that are in this film.\nâ€¢ array -- An array of starship resource URLs that are in this film.\nâ€¢ array -- An array of vehicle resource URLs that are in this film.\nâ€¢ array -- An array of people resource URLs that are in this film.\nâ€¢ array -- An array of planet resource URLs that are in this film.\nâ€¢ string -- the hypermedia URL of this resource.\nâ€¢ string -- the ISO 8601 date format of the time that this resource was created.\nâ€¢ string -- the ISO 8601 date format of the time that this resource was edited.\n\nA Starship resource is a single transport craft that has hyperdrive capability.\nâ€¢ -- get all the starship resources\nâ€¢ -- view the JSON schema for this resource\nâ€¢ string -- The name of this starship. The common name, such as \"Death Star\".\nâ€¢ string -- The model or official name of this starship. Such as \"T-65 X-wing\" or \"DS-1 Orbital Battle Station\".\nâ€¢ string -- The class of this starship, such as \"Starfighter\" or \"Deep Space Mobile Battlestation\"\nâ€¢ string -- The manufacturer of this starship. Comma separated if more than one.\nâ€¢ string -- The cost of this starship new, in galactic credits.\nâ€¢ string -- The length of this starship in meters.\nâ€¢ string -- The number of personnel needed to run or pilot this starship.\nâ€¢ string -- The number of non-essential people this starship can transport.\nâ€¢ string -- The maximum speed of this starship in the atmosphere. \"N/A\" if this starship is incapable of atmospheric flight.\nâ€¢ string -- The class of this starships hyperdrive.\nâ€¢ string -- The Maximum number of Megalights this starship can travel in a standard hour. A \"Megalight\" is a standard unit of distance and has never been defined before within the Star Wars universe. This figure is only really useful for measuring the difference in speed of starships. We can assume it is similar to AU, the distance between our Sun (Sol) and Earth.\nâ€¢ string -- The maximum number of kilograms that this starship can transport.\nâ€¢ The maximum length of time that this starship can provide consumables for its entire crew without having to resupply.\nâ€¢ array -- An array of Film URL Resources that this starship has appeared in.\nâ€¢ array -- An array of People URL Resources that this starship has been piloted by.\nâ€¢ string -- the hypermedia URL of this resource.\nâ€¢ string -- the ISO 8601 date format of the time that this resource was created.\nâ€¢ string -- the ISO 8601 date format of the time that this resource was edited.\n\nA Vehicle resource is a single transport craft that does not have hyperdrive capability.\nâ€¢ -- get all the vehicle resources\nâ€¢ -- view the JSON schema for this resource\nâ€¢ string -- The name of this vehicle. The common name, such as \"Sand Crawler\" or \"Speeder bike\".\nâ€¢ string -- The model or official name of this vehicle. Such as \"All-Terrain Attack Transport\".\nâ€¢ string -- The class of this vehicle, such as \"Wheeled\" or \"Repulsorcraft\".\nâ€¢ string -- The manufacturer of this vehicle. Comma separated if more than one.\nâ€¢ string -- The length of this vehicle in meters.\nâ€¢ string -- The cost of this vehicle new, in Galactic Credits.\nâ€¢ string -- The number of personnel needed to run or pilot this vehicle.\nâ€¢ string -- The number of non-essential people this vehicle can transport.\nâ€¢ string -- The maximum speed of this vehicle in the atmosphere.\nâ€¢ string -- The maximum number of kilograms that this vehicle can transport.\nâ€¢ The maximum length of time that this vehicle can provide consumables for its entire crew without having to resupply.\nâ€¢ array -- An array of Film URL Resources that this vehicle has appeared in.\nâ€¢ array -- An array of People URL Resources that this vehicle has been piloted by.\nâ€¢ string -- the hypermedia URL of this resource.\nâ€¢ string -- the ISO 8601 date format of the time that this resource was created.\nâ€¢ string -- the ISO 8601 date format of the time that this resource was edited.\n\nA Species resource is a type of person or character within the Star Wars Universe.\nâ€¢ -- get all the species resources\nâ€¢ -- view the JSON schema for this resource\nâ€¢ string -- The name of this species.\nâ€¢ string -- The classification of this species, such as \"mammal\" or \"reptile\".\nâ€¢ string -- The designation of this species, such as \"sentient\".\nâ€¢ string -- The average height of this species in centimeters.\nâ€¢ string -- The average lifespan of this species in years.\nâ€¢ string -- A comma-separated string of common eye colors for this species, \"none\" if this species does not typically have eyes.\nâ€¢ string -- A comma-separated string of common hair colors for this species, \"none\" if this species does not typically have hair.\nâ€¢ string -- A comma-separated string of common skin colors for this species, \"none\" if this species does not typically have skin.\nâ€¢ string -- The language commonly spoken by this species.\nâ€¢ string -- The URL of a planet resource, a planet that this species originates from.\nâ€¢ array -- An array of People URL Resources that are a part of this species.\nâ€¢ array -- An array of Film URL Resources that this species has appeared in.\nâ€¢ string -- the hypermedia URL of this resource.\nâ€¢ string -- the ISO 8601 date format of the time that this resource was created.\nâ€¢ string -- the ISO 8601 date format of the time that this resource was edited.\n\nA Planet resource is a large mass, planet or planetoid in the Star Wars Universe, at the time of 0 ABY.\nâ€¢ -- get all the planets resources\nâ€¢ -- view the JSON schema for this resource\nâ€¢ string -- The name of this planet.\nâ€¢ string -- The diameter of this planet in kilometers.\nâ€¢ string -- The number of standard hours it takes for this planet to complete a single rotation on its axis.\nâ€¢ string -- The number of standard days it takes for this planet to complete a single orbit of its local star.\nâ€¢ string -- A number denoting the gravity of this planet, where \"1\" is normal or 1 standard G. \"2\" is twice or 2 standard Gs. \"0.5\" is half or 0.5 standard Gs.\nâ€¢ string -- The average population of sentient beings inhabiting this planet.\nâ€¢ string -- The climate of this planet. Comma separated if diverse.\nâ€¢ string -- The terrain of this planet. Comma separated if diverse.\nâ€¢ string -- The percentage of the planet surface that is naturally occurring water or bodies of water.\nâ€¢ array -- An array of People URL Resources that live on this planet.\nâ€¢ array -- An array of Film URL Resources that this planet has appeared in.\nâ€¢ string -- the hypermedia URL of this resource.\nâ€¢ string -- the ISO 8601 date format of the time that this resource was created.\nâ€¢ string -- the ISO 8601 date format of the time that this resource was edited."
    },
    {
        "link": "https://hackmamba.io/blog/2020/12/aggregate-multiple-api-requests-with-promise-all",
        "document": "I promise you'll get a summary of this post at the end.\n\nAsynchronous operations are at the backbone of implementing interactivity in modern JavaScript applications. These are used when making API calls, network requests, or even via a basic delay function.\n\nAsynchronous operations utilize promises, callback functions, or async/await. Commonly, these operations are singular and do not require aggregation of multiple async operations into one.\n\nRecently, I started working to build an aggregation service that utilizes multiple 3rd party APIs and aggregates the resulting data. In this post, we'll learn how we make concurrent async requests using in JavaScript. Also, we'll learn how to limit these requests to run in certain groups/portions at a time.\n\nAn async function to fetch data from an API typically looks like:\n\nHere we utilize Axios, a promise-based HTTP client, to make an HTTP request to retrieve data in a local json file. An alternative to using async/await is to use the method of a promise.\n\nWith , we handle multiple similar requests concurrently and return a single aggregated response. Promise.all() takes an iterable (an array) of promises. It returns an array containing each promise resolution in the same order.\n\nIf any of the promises in Promise.all() is rejected, the promise aggregation is rejected. Here's an example below:\n\nThis code sample is more elaborate and in a try/catch block to catch any failure in the promise resolution.\n\nis a useful array method that flattens the array. Previously, this would be done with a forloop or reduce function.\n\nAn alternative with the API looks like this:\n\nAfter using , is required to parse the response and it also returns a promise! Multiple promises, this is becoming a telenovela!\n\nAnother promise.all is required to aggregate the response.\n\nTo better understand the effect of , we'll create a timing function that resolves a promise after a certain period.\n\nWe'll create three promises with:\n\nEach promise resolves at different times of five, eight, and two seconds respectively.\n\nCalling each function separately in an async/await will return the resolved value of each after the set period. Aggregating the result will require further JavaScript operation to build an array.\n\nCalling all in will resolve them all at the same time. In this case, in the time the function requiring the most time executes - 8 seconds.\n\nUsing , we have:\n\nIt's an efficient and cleaner code for me. ðŸ˜ƒ\n\nStill, on efficiency, you may want to make large numbers of concurrent requests. Rather than make them all at once, it would be efficient to chunk them.\n\nA useful npm package I found to do this is p-limit.\n\nYou can add it to your project using npm or yarn with:\n\nCreate a limit and specify concurrency count with:\n\nUse this limit in the promise with:\n\nThis block runs two promises at a time.\n\nHere's a CodeSandbox link with all the code blocks running in a React app and logging data to the console.\n\nJust like promises in JavaScript, you knew this summary was coming. I told you at the beginning. This is just like promises in JavaScript. In this post, we saw how to make aggregated promise resolutions using and limit the concurrency where necessary using p-limit.\n\nOther promise methods to check out include:\n\nHere's to becoming better. ðŸ¥‚"
    },
    {
        "link": "https://stackoverflow.com/questions/63684006/node-using-promise-all-to-call-apis-in-parallel",
        "document": "doesn't, no; your code does (well, probably; see the Notes below). The work is already underway before sees the promises. What does is give you a promise that will settle when all of the promises you give it are fulfilled (or one of them is rejected).\n\nIt's your code that makes the work run in parallel, by starting the actions that the promises report the completion of (in the callback) in order to give them to in the first place. See comments:\n\nRemember that a promise is just a way to observe the completion of an asynchronous process. Promises don't run anything. They just report the completion of something, along with the fulfillment value or rejection reason.\n\nIf returns a promise, your code is falling prey to the explicit promise creation anti-pattern: There's no reason to use here at all. Instead:\n\nIf returns its value immediately, then there's no point in using promises here at all, because the operations are already complete by the time it returns.\n\nThe you've shown in the question returns a promise (because it's an function), but you wouldn't call that as , just as ."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all",
        "document": "The static method takes an iterable of promises as input and returns a single . This returned promise fulfills when all of the input's promises fulfill (including when an empty iterable is passed), with an array of the fulfillment values. It rejects when any of the input's promises rejects, with this first rejection reason.\n\nThe method is one of the promise concurrency methods. It can be useful for aggregating the results of multiple promises. It is typically used when there are multiple related asynchronous tasks that the overall code relies on to work successfully â€” all of whom we want to fulfill before the code execution continues. will reject immediately upon any of the input promises rejecting. In comparison, the promise returned by will wait for all input promises to complete, regardless of whether or not one rejects. Use if you need the final result of every promise in the input iterable.\n\nwaits for all fulfillments (or the first rejection). If the contains non-promise values, they will be ignored, but still counted in the returned promise array value (if the promise is fulfilled): // All values are non-promises, so the returned promise gets fulfilled const p = Promise.all([1, 2, 3]); // The only input promise is already fulfilled, // so the returned promise gets fulfilled const p2 = Promise.all([1, 2, 3, Promise.resolve(444)]); // One (and the only) input promise is rejected, // so the returned promise gets rejected const p3 = Promise.all([1, 2, 3, Promise.reject(555)]); // Using setTimeout, we can execute code after the queue is empty setTimeout(() => { console.log(p); console.log(p2); console.log(p3); }); // Logs: // Promise { <state>: \"fulfilled\", <value>: Array[3] } // Promise { <state>: \"fulfilled\", <value>: Array[4] } // Promise { <state>: \"rejected\", <reason>: 555 }\n\nThis following example demonstrates the asynchronicity of when a non-empty is passed: // Passing an array of promises that are already resolved, // to trigger Promise.all as soon as possible const resolvedPromisesArray = [Promise.resolve(33), Promise.resolve(44)]; const p = Promise.all(resolvedPromisesArray); // Immediately logging the value of p console.log(p); // Using setTimeout, we can execute code after the queue is empty setTimeout(() => { console.log(\"the queue is now empty\"); console.log(p); }); // Logs, in order: // Promise { <state>: \"pending\" } // the queue is now empty // Promise { <state>: \"fulfilled\", <value>: Array[2] } The same thing happens if rejects: const mixedPromisesArray = [Promise.resolve(33), Promise.reject(44)]; const p = Promise.all(mixedPromisesArray); console.log(p); setTimeout(() => { console.log(\"the queue is now empty\"); console.log(p); }); // Logs: // Promise { <state>: \"pending\" } // the queue is now empty // Promise { <state>: \"rejected\", <reason>: 44 } resolves synchronously if and only if the passed is empty: const p = Promise.all([]); // Will be immediately resolved const p2 = Promise.all([1337, \"hi\"]); // Non-promise values are ignored, but the evaluation is done asynchronously console.log(p); console.log(p2); setTimeout(() => { console.log(\"the queue is now empty\"); console.log(p2); }); // Logs: // Promise { <state>: \"fulfilled\", <value>: Array[0] } // Promise { <state>: \"pending\" } // the queue is now empty // Promise { <state>: \"fulfilled\", <value>: Array[2] }\n\nWithin async functions, it's very common to \"over-await\" your code. For example, given the following functions: function promptForDishChoice() { return new Promise((resolve, reject) => { const dialog = document.createElement(\"dialog\"); dialog.innerHTML = ` <form method=\"dialog\"> <p>What would you like to eat?</p> <select> <option value=\"pizza\">Pizza</option> <option value=\"pasta\">Pasta</option> <option value=\"salad\">Salad</option> </select> <menu> <li><button value=\"cancel\">Cancel</button></li> <li><button type=\"submit\" value=\"ok\">OK</button></li> </menu> </form> `; dialog.addEventListener(\"close\", () => { if (dialog.returnValue === \"ok\") { resolve(dialog.querySelector(\"select\").value); } else { reject(new Error(\"User cancelled dialog\")); } }); document.body.appendChild(dialog); dialog.showModal(); }); } async function fetchPrices() { const response = await fetch(\"/prices\"); return await response.json(); } You may write a function like this: However, note that the execution of and don't depend on the result of each other. While the user is choosing their dish, it's fine for the prices to be fetched in the background, but in the code above, the operator causes the async function to pause until the choice is made, and then again until the prices are fetched. We can use to run them concurrently, so that the user doesn't have to wait for the prices to be fetched before the result is given: is the best choice of concurrency method here, because error handling is intuitive â€” if any of the promises reject, the result is no longer available, so the whole expression throws. accepts an iterable of promises, so if you are using it to run several async functions concurrently, you need to call the async functions and use the returned promises. Directly passing the functions to does not work, since they are not promises. async function getPrice() { const [choice, prices] = await Promise.all([ promptForDishChoice, fetchPrices, ]); // `choice` and `prices` are still the original async functions; // Promise.all() does nothing to non-promises }"
    },
    {
        "link": "https://stackoverflow.com/questions/73092249/multiple-api-calls-with-promise-all",
        "document": "I'm trying to get different data from different APIs. I don't have any problem when getting one and updating state, but I can't figure out how can I update two different state with .\n\nHow can I make this code work?"
    },
    {
        "link": "https://medium.com/codex/running-concurrent-requests-with-async-await-and-promise-all-daaca1b5da4d",
        "document": "In this article Iâ€™d like to touch on async, await, and Promise.all in JavaScript. First, Iâ€™ll talk about concurrency vs parallelism and why we will be targeting parallelism in this article. Then, Iâ€™ll talk about how to use async and await to implement a parallel algorithm in serial and how to make it work in parallel by using Promise.all. Finally, Iâ€™ll create an example project using Salesforceâ€™s Lightning Web Components where I will build an art gallery using Harvardâ€™s Art Gallery API.\n\nI want to quickly touch on the difference between concurrency and parallelism. You can relate concurrency to how a single-threaded CPU processes multiple tasks. Single-threaded CPUs emulate parallelism by switching between processes quickly enough that it seems like multiple things are happening at the same time. Parallelism is when a CPU has multiple cores and can actually run two tasks at the exact same time. Another great example is this:\n\nKnowing this difference helps us consider what options we have from an algorithmic standpoint. Our goal is to make these HTTP requests in parallel. Due to some limitations in JavaScript implementation and browser variability, we donâ€™t actually get to determine if our algorithm will be run concurrently or in parallel. Luckily, I donâ€™t need to change our algorithm at all. The underlying JavaScript event loop will make it seem like the code is running in parallel, which is good enough for this article!\n\nIn order to understand this parallel algorithm, Iâ€™ll first use async and await to build a serial algorithm. If you write this code in an IDE, youâ€™ll likely get a notification saying that using await in a loop is a missed optimization opportunity â€” and your IDE would be correct.\n\nOne reason that you might implement an algorithm like this is if you need to get the data from two different URLs, then blend that data together to create your final object. In the code above, you can imagine that we are gathering some data about a post, then grabbing the data about the post's tags, and finally merging that data into the object youâ€™d actually use later on.\n\nWhile this code will work, you might notice that we on each fetch. You'll see something like:\nâ€¢ Wait for fetch post one to complete\nâ€¢ Wait for post one tags to complete\n\nThe problem is weâ€™re waiting serially for each network request to complete before starting the next request. Thereâ€™s no need for this: Computers are perfectly capable of executing more than one network request at the same time.\n\nSo how can we make this algorithm better?\n\nThe easiest way to make this algorithm faster is to remove the keyword before the command. This will tell JavaScript to start the execution of all the requests in parallel. But in order to pause execution and wait for all of the promises to return, we need to await on something. We'll use to do just that.\n\nWhen we use , JavaScript will wait for the entire array of promises passed to to resolve. Only then will it return all the results at the same time. A rewrite looks like this:\n\nThis code will map each URL into a and then for all of those promises to complete. Now when we pass the portion of the code, we can be sure that both fetch requests have resolved and the responses are in the data array in the correct position. So will be our post data and will be our tags data.\n\nNow that we have all the necessary building blocks to implement our pre-fetched image gallery, letâ€™s build it.\n\nBelow is a screenshot of the app I built for this article, and here is the link to the documentation about the Harvard Art Museum API docs [2]. Youâ€™ll need to apply for your own API key if youâ€™d like to follow along. The process seemed pretty automatic to me since you just fill out a Google Form and then receive your API key in your email instantly.\n\nIt doesnâ€™t look like much, but as you navigate through the gallery, it pre-fetches the next pages of data automatically. That way, the user viewing the gallery shouldnâ€™t see any loading time for the actual data. The images are only loaded when they are displayed on the page. And while those do load after the fact, the actual data for the page is loaded instantly since it is cached in the component. Finally, as a challenge to myself, Iâ€™m using Salesforceâ€™s Lightning Web Components for this project â€” a completely new technology to me. Letâ€™s get into building the component.\n\nHere are some of the resources that I used while learning about Lightning Web Components. If youâ€™d like to follow along, then youâ€™ll at least need to set up your local dev environment and create a â€œhello worldâ€ Lightning Web Component.\n\nAlright, now that your environment is set up and youâ€™ve created your first LWC, letâ€™s get started. By the way, all the code for this article can be found at my GitHub repo [7].\n\nA quick aside: Lightning Web Components are a little more limited than components you might be used to if you are coming from a React background. For example, you canâ€™t use JavaScript expressions in component properties, i.e. the image src, in the following example:\n\nThe reason for that is when you force all of your code to happen in the JavaScript files rather than in the HTML template files, your code becomes much easier to test. So letâ€™s chalk this up to â€œitâ€™s better for testingâ€ and move on with our lives.\n\nIn order to create this gallery, weâ€™ll need to build two components. The first component is for displaying each gallery image, and the second component is for pre-fetching and pagination.\n\nThe first component is the simpler of the two. In VSCode, execute the command and name the component . This will create three files for us: an HTML, JavaScript, and XML file. This component will not need any changes to the XML file since the item itself isn't visible in any Salesforce admin pages.\n\nNext, change the contents of the HTML file to the following:\n\nNote that in this HTML file, the style property is set to which is a function in our JavaScript file, so let's work on that one.\n\nChange the contents of the JS file to the following:\n\nThere are a few things to notice here. First, the record property is decorated with which allows us to assign to this property from other components. Keep an eye out for this record property on the main gallery component. Also, since we can't have JavaScript expressions in our HTML files, I've also brought the background image inline CSS into the JavaScript file. This allows me to use string interpolation with the image. The image function is nothing special as it is â€” just an easy way for me to get the first image URL from the record that we received from the Harvard Art Gallery API.\n\nOur final step of this component is to add a CSS file that wasnâ€™t created for us automatically. So create in the harvardArtMuseumGalleryItem directory. You don't need to tell the application to use this file as it is included automatically just by its existence.\n\nChange the contents of your newly created CSS file to the following:\n\nNow that our busy work is out of the way, we can get to the actual gallery.\n\nRun in VSCode again and name the component . This will, once again, generate our HTML, JavaScript, and XML files. We need to pay close attention to the XML file this time. The XML file is what tells Salesforce where our component is allowed to be located as well as how we will store our API key in the component.\n\nThere are three key things to pay attention to in this XML file. The first is which will allow our component to be found in the Salesforce admin. The second is the which says which areas of the Salesforce site our component can be used. This one says that we are allowing our component to be displayed on HomePage type pages. Finally, the section will display a text box when adding the component. There, we can paste our API key (as seen in the following screenshot). You can find more information about this XML file here [8].\n\nNext, letâ€™s take care of the HTML and CSS files.\n\nMost of this is standard HTML with some custom components. The line I want you to pay attention to most is the <c-harvard-art-museum-gallery-item> tag and its record property. Youâ€™ll remember that this is the property we decorated with in the gallery item JavaScript file. The decoration allows us to pass in the record through this property.\n\nNext, onto the CSS file:\n\nIâ€™ve saved the most interesting for last! The JavaScript file includes our pre-fetching logic and page-rolling algorithm.\n\nNotice that we are decorating the harvardApiKey with . This is how the property from our XML file will be injected into our component. Most of the code in this file facilitates changing pages and chunking the response so that we get rows of four gallery items. Pay attention to as well as : this is where the magic happens. First, notice that calculates a range of pages from whatever the current requested page is. If the current requested page is five, then we will cache all pages from two until page eight. We then loop over the pages and create a promise for each page.\n\nOriginally, I was thinking that weâ€™d need to on the in order to avoid loading a page twice. But then I realized it is a low cost to pay in order to not wait for all of the pages to be returned from the API. So the current algorithm is as follows:\nâ€¢ Bounds are calculated as page two through page eight, and promises are created for those requests.\nâ€¢ Since we arenâ€™t waiting for the promises to return, we will again request page five and make an extra API request (but this only happens for pages that arenâ€™t in the cache).\nâ€¢ So let's say that the user progresses to page six.\nâ€¢ Bounds are calculated as pages three through nine, and promises are created for those requests.\nâ€¢ Since we already have pages two through eight in the cache, and since we didnâ€™t await on those promises, page six will immediately load from the cache while the promise for page nine is being fulfilled (since it is the only page missing from the cache).\n\nAnd there you have it! Weâ€™ve explored concurrency and parallelism. We learned how to build an async/await flow in serial (which you should never do). We then upgraded our serial flow to be in parallel and learned how to wait for all the promises to resolve before continuing. Finally, weâ€™ve built a Lightning Web Component for the Harvard Art Museum using async/await and . (Although in this case, we didn't need the since the algorithm works better if we don't wait for all the promises to resolve before continuing on.)\n\nThanks for reading and feel free to leave any comments and questions below."
    },
    {
        "link": "https://medium.com/@george.norberg/history-api-getting-started-36bfc82ddefc",
        "document": "While building a single-page progressive web app, I ran into the History API â€” a powerful set of methods for page navigation and routing in pure vanilla JavaScript.\n\nIf you like building apps without heavy frameworks or routing libraries, this oneâ€™s for you.\n\nI had to fiddle with the History API for a while before â€œgetting itâ€, so hopefully this article will help you understand it faster so you can get back to building sooner.\n\nThe History APIâ€¦ or how I learned to stop worrying and love the back button\n\nThe main reason I went down this rabbit hole is because users love the browserâ€™s back button.\n\nIt even won an award as the most pressed button in Firefox back in the day: http://www.internetnews.com/skerner/2010/07/what-is-the-most-clicked-firef.html\n\nIâ€™m not sure if it still ranks #1, but itâ€™s telling that the back button takes the highly coveted top-left-most real estate on all modern browsers.\n\nSo your app should definitely 100% expect that users will try to use the back button everywhere in your app to return to previous views.\n\nThis is where the History API comes in. The History API assumes that your view is a function of state â€” that is, what is displayed on screen depends on a global state object. This allows the browser to store all your states so that when a user presses the back button, they return to the previous state as expected.\n\nSo to use the History API, you must have a global state of some kind that your views depend on. It doesnâ€™t matter if you mutate state (as expected in an object-oriented paradigm) or use immutable state (as expected in a functional programming paradigm).\n\nIf you have state that looks like this:\n\nYour render function should see that it should not display a trophy, and there should not be a trophy visible on screen. Then if your user does something that rewards a trophy, your state should change to this:\n\nObserving a state change, your render function now sees that it should display a trophy, and it does just that â€” it renders a trophy on the screen for the user to see.\n\nItâ€™s important that you donâ€™t just render things willy-nilly that arenâ€™t tied to state. Otherwise, these changes arenâ€™t captured in the state object that the browser is storing.\n\nThe flow looks like this:\n\nEvery action should trigger a state change, which triggers a re-render. For those familiar with React, itâ€™s very similar to Reactâ€™s one-way data flow where a state change triggers a re-render, except React has fancy diffing algorithms that prevent the whole application from being re-rendered.\n\nThis means no matter which state object the browser delivers to you, youâ€™ll be able to properly render the view that the user expects.\n\nIf thatâ€™s not crystal clear yet, donâ€™t worry. Weâ€™re about to dig into the mechanics which should elucidate how the whole operation works.\n\nTo use the browserâ€™s history functionality, you begin by telling the browser to remember your initial state. This requires the replaceState method like so:\n\nYouâ€™ll notice it takes 3 parameters. The first is obviously our state object. What about the other 2? The second is a title that may be used by browsers in the future, so we just set it to null for now. The third is important though â€” it will become the URL path.\n\nWhat is the URL path? Essentially itâ€™s all the stuff that comes at the end of the URL. So if we append â€œtrophyâ€ to our base URL https://example.com, then the URL that the user sees in their browserâ€™s address bar would immediately become https://example.com/trophy.\n\nIn my application, I intentionally left the path empty. This means that no matter what the user clicks on, they will see the original URL. I did this so that if they refresh, bookmark or share the URL then the application will still load at its entry point.\n\nIf you want to have multiple entry points, then you need to customize your server to handle those routes. Otherwise, the user may bookmark a â€œbadâ€ URL that the server does not understand. For example, if I build a URL like https://example.com/not-on-server and the user tries to load that URL, my server may have no idea what to do with that path. We would need to change our server-side code to handle all possible paths. The minimum logic would be to simply redirect to the original URL, so we achieve the same effect with less code by having no path at all.\n\nIf you decide to implement custom paths for your application, be sure to update your server code to handle those paths.\n\nSo youâ€™ve initialized your state. Whatâ€™s next?\n\nWhenever the user does something that updates state, such as clicking a checkbox or navigating to a different view, you will need to update your state and then store it in the browser. After updating your state, call this:\n\nWell that looks awfully familiar, doesnâ€™t it! Itâ€™s identical to our last use of the History API except our method is now as opposed to .\n\nNote that we push the NEW state that the user has triggered, since the OLD state was already stored.\n\nWith every push, the browser gathers more and more states that it can cycle through if the user wants to start cycling back.\n\nBehind the scenes, this uses a Stack data structure. The History API pushes states until it needs to pop them. The method pushes, and the back button pops.\n\nItâ€™s nice and all that the browser can pop our states off the Stack one by one, but how do we connect that to our application?\n\nSomewhere in our app, we need to set up an event listener that re-renders our app with the old state, meaning your function updates some piece of the user interface based on these state changes:\n\nThe browserâ€™s back button triggers the listener, which connects to the History API. Notice that the callback receives an event â€” this event has a property that has your old state! Just set your application state to this old state and trigger a re-render to display the old state.\n\nNow when the user presses the back button â€” voila! They see the old state that you most recently pushed.\n\nPutting it all together\n\nLetâ€™s summarize by looking at all the code together with an example:\n\nBefore reading further, you can play with the above code at https://jsfiddle.net/ax9qLe7r/.\n\nThe function is called immediately to store and render the initial state. Then, we set up a button that, upon being clicked, triggers the function. This function mutates the state, leading to a new state being pushed and rendered. This can be repeated ad infinitum. Then, whenever the user presses the back button, the callback triggers to revive the most recent previous state.\n\nI recognize there are many ways of getting started with the History API, and this is just one example. Feel free to leave a comment below if you know a different pattern!\n\nIâ€™ll leave you with a bonus tip. If you want to have your own back button somewhere in your application, this setup makes it really easy.\n\nLetâ€™s say you have an HTML button with class that you want to behave the same as the browserâ€™s back button. Here is how you would use the History API to do so:\n\nYou simply grab the button element and set up a listener. When your appâ€™s back button is clicked, the callback is called and pops the history Stack. If you recall from earlier, this triggers your listener, which stores and renders the previous state.\n\nNote that we must manually call window.history.back inside the callback wrapper because of how works. See this post for details: https://stackoverflow.com/questions/46879422/window-history-back-illegal-invocation\n\nSo now you know that the browserâ€™s back button is just calling window.history.back, and you can too!"
    },
    {
        "link": "https://blog.pixelfreestudio.com/how-to-use-html5-history-api-for-single-page-apps",
        "document": "The HTML5 History API allows you to manipulate the browser history and the URL displayed in the address bar without reloading the page. This is particularly useful for SPAs where you want to update the URL to reflect the current state or view, without actually navigating away from the page. The History API provides methods to push, replace, and manipulate the history entries, enabling you to create a more dynamic and interactive web application.\n\nWhy Use the History API in SPAs?\n\nUsing the History API in your SPA brings several benefits:\n\nUsers can navigate through your app using the browserâ€™s back and forward buttons, making the experience more intuitive and consistent with traditional web navigation.\n\nSearch engines can index the different states of your SPA, improving your visibility and ranking in search results.\n\nUsers can bookmark specific states or views in your app, making it easier to return to a particular section later.\n\nYou can track user interactions more effectively by pushing state changes to the browser history, allowing for more detailed analytics.\n\nGetting Started with the History API\n\nBefore diving into the advanced techniques, itâ€™s essential to understand the basics of the History API. The primary methods youâ€™ll be using are , , and the event.\n\nThe method allows you to add a new entry to the browser history stack. This method takes three arguments: state object, title, and URL.\n\nThe method works similarly to , but it modifies the current history entry instead of adding a new one.\n\nThe event is triggered when the active history entry changes. This can happen, for example, when the user navigates back or forward in the browser history.\n\nNow that weâ€™ve covered the basics, letâ€™s look at how to implement the History API in a Single Page App. Weâ€™ll create a simple example to demonstrate how to use , , and in practice.\n\nFirst, letâ€™s set up the basic HTML structure for our SPA.\n\nNext, weâ€™ll add JavaScript to handle navigation and update the content dynamically based on the current URL.\n\nWith the basic navigation setup, we can enhance the user experience by adding more interactive elements and handling different states more gracefully.\n\nFor SPAs, handling form submissions without reloading the page is crucial. You can use AJAX to submit forms and update the state using the History API.\n\nFor more complex SPAs, managing state transitions and history entries becomes critical. You might want to use libraries like React Router or Vue Router, which abstract the complexities of navigation and state management.\n\nIn real-world applications, you often need to handle dynamic content and URL parameters. The HTML5 History API can manage these scenarios efficiently, allowing you to pass state data and update the URL dynamically.\n\nTo handle URL parameters, you can parse the URL and update the state accordingly. This is particularly useful for SPAs that require dynamic content based on parameters, such as user profiles or product details.\n\nWhen users navigate back and forth, you may want to preserve the state of certain elements, such as form inputs or scroll positions. The event can be used to restore these states.\n\nModern JavaScript frameworks like React, Angular, and Vue have built-in solutions for handling routing and state management. Integrating the HTML5 History API with these frameworks can further enhance your SPAâ€™s functionality and user experience.\n\nReact Router is a powerful routing library for React that leverages the HTML5 History API under the hood. It simplifies navigation and state management in your React application.\n\nHereâ€™s how you can set up a basic React Router configuration:\n\nReact Router also makes it easy to handle state and URL parameters.\n\nBest Practices for Using the History API\n\nAlways ensure that the URLs you push to the history stack are consistent and reflect the current state of your application. This helps maintain a seamless user experience and improves the accuracy of analytics.\n\nAlways include error handling when manipulating the history stack. This ensures that your application remains robust and user-friendly, even if unexpected issues arise.\n\nAlthough the parameter in and is currently not widely used by browsers, itâ€™s a good practice to provide descriptive titles. This ensures future compatibility and helps maintain clear code.\n\nUse browser developer tools to monitor and debug your history stack manipulations. Tools like Chrome DevTools can help you inspect the current state, navigate through the history, and identify any issues with your implementation.\n\nIn Single Page Applications, managing scroll positions can significantly enhance user experience. When navigating between different views or states, itâ€™s essential to ensure smooth scrolling and proper scroll restoration.\n\nSmooth scrolling provides a more polished experience when users navigate between sections of your SPA. You can implement smooth scrolling using JavaScript.\n\nTo maintain scroll positions when navigating back and forth, you can save and restore scroll positions using the History API.\n\nLazy loading content is an effective way to enhance performance and user experience in SPAs. By loading content only when needed, you reduce initial load times and resource usage.\n\nHereâ€™s an example of how to implement lazy loading for content sections:\n\nPre-fetching content can further improve user experience by loading resources in the background before they are needed. This technique is particularly useful for anticipated user actions, such as hovering over a link or navigating to the next page.\n\nFor more complex SPAs, managing state transitions can become challenging. Using state management libraries like Redux or Vuex can help you handle state more efficiently.\n\nIf youâ€™re using React, integrating Redux with the History API can simplify state management.\n\nProperly implemented SPAs can be SEO-friendly. Using server-side rendering (SSR) and pre-rendering can help search engines crawl and index your SPA content more effectively.\n\nNext.js is a popular React framework that supports SSR and static site generation, enhancing SEO for SPAs.\n\nUsing the History API with Server-Side Rendering\n\nSSR can significantly improve the SEO of your SPA by ensuring that content is available to search engines.\n\nExample with Express.js and React\n\nWhen implementing the HTML5 History API in your Single Page Application, itâ€™s crucial to consider security implications. Proper handling of user data and ensuring that navigation and state changes are secure can prevent common vulnerabilities such as Cross-Site Scripting (XSS) and Cross-Site Request Forgery (CSRF).\n\nCross-Site Scripting (XSS) is a common vulnerability where an attacker injects malicious scripts into your web application. Using the History API, itâ€™s essential to sanitize user input to prevent XSS attacks.\n\nAlways sanitize any data that is dynamically added to the DOM. Use libraries like DOMPurify to clean user input.\n\nCross-Site Request Forgery (CSRF) attacks occur when an attacker tricks a user into performing actions on a web application where they are authenticated. Using anti-CSRF tokens can help mitigate this risk.\n\nImplement anti-CSRF tokens in your forms and AJAX requests to ensure that actions are performed by authenticated users.\n\nEnsure that sensitive data is handled securely. Avoid exposing sensitive information in the URL or client-side state.\n\nWhen using the History API to manage state, ensure that sensitive information is stored securely and not exposed in the URL or history state.\n\nAlways use HTTPS to ensure secure communication between the client and server. This helps protect data integrity and confidentiality.\n\nModern JavaScript frameworks offer advanced routing capabilities that integrate seamlessly with the History API, making it easier to manage complex navigation scenarios.\n\nAngular provides a powerful router that leverages the History API to manage navigation and state.\n\nFirst, install Angular Router if you havenâ€™t already:\n\nHereâ€™s how to set up basic routes in an Angular application:\n\nUse the Angular Router to navigate programmatically and handle state changes.\n\nVue.js offers Vue Router, a feature-rich routing library that works seamlessly with the History API.\n\nUse Vue Router to navigate and manage state in your Vue application.\n\nIntegrating the HTML5 History API with back-end frameworks ensures seamless server-side rendering and enhanced SEO. Letâ€™s explore how to implement the History API with popular back-end frameworks like Node.js with Express and Django.\n\nNode.js with Express is a popular choice for building server-side applications. Integrating the History API with Express allows you to handle both client-side and server-side routing effectively.\n\nFirst, set up an Express server:\n\nCreate an file for your Express server:\n\nEnsure your directory contains your SPAâ€™s and other static assets. The catch-all route ( ) allows the server to handle client-side routes gracefully, falling back to the SPAâ€™s .\n\nDjango is a robust Python web framework that supports server-side rendering and can work seamlessly with client-side applications using the History API.\n\nIn your , create a view to serve the SPA:\n\nIn your , set up the URL routing:\n\nEnsure your contains your SPAâ€™s entry point.\n\nBy setting up back-end frameworks like Express and Django, you can ensure that your SPA handles routing both on the client and server sides, providing a seamless experience for users and improving SEO.\n\nPerformance optimization is crucial for providing a fast and responsive user experience in SPAs. Here are some techniques to optimize performance in your SPAs.\n\nCode splitting allows you to split your code into smaller bundles that can be loaded on demand. This reduces the initial load time and improves performance.\n\nLazy loading defers the loading of non-critical resources until they are needed. This technique can significantly improve the initial load time of your SPA.\n\nCaching can significantly improve performance by storing frequently accessed data locally, reducing the need to fetch it from the server repeatedly.\n\nMinifying and compressing your JavaScript, CSS, and HTML files can reduce their size and improve load times.\n\nExample: Using Terser for Minification\n\nUsing a CDN can improve the delivery speed of your static assets by serving them from servers geographically closer to your users.\n\nConfigure your build process to upload assets to a CDN, and update your asset URLs to point to the CDN.\n\nImproving the user experience in your SPA is key to keeping users engaged and satisfied. Here are some techniques to enhance the user experience.\n\nA custom 404 page provides a better experience when users navigate to a non-existent route.\n\nLoading indicators provide visual feedback to users while data is being fetched, improving perceived performance.\n\nEnsure your SPA is responsive and works well on different devices and screen sizes.\n\nMaking your SPA accessible ensures that it can be used by as many people as possible, including those with disabilities.\n\nAs we wrap up this comprehensive guide on using the HTML5 History API for Single Page Applications, here are some final tips and best practices to ensure your implementation is robust, user-friendly, and effective:\n\nConsistency is key in creating a seamless user experience. Make sure that the navigation behavior is predictable and aligns with usersâ€™ expectations from traditional multi-page applications.\n\nMaintain a consistent URL structure that reflects the current state of your application accurately. This not only helps users but also improves your SEO.\n\nDifferent browsers and devices may handle the History API differently. Thoroughly test your SPA across various platforms to ensure compatibility and a smooth experience for all users.\n\nUse tools like BrowserStack or Sauce Labs to test your application on different browsers and devices.\n\nAccessibility should be a priority to ensure your application can be used by everyone, including people with disabilities. Follow the Web Content Accessibility Guidelines (WCAG) to enhance accessibility.\n\nUse ARIA roles and properties to make your navigation accessible.\n\nUse analytics tools to monitor user interactions and application performance. This data can help you identify areas for improvement and understand user behavior better.\n\nIntegrate Google Analytics to track page views and user interactions in your SPA.\n\nPlan for edge cases and handle errors gracefully. Ensure that your application can recover from unexpected situations without crashing or providing a poor user experience.\n\nKeep Up with Latest Trends and Technologies\n\nWeb development is constantly evolving. Stay updated with the latest trends, best practices, and technologies to keep your SPA performant, secure, and user-friendly.\n\nExample: Following Industry Blogs and Communities\n\nJoin web development communities and follow industry blogs like CSS-Tricks, Smashing Magazine, and MDN Web Docs to stay informed.\n\nProgressive enhancement ensures that your application works for all users, regardless of their browser capabilities. Build a solid, accessible core and enhance it with JavaScript and other technologies.\n\nEnsure your application provides basic functionality even if JavaScript is disabled.\n\nThe HTML5 History API is a powerful tool for enhancing Single Page Applications (SPAs) by managing navigation and state without page reloads. Using methods like , , and handling the event, you can create a seamless user experience that feels intuitive and consistent.\n\nIntegrating the History API with back-end frameworks such as Node.js with Express or Django ensures both client-side and server-side routing, improving SEO and user experience. Performance optimizations like code splitting, lazy loading, caching, and using CDNs can make your SPA faster and more responsive. Enhancing user experience through custom 404 pages, loading indicators, responsive design, and accessibility ensures that your application is user-friendly and inclusive.\nâ€¢ How to Use TypeScript for Better JavaScript Development\nâ€¢ How to Implement Dark Mode in Your Web Application\nâ€¢ Best Practices for Handling Forms in Frontend Development\nâ€¢ How to Use Webpack for Efficient Module Bundling\nâ€¢ The Importance of Code Reviews in Frontend Development"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/History/pushState",
        "document": "The object is a JavaScript object which is associated with the new history entry created by . Whenever the user navigates to the new , a event is fired, and the property of the event contains a copy of the history entry's object.\n\nThe object can be anything that can be serialized.\n\nNote: Some browsers save objects to the user's disk so they can be restored after the user restarts the browser, and impose a size limit on the serialized representation of a object, and will throw an exception if you pass a object whose serialized representation is larger than that size limit. So in cases where you want to ensure you have more space than what some browsers might impose, you're encouraged to use and/or ."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/History_API/Working_with_the_History_API",
        "document": "The History API enables a website to interact with the browser's session history: that is, the list of pages that the user has visited in a given window. As the user visits new pages, for example by clicking links, those new pages are added to the session history. The user can also move back and forth through the history using the browser's \"Back\" and \"Forward\" buttons. The main interface defined in the History API is the interface, and this defines two quite distinct sets of methods:\nâ€¢ Methods to navigate to a page in the session history: In this guide we'll be concerned only with the second set of methods, as these have more complex behavior. The method adds a new entry to the session history, while the method updates the session history entry for the current page. Both these methods take a parameter which can contain any serializable object. When the browser navigates to this history entry, the browser fires a event, which contains the state object associated with that entry. The main purpose of these APIs is to support websites like Single-page applications, that use JavaScript APIs such as to update the page with new content, instead of loading a whole new page.\n\nTraditionally, websites are implemented as a collection of pages. When users navigate to different parts of the site by clicking links, the browser loads a whole new page each time. While this is great for many sites, it can have some disadvantages:\nâ€¢ It can be inefficient to load a whole page every time, when only part of the page needs to be updated.\nâ€¢ It is hard to maintain application state when navigating across pages For these reasons, a popular pattern for web apps is the single-page application (SPA), in which the site consists of a single page, and when the user clicks links, the page:\nâ€¢ Prevents the default behavior of loading a new page\nâ€¢ Updates the page with the new content document.addEventListener(\"click\", async (event) => { const creature = event.target.getAttribute(\"data-creature\"); if (creature) { // Prevent a new page from loading event.preventDefault(); try { // Fetch new content const response = await fetch(`creatures/${creature}.json`); const json = await response.json(); // Update the page with the new content displayContent(json); } catch (err) { console.error(err); } } }); In this click handler, if the link contains a data attribute , then we use the value of that attribute to fetch a JSON file containing the new content for the page. The JSON file might look like this: { \"description\": \"Bald eagles are not actually bald.\", \"image\": { \"src\": \"images/eagle.jpg\", \"alt\": \"A bald eagle\" }, \"name\": \"Eagle\" } Our function updates the page with the JSON: // Update the page with the new content function displayContent(content) { document.title = `Creatures: ${content.name}`; const description = document.querySelector(\"#description\"); description.textContent = content.description; const photo = document.querySelector(\"#photo\"); photo.setAttribute(\"src\", content.image.src); photo.setAttribute(\"alt\", content.image.alt); } The problem is that it breaks the expected behavior of the browser's \"Back\" and \"Forward\" buttons. From the user's point of view, they clicked a link and the page updated, so it looks like a new page. If they then press the browser's \"Back\" button, they expect to go to the state before they clicked the link. But as far as the browser is concerned, the last link didn't load a new page, so \"Back\" will take the browser to whichever page was loaded before the user opened the SPA. This is essentially the problem that , , and the event solve. They enable us to synthesize history entries, and to be notified when the current session history entry changes to one of these entries (for example, because the user pressed the \"Back\" or \"Forward\" buttons).\n\nThere's one more piece we need to add. When the user loads the SPA, the browser adds a history entry. Because this was an actual page load, the entry has no state associated with it. So suppose the user:\nâ€¢ Clicks a link inside the SPA: the click handler updates the page and adds a history entry with Now we want to go back to the SPA's initial state, but since this is a navigation in the same document, the page will not be reloaded, and since the history entry for the initial page has no state, we can't use to restore it. The solution here is to use to set the state object for the initial page. For example: // Create state on page load and replace the current history with it const image = document.querySelector(\"#photo\"); const initialState = { description: document.querySelector(\"#description\").textContent, image: { src: image.getAttribute(\"src\"), alt: image.getAttribute(\"alt\"), }, name: \"Home\", }; history.replaceState(initialState, \"\", document.location.href); On page load, we collect all the parts of the page that we need to restore when the user returns to the starting point for the SPA. This has the same structure as the JSON we fetch when handling other navigations. We pass this object into , which effectively adds the state object to the current history entry. When the user returns to our starting point, the event will contain this initial state, and we can use our function to update the page."
    },
    {
        "link": "https://blog.carlosrojas.dev/client-side-routing-in-javascript-creating-smooth-single-page-apps-2e7b2dcc546f",
        "document": "In the evolving landscape of web development, single-page applications (SPAs) have become increasingly popular for their ability to offer a seamless user experience similar to desktop applications. Central to this user experience is client-side routing, a technique that allows SPAs to navigate between different views without requiring a full page reload. This article delves into the fundamentals of client-side routing in JavaScript, offering a comprehensive guide to creating efficient, smooth-operating SPAs without relying on external frameworks or libraries.\n\nClient-side routing refers to the process where the route changes are handled internally by the JavaScript that runs on the page. When a user clicks a link, instead of making a server request for the new page, the JavaScript intercepts this action and renders the new content on the current page itself.\nâ€¢ Faster Transitions: Only the necessary content is updated, reducing the amount of data transferred and processed.\nâ€¢ Improved User Experience: Eliminates the flicker and delay of full page reloads.\nâ€¢ Better Performance: Reduces server load as fewer requests are made for full pages.\n\nIn client-side routing, the URL is manipulated using the HTML5 History API. This includes methods like to add entries to the browser's history stack, enabling the SPA to handle URL changes without refreshing the page.\n\nLetâ€™s create a simple SPA with two pages: Home and About.\n\nExplanation of the Example\nâ€¢ On Page Load: When the page loads, is called to load the correct content based on the current URL.\nâ€¢ Handling Back Button: ensures that when the user navigates using the browser's back and forward buttons, the content updates accordingly.\nâ€¢ Navigation Function: The function checks the path and updates the div with the relevant content.\nâ€¢ Event Listeners: Prevent the default link behavior and use to change the URL without reloading the page.\n\nClient-side routing in JavaScript offers a powerful method to enhance user experience in single-page applications. By managing routing on the client side, developers can create fast, responsive, and interactive web applications. This guide presents the basic concepts and a simple implementation to get started. As web technologies continue to evolve, understanding these core principles remains crucial for building modern web applications. Remember, while frameworks and libraries offer more features and ease of use, grasping the underlying mechanics empowers developers to create customized solutions tailored to specific project needs."
    }
]