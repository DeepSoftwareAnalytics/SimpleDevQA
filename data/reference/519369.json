[
    {
        "link": "https://numpy.org/doc/2.2/reference/generated/numpy.astype.html",
        "document": "Specifies whether to copy an array when the specified dtype matches the data type of the input array . If , a newly allocated array must always be returned. If and the specified dtype matches the data type of the input array, the input array must be returned; otherwise, a newly allocated array must be returned. Defaults to ."
    },
    {
        "link": "https://numpy.org/doc/2.0/reference/generated/numpy.astype.html",
        "document": "Specifies whether to copy an array when the specified dtype matches the data type of the input array . If , a newly allocated array must always be returned. If and the specified dtype matches the data type of the input array, the input array must be returned; otherwise, a newly allocated array must be returned. Defaults to ."
    },
    {
        "link": "https://numpy.org/devdocs/user/quickstart.html",
        "document": "Youâ€™ll need to know a bit of Python. For a refresher, see the Python tutorial. To work the examples, youâ€™ll need installed in addition to NumPy. This is a quick overview of arrays in NumPy. It demonstrates how n-dimensional (\\(n>=2\\)) arrays are represented and can be manipulated. In particular, if you donâ€™t know how to apply common functions to n-dimensional arrays (without using for-loops), or if you want to understand axis and shape properties for n-dimensional arrays, this article might be of help. After reading, you should be able to:\nâ€¢ None Understand the difference between one-, two- and n-dimensional arrays in NumPy;\nâ€¢ None Understand how to apply some linear algebra operations to n-dimensional arrays without using for-loops;\n\nNumPyâ€™s main object is the homogeneous multidimensional array. It is a table of elements (usually numbers), all of the same type, indexed by a tuple of non-negative integers. In NumPy dimensions are called axes. For example, the array for the coordinates of a point in 3D space, , has one axis. That axis has 3 elements in it, so we say it has a length of 3. In the example pictured below, the array has 2 axes. The first axis has a length of 2, the second axis has a length of 3. NumPyâ€™s array class is called . It is also known by the alias . Note that is not the same as the Standard Python Library class , which only handles one-dimensional arrays and offers less functionality. The more important attributes of an object are: the number of axes (dimensions) of the array. the dimensions of the array. This is a tuple of integers indicating the size of the array in each dimension. For a matrix with n rows and m columns, will be . The length of the tuple is therefore the number of axes, . the total number of elements of the array. This is equal to the product of the elements of . an object describing the type of the elements in the array. One can create or specify dtypeâ€™s using standard Python types. Additionally NumPy provides types of its own. numpy.int32, numpy.int16, and numpy.float64 are some examples. the size in bytes of each element of the array. For example, an array of elements of type has 8 (=64/8), while one of type has 4 (=32/8). It is equivalent to . the buffer containing the actual elements of the array. Normally, we wonâ€™t need to use this attribute because we will access the elements in an array using indexing facilities. There are several ways to create arrays. For example, you can create an array from a regular Python list or tuple using the function. The type of the resulting array is deduced from the type of the elements in the sequences. A frequent error consists in calling with multiple arguments, rather than providing a single sequence as an argument. : array() takes from 1 to 2 positional arguments but 4 were given transforms sequences of sequences into two-dimensional arrays, sequences of sequences of sequences into three-dimensional arrays, and so on. The type of the array can also be explicitly specified at creation time: Often, the elements of an array are originally unknown, but its size is known. Hence, NumPy offers several functions to create arrays with initial placeholder content. These minimize the necessity of growing arrays, an expensive operation. The function creates an array full of zeros, the function creates an array full of ones, and the function creates an array whose initial content is random and depends on the state of the memory. By default, the dtype of the created array is , but it can be specified via the key word argument . To create sequences of numbers, NumPy provides the function which is analogous to the Python built-in , but returns an array. When is used with floating point arguments, it is generally not possible to predict the number of elements obtained, due to the finite floating point precision. For this reason, it is usually better to use the function that receives as an argument the number of elements that we want, instead of the step: # useful to evaluate function at lots of points When you print an array, NumPy displays it in a similar way to nested lists, but with the following layout:\nâ€¢ None the last axis is printed from left to right,\nâ€¢ None the second-to-last is printed from top to bottom,\nâ€¢ None the rest are also printed from top to bottom, with each slice separated from the next by an empty line. One-dimensional arrays are then printed as rows, bidimensionals as matrices and tridimensionals as lists of matrices. See below to get more details on . If an array is too large to be printed, NumPy automatically skips the central part of the array and only prints the corners: To disable this behaviour and force NumPy to print the entire array, you can change the printing options using . Arithmetic operators on arrays apply elementwise. A new array is created and filled with the result. Unlike in many matrix languages, the product operator operates elementwise in NumPy arrays. The matrix product can be performed using the operator (in python >=3.5) or the function or method: Some operations, such as and , act in place to modify an existing array rather than create a new one. # b is not automatically converted to integer type : Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind' When operating with arrays of different types, the type of the resulting array corresponds to the more general or precise one (a behavior known as upcasting). Many unary operations, such as computing the sum of all the elements in the array, are implemented as methods of the class. By default, these operations apply to the array as though it were a list of numbers, regardless of its shape. However, by specifying the parameter you can apply an operation along the specified axis of an array: NumPy provides familiar mathematical functions such as sin, cos, and exp. In NumPy, these are called â€œuniversal functionsâ€ ( ). Within NumPy, these functions operate elementwise on an array, producing an array as output. One-dimensional arrays can be indexed, sliced and iterated over, much like lists and other Python sequences. # from start to position 6, exclusive, set every 2nd element to 1000 Multidimensional arrays can have one index per axis. These indices are given in a tuple separated by commas: # each row in the second column of b # equivalent to the previous example # each column in the second and third row of b When fewer indices are provided than the number of axes, the missing indices are considered complete slices # the last row. Equivalent to b[-1, :] The expression within brackets in is treated as an followed by as many instances of as needed to represent the remaining axes. NumPy also allows you to write this using dots as . The dots ( ) represent as many colons as needed to produce a complete indexing tuple. For example, if is an array with 5 axes, then # same as c[1, :, :] or c[1] Iterating over multidimensional arrays is done with respect to the first axis: However, if one wants to perform an operation on each element in the array, one can use the attribute which is an iterator over all the elements of the array:\n\nChanging the shape of an array# An array has a shape given by the number of elements along each axis: The shape of an array can be changed with various commands. Note that the following three commands all return a modified array, but do not change the original array: The order of the elements in the array resulting from is normally â€œC-styleâ€, that is, the rightmost index â€œchanges the fastestâ€, so the element after is . If the array is reshaped to some other shape, again the array is treated as â€œC-styleâ€. NumPy normally creates arrays stored in this order, so will usually not need to copy its argument, but if the array was made by taking slices of another array or created with unusual options, it may need to be copied. The functions and can also be instructed, using an optional argument, to use FORTRAN-style arrays, in which the leftmost index changes the fastest. The function returns its argument with a modified shape, whereas the method modifies the array itself: If a dimension is given as in a reshaping operation, the other dimensions are automatically calculated: Several arrays can be stacked together along different axes: The function stacks 1D arrays as columns into a 2D array. It is equivalent to only for 2D arrays: # the result is different In general, for arrays with more than two dimensions, stacks along their second axes, stacks along their first axes, and allows for an optional arguments giving the number of the axis along which the concatenation should happen. In complex cases, and are useful for creating arrays by stacking numbers along one axis. They allow the use of range literals . When used with arrays as arguments, and are similar to and in their default behavior, but allow for an optional argument giving the number of the axis along which to concatenate. Splitting one array into several smaller ones# Using , you can split an array along its horizontal axis, either by specifying the number of equally shaped arrays to return, or by specifying the columns after which the division should occur: # Split `a` after the third and the fourth column splits along the vertical axis, and allows one to specify along which axis to split.\n\nWhen operating and manipulating arrays, their data is sometimes copied into a new array and sometimes not. This is often a source of confusion for beginners. There are three cases: No copy at all# Simple assignments make no copy of objects or their data. # no new object is created # a and b are two names for the same ndarray object Python passes mutable objects as references, so function calls make no copy. # id is a unique identifier of an object Different array objects can share the same data. The method creates a new array object that looks at the same data. # c is a view of the data owned by a # a's shape doesn't change, reassigned c is still a view of a Slicing an array returns a view of it: # s[:] is a view of s. Note the difference between s = 10 and s[:] = 10 The method makes a complete copy of the array and its data. # a new array object with new data is created Sometimes should be called after slicing if the original array is not required anymore. For example, suppose is a huge intermediate result and the final result only contains a small fraction of , a deep copy should be made when constructing with slicing: # the memory of ``a`` can be released. If is used instead, is referenced by and will persist in memory even if is executed. See also Copies and views. Here is a list of some useful NumPy functions and methods names ordered in categories. See Routines and objects by topic for the full list.\n\nNumPy offers more indexing facilities than regular Python sequences. In addition to indexing by integers and slices, as we saw before, arrays can be indexed by arrays of integers and arrays of booleans. # the elements of `a` at the positions `i` When the indexed array is multidimensional, a single array of indices refers to the first dimension of . The following example shows this behavior by converting an image of labels into a color image using a palette. # each value corresponds to a color in the palette We can also give indexes for more than one dimension. The arrays of indices for each dimension must have the same shape. # indices for the first dim of `a` # indices for the second dim # i and j must have equal shape In Python, is exactly the same as â€”so we can put and in a and then do the indexing with that. However, we can not do this by putting and into an array, because this array will be interpreted as indexing the first dimension of . File , line , in : index 3 is out of bounds for axis 0 with size 3 Another common use of indexing with arrays is the search of the maximum value of time-dependent series: # index of the maxima for each series # times corresponding to the maxima You can also use indexing with arrays as a target to assign to: However, when the list of indices contains repetitions, the assignment is done several times, leaving behind the last value: This is reasonable enough, but watch out if you want to use Pythonâ€™s construct, as it may not do what you expect: Even though 0 occurs twice in the list of indices, the 0th element is only incremented once. This is because Python requires to be equivalent to . When we index arrays with arrays of (integer) indices we are providing the list of indices to pick. With boolean indices the approach is different; we explicitly choose which items in the array we want and which ones we donâ€™t. The most natural way one can think of for boolean indexing is to use boolean arrays that have the same shape as the original array: # `b` is a boolean with `a`'s shape This property can be very useful in assignments: # All elements of `a` higher than 4 become 0 You can look at the following example to see how to use boolean indexing to generate an image of the Mandelbrot set: \"\"\"Returns an image of the Mandelbrot fractal of size (h,w).\"\"\" The second way of indexing with booleans is more similar to integer indexing; for each dimension of the array we give a 1D boolean array selecting the slices we want: Note that the length of the 1D boolean array must coincide with the length of the dimension (or axis) you want to slice. In the previous example, has length 3 (the number of rows in ), and (of length 4) is suitable to index the 2nd axis (columns) of . The function can be used to combine different vectors so as to obtain the result for each n-uplet. For example, if you want to compute all the a+b*c for all the triplets taken from each of the vectors a, b and c: You could also implement the reduce as follows: The advantage of this version of reduce compared to the normal ufunc.reduce is that it makes use of the broadcasting rules in order to avoid creating an argument array the size of the output times the number of vectors."
    },
    {
        "link": "https://numpy.org/doc/2.1/reference/generated/numpy.ndarray.astype.html",
        "document": "Copy of the array, cast to a specified type.\n\nTypecode or data-type to which the array is cast. Controls the memory layout order of the result. â€˜Câ€™ means C order, â€˜Fâ€™ means Fortran order, â€˜Aâ€™ means â€˜Fâ€™ order if all the arrays are Fortran contiguous, â€˜Câ€™ order otherwise, and â€˜Kâ€™ means as close to the order the array elements appear in memory as possible. Default is â€˜Kâ€™. Controls what kind of data casting may occur. Defaults to â€˜unsafeâ€™ for backwards compatibility.\nâ€¢ None â€˜noâ€™ means the data types should not be cast at all.\nâ€¢ None â€˜equivâ€™ means only byte-order changes are allowed.\nâ€¢ None â€˜safeâ€™ means only casts which can preserve values are allowed.\nâ€¢ None â€˜same_kindâ€™ means only safe casts or casts within a kind, like float64 to float32, are allowed.\nâ€¢ None â€˜unsafeâ€™ means any data conversions may be done. If True, then sub-classes will be passed-through (default), otherwise the returned array will be forced to be a base-class array. By default, astype always returns a newly allocated array. If this is set to false, and the , order, and subok requirements are satisfied, the input array is returned instead of a copy. Unless is False and the other conditions for returning the input array are satisfied (see description for input parameter), arr_t is a new array of the same shape as the input array, with dtype, order given by , order. When casting from complex to float or int. To avoid this, one should use .\n\nChanged in version 1.17.0: Casting between a simple data type and a structured one is possible only for â€œunsafeâ€ casting. Casting to multiple fields is allowed, but casting from multiple fields is not.\n\nChanged in version 1.9.0: Casting from numeric to string types in â€˜safeâ€™ casting mode requires that the string dtype length is long enough to store the max integer/float value converted."
    },
    {
        "link": "https://scipy-lectures.org/advanced/image_processing",
        "document": "2.6. Image manipulation and processing using Numpy and ScipyÂ¶\n\nThis section addresses basic image manipulation and processing using the core scientific modules NumPy and SciPy. Some of the operations covered by this tutorial may be useful for other kinds of multidimensional array processing than image processing. In particular, the submodule provides functions operating on n-dimensional NumPy arrays.\n\nTools used in this tutorial:\nâ€¢ None : submodule dedicated to image processing (n-dimensional images). See the documentation:\nâ€¢ Image segmentation: labeling pixels corresponding to different objects\n\n# First we need to create the PNG file Need to know the shape and dtype of the image (how to separate data bytes). For large data, use for memory mapping:\n\nLocal filters: replace the value of pixels by a function of the values of neighboring pixels. increase the weight of edges by adding an approximation of the Laplacian: A Gaussian filter smoothes the noise outâ€¦ and the edges as well:\nâ€¢ Create a binary image (of 0s and 1s) with several objects (circles, ellipses, squares, or random shapes).\nâ€¢ Try two different denoising methods for denoising the image: gaussian filtering and median filtering.\nâ€¢ Compare the histograms of the two different denoised images. Which one is the closest to the histogram of the original (noise-free) image? More denoising filters are available in , see the Scikit-image: image processing tutorial. See wikipedia for a definition of mathematical morphology. Probe an image with a simple shape (a structuring element), and modify this image according to how the shape locally fits or misses the image. Erosion = minimum filter. Replace the value of a pixel by the minimal value covered by the structuring element.: Many other mathematical morphology operations: hit and miss transform, tophat, etc.\n\nUse mathematical morphology to clean up the result: Check that reconstruction operations (erosion + propagation) produce a better result than opening/closing: Check how a first denoising step (e.g. with a median filter) modifies the histogram, and check that the resulting histogram-based segmentation is more accurate. More advanced segmentation algorithms are found in the : see Scikit-image: image processing. Other Scientific Packages provide algorithms that can be useful for image processing. In this example, we use the spectral clustering function of the in order to segment glued objects. # Convert the image into a graph with the value of the gradient on # Take a decreasing function of the gradient: we take it weakly # dependant from the gradient the segmentation is close to a voronoi\n\nCompute size, mean_value, etc. of each region: Can be used outside the limited scope of segmentation applications. # note that we use broadcasting When regions are regular blocks, it is more efficient to use stride tricks (Example: fake dimensions with strides). One example with mathematical morphology: granulometry"
    },
    {
        "link": "https://stackoverflow.com/questions/10443295/combine-3-separate-numpy-arrays-to-an-rgb-image-in-python",
        "document": "So I have a set of data which I am able to convert to form separate numpy arrays of R, G, B bands. Now I need to combine them to form an RGB image.\n\nI tried 'Image' to do the job but it requires 'mode' to be attributed.\n\nI tried to do a trick. I would use Image.fromarray() to take the array to image but it attains 'F' mode by default when Image.merge requires 'L' mode images to merge. If I would declare the attribute of array in fromarray() to 'L' at first place, all the R G B images become distorted.\n\nBut, if I save the images and then open them and then merge, it works fine. Image reads the image with 'L' mode.\n\nNow I have two issues.\n\nFirst, I dont think it is an elegant way of doing the work. So if anyone knows the better way of doing it, please tell\n\nSecondly, Image.SAVE is not working properly. Following are the errors I face:\n\nAnd please mind that the image is around 4000x4000 size array."
    },
    {
        "link": "https://analyticsvidhya.com/blog/2021/05/image-processing-using-numpy-with-practical-implementation-and-code",
        "document": "Image Processing Using Numpy: With Practical Implementation And Code\n\nNumPy also called Numerical Python is an amazing library open-source Python library for data manipulation and scientific computing. It is used in the domain of linear algebra, Fourier transforms, matrices, and the data science field. which is used. NumPy arrays are way faster than Python Lists.You must have known about Image processing Libraries such as OpenCV, Python Image Library(PIL), Scikit-Image, and many more. If you would like to know more about Image Processing Libraries in Python, then must check out this article.ðŸ™‚\n\nFor more articles related to machine learning and Python ðŸ˜ŠðŸ˜Š , check out this Link\n\nYou must be wondering that NumPy is also used for Image Processing. The fundamental idea is that we know images are made up of NumPy ndarrays. So we can manipulate these arrays and play with images. I hope this blog will give you a broad overview of NumPy for Image Processing.ðŸ˜\n\nThis article was published as a part of the Data Science Blogathon.\n\nType below commands in Anaconds Prompt and all the required will get installed.\n\nWe are using numpy, matplotlib, and Python Imaging Library (PIL) libraries for our further analysis.\n\nTo open an image, we are using the open() method from the PIL Image module. Similarly, we can use the matplotlib library to read and show images. It uses an image module for working with images. It offers two useful methods imread() and imshow()\n\nIn this analysis, we are using imshow() method to display the image.\n\nIn this section, we will see what is the dimension, shape, and data type of an image. To check the size of the image, we are using the Image.size property. Check the below code:\n\nTo save a ndarray as an image, we are using the Imag.save() method.\n\nWe are rotating an image from scratch without using the PIL library. If you would like to rotate an image by using the PIL, then use Image.rotate() method.\n\nAlgorithm: image(ndarray) -> transpose -> mirror image across y axis (middle column)\n\nCheck the below code to rotate an image by 90 degrees in a clockwise direction.\n\nCheck the below code to rotate an image by 90 degrees in an anticlockwise direction.\n\nConverting a color image to a negative image is very simple. You to perform only 3 steps for each pixel of the image\nâ€¢ First, get the RGB values of the pixel\nâ€¢ Finally, save the new RGB values in the pixel\n\nCheck the below code to convert an image to a negative image.\n\nTo add black padding around an image, use the below code:\n\nTo split the image into each RGB colors, you can use the below code:\n\nWe can reduce the color intensity depends on our needs. Check the below code for color reduction.\n\nWe can trim an image in Numpy using Array Slicing. Check the below code for trimming an image using python.\n\nWe can paste a slice of an image onto another image. Check the below code in Python for pasting a slice of the image.\n\nWe can also binarize an Image using Numpy. Check the below code to binarize an image.\n\nCheck the below code for flipping an image.\n\nAn Alternate way to Flip an Image\n\nCheck the below code for Flipping an Image:\n\nIf you want to blend two images, then you can do that too. Check the below code\n\nCheck the below code for masking an image.\n\nLetâ€™s draw the histogram using a matplotlib hist() function. Check the below code to draw the Pixel Intensity Histogram\n\nSo in this article, we had a detailed discussion on Image Processing Using Numpy. Hope you learn something from this blog and it will help you in the future. Thanks for reading and your patience. Good luck!\n\nThe media shown in this article are not owned by Analytics Vidhya and is used at the Authorâ€™s discretion."
    },
    {
        "link": "https://pythoninformer.com/python-libraries/numpy/numpy-and-images",
        "document": "In this section, we will learn how to use NumPy to store and manipulate image data. We will use the Python Imaging Library (PIL) to read and write data to standard image file formats.\n\nThis article explains how image data is stored in a NumPy array. Other articles include:\nâ€¢ NumPy image transformations - scaling, rotating, and general affine transforms on images using the ndimage module from the SciPy package.\n\nIf you want to learn more about numpy in general, try the other tutorials.\n\nBefore trying these examples you will need to install the NumPy and Pillow packages (Pillow is a fork of the PIL library).\n\nHere is a 5 by 4 pixel RGB image:\n\nThe image contains 4 lines of pixels. Each line of pixels contains 5 pixels. Each pixel contains 3 bytes (representing the red, green and blue values of the pixel colour):\n\nRGB images are usually stored as 3-dimensional arrays of 8-bit unsigned integers. The shape of the array is:\n\nHere is how we create an array to represent a 5 pixel wide by 4 pixel high image:\n\nNotice that the first dimension is the height, and the second dimension is the width. That is because the data is ordered by lines, then each line is ordered by pixels, and finally, each pixel contains 3-byte values for RGB. Each colour is represented by an unsigned byte ( type ).\n\nNow let's fill the array with orange pixels (red=255, green=128, blue=0). We use slices to do this, the three values are broadcast across all the rows and columns of the array:\n\nNow we can use to create a PIL image from the NumPy array, and save it as a PNG file:\n\nThe PIL function function creates a PIL image from a NumPy array. If the NumPy array has the shape it will automatically create an RGB image. We can then use the PIL function to save the image. By default, the image type will be based on the file extension, so in this case, it will be a PNG image.\n\nNow let's add some code to create a NumPy image and then save it:\n\nWhat does this code do?\nâ€¢ Use slice notation to fill the left half of the array with orange.\nâ€¢ Use slice notation to fill the right half of the array with blue.\n\nAnd here is the image:\n\nAn RGBA image has 4 channels (unlike an RGB image that has only 3). The fourth channel is an alpha channel. An alpha value of 255 will make the pixel fully opaque, a value of 0 will make it fully transparent, and values in between will make the pixel partly transparent.\n\nIn the code below we create an RGBA image, initially setting the same blue and orange areas as before, with an alpha value of 255. We then create a 1-dimensional array of length 200 with values that gradually change from 0 to 255. We fill channel 3 of each line of the image with these values. This means that the pixels on the left side of the image will be transparent, and the pixels on the right will be almost fully opaque. The transparency varies smoothly from left to right:\n\nAnd here is the image:\n\nThe left-hand side of the image is more transparent. This allows the white background of the page to show through, making the colour appear lighter towards the left.\n\nGreyscale images are handled slightly differently. Because there is only one channel, there is no need to create a 3-dimensional array, you should use a 2-dimensional array instead:\n\nIn this case, we have created a chequerboard image:\n\nYou can read an image using the PIL function, and convert it to an array using the numpy function. Here, we read the images that were created previously, and print their NumPy shape:\n\nYou can manipulate the image data and write it back out to a file. For example, this code inverts a greyscale image (swapping black and white). and saves it back:\n\nThis is a very simple example of image processing. See the links at the start of this article for other image processing techniques using NumPy."
    },
    {
        "link": "https://stackoverflow.com/questions/69783111/how-to-create-a-numpy-image-array-with-the-rgb-value-of-each-point-using-python",
        "document": "When processing images with Python, you should try and use vectorised Numpy operations because they are much faster, and less prone to errors. If you start using Python and loops, you have probably gone wrong already IMHO.\n\nI am not certain, but I think you want to generate a random image and subtract it from an input image so you need both parts to recreate the whole, so I think you want code more like this:\n\nIf you prefer to persist with lists and loops, there are a few issues in your code:\nâ€¢ None you keep recycling , so initially it is PIL , then it's a Numpy , then a PIL so it is hard to refer back to anything you calculated earlier\nâ€¢ None rather than which gives you an array of , you should use to get an unsigned 8-bit array, because PIL will not like 192-bits/pixel\nâ€¢ None the shape of the Numpy array you create from the list will be wrong and need reshaping with\nâ€¢ None rather than calling three times for every pixel and converting the result to a Numpy array, you could call to get all three values as a Numpy array in one call\nâ€¢ None you are probably going to have problems with overflows and underflows since you lose the underlying type of values in lists"
    },
    {
        "link": "https://note.nkmk.me/en/python-numpy-image-processing",
        "document": "By reading the image as a NumPy array , various image processing can be performed using NumPy functions.\n\nBy operating ndarray, you can get and set (change) pixel values, trim images, concatenate images, etc. Those who are familiar with NumPy can do various image processing without using libraries such as OpenCV.\n\nEven when using OpenCV, OpenCV for Python treats image data as , so it is useful to know how to use NumPy ( ). In addition to OpenCV, many libraries such as scikit-image treat images as .\n\nThis article describes the following contents.\nâ€¢ How to read image file as NumPy array\nâ€¢ How to save NumPy array as image file\n\nSample codes on this article use Pillow to read and save image files. If you want to use OpenCV, see the following article.\n\nSee also the following article about Pillow. Simple operations such as reading, saving, resizing, and rotating images can be done by Pillow alone.\nâ€¢ How to use Pillow (PIL: Python Imaging Library)\n\nHow to read an image file as\n\nTake the following image as an example.\n\nPassing the image data read by to returns 3D whose shape is .\n\nThe order of colors (channels) is RGB (red, green, blue). Note that it is different from the case of reading with of OpenCV.\n\nIf you convert the image to grayscale with and then pass it to , it returns 2D whose shape is .\n\nYou can also get from with . returns a rewritable , while returns a read-only .\n\nFor , you can change the value of the element (pixel).\n\nFor , you cannot change value because rewriting is prohibited. It is possible to create a new based on the read .\n\nThe data type of the read is (8-bit unsigned integer).\n\nIf you want to process it as a floating point number , you can convert it with or specify the data type in the second argument of and .\n\nSee the following article for more information about the data type in NumPy.\nâ€¢ NumPy: astype() to change dtype of an array\n\nHow to save NumPy array as image file\n\nPassing to returns . It can be saved as an image file with method. The format of the saved file is automatically determined from the extension of the path passed in the argument of .\n\nA grayscale image (2D array) can also be passed to . automatically becomes (grayscale). It can be saved with .\n\nIf you just want to save it, you can write it in one line.\n\nIf the data type of is , etc., an error will occur, so it is necessary to convert to .\n\nNote that if the pixel value is represented by to , it is necessary to multiply by and convert to and save.\n\nWith , parameters according to the format can be passed as arguments. See Image file format for details.\n\nFor example, in the case of JPG, you can pass the quality of the image as the argument . It ranges from (the lowest) to (the highest) and defaults to .\nâ€¢ How to use Pillow (PIL: Python Imaging Library)\n\nYou can get the value of a pixel by specifying the coordinates at the index of . Note that the order is in xy coordinates. The origin is the upper left.\n\nThe above example shows the value at , i.e., the 100th row and 150th column of pixels. As mentioned above, the colors of the obtained using Pillow are in RGB order, so the result is .\n\nYou can also use unpacking to assign them to separate variables.\n\nIt is also possible to get the value by specifying the color.\n\nYou can also change to a new value. You can change RGB all at once or change it with just a single color.\n\nFor more information on getting and setting values of an , see the following article.\nâ€¢ NumPy: Get and set values in an array using various indexing\n\nGenerate single-color images by setting other color values to , and concatenate them horizontally with .\n\nIt is also easy to calculate and manipulate pixel values.\n\nA negative-positive inverted image can be generated by subtracting the pixel value from the max value ( for ).\n\nBecause the original size is too large, it is resized with for convenience. The same applies to the following examples.\n\nCut off the remainder of the division using and multiply again, the pixel values become discrete, and the number of colors can be reduced.\n\nIt is also possible to assign to black and white according to the threshold.\n\nSee the following articles for details.\n\nYou can do anything you want with pixel values, such as multiplication, division, exponentiation, etc.\n\nYou don't need to use the loop because the entire image can be calculated as it is.\n\nAs a result of the calculation, the data type of is converted to the floating point number . Note that you need to convert it to when you save it.\n\nBy specifying an area with slice, you can trim it to a rectangle.\n\nSee the following article for more information on slicing for .\n\nIt may be convenient to define a function that specifies the upper left coordinates and the width and height of the area to be trimmed.\n\nIf you specify outside the size of the image, it will be ignored.\n\nYou can also split the image by slicing.\n\nIt is also possible to split the image with NumPy function.\n\nsplits horizontally. If an integer value is specified for the second argument, is split equally.\n\nIf a list is specified as the second argument, is split at the position of that value.\n\nsplits vertically. The usage of is the same as .\n\nWhen an integer value is specified as the second argument with or , an error is raised if it cannot be split equally. adjusts the size appropriately and splits it.\nâ€¢ NumPy: Split an array with np.split, np.vsplit, np.hsplit, etc.\n\nUsing slices, one array rectangle can be replaced with another array rectangle.\n\nBy using this, a part of the image or the entire image can be pasted to another image.\n\nNote that an error will occur if the size of the area specified on the left side differs from the size of the area specified on the right side.\n\nBy the operation for each element (= pixel) of the array, two images can be alpha-blended or composited based on a mask image. See the following articles for details.\nâ€¢ Alpha blending and masking of images with Python, OpenCV, NumPy\n\nThere are also functions that rotate the array and flip it up, down, left, and right."
    }
]