[
    {
        "link": "https://mui.com/x/react-data-grid/filtering/customization?srsltid=AfmBOopLY7yjXtG5IsJkMJOiB5CvClHUj421WGsUOykb5eSu6Pg1ynD0",
        "document": "The full typing details can be found on the GridFilterOperator API page. An operator determines if a cell value should be considered as a valid filtered value. The candidate value used by the operator is the one corresponding to the attribute or the value returned by the of the . Each column type comes with a default array of operators. You can get them by importing the following functions: You can find more information about the supported column types in the columns section. If the built-in filter operators are not enough, creating a custom operator is an option. A custom operator is defined by creating a object. This object has to be added to the attribute of the . The main part of an operator is the function. When applying the filters, the Data Grid will call this function with the filter item and the column on which the item must be applied. This function must return another function that takes the cell value as an input and return if it satisfies the operator condition. operator GridFilterOperator any number label value filterItem column filterItem field filterItem value filterItem operator value row column apiRef value filterItem value InputComponent RatingInputValue InputComponentProps type The is only used for rendering purposes. If the column has a , then will be the resolved value. The filter button displays a tooltip on hover if there are active filters. Pass in the filter operator to customize or convert the value to a more human-readable form. In the demo below, you can see how to create a completely new operator for the Rating column.\n\nYou can create custom operators that re-use the logic of the built-in ones. In the demo below, the selected rows are always visible even when they don't match the filtering rules.\n\nYou can create a custom operator which accepts multiple values. To do this, provide an array of values to the property of the . The of the will be applied to each item of the array. The filtering function must be adapted to handle as an array. Below is an example for a \"between\" operator, applied on the \"Quantity\" column. operator GridFilterOperator any number label value filterItem Array filterItem value filterItem value length filterItem value filterItem value value value filterItem value value value filterItem value InputComponent InputNumberInterval\n\nTo remove built-in operators, import the method to generate them and filter the output to fit your needs. In the demo below, the column only has the and operators.\n\nThe value used by the operator to look for has to be entered by the user. On most column types, a text field is used. However, a custom component can be rendered instead. In the demo below, the column reuses the numeric operators but the rating component is used to enter the value of the filter.\n\nWhen defining a custom column type, by default the Data Grid will reuse the operators from the type that was extended. The filter operators can then be edited just like on a regular column. You can customize the rendering of the filter panel as shown in the component section of the documentation. The customization of the filter panel content can be performed by passing props to the default component. The available props allow overriding:\nâ€¢ The (can contains and )\nâ€¢ The order of the column selector (can be or )\nâ€¢ Any prop of the input components Input components can be customized by using two approaches. You can pass a prop to any input container or you can use CSS selectors on nested components of the filter panel. More details are available in the demo. The value input is a special case, because it can contain a wide variety of components (the one provided or your custom ). To pass props directly to the and not its wrapper, you can use ."
    },
    {
        "link": "https://mui.com/x/react-data-grid/filtering?srsltid=AfmBOooxMf040nZQ6aOYfqK_ufqkUTilyfIkQ7MlmE1tMxnDqzrUUk1T",
        "document": "Easily filter your rows based on one or several criteria. The filters can be modified through the Data Grid interface in several ways:\nâ€¢ By opening the column menu and clicking the Filter menu item.\nâ€¢ By clicking the Filters button in the Data Grid toolbar (if enabled). Each column type has its own filter operators. The demo below lets you explore all the operators for each built-in column type. See the dedicated section to learn how to create your own custom filter operator.\n\nThe Data Grid can only filter the rows according to one criterion at the time. To use multi-filters, you need to upgrade to the Pro plan or above. The full typing details can be found on the GridFilterModel API page. The filter model is composed of a list of and a : A filter item represents a filtering rule and is composed of several elements:\nâ€¢ : the field on which the rule applies.\nâ€¢ : the value to look for.\nâ€¢ : name of the operator method to use (for example contains), matches the key of the operator object.\nâ€¢ (): required when multiple filter items are used. Some operators do not need any value (for instance the operator of the column). The tells the Data Grid if a row should satisfy all ( ) filter items or at least one ( ) in order to be considered valid. filterModel GridFilterModel items id field operator value id field operator value logicOperator GridLogicOperator Or filterModel GridFilterModel items id field operator value id field operator value logicOperator GridLogicOperator And If no is provided, the Data Grid will use by default. To initialize the filters without controlling them, provide the model to the prop.\n\nUse the prop to control the filter applied on the rows. You can use the prop to listen to changes to the filters and update the prop accordingly.\n\nTo disable the filter of a single column, set the property in to . In the example below, the rating column cannot be filtered.\n\nYou can initialize the , set the prop, or use the API method to set the filters for non-filterable columns. These filters will be applied but will be read-only on the UI and the user won't be able to change them.\n\nBy default, the user stays on the same page after a filter is applied, unless the new row count indicates that that page doesn't exist anymore. In that case, the user is sent to the last page as defined by the new row count. To send the user back to the first page when a new filter is applied, use the prop.\n\nYou can ignore diacritics (accents) when filtering the rows. See Quick filter - Ignore diacritics (accents). The grid exposes a set of methods that enables all of these features using the imperative . To know more about how to use it, check the API Object section. Only use this API as the last option. Give preference to the props to control the Data Grid."
    },
    {
        "link": "https://stackoverflow.com/questions/67158647/material-ui-datagrid-custom-list-filter",
        "document": "I tried some custom filters on the Material UI DataGrid, e.g. https://material-ui.com/components/data-grid/filtering/\n\nBut I don't see the possiblity to make a list with text to filter. So one row contains \"start\", \"stop\" and \"undefined\" as values. How can I filter them directly without typing in the text all the time? (something like a list of predefined values)\n\nThank you in advance."
    },
    {
        "link": "https://github.com/mui/mui-x/issues/9782",
        "document": "The DataGrid offers an impressive list of options to customise filtering, but unfortunately sometimes a completely customised UI is needed. I'm looking for a way to intercept the actual entry points into the filtering to use my existing filtering solution.\n\nI have a use case where the filtering is done on the server using a custom filter UI for each individual data set.\n\n The filter UI is completely externalised and does already exist and I would need to make the DataGrid use the existing filter dialogs.\n\nAssuming that only the UI to invoke filtering offered by the DataGrid is used and the rest is custom implemented , only two callbacks (that I cannot find) would be needed:\nâ€¢ a callback when the filter option from the column menu is clicked\nâ€¢ a callback when the filter icon on column header when there are active filters\n\nAdditionally it would only be needed to set the number of active filters for each column, so the UI can be initialised whin the predefined filter definition.\n\nAssuming that the DataGrid would allow me call my custom code when the user invokes the above functions, it should be possible to add a customised filtering logic in a very generic way.\nâ€¢ Allow to intercept when the user wants to set a new filter for a column:\nâ€¢ Allow to intercept when to user wants to modify an existing filter:\n\nI have spend quite some time investigating all the available customisation options in DataGrid and am quite impressed.\n\n Unfortunately when a completely customised filter UI is needed this currently does not seem to be possible.\n\n As far as I understand it should be possible to completely customise the filtering by simply hooking into the entry points when setting or changing a filter."
    },
    {
        "link": "https://mui.com/x/api/data-grid/grid-filter-panel?srsltid=AfmBOooJ0Lod5AENB-eOfMuVGRs5eIpNQVCBdADgzQZqExAfU72i_vNp",
        "document": "API reference docs for the React GridFilterPanel component. Learn about the props, CSS, and other APIs of this exported module.\n\nLearn about the difference by reading this guide on minimizing bundle size.\n\nChanges how the options in the columns selector should be ordered. If not specified, the order is derived from the prop. If , the button will not be displayed. If , the button will be disabled Type : { columnInputProps?: any, columnsSort?: 'asc'\n\n| 'desc', deleteIconProps?: any, filterColumns?: func, logicOperatorInputProps?: any, operatorInputProps?: any, valueInputProps?: any } Function that returns the next filter item to be picked as default filter. The system prop that allows defining system overrides as well as additional CSS styles. See the `sx` page for more details.\n\nThe is forwarded to the root element.\n\nIf you did not find the information in this page, consider having a look at the implementation of the component for more detail."
    },
    {
        "link": "https://mui.com/material-ui/react-select?srsltid=AfmBOopWnUAKpxjz6cv9M1Yk9uYbjHm8BxAefIymajR_hNVtTgj6wck1",
        "document": "The Select component is meant to be interchangeable with a native element. If you are looking for more advanced features, like combobox, multiselect, autocomplete, async or creatable support, head to the component. It's meant to be an improved version of the \"react-select\" and \"downshift\" packages. The Select component is implemented as a custom element of the InputBase. It extends the text field components subcomponents, either the OutlinedInput, Input, or FilledInput, depending on the variant selected. It shares the same styles and many of the same props. Refer to the respective component's API page for details. Unlike input components, the prop is not available in Select. To add a placeholder, refer to the placeholder section below.\n\nThe wrapper component is a complete form control including a label, input and help text. You can find an example with the select mode in this section. Here are some examples of customizing the component. You can learn more about this in the overrides documentation page. The first step is to style the component. Once it's styled, you can either use it directly as a text field or provide it to the select prop to have a field. Notice that the variant is easier to customize, since it does not wrap the contents in a / markup.\n\nðŸŽ¨ If you are looking for inspiration, you can check MUI Treasury's customization examples. The component can handle multiple selections. It's enabled with the prop. Like with the single selection, you can pull out the new value by accessing in the callback. It's always an array.\n\nIf you wish to wrap the ListSubheader in a custom component, you'll have to annotate it so Material UI can handle it properly when determining focusable elements. You have two options for solving this: Option 1: Define a static boolean field called on your component function, and set it to : Option 2: Place a prop on each instance of your component. The prop doesn't have to be forwarded to the ListSubheader, nor present in the underlying DOM element. It just has to be placed on a component that's used as a subheader. We recommend the first option as it doesn't require updating all the usage sites of the component. Keep in mind this is only necessary if you wrap the ListSubheader in a custom component. If you use the ListSubheader directly, no additional code is required. To properly label your input you need an extra element with an that contains a label. That needs to match the of the , for example: Alternatively a with an and creates the proper markup and ids for you: For a native select, you should mention a label by giving the value of the attribute of the select element to the 's attribute:"
    },
    {
        "link": "https://stackoverflow.com/questions/74836479/using-select-component-in-datagrid-mui",
        "document": "I created a table using DataGrid MUI library and wanted to add a select component to all the cells for a specific column\n\nWhat I did so far\n\nI created a Select component and pass it to in colDef\n\nmy component used since I wanted it to be editable\n\nsubsequently, for each cell, there is a , and that makes the table heavy, Is there any idea to improve it?"
    },
    {
        "link": "https://mui.com/material-ui/react-text-field?srsltid=AfmBOooACe3cTxLfPYqQXVn4dPKh8eARlpVtmREWx3BGLznqC0fucjhR",
        "document": "is composed of smaller components ( , , , , , and ) that you can leverage directly to significantly customize your form inputs. You might also have noticed that some native HTML input properties are missing from the component. This is on purpose. The component takes care of the most used properties. Then, it's up to the user to use the underlying component shown in the following demo. Still, you can use (and , properties) if you want to avoid some boilerplate.\n\nðŸŽ¨ If you are looking for inspiration, you can check MUI Treasury's customization examples. For advanced customization use cases, a hook is exposed. This hook returns the context value of the parent component.\nâ€¢ (bool): Indicate whether the child or component has a start adornment.\nâ€¢ (string): The theme color is being used, inherited from prop .\nâ€¢ (bool): Indicate whether the component is being displayed in a disabled state, inherited from prop.\nâ€¢ (bool): Indicate whether the component is being displayed in an error state, inherited from prop\nâ€¢ (bool): Indicate whether input is filled\nâ€¢ (bool): Indicate whether the component and its children are being displayed in a focused state\nâ€¢ (bool): Indicate whether the component is taking up the full width of its container, inherited from prop\nâ€¢ (bool): Indicate whether the label is being hidden, inherited from prop\nâ€¢ (bool): Indicate whether the label is indicating that the input is required input, inherited from the prop\nâ€¢ (string): The size of the component, inherited from the prop\nâ€¢ (string): The variant is being used by the component and its children, inherited from prop\nâ€¢ (func): Should be called when the input is blurred\nâ€¢ (func): Should be called when the input is focused\nâ€¢ (func): Should be called when the input is emptied\nâ€¢ (func): Should be called when the input is filled\n\nGlobal styles for the auto-fill keyframes are injected and removed on each mount and unmount, respectively. If you are loading a large number of Text Field components at once, it might be a good idea to change this default behavior by enabling in . Make sure to inject for the auto-fill keyframes at the top of your application. The input label \"shrink\" state isn't always correct. The input label is supposed to shrink as soon as the input is displaying something. In some circumstances, we can't determine the \"shrink\" state (number input, datetime input, Stripe input). You might notice an overlap. To workaround the issue, you can force the \"shrink\" state of the label. The floating label is absolutely positioned. It won't impact the layout of the page. Make sure that the input is larger than the label to display correctly. We do not recommend using with a Text Field due to potential usability issues:\nâ€¢ it allows certain non-numeric characters ('e', '+', '-', '.') and silently discards others\nâ€¢ the functionality of scrolling to increment/decrement the number can cause accidental and hard-to-notice changes\nâ€¢ and moreâ€”see Why the GOV.UK Design System team changed the input type for numbers for a more detailed explanation of the limitations of If you need a text field with number validation, you can use MUI Base's Number Input instead. You can follow this GitHub issue to track the progress of introducing the Number Input component to Material UI. The helper text prop affects the height of the text field. If two text fields are placed side by side, one with a helper text and one without, they will have different heights. For example:"
    },
    {
        "link": "https://stackoverflow.com/questions/74939133/how-can-i-use-mui-textfield-with-select-and-multiple-props",
        "document": "I am trying to create multiple select input but had problem with the TextField because it is not accepting multiple props My TextField is shown in the code block.\n\nWith TextField I can't select multiple items but label seems pretty nice\n\n\n\nThen I found a solution to choose multiple select which I used and as shown in the code block.\n\nWith Select I can select multiple items perfectly but the label seems weird.\n\n\n\nAlso when there are no items selected input gets weird too"
    },
    {
        "link": "https://mui.com/x/react-data-grid?srsltid=AfmBOor5mKZprcX77seLezKNJ4S0A521_i1AzpmN0e0sqU1rDlgq4yHY",
        "document": "A fast and extendable React data table and React data grid. It's a feature-rich component available with MIT or commercial licenses. The Data Grid component is built with React and TypeScript to provide a smooth UX for manipulating an unlimited set of data. It features an intuitive API for real-time updates as well as theming and custom templatesâ€”all with blazing-fast performance.\n\nThe Data Grid presents information in a structured format of rows and columns. The data is displayed in a user-friendly interface for efficient editing, reviewing, and analysis. Visit the installation guide to learn how to install the correct package version and dependencies. The component comes in three different versions, one available under MIT license and two available under commercial license. The MIT-licensed version (also referred to as the \"Community version\") is a stronger alternative to plain data tables. It's a clean abstraction with basic features like editing, pagination, column grouping, and single-column sorting and filtering.\n\nThe commercially licensed versions are available in two plans: Pro and Premium. The Pro plan extends the features available in the Community version to support more complex use cases. It adds features like advanced filtering, column pinning, column and row reordering, support for tree data, and virtualization to handle bigger datasets. The demo below displays 31 columns and 100,000 rowsâ€”over 3 million cells in total.\n\nThe Premium plan includes everything from Pro, as well as advanced features for data analysis and large dataset management, like row grouping with aggregation functions (such as sum and average) and the ability to export to Excel files. Visit the showcase page for a comprehensive overview of all features exclusive to this plan. The demo below groups rows by commodity name, and uses an aggregation function to calculate the sum of quantities for each group and in total (displayed in a summary row). You can experiment with grouping other columns in the columns' header menus. And since you're here, try exporting to Excel and copying and pasting data from-to Excel tables."
    }
]