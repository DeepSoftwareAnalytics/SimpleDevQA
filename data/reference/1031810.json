[
    {
        "link": "https://angelcode.com/products/bmfont/documentation.html",
        "document": "The Bitmap Font Generator is a free program to generate bitmap fonts from true type fonts. The bitmaps are generated in such a way as to leave as little unused space as possible. The position of the characters in the bitmap is not regular so you'll need the generated font descriptor file to determine how to draw each character."
    },
    {
        "link": "https://monogameextended.net/docs/features/fonts/bitmapfont",
        "document": ""
    },
    {
        "link": "https://angelcode.com/products/bmfont",
        "document": ""
    },
    {
        "link": "https://docs.godotengine.org/en/stable/tutorials/ui/gui_using_fonts.html",
        "document": "Godot allows you to set specific fonts for different UI nodes.\n\nThere are three different places where you can setup font usage. The first is the theme editor. Choose the node you want to set the font for and select the font tab. The second is in the inspector for control nodes under Theme Overrides > Fonts. Lastly, in the inspector settings for themes under Default Font.\n\nIf no font override is specified anywhere, Open Sans SemiBold is used as the default project font.\n\nThere are 2 kinds of font files: dynamic (TTF/OTF/WOFF/WOFF2 formats) and bitmap (BMFont format or monospaced image). Dynamic fonts are the most commonly used option, as they can be resized and still look crisp at higher sizes. Thanks to their vector-based nature, they can also contain a lot more glyphs while keeping a reasonable file size compared to bitmap fonts. Dynamic fonts also support some advanced features that bitmap fonts cannot support, such as ligatures (several characters transforming into a single different design).\n\nGodot supports the BMFont ( ) bitmap font format. This is a format created by the BMFont program. Many BMFont-compatible programs also exist, like BMGlyph or web-based fontcutter. Alternatively, you can import any image to be used as a bitmap font. This is only supported for monospaced fonts (fonts where each character has the same width). To do so, select the image in the FileSystem dock, go to the Import dock, change its import type to Font Data (Monospace Image Font) then click Reimport: The font's character set layout can be in any order, but orders that match standard Unicode are recommended as they'll require far less configuration to import. For example, the bitmap font below contains ASCII characters and follows standard ASCII ordering: The following import options can be used to import the above font image successfully: Import options to use for the above example fontÔÉÅ The Character Ranges option is an array that maps each position on the image (in tile coordinates, not pixels). The font atlas is traversed from left to right and top to bottom. Characters can be specified with decimal numbers ( ), hexadecimal numbers ( ) or between single quotes ( ). Ranges can be specified with a hyphen between characters. For instance, (or ) denotes the full ASCII range. As another example, is equivalent to and denotes the range of printable (visible) ASCII characters. Make sure the Character Ranges option doesn't exceed the number of Columns √ó Rows defined. Otherwise, the font will fail to import. If your font image contains margins not used for font glyphs (such as attribution information), try adjusting Image Margin. This is a margin applied only once around the whole image. If your font image contains guides (in the form of lines between glyphs) or if spacing between characters appears incorrect, try adjusting Character Margin. This margin is applied for every imported glyph.\n\nFont outlines and shadows can be used to improve readability when the background color isn't known in advance. For instance, this is the case for HUD elements that are drawn over a 2D/3D scene. Font outlines are available in most nodes that derive from Control, in addition to Label3D. To enable outline for a font on a given node, configure the theme overrides Font Outline Color and Outline Size in the inspector. The result should look like this: If using a font with MSDF rendering, its MSDF Pixel Range import option be set to at least twice the value of the outline size for outline rendering to look correct. Otherwise, the outline may appear to be cut off earlier than intended. Support for font shadows is more limited: they are only available in Label and RichTextLabel. Additionally, font shadows always have a hard edge (but you can reduce their opacity to make them look more subtle). To enable font shadows on a given node, configure the Font Shadow Color, Shadow Offset X, and Shadow Offset Y theme overrides in a Label or RichTextLabel node accordingly: The result should look like this: You can create local overrides to font display in Label nodes by creating a LabelSettings resource that you reuse across Label nodes. This resource takes priority over theme properties.\n\nYou can adjust how the font should be smoothed out when rendering by adjusting antialiasing and hinting. These are different properties, with different use cases. Antialiasing controls how glyph edges should be smoothed out when rasterizing the font. The default antialiasing method (Grayscale) works well on every display technology. However, at small sizes, grayscale antialiasing may result in fonts looking blurry. The antialiasing sharpness can be improved by using LCD subpixel optimization, which exploits the subpixel patterns of most LCD displays by offsetting the font antialiasing on a per-channel basis (red/green/blue). The downside is that this can introduce \"fringing\" on edges, especially on display technologies that don't use standard RGB subpixels (such as OLED displays). In most games, it's recommended to stick to the default Grayscale antialiasing. For non-game applications, LCD subpixel optimization is worth exploring. Antialiasing cannot be changed on MSDF-rendered fonts ‚Äì these are always rendered with grayscale antialiasing. Hinting controls how aggressively glyph edges should be snapped to pixels when rasterizing the font. None results in the smoothest appearance, which can make the font look blurry at small sizes. Light (default) is sharper by snapping glyph edges to pixels on the Y axis only, while Full is even sharper by snapping glyph edges to pixels on both X and Y axes. Depending on personal preference, you may prefer using one hinting mode over the other. From top to bottom: None, Light, Full hintingÔÉÅ If changing the hinting mode has no visible effect after clicking Reimport, it's usually because the font doesn't include hinting instructions. This can be resolved by looking for a version of the font file that includes hinting instructions, or enabling Force Autohinter in the Import dock. This will use FreeType's autohinter to automatically add hinting instructions to the imported font. Subpixel positioning can be adjusted. This is a FreeType feature that allows glyphs to be rendered more closely to their intended form. The default setting of Auto automatically enables subpixel positioning at small sizes, but disables it at large font sizes to improve rasterization performance. You can force the subpixel positioning mode to Disabled, One half of a pixel or One quarter of a pixel. One quarter of a pixel provides the best quality, at the cost of longer rasterization times. Changing antialiasing, hinting and subpixel positioning has the most visible effect at smaller font sizes. Fonts that have a pixel art appearance should have their subpixel positioning mode set to Disabled. Otherwise, the font may appear to have uneven pixel sizes. This step is not required for bitmap fonts, as subpixel positioning is only relevant for dynamic fonts (which are usually made of vector elements). By default, fonts do not have mipmaps generated to reduce memory usage and speed up rasterization. However, this can cause downscaled fonts to become grainy. This can be especially noticeable with 3D text that doesn't have Fixed Size enabled. This can also occur when displaying text with a traditional rasterized (non-MSDF) font in a Control node that has its scale lower than . After selecting a font in the FileSystem dock, you can enable the Mipmaps in the Import dock to improve downscaled font rendering appearance. Mipmaps can be enabled on MSDF fonts as well. This can improve font rendering quality a little at smaller-than-default sizes, but MSDF fonts are already resistant to graininess out of the box. Multi-channel signed distance field (MSDF) font rendering allows rendering fonts at any size, without having to re-rasterize them when their size changes. MSDF font rendering has 2 upsides over traditional font rasterization, which Godot uses by default:\n‚Ä¢ None The font will always look crisp, even at huge sizes.\n‚Ä¢ None There is less stuttering when rendering characters at large font sizes for the first time, as there is no rasterization performed. The downsides of MSDF font rendering are:\n‚Ä¢ None Higher baseline cost for font rendering. This is usually not noticeable on desktop platforms, but it can have an impact on low-end mobile devices.\n‚Ä¢ None Fonts at small sizes will not look as clear as rasterized fonts, due to the lack of hinting.\n‚Ä¢ None Rendering new glyphs for the first time at small font sizes may be more expensive compared to traditional rasterized fonts. Font prerendering can be used to alleviate this.\n‚Ä¢ None LCD subpixel optimization cannot be enabled for MSDF fonts.\n‚Ä¢ None Fonts with self-intersecting outlines will not render correctly in MSDF mode. If you notice rendering issues on fonts downloaded from websites such as Google Fonts, try downloading the font from the font author's official website instead. Comparison of font rasterization methods. From top to bottom: rasterized without oversampling, rasterized with oversampling, MSDFÔÉÅ To enable MSDF rendering for a given font, select it in the FileSystem dock, go to the Import dock, enable Multichannel Signed Distance Field, then click Reimport:\n‚Ä¢ None EMJC bitmap image compression (used by iOS' system emoji font) is not supported. This means that to support emoji on iOS, you must use a custom font that uses SVG or PNG bitmap compression instead. For Godot to be able to display emoji, the font used (or one of its fallbacks) needs to include them. Otherwise, emoji won't be displayed and placeholder \"tofu\" characters will appear instead: Default appearance when trying to use emoji in a labelÔÉÅ After adding a font to display emoji such as Noto Color Emoji, you get the expected result: Correct appearance after adding an emoji font to the labelÔÉÅ To use a regular font alongside emoji, it's recommended to specify a fallback font that points to the emoji font in the regular font's advanced import options. If you wish to use the default project font while displaying emoji, leave the Base Font property in FontVariation empty while adding a font fallback pointing to the emoji font: Emoji fonts are quite large in size, so you may want to load a system font to provide emoji glyphs rather than bundling it with your project. This allows providing full emoji support in your project without increasing the size of its exported PCK. The downside is that emoji will look different depending on the platform, and loading system fonts is not supported on all platforms. It's possible to use a system font as a fallback font too. Tools like Fontello can be used to generate font files containing vectors imported from SVG files. This can be used to render custom vector elements as part of your text, or to create extruded 3D icons with 3D text and TextMesh. Fontello currently does not support creating multicolored fonts (which Godot can render). As of November 2022, support for multicolored fonts in icon font generation tools remains scarce. Depending on your use cases, this may lead to better results compared to using the tag in RichTextLabel. Unlike bitmap images (including SVGs which are rasterized on import by Godot), true vector data can be resized to any size without losing quality. After downloading the generated font file, load it in your Godot project then specify it as a custom font for a Label, RichTextLabel or Label3D node. Switch over to the Fontello web interface, then copy the character by selecting it then pressing ( on macOS). Paste the character in the Text property of your Label node. The character will appear as a placeholder glyph in the inspector, but it should appear correctly in the 2D/3D viewport. To use an icon font alongside a traditional font in the same Control, you can specify the icon font as a fallback. This works because icon fonts use the Unicode private use area, which is reserved for use by custom fonts and doesn't contain standard glyphs by design. Several modern icon fonts such as Font Awesome 6 have a desktop variant that uses ligatures to specify icons. This allows you to specify icons by entering their name directly in the Text property of any node that can display fonts. Once the icon's name is fully entered as text (such as ), it will be replaced by the icon. While easier to use, this approach cannot be used with font fallbacks as the main font's characters will take priority over the fallback font's ligatures. Godot supports defining one or more fallbacks when the main font lacks a glyph to be displayed. There are 2 main use cases for defining font fallbacks:\n‚Ä¢ None Use a font that only supports Latin character sets, but use another font to be able to display text another character set such as Cyrillic.\n‚Ä¢ None Use a font to render text, and another font to render emoji or icons. Open the Advanced Import Settings dialog by double-clicking the font file in the FileSystem dock. You can also select the font in the FileSystem dock, go to the Import dock then choose Advanced‚Ä¶ at the bottom: In the dialog that appears, look for Fallbacks section on the sidebar on the right, click the Array[Font] (size 0) text to expand the property, then click Add Element: Click the dropdown arrow on the new element, then choose a font file using the Quick Load or Load options: It is possible to add fallback fonts while using the default project font. To do so, leave the Base Font property empty while adding one or more font fallbacks. Font fallbacks can also be defined on a local basis similar to OpenType font features, but this is not covered here for brevity reasons. Godot has full support for variable fonts, which allow you to use a single font file to represent various font weights and styles (regular, bold, italic, ‚Ä¶). This must be supported by the font file you're using. To use a variable font, create a FontVariation resource in the location where you intend to use the font, then load a font file within the FontVariation resource: Scroll down to the FontVariation's Variation section, then click the Variation Coordinates text to expand the list of axes that can be adjusted: The set of axes you can adjust depends on the font loaded. Some variable fonts only support one axis of adjustment (typically weight or slant), while others may support multiple axes of adjustment. For example, here's the Inter V font with a weight of and a slant of : While variable font axis names and scales aren't standardized, some common conventions are usually followed by font designers. The weight axis is standardized in OpenType to work as follows: You can save the FontVariation to a resource file to reuse it in other places: When writing text in bold or italic, using font variants specifically designed for this looks better. Spacing between glyphs will be more consistent when using a bold font, and certain glyphs' shapes may change entirely in italic variants (compare \"a\" and \"a\"). However, real bold and italic fonts require shipping more font files, which increases distribution size. A single variable font file can also be used, but this file will be larger than a single non-variable font. While file size is usually not an issue for desktop projects, it can be a concern for mobile/web projects that strive to keep distribution size as low as possible. To allow bold and italic fonts to be displayed without having to ship additional fonts (or use a variable font that is larger in size), Godot supports faux bold and italic. Faux bold and italic is automatically used in RichTextLabel's bold and italic tags if no custom fonts are provided for bold and/or italic. To use faux bold, create a FontVariation resource in a property where a Font resource is expected. Set Variation > Embolden to a positive value to make a font bolder, or to a negative value to make it less bold. Recommended values are between and depending on the font. Faux italic is created by skewing the text, which is done by modifying the per-character transform. This is also provided in FontVariation using the Variation > Transform property. Setting the component of the character transform to a positive value will italicize the text. Recommended values are between and depending on the font. For stylistic purposes or for better readability, you may want to adjust how a font is presented in Godot. Create a FontVariation resource in a property where a Font resource is expected. There are 4 properties available in the Variation > Extra Spacing section, which accept positive and negative values:\n‚Ä¢ None Top: Additional spacing above glyphs. This is used for multiline text, but also to calculate the minimum size of controls such as Label and Button.\n‚Ä¢ None Bottom: Additional spacing below glyphs. This is used for multiline text, but also to calculate the minimum size of controls such as Label and Button. The Variation > Transform property can also be adjusted to stretch characters horizontally or vertically. This is specifically done by adjusting the (horizontal scale) and (vertical scale) components. Remember to adjust glyph spacing to account for any changes, as glyph transform doesn't affect how much space each glyph takes in the text. Non-uniform scaling of this kind should be used sparingly, as fonts are generally not designed to be displayed with stretching. Godot supports enabling OpenType font features, which are a standardized way to define alternate characters that can be toggled without having to swap font files entirely. Despite being named OpenType font features, these are also supported in TrueType ( ) and WOFF/WOFF2 font files. Support for OpenType features highly depends on the font used. Some fonts don't support any OpenType features, while other fonts can support dozens of toggleable features. There are 2 ways to use OpenType font features: Open the Advanced Import Settings dialog by double-clicking the font file in the FileSystem dock. You can also select the font in the FileSystem dock, go to the Import dock then choose Advanced‚Ä¶ at the bottom: In the dialog that appears, look for the Metadata Overrides > OpenType Features section on the sidebar on the right, click the Features (0 of N set) text to expand the property, then click Add Feature: To use a font feature, create a FontVariation resource like you would do for a variable font, then load a font file within the FontVariation resource: Scroll down to the FontVariation's OpenType Features section, click the Features (0 of N set) text to expand the property, then click Add Feature and select the desired feature in the dropdown: For example, here's the Inter font without the Slashed Zero feature (top), then with the Slashed Zero OpenType feature enabled (bottom): You can disable ligatures and/or kerning for a specific font by adding OpenType features, then unchecking them in the inspector: Loading system fonts is only supported on Windows, macOS, Linux, Android and iOS. However, loading system fonts on Android is unreliable as there is no official API for doing so. Godot has to rely on parsing system configuration files, which can be modified by third-party Android vendors. This may result in non-functional system font loading. System fonts are a different type of resource compared to imported fonts. They are never actually imported into the project, but are loaded at runtime. This has 2 benefits:\n‚Ä¢ None The fonts are not included within the exported PCK file, leading to a smaller file size for the exported project.\n‚Ä¢ None Since fonts are not included with the exported project, this avoids licensing issues that would occur if proprietary system fonts were distributed alongside the project. The engine automatically uses system fonts as fallback fonts, which makes it possible to display CJK characters and emoji without having to load a custom font. There are some restrictions that apply though, as mentioned in the Using emoji section. Create a SystemFont resource in the location where you desire to use the system font: Specifying a font name to use in a SystemFont resourceÔÉÅ You can either specify one or more font names explicitly (such as ), or specify the name of a font alias that maps to a \"standard\" default font for the system: On Android, Roboto is used for Latin/Cyrillic text and Noto Sans is used for other languages' glyphs such as CJK. On third-party Android distributions, the exact font selection may differ. If specifying more than one font, the first font that is found on the system will be used (from top to bottom). Font names and aliases are case-insensitive on all platforms. Like for font variations, you can save the SystemFont arrangement to a resource file to reuse it in other places. Remember that different system fonts have different metrics, which means that text that can fit within a rectangle on one platform may not be doing so on another platform. Always reserve some additional space during development so that labels can extend further if needed. Unlike Windows and macOS/iOS, the set of default fonts shipped on Linux depends on the distribution. This means that on different Linux distributions, different fonts may be displayed for a given system font name or alias. It is also possible to load fonts at runtime even if they aren't installed on the system. See Runtime loading and saving for details. When using traditional rasterized fonts, Godot caches glyphs on a per-font and per-size basis. This reduces stuttering, but it can still occur the first time a glyph is displayed when running the project. This can be especially noticeable at higher font sizes or on mobile devices. When using MSDF fonts, they only need to be rasterized once to a special signed distance field texture. This means caching can be done purely on a per-font basis, without taking the font size into consideration. However, the initial rendering of MSDF fonts is slower compared to a traditional rasterized font at a medium size. To avoid stuttering issues related to font rendering, it is possible to prerender certain glyphs. This can be done for all glyphs you intend to use (for optimal results), or only for common glyphs that are most likely to appear during gameplay (to reduce file size). Glyphs that aren't pre-rendered will be rasterized on-the-fly as usual. In both cases (traditional and MSDF), font rasterization is done on the CPU. This means that the GPU performance doesn't affect how long it takes for fonts to be rasterized. Open the Advanced Import Settings dialog by double-clicking the font file in the FileSystem dock. You can also select the font in the FileSystem dock, go to the Import dock then choose Advanced‚Ä¶ at the bottom: Move to the Pre-render Configurations tab of the Advanced Import Settings dialog, then add a configuration by clicking the \"plus\" symbol: Adding a new prerendering configuration in the Advanced Import Settings dialogÔÉÅ After adding a configuration, make sure it is selected by clicking its name once. You can also rename the configuration by double-clicking it. There are 2 ways to add glyphs to be prerendered to a given configuration. It is possible to use both approaches in a cumulative manner: For most projects, this approach is the most convenient to use, as it automatically sources text from your language translations. The downside is that it can only be used if your project supports internationalization. Otherwise, stick to the \"Using custom text\" approach described below. After adding translations to the Project Settings, use the Glyphs from the Translations tab to check translations by double-clicking them, then click Shape All Strings in the Translations and Add Glyphs at the bottom: Enabling prerendering in the Advanced Import Settings dialog with the Glyphs from the Translations tabÔÉÅ The list of prerendered glyphs is not automatically updated when translations are updated, so you need to repeat this process if your translations have changed significantly. While it requires manually specifying text that will appear in the game, this is the most efficient approach for games which don't feature user text input. This approach is worth exploring for mobile games to reduce the file size of the distributed app. To use existing text as a baseline for prerendering, go to the Glyphs from the Text sub-tab of the Advanced Import Settings dialog, enter text in the window on the right, then click Shape Text and Add Glyphs at the bottom of the dialog: Enabling prerendering in the Advanced Import Settings dialog with the Glyphs from the Text tabÔÉÅ If your project supports internationalization, you can paste the contents of your CSV or PO files in the above box to quickly prerender all possible characters that may be rendered during gameplay (excluding user-provided or non-translatable strings). The second method requires less configuration and fewer updates if your game's text changes, and is more suited to text-heavy games or multiplayer games with chat. On the other hand, it may cause glyphs that never show up in the game to be prerendered, which is less efficient in terms of file size. To use existing text as a baseline for prerendering, go to the Glyphs from the Character Map sub-tab of the Advanced Import Settings dialog, then double-click character sets to be enabled on the right: Enabling prerendering in the Advanced Import Settings dialog with the Glyphs from the Character Map tabÔÉÅ To ensure full prerendering, the character sets you need to enable depend on which languages are supported in your game. For English, only Basic Latin needs to be enabled. Enabling Latin-1 Supplement as well allows fully covering many more languages, such as French, German and Spanish. For Russian, Cyrillic needs to be enabled, and so on. In the GUI > Theme section of the advanced Project Settings, you can choose how the default font should be rendered:\n‚Ä¢ None Default Font Antialiasing: Controls the antialiasing method used for the default project font.\n‚Ä¢ None Default Font Hinting: Controls the hinting method used for the default project font.\n‚Ä¢ None Default Font Subpixel Positioning: Controls the subpixel positioning method for the default project font.\n‚Ä¢ None Default Font Multichannel Signed Distance Field: If , makes the default project font use MSDF font rendering instead of traditional rasterization.\n‚Ä¢ None Default Font Generate Mipmaps: If , enables mipmap generation and usage for the default project font. These project settings only affect the default project font (the one that is hardcoded in the engine binary). Custom fonts' properties are governed by their respective import options instead. You can use the Import Defaults section of the Project Settings dialog to override default import options for custom fonts."
    },
    {
        "link": "https://github.com/Experience-Monks/msdf-bmfont",
        "document": "Converts a font file into multichannel signed distance fields, then outputs packed spritesheets and a json representation of an AngelCode BMfont.\n\nSigned distance fields are a method of reproducing vector shapes from a texture representation, popularized in this paper by Valve. This tool uses Chlumsky/msdfgen to generate multichannel signed distance fields to preserve corners. The distance fields are created from vector fonts, then rendered into texture pages. A BMFont object is provided for character layout.\n\nUnless previously installed you'll need Cairo, since node-canvas depends on it. For system-specific installation view the node-canvas wiki.\n\nYou can quickly install the dependencies by using the command for your OS:\n\nEl Capitan users: If you have recently updated to El Capitan and are experiencing trouble when compiling, run the following command: . Read more about the problem on Stack Overflow.\n\nWriting the distance fields and font data to disk:\n\nRenders a bitmap font from the font at with optional settings, triggering on complete.\n‚Ä¢ (String|Array)\n‚Ä¢ the characters to include in the bitmap font. Defaults to all ASCII printable characters.\n‚Ä¢ (Number)\n‚Ä¢ the font size at which to generate the distance field. Defaults to\n‚Ä¢ (Number)\n‚Ä¢ the dimensions of an output texture sheet, normally power-of-2 for GPU usage. Both dimensions default to\n‚Ä¢ (Number)\n‚Ä¢ pixels between each glyph in the texture. Defaults to\n‚Ä¢ (Boolean)\n‚Ä¢ generate texture atlases with a transparent background, instead of white\n‚Ä¢ (String)\n‚Ä¢ what kind of distance field to generate. Defaults to . Must be one of:\n‚Ä¢ (Number)\n‚Ä¢ the width of the range around the shape between the minimum and maximum representable signed distance in pixels, defaults to\n\nThe is called with the arguments\n‚Ä¢ on success will be null/undefined\n‚Ä¢ an array of Buffers, each containing the PNG data of one texture sheet\n‚Ä¢ an object containing the BMFont data, to be used to render the font\n\nSince is optional, you can specify as the second argument."
    },
    {
        "link": "https://shakuro.com/blog/phaser-js-a-step-by-step-tutorial-on-making-a-phaser-3-game",
        "document": "In this article, we are going to develop from scratch a game made with Phaser.js. You‚Äôll learn how to set up a build on webpack, load assets, create characters and animations, add keyboard controls, handle a powerful tool for creating maps that is Tiled, and even how to implement a simple bot behavior. Let‚Äôs go!\n\n Table of contents\n‚Ä¢ Part 2: The first scene, loading assets and showing a character on screen\n\nFirst, a little background. Phaser is an open-source JavaScript 2D game development framework developed by the folks at Photon Storm. It uses Canvas and WebGL renderers. You can play games developed with Phaser 3 in any modern web browser, and with tools like Apache Cordova, you can even turn them into mobile or native desktop apps. Phaser is open-source, easy to get started, and generally a great option for people who are looking to try JS for game development.\n\nWhat you need to start\n‚Ä¢ None Basic knowledge of TypeScript to be able to get what all those ‚Äútypes‚Äù are\n\nThat‚Äôs it! After completing the tutorial, you‚Äôll be able to create games like this:\n\n \n\n Check it out and play the Demo version.\n\n Here are the assets for this tutorial that you are going to need.\n\n And this is where you can find the final code.\n\n So since it looks like we are ready to start, let‚Äôs turn to the initial stage which is about‚Ä¶\n\nWe begin by setting up the environment, the required packages, and setting up webpack.\n\n For this tutorial, we‚Äôll be using the yarn package manager, but you can use the npm one as well since we only need it to install packages and launch the app build.\n\nWe get the following structure:\n\n‚Äî this is where we‚Äôll store all game assets: png sprites, sprite sheets, and JSON files.\n\n ‚Äî for classes (player, score meter, etc.).\n\n ‚Äî a place to store the game scenes.\n\n Let‚Äôs add the file to an make it an entry point of the application:\n\nHere we tell the game to not scale, remove the screen border padding, and specify the div element that‚Äôll be the parent block where the game will be rendered.\n\nFilling our with the itself:\n\nAnd installing typescript and webpack with the necessary plugins and loaders:\n\nNote that we install html-webpack-plugin@5.0.0-alpha.10 because at the time of this article‚Äôs publication the plugin had an unresolved bug.\n\n Add and match it with and for linting and quick code formatting:\n\nDone! We have installed all the necessary packages, now we can proceed to set up the configs.\n\nWe‚Äôll create the configuration files at the root level of the file structure.\n\n tsconfig.json\n\nYou can read more about the contents of in the documentation.\n\n .eslintrc.js\n\nOptional, to automatically format files when saving to VSCode.\n\n ./vscode/settings.json\n\nTurning standard formatting off to avoid situations where it could get in conflict with eslint formatting.\n\n You can customize rules for eslint, prettier, and vscode to better suit your needs, it won‚Äôt affect working with Phaser in any way üòå\n\n webpack.config.js\n\n So that we can build our creation and run the dev-server, we need to first make a config for webpack:\n\nWhat we indicate in the config:\n‚Ä¢ None what loaders to use for files\n‚Ä¢ None what plugins to apply during the build\n‚Ä¢ None that the minification is done using Terser\n\nYou can find out more about each field of the webpack.config.js file on the official site.\n\n Done!\n\n We have described all the required configs. Now, all we need is to just write a couple of scripts to start dev-server and run the build.\n\n Let‚Äôs go to package.json and add this field:\n\nAwesome!\n\n Now let‚Äôs create a src/index.ts file that acts as an entry point for the bundle scripts and add some code snippets there to make sure everything works fine after starting dev-server.\n\n src/index.ts\n\nAdd a header to src/index.html just for testing purposes, and run dev-server to make sure everything‚Äôs OK.\n\n To start dev-server, execute the command .\n\n \n\n ‚ÄúHello, world!‚Äù and the ‚ÄúYep!‚Äù message in the console indicate that everything is set up alright and we can finally move on to Phaser itself üòé\n\nPart 2: The first scene, loading assets and showing a character on screen\n\n\n\nIn the previous part, we set up the entire development environment from scratch including webpack, TypeScript, linter, and formatter, which means it‚Äôs time to move on to setting up the game and begin placing objects. Don‚Äôt worry, it‚Äôs not one massive file. In this part, we‚Äôll start small by showing our character.\n\n First, we need to declare a Game object. It‚Äôs the most important of the required objects since Phaser won‚Äôt initialize without it. We‚Äôll initialize it at the ‚Äúentry point‚Äù, namely src/index.ts.\n\n A Game must contain the second required object ‚Äî a Scene, at least one. A Scene in the Phaser world is similar to a theater scene in the real world. It contains child elements like a real scene contains actors. These can be Sprites, Images, and Containers. For a start, this set of elements is enough for our purposes, since we‚Äôll be creating our own classes for child elements, inheriting their class properties.\n\n To declare a game, we need to indicate what parameters we‚Äôll launch it with. So, describe the following in the parameters:\n‚Ä¢ CANVAS WEBGL AUTO . Many effects can be unavailable with the CANVAS type that are available with the WEBGL one. In this tutorial, we‚Äôll be using the latter\n‚Ä¢ None ‚Äî DOM element id of the page where we‚Äôll add a Game canvas element)\n‚Ä¢ None ‚Äî the background color of the canvas\n‚Ä¢ None ‚Äî setting for resizing the game canvas. Our choice is since we‚Äôll have our own sizing system. Read more about modes\n‚Ä¢ None ‚Äî an object for setting the game physics\n‚Ä¢ None ‚Äî callbacks that will be triggered BEFORE ( ) or AFTER ( ) the game is initialized\n‚Ä¢ None ‚Äî CSS styles for the canvas element where the game will be rendered\n‚Ä¢ None ‚Äî a list of scenes to load and use in the game.\n\nTo declare a game, we need to indicate what parameters we‚Äôll launch it with. So, describe the following in the parameters:\n\n src/index.ts\n\nLet‚Äôs add to the same file a global function for resizing our game:\n\n src/index.ts\n\nTo avoid getting the error about Window not having a method and a global object, let‚Äôs patch the interface:\n\nNow TypeScript understands what is behind and .\n\nIf we run the game without a single scene, we‚Äôll get an error. Let‚Äôs create the first scene then, which will later act as the main scene for loading assets and launching the rest of the scenes.\n\n Create a scene Loading file to describe the Scene Class. In the constructor, indicate the Scene Key. We‚Äôll use it to select a specific scene among others. The Scene Key is a required parameter.\n\n src/scenes/loading/index.ts\n\nAs you can see, we are using the method. It is one of the built-in scene methods and is the scene lifecycle method. There are several such methods:\n‚Ä¢ None ‚Äî kicks in when a scene is created. It accepts the Data Object that we can pass when we call game.scenes.add(dataForInit) or game.scenes.start(dataForInit). For example, when we create a scene while being in some other scene (yes, you can do that). All scenes will be at the same hierarchy level, with no nested scenes.\n‚Ä¢ None ‚Äî a method that defines what we need to load before the scene and from where. We‚Äôll use it to load assets later on.\n‚Ä¢ None ‚Äî a method that gets triggered when a scene is created. In it, we‚Äôll specify positioning for such scene elements as Character and Enemies.\n‚Ä¢ None ‚Äî a method that gets called with every render frame (on average, 60 times per second). It‚Äôs a game loop in which redrawing, moving objects, etc. occurs.\n\nAlso, for convenient scene import, let‚Äôs create a file with which we will ‚Äútransmit‚Äù the exports in nested directories.\n\n src/scenes/index.ts\n\nNow we can start our game to see that the scene has been created and has triggered the message to the console, which we‚Äôd specified in the method. The brown of the background is the we specified in .\n\n \n\n Let‚Äôs load a character for this background!\n\n To do it, create a folder src/assets/sprites/, and add there a picture of our character ‚Äî . Next, in the method of the scene class, add the following:\n\n src/scenes/loading/index.ts\n\nNow to creating our character, let it be a simple sprite. Declare a character field, and write the following in the scene‚Äôs method:\n\n src/scenes/loading/index.ts\n\nHere we indicate that we add a sprite (add.sprite), place it at such and such XY coordinates, and use a texture with the key which we specified during loading in the method.\n\n Now, if we run the dev-server, instead of a character we‚Äôll get a black square with a green border. Squares like these signal that Phaser was unable to detect the texture or sprite along a path.\n\n But the path is right, so what gives?\n\n It has to do with webpack. We haven‚Äôt specified the assets‚Äô movement when building or running in dev mode. Let‚Äôs fix it.\n\n Add plugin import and initialization to webpack.config.js.\n\n webpack.config.js\n\nNow, when running in dev mode, we can see our character üòé\n\nGreat! We now know how to load and place sprites. One thing left‚Ä¶ Need more interactivity! Let‚Äôs bring our character to life by giving him the ability to move.\n\n We‚Äôll start by creating a separate class for our character and a separate scene for the level and call it . We begin with the scene since we‚Äôve already placed our character there in the previous part of this tutorial. \n\n Let‚Äôs create a scene folder with the index.ts scene file.\n\n src/scenes/level-1/index.ts\n\nDon‚Äôt forget to add the ‚Äútransmitter‚Äù to the scene. \n\n src/scenes/index.ts\n\nNow we need to add our scene to the scene array in \n\n src/index.ts\n\nAnd move our from the Loading scene to the Level1 scene:\n\nIn the Loading scene, we set our scene-level to launch after all other loadings are finished:\n\n src/scenes/loading/index.ts\n\nIn the method, we specify the key of the scene we want to launch.\n\n Let‚Äôs run the dev server and make sure our character is displayed.\n\n Awesome! Looks like he‚Äôs in his proper place.\n\nSince in the future there will be enemies behaving somewhat similar to the player character, let‚Äôs create an actor class to store general properties and methods, and then create a player class by extending the actor one.\n\n src/classes/actor.ts\n\nHere we indicate that the class is not just some sprite but a physical one. This is to adjust its collisions and physical dimensions for contact with walls and other objects.\n\n The and methods tell us that we are adding our physical sprite to the scene and need it considered in terms of scene physics.\n\n The method tells the world to react to the physical model of the sprite, its ‚Äúbox‚Äù.\n\n The protected method is designed to rotate an actor as it moves left or right.\n\n The public method is for attacking the actor. We can see a tween inside ‚Äî something like an animation done by manipulating some properties of the target object. Here we describe that the transparency will change 3 times within 100 ms , each time returning to the original alpha value . At the start of the blinking animation , we change the actor‚Äôs HP value in accordance with how much damage it received. At the end of the animation, we forcefully set the current character‚Äôs opacity to . The value of the property varies from 0 to 1. The lower the value, the more transparent the object.\n\n The method was created due to errors in Phaser types and helps us get that very physical model of a physical object.\n\nNow that the main actor class has been created, we can create the player class.\n\n src/classes/player.ts\n\nLet‚Äôs analyze the code above.\n\n Here we describe the keys to track which one of them is being pressed:\n\nIn each frame, we check if any control key is pressed and change the XY movement speed depending on the direction. If a key is not pressed, set the speed = 0. Also, when moving left-right, we check whether we need to rotate the character.\n\nSometimes character sprites are quite large or have white space. In this case, we can specify the size of the physical model (box) and set the point by XY coordinates to calculate the physical model.\n\nNote that when rotating the character, we move the rendering point of the physical model. We have to do it because of the body miscalculation error of Phaser.\n\nWonderful! We have created a character class, now we need to create a character on the first level scene.\n\n src/scenes/level-1/index.ts\n\nIn the method of the scene, we specify for each frame to call the method on the player character, which in turn changes its position.\n\nTime for a bit of running around\n\nRun the dev server and try some running around with your character.\n\n Excellent! The character moves and turns in the right direction üòé\n\n\n\nOK, our character can move now, but quite clumsily. Let‚Äôs add a movement animation and figure out what sprite sheets are.\n\n2D animation in Phaser is created using frames. Frames are sprites. Sprite sheets (atlases) are collections of sprites. The sprites in a sprite sheet are called frames. That is, you can create animation using frames from a sprite sheet.\n\n For example, this is how our character‚Äôs sprite looks like:\n\n \n\n And this is the sprite sheet with frames which we‚Äôll use for animation:\n\n \n\n But one sprite sheet is not enough. How can we indicate that such and such a frame is in such and such a position of the sprite sheet when a sprite sheet is just a picture? JSON comes to the rescue with information on each sprite: its name, width, height, and XY coordinates on the sprite sheet. Often, sprite sheets are generated automatically using online services or offline solutions, so you don‚Äôt have to create JSON yourself and manually lay the sprites out on the grid. Also, some generators add additional parameters to JSON like the property, for example, which indicates the point at the origin of XY coordinates, where 0 is the beginning, 0.5 is the middle, and 1 is the end of the sprite. The value can be negative, and not necessarily compliant with half sizes, that is, the value can be 1.23, or 0.99, or -3.33.\n\n Let‚Äôs take a look at the description of a frame:\n\n src/assets/spritesheets/a-king_atlas.json\n\nHere we can see that the frame called is located at 0-0 coordinates and has a width of 78px and a height of 58px.\n\nTo use an atlas by its key it must be loaded like the rest of the assets.\n\n Let‚Äôs go to the Loading scene and load our atlas and its JSON file.\n\n src/scenes/loading/index.ts\n\nNow we can use our atlas in the right places with the texture key.\n\n Let‚Äôs add running animation to our character! Go to the class and describe the method for creating animation.\n\n src/classes/player.ts\n\nHere we indicate that we want to create an animation with such and such a key with the animation frames taken from the atlas, by the prefix.\n\n Great, we‚Äôve created two animations: and . Now let‚Äôs add the running animation:\n\n src/classes/player.ts\n\nHere we check for each button whether the animation is currently playing, and if not, we play it with such and such key.\n\n Now let‚Äôs start the dev-server and try runningüòé\n\n\n\nSo, we managed to create a development environment from scratch, load assets, and place them on the stage, and we also added a character with the ability to move. Now let‚Äôs make a location for him to be actually able to do that.\n\nTo create a location, we need the Tiled editor. It‚Äôs free and its developers appreciate donations that help them make it bigger and better.\n\n We also need assets ‚Äî the so-called . They are very similar to sprite sheets but are rigidly attached to the grid. Usually, tileset authors indicate the dimension of a grid. In the assets for this tutorial, we attached the necessary assets (assets/tilemaps/tiles), but you can also find some free packages available in the public domain, for example, on itch.io. Follow the example from the tutorial and create your own world.\n\nOpen the Tiled editor and choose the New Tileset option.\n\n You‚Äôll see the menu for adding a tileset to a project. Select the tileset from the tutorial materials (assets/tilemaps/tiles/dungeon-16-16). Now you need to specify the tile dimension (grid dimension): and . In our case, it‚Äôs 16√ó16. Also, make sure that you check the ‚ÄúEmbed in map‚Äù box. In case it cannot be installed or removed, it‚Äôs okay, we‚Äôll return to it later.\n\n Click OK.\n\n \n\n Next, Tiled is going to ask you about the project file name and where to save it. The project file applies only to the Tiled editor, it‚Äôs not used in the game, so we can save it wherever we want and under any name. Just don‚Äôt forget to select the format of the saved file. We leave it to be the standard .\n\n What we see before us now is the tile tab, where we can select any tile and edit it like adding any parameters, keys, values, names, etc. For now, let‚Äôs leave it as it is, but we are definitely going to return here later.\n\n \n\n By adding a tileset ‚Äî the material for creating the map ‚Äî we can finally create the map itself!\n\n To do this call the menu File ‚Üí New ‚Üí New Map‚Ä¶\n\n We have a choice of map parameters before us. We are going to create a map with standard settings for the width and height (Map size), measured in tiles, and set the sizes of our tiles (Tile size) according to our tileset. As our tileset has a grid of 16√ó16 pixels, so in this window, we set the Tile size to 16√ó16 pixels.\n\n \n\n Great! We now have a map editing tab:\n\n \n\n Let‚Äôs analyze the areas:\n‚Ä¢ None ‚Äî these are map settings that you can edit in case you make a mistake in the New Map‚Ä¶ menu.\n‚Ä¢ None ‚Äî it‚Äôs the map grid where we‚Äôll place our tiles. That is, it‚Äôs like a canvas for drawing a map with tilesüôÇ\n‚Ä¢ None ‚Äî these are map layers. There can be many of them and they can be of different types. For example: on the Ground layer we‚Äôll mark the places where our character will move, and on the Walls layer we‚Äôll place walls and obstacles through which he won‚Äôt be able to pass. Splitting into layers is a good practice since it is both more convenient for creating and editing a map, as well as for a more handy selection of the necessary layers for using some events in the game specifically with these layers.\n‚Ä¢ None ‚Äî this is the tileset window of the tileset we loaded earlier.\n\nSo let‚Äôs create a location already!\n\n To do this, in the layers area, select the tab, then select the standard layer and rename it. In this tutorial, we‚Äôll call it Ground, but you can choose any name.\n\n Now select the tiles from the area and place them on the map, like putting brush to canvas.\n\n You can use any of the tools from the toolbar above the . Stamp Brush, Shape Fill Tool, and Eraser seem to be the most popular ones.\n\n Now let‚Äôs add another layer with walls and name it Walls.\n\n And here‚Äôs our first map!\n\n \n\n That‚Äôs enough for a start. Let‚Äôs transfer the map into the game.\n\nSave the Tiled project.\n\n Then go to File ‚Üí Export As‚Ä¶\n\n You‚Äôll see the window for saving the map file. Select the JSON map files format and save. Let‚Äôs do it under the project name ‚Äî dungeon.\n\n Create folders src/assets/tilemaps/tiles/ for tilesets files (.png images) and src/assets/tilemaps/json/ for json map files, where we‚Äôll transfer our map files.\n\n As a result, our src/assets/ folder will look like this:\n\nNext, load the map using Phaser. To do this, go to the Loading scene, where we load all the assets, and add the following:\n\nSo, first, we load the texture, our tileset, and then load the JSON map file, which stores information about the location of each tile and the way it‚Äôs divided into layers.\n\n Go to the scene of the first level, and define our map to display it.\n\n Let‚Äôs create a function for initializing the map, and describe the property types:\n\nHere, we define tilemap with so-and-so a key and such-and-such width and height tile parameters. After that, we define the connection between of the texture and the JSON file of the map (we indicate the keys that we used while loading on the Loading scene). Next, describe the and layers where the first argument is the name of the layer, the second one is the map information, i.e. , and the arguments number 3 and 4 are the XY coordinates relative to the world where we start drawing the map. After describing all the information about the map and layers, we set the size of the physical world to , where we state that we start counting at so-and-so XY coordinates, and set the width and height of the world to the similar to the wall layer.\n\n It only remains to call our function at the very beginning of the method of the first level scene:\n\nLet‚Äôs start the dev-server to see that‚Ä¶ Our location isn‚Äôt there, and in the console, we see a warning from Phaser that the tileset ‚Äúdungeon‚Äù could not be loaded. Don‚Äôt worry, everything is just as it should be!\n\n This is because when loading the tileset into Tiled, we didn‚Äôt change its name. And if you did everything according to the tutorial, now the map inside the JSON code is trying to associate itself with a tileset named ‚Äúdungeon-16-16‚Äù. Let‚Äôs fix it!\n\n In the tilesets area, click on the settings icon for this tileset, and in the window that opens, change the Name property from ‚Äúdungeon-16-16‚Äù to ‚Äúdungeon‚Äù. Save.\n\n \n\n \n\n Also, make sure that in the tileset area and with the dungeon selected, the ‚ÄúEmbed Tileset‚Äù button is not active. If it is active, click on it.\n\n \n\n Now let‚Äôs re-export our JSON file. File -> Export As ‚Ä¶ -> File format .json.\n\n Transfer the new JSON file into the project and start the dev-server for verification.\n\n Voila! We see the map!\n\n\n\nLet‚Äôs try running around the map. As you can see, the character does not react to the walls, as if the whole map is just a background picture. To fix this, we need to set collisions on certain tiles.\n\n It‚Äôs very convenient to do everything there in the Tiled editor.\n\n Open up our ‚Äúdungeon‚Äù tileset and select all the tiles. Further, on the left, there are Properties. In the ‚ÄúCustom Properties‚Äù area, right-click ‚Üí Add Property ‚Üí choose any property name (we going to use ‚Äúcollides‚Äù), the data type is bool ‚Üí OK.\n\n \n\n There should appear a new field with the option to check the box. It might happen so that the created field is of the wrong type. In such a case, just delete it.\n\n Now that all the tiles have the collides property, select only those tiles that cannot be passed through, and check the collides checkbox.\n\n \n\n Save the project, export the dungeon.json, and transfer it into the game assets.\n\n Now, go to the scene of the first level and to the map creation function and enable collisions on tiles that we want to select by property:\n\nTo see if collisions have been applied OK to the walls, let‚Äôs write a short helper function that will simply show us debug information and highlight the collision walls.\n\nStart the dev-server and you‚Äôll now see exactly which walls have collisions.\n\n \n\n But wait! Our character is still walking through the walls, what‚Äôs the matter?\n\n The fact is, we didn‚Äôt indicate that the character should react to the walls in some way. Let‚Äôs fix this!\n\n On the first level stage, in the method, after initializing the map and the player, add the so-called ‚Äúcollider‚Äù, a method that includes collisions between two objects:\n\nThat‚Äôs it, our character is no longer able to pass through the walls:\n\n \n\n Now you can create your own locations, load them into the game, and identify impassable areas.\n\n Try to improve your location, or expand it. Try different tiles or even choose a tileset for your own idea, the world is yoursüòé\n\nWith the help of Tiled, we can not only build a map but also add points to show where to place the objects.\n\n How about rewarding our character with chests? Let‚Äôs create it all in the same old Tiled.\n\nTo place objects in Tiled, we need to first create a separate layer for them. Go to the Layers area ‚Üí Right-click on the empty space ‚Üí New ‚Üí Object Layer. Let‚Äôs call it ‚ÄúChests‚Äù.\n\n Now select ‚ÄúInsert Point‚Äù on the toolbar and place points where you want the objects to be.\n\n Select all the points, and on the left side, in the object properties, set the ‚ÄúName‚Äù property to ‚ÄúChestPoint‚Äù.\n\n \n\n Export the JSON and go to the first level scene.\n\nNow we can place any object on any point. In our case, it‚Äôs chests.\n\n Due to errors with Phaser types, it‚Äôs better to prepare a small helper adapter in src/helpers/gameobject-to-object-point.ts, with which we‚Äôll translate the GameObject type to ObjectPoint.\n\nAlso, we‚Äôll need to separately load our tileset as a sprite sheet so that we can take certain sprites from there (note, the sprites, not the tiles). To do this, go to the Loading scene and add the loading of the sprite sheet with the tiles_spr key (the name can be anything), specifying the dimension of the sprites:\n\nNow, on the first level stage, we‚Äôll define an array of chests, add a function that creates chests and call it after initialization of the character:\n\nUsing the function, select the required objects from the required layer. The first argument is the layer‚Äôs name, the second one is the callback function for filtering. In our case, if the object has the name ‚ÄúChestPoint‚Äù, then it‚Äôs suitable, and will fall into the array of the same chestPoints objects.\n\n Next, let‚Äôs create a sprite with a physical model for each point from the chestPoints array.\n\n is the sprite‚Äôs ID in the sprite sheet, but how to find it? It‚Äôs simple! Open the tileset in the Tiled editor, select the chest, and on the left side, you‚Äôll see its ID:\n\n \n\n Also, we made sure that when a character ‚Äústeps‚Äù on a chest, there will be a flash, and the chest will disappear as if it had been taken.\n\n Let‚Äôs start the dev server and check it:\n\n\n\nCameras and following the player character\n\nCool, we can now collect chests! But what to do with those chests that are on the map, but that we don‚Äôt see? Time to work with the map.\n\n Each scene has a main camera already, and this is how it is being accessed ‚Äî through . Also, we can create our own cameras. For this tutorial, the main camera is enough, but if you want to learn more about cameras, be sure to look into these examples.\n\n Let‚Äôs add a function, where we‚Äôll call several methods for the camera and call the function after all initializations in the method:\n\nHere we have set the camera size, zoom, and the target that the camera will follow. is the value for the smooth movement of the camera towards the target position, thus we made the movement of the camera smoother.\n\n\n\nWe have already added chests to the map, but so far they don‚Äôt give out anything, they only disappear. Let‚Äôs create a score counter and link it to the moment of the chest collection.\n\n Let‚Äôs start small ‚Äî with the text. So, create a class, which will be common for all text labels.\n\n src/classes/text.ts\n\nNow we‚Äôll create a class for the counter, which will inherit from our main class, where we‚Äôll define a method for changing the value depending on the operation.\n\n src/classes/score.ts\n\nNow we need to create a separate scene for the UI elements, which will be on top of the main game and levels.\n\n And immediately add there our counter:\n\n src/scenes/ui/index.ts\n\nAlso, don‚Äôt forget to add the UI scene to the . We‚Äôll launch it together with the level from the Loading scene.\n\n src/index.ts\n\nGreat, we‚Äôve added a counter, but right now it doesn‚Äôt respond to collecting chests. Let‚Äôs establish this connection using the event system, and send the corresponding event from one scene to another, at the moment when we pick up the chest.\n\n In this tutorial, we‚Äôll not have many events, but in order not to remember the names of events, it is considered a good practice to store events in constants.\n\n Let‚Äôs create a file for these constants, and add only one event there so far ‚Äî the looting.\n\n src/consts.ts\n\nTo work with an event, we must trigger it and describe its handler somewhere. Let‚Äôs add this event trigger to the moment when the game character comes into contact with the chest. At the moment, this action triggers the destruction of the chest and the flash of the camera.\n\n src/scenes/level-1/index.ts\n\nNow let‚Äôs go to the UI scene, declare a listener for the looting event, and also describe its handler, which will change the counter value when we pick up the chest.\n\n src/scenes/ui/index.ts\n\nNow the counter responds to the collection of chests and increases the counter.\n\n\n\nSo we are now in the final part of our Phase 3 game tutorial. We already have a character to explore the locations, and chests that we get game points for. But there‚Äôs not enough action, there‚Äôs not enough of what could create a desire to win ‚Äî challenge. At the moment, our main character lives in greenhouse conditions and aimlessly collects chests. To create a more enjoyable gaming experience, you need to set goals and some obstacles on the way ‚Äî enemies.\n\n In this part, we‚Äôll place enemies on the map and add logic to them so that they attack our hero if he gets too close.\n\n Also, we‚Äôll add the win/lose logic, and depending on the status of the game completion, show the corresponding screen with the corresponding message.\n\nTo begin with, let‚Äôs create a class of enemies, which we‚Äôll use to ‚Äúpopulate‚Äù the location with enemies. The enemy class will be similar to the player‚Äôs class but without keyboard control.\n\n src/classes/enemy.ts\n\nDefine a constant value of the radius for the enemy, i.e. at what distance the target must be for the enemy to start pursuing it.\n\nAlso, add the ability to change the target. We‚Äôll not be using this function in this tutorial, but after completing it, you‚Äôll be able to upgrade the game by adding several extra characters.\n\nPay attention to the function, this is a built-in function for classes like , and it gets triggered every time before the game frames are re-rendered. Here we describe the ‚Äúbrains‚Äù of our enemy. They will appear to be waiting until the target comes close enough to start moving towards it:\n\nThe enemy class is there, now let‚Äôs recall the information about adding chests to the location ‚Äî on a separate Enemies layer. In the same way, add a couple of enemies to the first level scene.\n\n \n\n src/scenes/level-1/index.ts\n\nFor each enemy, specify that they should not go through walls, the character, and through other enemies.\n\n Also, describe that when in contact with the character, the enemy will inflict damage to the player in the amount of 1 HP (without additional restrictions, they will inflict damage very quickly).\n\n \n\n Now let‚Äôs display an HP value above the character‚Äôs head. To do this, add the class.\n\n src/classes/player.ts\n\nNow the HP value will be shown above the game character, even when he moves, since in the method we update the position for the text value of HP.\n\n We‚Äôve also extended the standard method of the superclass to change the HP value.\n\n \n\n When the enemy starts attacking the character, we can see how quickly the damage is dealt. So far, we are satisfied with this result, but you can add additional conditions for taking damage.\n\nNow the enemies can attack us, but we must also be able to defend. And, as they say, the best defense is a good offense. Let‚Äôs add our character the ability to attack by pressing the spacebar.\n\n Go to the class and add this little bit there:\n\n src/classes/player.ts\n\nExcellent! Our character can now attack enemies. When we press the spacebar, we play the attack animation, which was described in one of the previous parts, and trigger the attack event. We‚Äôll declare listeners for this event in the class.\n\n src/classes/enemy.ts\n\nHere we describe the handler for the damage-taking event, and each time we make our player character swing the hammer, we check to see if the enemy is really close enough to get damaged.\n\n When receiving damage, we turn off the physical model of the enemy so that they don‚Äôt continue to attack the player character while in the process of disappearing, and after blinking, we remove them from the scene.\n\n Also, we described that at the moment when the enemy is being removed from the scene, we must stop the damage reception. Otherwise, the enemy will still be able to take damage and will try to process the event.\n\n\n\nGreat, we can now fight the enemies! Time to add a game completion screen to show if we won or lost.\n\n Let‚Äôs start with the losing option. In the class, when receiving damage, add a check for the HP value, and if it becomes 0, then it will trigger the end-of-the-game event with the status of a loss.\n\n Determine the possible game statuses:\n\n src/consts.ts\n\nNext, let‚Äôs add a listener for this event to the UI scene and define an event handler. Also, add a text output to the screen, which will contain our message about the game status.\n\n src/scenes/ui/index.ts\n\nNow, when the main character runs out of HP, we are shown a screen with the corresponding inscription:\n\n \n\n Great, we have the logic of losing ready, now let‚Äôs implement the winning one.\n\n Remember that object where we specified the parameters for the game? We can use this object to store some parameters, for example, the number of points needed to win.\n\n Let‚Äôs go to the file with and add a field where we describe that you need to score 40 points to win, that is, collect 4 chests.\n\n src/index.ts\n\nNow let‚Äôs return to the UI scene, and in the handler for collecting the chest, we‚Äôll check if we have enough points to win.\n\n src/scenes/ui/index.ts\n\nCool, now that we have 40 points, we see the victory screen!\n\n\n\nYou probably noticed that in the inscription there‚Äôs something about restarting the game on click. Let‚Äôs implement it, it‚Äôs pretty simple.\n\n On the UI scene, inside our end-of-the-game event handler, add a click listener. Inside, we‚Äôll be clearing all current event listeners and restarting the scene:\n\n src/scenes/ui/index.ts\n\nTo make one scene from another, we use a record of getting a scene from the list of scenes by its key and then we can work with the resulting one.\n\n Awesome! Now we can restart the gameüòé\n\n When we restart the scene, all objects there are destroyed (the method built into the scene class gets triggered), but all their listeners remain. Because of this, we can observe a bug when, after restarting, when we press the spacebar, an error is displayed in the console that such and such animation cannot be found. This is an attack animation. The error occurs due to the fact that the listener tied to the state of the player BEFORE the restart gets triggered, and is still trying to play an animation that no longer exists. Add the class to remove all listeners when the player character gets destroyed.\n\n src/classes/player.ts\n\nNow there are no errors, and we can start the game again as many times as we likeüòé\n\nThank you for being here!\n\nThis concludes our Phaser 3 tutorial. We have learned from scratch how to set up the environment for developing and building a web game project with Phaser.js. We created scenes and classes for the player character and his enemies. We downloaded and worked with sprites, sprite sheets, atlas, animations. We learned how to create a game map from scratch and place objects. We added keyboard controls for the player character and taught bots to hunt him. And finally, we described the logic for winning and losing.\n\n So, everything‚Äôs in your hands now. This tutorial is enough to get your feet wet so that you could dive deeper, and understand what they all are talking about in other tutorials.\n\n Once again,\n‚Ä¢ None Check the game out and play the\n‚Ä¢ None Here are the\n‚Ä¢ None And this is where you can find the"
    },
    {
        "link": "https://stackoverflow.com/questions/56509012/good-practice-for-using-almost-identical-sprites-in-phaser-alternatives-to-usin",
        "document": "So, I have been working in Unity but I've decided it's time to change to something I know better: JavaScript. I've been considering switching to Phaser.js but I have some questions regarding an issue I've been having even in Unity and that I found no solution to at the moment while searching on the internet. I have no code to provide as I haven't yet started actually programming in Phaser, so I'll try to be explicit.\n\nMy game idea basically revolves around some lights that change colors. The sprites I have for the lights look identical, but just with different colors, but not entirely (only parts of them are colored differently). The problem is that my game has many different colored lights and it has to change between them. Like, if one light is red and you click on it, it becomes green, for example. Creating and loading so many sprites that look almost the same seems like a bad practice, and I wonder if there is a way to change the color of a sprite or a part of the sprite by code. I know that Phaser doesn't support svg and that svg in games is a bad idea in general because of performance issues but it would have saved me a lot of time to just add the generated svg code of the sprites I use and just change the fill of the parts I want.\n\nSo, my question is: what are the best alternatives (if any) to using multiple sprites or how can you change the color of specific parts of them?"
    },
    {
        "link": "https://html5gamedevs.com/topic/2497-sprite-font",
        "document": "Hello everyone, it's been a while...\n\nI am making a game and i need to implement a font from a spritesheet, i've been thinking of parsing the word and then drawing each part of the sprite but i need to know if there is a better way to achieve it.\n\nI am not using any framework."
    },
    {
        "link": "https://stackoverflow.com/questions/51217147/how-to-use-a-local-font-in-phaser-3",
        "document": "For Phaser 3 there is a good official example for Custom Webfont\n\nThis comes down to:"
    },
    {
        "link": "https://docs.phaser.io/phaser/getting-started/making-your-first-phaser-game",
        "document": "Welcome to our first tutorial on Making a Game with Phaser 3. Here we will learn how to create a small game involving a player running and jumping around platforms, collecting stars and avoiding baddies. While going through this process we'll explain some of the core features of the framework.\n\nDownload this zip file which contains each step of this tutorial in code and the assets that go with it.\n\nYou need to have a very basic knowledge of JavaScript.\n\nAlso make sure you go through the Getting Started Guide, it will show you how to download the framework, set up a local development environment, and give you a glimpse of the structure of a Phaser project and its core functions.\n\nIf you've gone through the Getting Started Guide you will have downloaded Phaser and got everything set-up and ready to code. Download the resources for this tutorial and unzip them into your web root.\n\nOpen the page in your editor of choice and let's have a closer look at the code. After a little boilerplate HTML that includes Phaser the code structure looks like this:\n\nThe config object is how you configure your Phaser Game. There are lots of options that can be placed in this object and as you expand on your Phaser knowledge you'll encounter more of them. But in this tutorial we're just going to set the renderer, dimensions and a default Scene.\n\nAn instance of a Phaser.Game object is assigned to a local variable called and the configuration object is passed to it. This will start the process of bringing Phaser to life.\n\nThe property can be either , , or . This is the rendering context that you want to use for your game. The recommended value is which automatically tries to use WebGL, but if the browser or device doesn't support it it'll fall back to Canvas. The canvas element that Phaser creates will be simply be appended to the document at the point the script was called, but you can also specify a parent container in the game config should you wish.\n\nThe and properties set the size of the canvas element that Phaser will create. In this case 800 x 600 pixels. Your game world can be any size you like, but this is the resolution the game will display in.\n\nThe property of the configuration object will be covered in more detail further on in this tutorial.\n\nLet's load the assets we need for our game. You do this by putting calls to the Phaser Loader inside of a Scene function called . Phaser will automatically look for this function when it starts and load anything defined within it.\n\nCurrently the function is empty. Change it to:\n\nThis will load in 5 assets: 4 images and a sprite sheet. It may appear obvious to some of you, but I would like to point out the first parameter, also known as the asset key (i.e. 'sky', 'bomb'). This string is a link to the loaded asset and is what you'll use in your code when creating Game Objects. You're free to use any valid JavaScript string as the key.\n\nIn order to display one of the images we've loaded place the following code inside the function:\n\nYou can find this in . If you load it in a browser you should now see a game screen with a blue sky backdrop covering it:\n\nThe values and are the x and y coordinates of the image. Why 400 and 300? It's because in Phaser 3 all Game Objects are positioned based on their center by default. The background image is 800 x 600 pixels in size, so if we were to display it centered at 0 x 0 you'd only see the bottom-right corner of it. If we display it at 400 x 300 you see the whole thing.\n\nHint: You can use to change this. For example the code: would reset the drawing position of the image to the top-left. In Phaser 2 this was achieved via the property but in Phaser 3 it's the and properties instead.\n\nThe order in which game objects are displayed matches the order in which you create them. So if you wish to place a star sprite above the background, you would need to ensure that it was added as an image second, after the sky image:\n\nIf you put the image first it will be covered-up by the sky image.\n\nUnder the hood is creating a new Image Game Object and adding it to the current Scenes display list. This list is where all of your Game Objects live. You could position the image anywhere and Phaser will not mind. Of course, if it's outside of the region 0x0 to 800x600 then you're not going to visually see it, because it'll be \"off screen\", but it will still exist within the Scene.\n\nThe Scene itself has no fixed size and extends infinitely in all directions. The Camera system controls your view into the Scene and you can move and zoom the active camera as required. You can also create new cameras for other views into the Scene. This topic is beyond the scope of this specific tutorial, suffice to say the camera system in Phaser 3 is significantly more powerful than in v2. Things that were literally not possible before now are.\n\nFor now let's build up the Scene by adding a background image and some platforms. Here is the updated function:\n\nGlancing quickly at the code you'll see a call to . This means we're using the Arcade Physics system, but before we can do that we need to add it to our Game Config to tell Phaser our game requires it. So let's update that to include physics support. Here is the revised game config:\n\nThe new addition is the property. With this code in place if you run it, which you'll find as in the tutorial zip file, you should see a much more game-like scene:\n\nWe've got a backdrop and some platforms, but how exactly are those platforms working?\n\nWe just added a bunch of code to our function that deserves a more detailed explanation. First, this part:\n\nThis creates a new Static Physics Group and assigns it to the local variable . In Arcade Physics there are two types of physics bodies: Dynamic and Static. A dynamic body is one that can move around via forces such as velocity or acceleration. It can bounce and collide with other objects and that collision is influenced by the mass of the body and other elements.\n\nIn stark contrast, a Static Body simply has a position and a size. It isn't touched by gravity, you cannot set velocity on it and when something collides with it, it never moves. Static by name, static by nature. And perfect for the ground and platforms that we're going to let the player run around on.\n\nBut what is a Group? As their name implies they are ways for you to group together similar objects and control them all as one single unit. You can also check for collision between Groups and other game objects. Groups are capable of creating their own Game Objects via handy helper functions like . A Physics Group will automatically create physics enabled children, saving you some leg-work in the process.\n\nWith our platform Group made we can now use it to create the platforms:\n\nAs we saw previously it creates this scene:\n\nDuring our preload we imported a 'ground' image. It's a simple green rectangle, 400 x 32 pixels in size and will serve for our basic plaform needs:\n\nThe first line of code above adds a new ground image at 400 x 568 (remember, images are positioned based on their center) - the problem is that we need this platform to span the full width of our game, otherwise the player will just drop off the sides. To do that we scale it x2 with the function . It's now 800 x 64 in size, which is perfect for our needs. The call to is required because we have scaled a static physics body, so we have to tell the physics world about the changes we made.\n\nThe ground is scaled and in place, so it's time for the other platforms:\n\nThe process is exactly the same as before, only we don't need to scale these platforms as they're the right size already.\n\n3 platforms are placed around the screen, the right distances apart to allow the player to leap up to them.\n\nWe've got some lovely tempting platforms, but no-one to run around them. Let's rectify that.\n\nCreate a new variable called and add the following code to the function. You can see this in :\n\nThere are two separate things going on here: the creation of a Physics Sprite and the creation of some animations that it can use.\n\nThe first part of the code creates the sprite:\n\nThis creates a new sprite called , positioned at 100 x 450 pixels from the bottom of the game. The sprite was created via the Physics Game Object Factory ( ) which means it has a Dynamic Physics body by default.\n\nAfter creating the sprite it is given a slight bounce value of 0.2. This means when it lands after jumping it will bounce ever so slightly. The sprite is then set to collide with the world bounds. The bounds, by default, are on the outside of the game dimensions. As we set the game to be 800 x 600 then the player won't be able to run outside of this area. It will stop the player from being able to run off the edges of the screen or jump through the top.\n\nIf you glance back to the function you'll see that 'dude' was loaded as a sprite sheet, not an image. That is because it contains animation frames. This is what the full sprite sheet looks like:\n\nThere are 9 frames in total, 4 for running left, 1 for facing the camera and 4 for running right. Note: Phaser supports flipping sprites to save on animation frames, but for the sake of this tutorial we'll keep it old school.\n\nWe define two animations called 'left' and 'right'. Here is the left animation:\n\nThe 'left' animation uses frames 0, 1, 2 and 3 and runs at 10 frames per second. The 'repeat -1' value tells the animation to loop.\n\nThis is our standard run-cycle and we repeat it for running in the opposite direction, using the key 'right' and a final one for 'turn'.\n\nExtra Info: In Phaser 3 the Animation Manager is a global system. Animations created within it are globally available to all Game Objects. They share the base animation data while managing their own timelines. This allows you to define a single animation once and apply it to as many Game Objects as you require. This is different to Phaser 2 where animations belonged specifically to the Game Objects they were created on.\n\nPhaser has support for a variety of different physics systems, each acting as a plugin available to any Phaser Scene. At the time of writing it ships with Arcade Physics, Impact Physics and Matter.js Physics. For the sake of this tutorial we will be using the Arcade Physics system for our game, which is simple and light-weight, perfect for mobile browsers.\n\nWhen a Physics Sprite is created it is given a property, which is a reference to its Arcade Physics Body. This represents the sprite as a physical body in Phasers Arcade Physics engine. The body object has a lot of properties and methods that we can play with.\n\nFor example, to simulate the effects of gravity on a sprite, it's as simple as writing:\n\nThis is an arbitrary value, but logically, the higher the value, the heavier your object feels and the quicker it falls. If you add this to your code or run you will see that the player falls down without stopping, completely ignoring the ground we created earlier:\n\nThe reason for this is that we're not yet testing for collision between the ground and the player.\n\nWe already told Phaser that our ground and platforms would be static bodies. Had we not done that, and created dynamic ones instead, then when the player collided with them it would stop for a moment and then everything would have collapsed. This is because unless told otherwise, the ground sprite is a moving physical object and when the player hits it, the resulting force of the collision is applied to the ground, therefore, the two bodies exchange their velocities and ground starts falling as well.\n\nIn order to allow the player to collide with the platforms we can create a Collider object. This object monitors two physics objects (which can include Groups) and checks for collisions or overlap between them. If that occurs it can then optionally invoke your own callback, but for the sake of just colliding with platforms we don't require that:\n\nThe Collider is the one that performs the magic. It takes two objects and tests for collision and performs separation against them. In this case we're giving it the player sprite and the platforms Group. It's clever enough to run collision against all Group members, so this one call will collide against the ground and all platforms. The result is a firm platform that doesn't collapse:\n\nControlling the player with the keyboard\n\nColliding is all good and well, but we really need the player to move. You would probably think of heading to the documentation and searching about how to add an event listener, but that is not necessary here. Phaser has a built-in Keyboard manager and one of the benefits of using that is this handy little function:\n\nThis populates the cursors object with four properties: up, down, left, right, that are all instances of Key objects. Then all we need to do is poll these in our loop:\n\nAlthough we've added a lot of code it should all be pretty readable.\n\nThe first thing it does is check to see if the left key is being held down. If it is we apply a negative horizontal velocity and start the 'left' running animation. If they are holding down 'right' instead we literally do the opposite. By clearing the velocity and setting it in this manner, every frame, it creates a 'stop-start' style of movement.\n\nThe player sprite will move only when a key is held down and stop immediately they are not. Phaser also allows you to create more complex motions, with momentum and acceleration, but this gives us the effect we need for this game. The final part of the key check sets the animation to 'turn' and zero the horizontal velocity if no key is held down.\n\nThe final part of the code adds the ability to jump. The up cursor is our jump key and we test if that is down. However we also test if the player is touching the floor, otherwise they could jump while in mid-air.\n\nIf both of these conditions are met we apply a vertical velocity of 330 px/sec sq. The player will fall to the ground automatically because of gravity. With the controls in place we now have a game world we can explore. Load up part7.html and have a play. Try tweaking values like the 330 for the jump to lower and higher values to see the effect it will have.\n\nIt's time to give our little game a purpose. Let's drop a sprinkling of stars into the scene and allow the player to collect them. To achieve this we'll create a new Group called 'stars' and populate it. In our create function we add the following code (this can be seen in ):\n\nThe process is similar to when we created the platforms Group. As we need the stars to move and bounce we create a dynamic physics group instead of a static one.\n\nGroups are able to take configuration objects to aid in their setup. In this case the group configuration object has 3 parts: First it sets the texture key to be the star image. This means that any children created as a result of the config object will all be given the star texture by default. Then it sets the repeat value to be 11. Because it creates 1 child automatically, repeating 11 times means we'll get 12 in total, which is just what we need for our game.\n\nThe final part is - this is used to set the position of the 12 children the Group creates. Each child will be placed starting at x: 12, y: 0 and with an x step of 70. This means that the first child will be positioned at 12 x 0, the second one is 70 pixels on from that at 82 x 0, the third one is at 152 x 0, and so on. The 'step' values are a really handy way of spacing out a Groups children during creation. The value of 70 is chosen because it means all 12 children will be perfectly spaced out across the screen.\n\nThe next piece of code iterates all children in the Group and gives them a random Y bounce value between 0.4 and 0.8. The bounce range is between 0, no bounce at all, and 1, a full bounce. Because the stars are all spawned at y 0 gravity is going to pull them down until they collide with the platforms or ground. The bounce value means they'll randomly bounce back up again until finally settling to rest.\n\nIf we were to run the code like it is now the stars would fall through the bottom of the game and out of sight. To stop that we need to check for their collision against the platforms. We can use another Collider object to do this:\n\nAs well as doing this we will also check to see if the player overlaps with a star or not:\n\nThis tells Phaser to check for an overlap between the player and any star in the stars Group. If found then they are passed to the 'collectStar' function:\n\nQuite simply the star has its physics body disabled and its parent Game Object is made inactive and invisible, which removes it from display. Running the game now gives us a player that can dash about, jump, bounce off the platforms and collecting the stars that fall from above. Not bad for a few lines of hopefully mostly quite readable code :)\n\nThere are two final touches we're going to add to our game: an enemy to avoid that can kill the player, and a score when you collect the stars. First, the score.\n\nTo do this we'll make use of a Text Game Object. Here we create two new variables, one to hold the actual score and the text object itself:\n\nThe is set-up in the function:\n\n16 x 16 is the coordinate to display the text at. 'score: 0' is the default string to display and the object that follows contains a font size and fill color. By not specifying which font we'll actually use the Phaser default, which is Courier.\n\nNext we need to modify the function so that when the player picks-up a star their score increases and the text is updated to reflect this:\n\nSo 10 points are added for every star and the is updated to show this new total. If you run you will see the stars fall and the score increase as you collect them.\n\nIn the final part we'll add some baddies.\n\nIn order to round our game out it's time to add some baddies. This will give a nice element of challenge to the game, something that was previously missing.\n\nThe idea is this: When you collect all the stars the first time it will release a bouncing bomb. The bomb will just randomly bounce around the level and if you collide with it, you die. All of the stars will respawn so you can collect them again, and if you do, it will release another bomb. This will give the player a challenge: get as high a score as possible without dying.\n\nThe first thing we need is a Group for the bombs and a couple of Colliders:\n\nThe bombs will of course bounce off the platforms, and if the player hits them we'll call the function. All that will do is stop the game and turn the player red:\n\nSo far, so good, but we need to release a bomb. To do that we modify the function:\n\nWe use a Group method called to see how many stars are left alive. If it's none then the player has collected them all, so we use the iterate function to re-enable all of the stars and reset their y position to zero. This will make all of the stars drop from the top of the screen again.\n\nThe next part of the code creates a bomb. First we pick a random x coordinate for it, always on the opposite side of the screen to the player, just to give them a chance. Then the bomb is created, it's set to collide with the world, bounce and have a random velocity.\n\nThe end result is a nice little bomb sprite that rebounds around the screen. Small enough to be easy to avoid, at the start, but as soon as the numbers build up it becomes a lot harder!\n\nAnd our game is done üòä\n\nYou have now learned how to create a sprite with physics properties, to control its motion and to make it interact with other objects in a small game world. There are lots more things you can do to enhance this. Why not expand the size of the level and allow the camera to scroll? Maybe add in different baddie types, different value pick-ups, or give the player a health bar.\n\nOr for a non-violent style game you could make it a speed-run and simply challenge them to collect the stars as quickly as possible.\n\nWith the help of what you have learned in this tutorial and the hundreds of examples available to you, you should now have a solid foundation for a future project. But as always if you have questions, need advice or want to share what you've been working on then feel free to ask for help in the Phaser forum."
    }
]