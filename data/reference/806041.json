[
    {
        "link": "https://docs.aiogram.dev",
        "document": "# Bot token can be obtained via https://t.me/BotFather # All handlers should be attached to the Router (or Dispatcher) # Most event objects have aliases for API methods that can be called in events' context # For example if you want to answer to incoming message you can use `message.answer(...)` alias # and the target chat will be passed to :ref:`aiogram.methods.send_message.SendMessage` Handler will forward receive a message back to the sender By default, message handler will handle all message types (like a text, photo, sticker etc.) # But not all the types is supported to be copied so need to handle it # Initialize Bot instance with default bot properties which will be passed to all API calls"
    },
    {
        "link": "https://docs.aiogram.dev/en/v2.25.1",
        "document": "aiogram is a pretty simple and fully asynchronous framework for Telegram Bot API written in Python 3.7 with asyncio and aiohttp. It helps you to make your bots faster and simpler.\n‚Ä¢ None Can reply into webhook. (In other words make requests in response to updates)"
    },
    {
        "link": "https://docs.aiogram.dev/_/downloads/en/v2.25.1/pdf",
        "document": ""
    },
    {
        "link": "https://aiogram-birdi7.readthedocs.io/en/latest",
        "document": "aiogram is a pretty simple and fully asynchronous library for Telegram Bot API written in Python 3.7 with asyncio and aiohttp. It helps you to make your bots faster and simpler.\n‚Ä¢ None Can reply into webhook. (In other words make requests in response to updates)"
    },
    {
        "link": "https://docs.aiogram.dev/en/v3.17.0/changelog.html",
        "document": "\n‚Ä¢ None Checked compatibility with Python 3.13 (added to the CI/CD processes), so now aiogram is totally compatible with it. Dropped compatibility with Python 3.8 due to this version being EOL. In some cases you will need to have the installed compiler (Rust or C++) to install some of the dependencies to compile packages from source on command.\n‚Ä¢ None If you are using Windows, you will need to have the Visual Studio installed.\n‚Ä¢ None If you are using Linux, you will need to have the package installed.\n‚Ä¢ None If you are using macOS, you will need to have the Xcode installed. When developers of this dependencies will release new versions with precompiled wheels for Windows, Linux and macOS, this action will not be necessary anymore until the next version of the Python interpreter.\n‚Ä¢ Integrated the attribute into various message manipulation methods, ensuring consistent data handling. This update eliminates the need to pass the as a parameter, instead directly accessing it from the instance attributes. #1586\n‚Ä¢ None Add function to all built-in storage implementations, and #1431\n‚Ä¢ None Enhanced the inheritance of handlers and actions in Scenes. Refactored to eliminate the copying of previously connected handlers and actions from parent scenes. Now, handlers are dynamically rebuilt based on the current class, properly utilizing class inheritance and enabling handler overrides. That‚Äôs mean that you can now override handlers and actions in the child scene, instead of copying and duplicating them. #1583\n‚Ä¢ \n‚Ä¢ None Added the class and the field in the class , allowing bots to send and receive inline buttons that copy arbitrary text.\n‚Ä¢ None Added the parameter to the methods , , , , , , , , , , , , , , , , , and .\n‚Ä¢ None Added the class for transactions related to paid broadcasted messages.\n‚Ä¢ None Introduced the ability to add media to existing text messages using the method .\n‚Ä¢ None Added support for hashtag and cashtag entities with a specified chat username that opens a search for the relevant tag within the specified chat.\n‚Ä¢ None Fix PytestDeprecationWarning thrown by pytest-asyncio when running the tests #1584\n‚Ä¢ From now UUID will have 32 bytes length instead of 36 bytes (with no separators) in the callback data representation. #1602\n‚Ä¢ None Added possibility to use custom events in routers (If router does not support custom event it does not break and passes it to included routers). #1147\n‚Ä¢ The strategy can be changed in dispatcher: If you have implemented you own storages you should extend record key generation with new one attribute -\n‚Ä¢ None Added a tool to make text formatting flexible and easy. More details on the corresponding documentation page #1172\n‚Ä¢ None Made list to revolve automatically in start_polling method if not set explicitly. #1178\n‚Ä¢ None Change type of result in InlineQueryResult enum for and to more correct according to documentation. Change regexp for entities parsing to more correct ( ). #1146\n‚Ä¢ None Fixed signature of startup/shutdown events to include the as the handler arguments. #1155\n‚Ä¢ None Fixed the serialization error associated with nested subtypes like InputMedia, ChatMember, etc. The previously generated code resulted in an invalid schema under pydantic v2, which has stricter type parsing. Hence, subtypes without the specification of all subtype unions were generating an empty object. This has been rectified now. #1213\n‚Ä¢ None Removed text filter in due to is planned to remove this filter few versions ago.\n‚Ä¢ Note that this issue has breaking changes described in the Bot API changelog, this changes is not breaking in the API but breaking inside aiogram because Beta stage is not finished.\n‚Ä¢ Note that arguments switch_pm_parameter and switch_pm_text was deprecated and should be changed to button argument as described in API docs.\n‚Ä¢ Be careful, not all libraries is already updated to using V2\n‚Ä¢ None Added global defaults and in addition to to the Bot instance, reworked internal request builder mechanism. #1142\n‚Ä¢ None Replaced ContextVar‚Äôs with a new feature called Validation Context in Pydantic to improve the clarity, usability, and versatility of handling the Bot instance within method shortcuts. Breaking: The ‚Äòbot‚Äô argument now is required in\n\nThis update will break backward compability with Python 3.6 and works only with Python 3.7+: - contextvars (PEP-567); - New syntax for annotations (PEP-563). Changes: - Used contextvars instead of ; - Implemented filters factory; - Implemented new filters mechanism; - Allowed to customize command prefix in CommandsFilter; - Implemented mechanism of passing results from filters (as dicts) as kwargs in handlers (like fixtures in pytest); - Implemented states group feature; - Implemented FSM storage‚Äôs proxy; - Changed files uploading mechanism; - Implemented pipe for uploading files from URL; - Implemented I18n Middleware; - Errors handlers now should accept only two arguments (current update and exception); - Used instead of for Socks4/5 proxy; - types.ContentType was divided to and ; - Allowed to use rapidjson instead of ujson/json; - method in bot and dispatcher objects was renamed to ; Full changelog - You can read more details about this release in migration FAQ: https://aiogram.readthedocs.io/en/latest/migration_1_to_2.html"
    },
    {
        "link": "https://sqldocs.org/sqlite-database/aiosqlite-python",
        "document": "SQLite is one of the most widely used database engines in the world. Its lightweight, file-based architecture makes it perfect for embedded databases in desktop and mobile applications. However, Python‚Äôs standard SQLite library blocks the event loop while executing queries, hurting performance in asynchronous programs.\n\nEnter AioSQLite ‚Äì an elegant asynchronous library interacting with SQLite from Python‚Äôs asyncio event loop without blocking. Let‚Äôs learn how AioSQLite makes SQLite fully non-blocking and explore some real-world use cases through examples.\n\nAioSQLite is an asynchronous, non-blocking SQLite driver for Python. It allows you to access SQLite databases from asyncio coroutines without blocking the main event loop thread.\n\nHere are some key things to know about AioSQLite:\n‚Ä¢ It provides an async version of the SQLite Python API, replicating nearly all the features of\n‚Ä¢ Uses a background thread per connection to talk to SQLite without blocking asyncio event loop\n‚Ä¢ Lets you access SQLite using async/await instead of callbacks\n\nInstalling AioSQLite is as simple as:\n\nThat‚Äôs it! Now, let‚Äôs look at how to use it.\n\nThe API for AioSQLite mirrors , but with async methods instead of synchronous ones.\n\nFor example, here is how to connect to an SQLite database file, insert data, and query it:\n\nThere are a few key things to notice here:\n‚Ä¢ Executing SQL happens via , using\n‚Ä¢ Getting query results uses an async cursor that returns rows via\n\nThis allows the database code to run non-blockingly within an asyncio event loop.\n\nA key feature of AioSQLite is the use of async context managers to manage connections and cursors automatically:\n\nThis takes care of opening and closing connections for you.\n\nAioSQLite replicates most other advanced features of too:\n\nThe API supports nearly everything you can do in standard SQLite.\n\nHere is an example of using AioSQLite with a real-world data analytics database containing user analytics events:\n\nThis allows storing analytic event data from users in SQLite by leveraging AioSQLite‚Äôs non-blocking API!\n\nHere are some of the major benefits you get from using AioSQLite:\n‚Ä¢ Avoid callback hell by using instead\n‚Ä¢ Replicates nearly all functionality of module\n‚Ä¢ Enables real-time analytics, streaming, and more use cases by removing SQLite blocking behavior\n\nIf you need to use SQLite from an asyncio app, AioSQLite is currently the best way to go about it while avoiding bottlenecks.\n\nAs you can see, AioSQLite retains nearly all the underlying SQLite functionality while adding async capabilities.\n\nAioSQLite brings the simplicity and ubiquity of SQLite to the world of asyncio and Python async programming. With its async API using , context managers, non-blocking behavior, and Python 3.7+ support, AioSQLite is the go-to choice for accessing SQLite from an asyncio application.\n\nWhether you need real-time analytics, streaming processing, or just a simple offline data store, AioSQLite takes the blocking factor out of SQLite. This lets you build highly concurrent database-backed programs without the headaches of callback hell or stalling the event loop.\n\nIf you found this useful, be sure to check out the AioSQLite documentation to learn more!"
    },
    {
        "link": "https://github.com/omnilib/aiosqlite",
        "document": "It replicates the standard module, but with async versions of all the standard connection and cursor methods, plus context managers for automatically closing connections and cursors:\n\nIt can also be used in the traditional, procedural manner:\n\naiosqlite also replicates most of the advanced features of :\n\naiosqlite is compatible with Python 3.8 and newer. You can install it from PyPI:\n\naiosqlite allows interaction with SQLite databases on the main AsyncIO event loop without blocking execution of other coroutines while waiting for queries or data fetches. It does this by using a single, shared thread per connection. This thread executes all actions within a shared request queue to prevent overlapping actions.\n\nConnection objects are proxies to the real connections, contain the shared execution thread, and provide context managers to handle automatically closing connections. Cursors are similarly proxies to the real cursors, and provide async iterators to query results.\n\naiosqlite is copyright Amethyst Reese, and licensed under the MIT license. I am providing code in this repository to you under an open source license. This is my personal repository; the license you receive to my code is from me and not from my employer. See the LICENSE file for details."
    },
    {
        "link": "https://en.ittrip.xyz/python/async-sqlite-python",
        "document": "Python‚Äôs simplicity and readability have made it a preferred language for both beginners and seasoned developers, particularly for database operations. SQLite, a lightweight yet powerful database engine, is commonly integrated with Python for local data storage and manipulation. However, as applications grow in complexity, the need to manage database operations without blocking the main thread becomes evident. This is where asynchronous programming steps in to enhance performance and user experience. In this article, we delve deep into the realm of Python‚Äôs asynchronous capabilities with SQLite, providing you with the knowledge to implement non-blocking database interactions in your next Python project.\n\nAsynchronous operations are essential in modern application development, enabling the program to continue running while waiting for IO-bound tasks, such as database operations, to complete. This non-blocking behavior is particularly crucial for applications that require high concurrency or need to maintain responsiveness under load.\n\nPython‚Äôs asynchronous programming capabilities are built on the foundations of coroutines, event loops, and the ‚Äòasync‚Äô and ‚Äòawait‚Äô syntax introduced in Python 3.5. These features allow developers to write code that can perform multiple operations in the background while the main program thread executes other tasks.\n\nThe Role of Asyncio in Asynchronous Operations\n\nAsyncio is Python‚Äôs standard library for writing concurrent code using the async/await syntax. It provides the framework for creating and managing event loops, which are critical for handling asynchronous tasks.\n\nThe integration of SQLite with asyncio in Python applications involves several steps and considerations to ensure smooth and efficient operation.\n\nBefore diving into SQLite operations, it is important to set up an environment that supports asynchronous execution. This often involves creating an event loop and establishing a database connection using an asynchronous SQLite library.\n\nNot all SQLite libraries support asynchronous operations. Libraries like `aiosqlite` are designed to work seamlessly with Python‚Äôs async/await features. When selecting a library, ensure it is compatible with asyncio and provides non-blocking database operations.\n\nOnce you have an asynchronous SQLite library in place, you can start executing database operations without blocking the main thread. This includes creating tables, inserting data, and querying the database asynchronously.\n\nCRUD operations‚ÄîCreate, Read, Update, Delete‚Äîcan be performed using the async/await syntax. Here‚Äôs an example of how to perform an asynchronous query:\n\nBest Practices for Asynchronous SQLite in Python\n\nTo effectively use SQLite in an asynchronous context, follow these best practices:\n\n‚Äì Use connection pools to manage database connections efficiently.\n\n ‚Äì Handle exceptions properly to avoid crashing your application.\n\n ‚Äì Test asynchronous operations thoroughly to ensure they work as expected.\n\nResource management is critical in asynchronous programming. Ensure that all database connections are properly opened and closed, and that resources are cleaned up after use.\n\nContext managers are a great way to manage resources with minimal code. They automatically close connections and clean up resources, even if an error occurs during an operation.\n\nIncorporating asynchronous SQLite operations into a Python project can significantly improve its performance and responsiveness. By understanding the principles of asynchronous programming and following best practices, you can unlock the full potential of your applications. Remember to select the right tools and libraries, manage your resources carefully, and test your code to ensure reliable and efficient database interactions."
    },
    {
        "link": "https://medium.com/@zimyanin88/aiosqlite-async-sqlite-upgrade-with-decorators-15a6d703bbd6",
        "document": "aiosqlite is a high-performance asynchronous SQLite driver for Python. It provides two ways to connect to a database: through the cursor and through the context manager.\n\nThe most common way to connect to a database using aiosqlite is through the cursor. To do this, you first need to create a connection object. You can do this using the method:\n\nUse code with caution. Learn more\n\nOnce you have a connection object, you can create a cursor object. You can do this using the method:\n\nUse code with caution. Learn more\n\nThe cursor object provides a number of methods that you can use to interact with the database. For example, you can use the method to execute a SQL statement:\n\nUse code with caution. Learn more\n\nYou can also use the method to fetch all of the rows from a table:\n\nUse code with caution. Learn more\n\nOnce you are finished interacting with the database, you need to close the cursor object. You can do this using the method:\n\nUse code with caution. Learn more\n\nAnother way to connect to a database using aiosqlite is through the context manager. This is a more concise way to connect to the database, and it ensures that the connection is closed properly even if an exception is raised.\n\nTo connect to a database using the context manager, you can use the following code:\n\nUse code with caution. Learn more\n\nAs you can see, the code is much more concise when you use the context manager. Additionally, you don‚Äôt need to worry about closing the connection manually, because the context manager will do it for you.\n\nWhich method should you use?\n\nThe method that you use to connect to a database using aiosqlite depends on your specific needs. If you need to interact with the database multiple times, then you should use the cursor method. However, if you only need to interact with the database once, then you should use the context manager method."
    },
    {
        "link": "https://stackoverflow.com/questions/63813922/what-is-the-difference-between-aiosqlite-and-sqlite-in-multi-threaded-mode",
        "document": "I'm trying to asynchronously process multiple files, and processing each file requires some reads and writes to an SQLite database. I've been looking at some options, and I found the aiosqlite module here. However, I was reading the SQLite documentation here, and it says that it supports multi-threaded mode. In fact, the default mode is \"serialized\" which means it \"can be safely used by multiple threads with no restriction.\"\n\nI don't understand what the difference is. The aiosqlite documentation says:\n\naiosqlite allows interaction with SQLite databases on the main AsyncIO event loop without blocking execution of other coroutines while waiting for queries or data fetches. It does this by using a single, shared thread per connection.\n\nI get that there is a difference between aiosqlite and the \"multi-threaded\" mode on sqlite because the multi-threaded mode requires only one connection per thread, whereas in aiosqlite, you can reuse this single connection across multiple threads. But isn't this the same as serialized mode where it can be \"used by multiple threads with no restriction\"?\n\nEdit: My question right now is \"Is my current understanding below is correct?\":\n‚Ä¢ Sqlite in \"serialized\" mode can be used by multiple threads at one time, so this would be used if I used the module in python and spawned multiple threads. Here I have the options of either using a separate connection per thread or sharing the connection across multiple threads.\n‚Ä¢ aiosqlite is used with asyncio. So since asyncio has multiple coroutines that share one thread, aiosqlite also works with one thread. So I create one connection that I share among all the coroutines.\n‚Ä¢ Since aiosqlite is basically a wrapper for sqlite, I can combine the functionality of 1 and 2. So I can have multiple threads where each thread has an asyncio event loop with multiple coroutines. So the basic sqlite functionality will handle the multi-threading and the aiosqlite will handle the coroutines."
    },
    {
        "link": "https://stackoverflow.com/questions/67096753/aiogram-set-state-for-a-exact-user",
        "document": "I'm writing a bot in python and aiogram. The point is that the administrator accepts (or rejects) user requests. Accordingly, when the administrator clicks on the button in his chat, I need to change the user's state (his uid is known). I didn't find how to do it anywhere.\n\nI'm looking for something like"
    },
    {
        "link": "https://medium.com/sp-lutsk/exploring-finite-state-machine-in-aiogram-3-a-powerful-tool-for-telegram-bot-development-9cd2d19cfae9",
        "document": "In the realm of Telegram bot development, the quest for efficiency and robustness is an ongoing endeavor. With each iteration, developers seek tools and frameworks that streamline the development process while ensuring the scalability and maintainability of their bots. In this pursuit, the integration of Finite State Machines (FSMs) has emerged as a powerful technique, providing a structured approach to managing bot behavior. In this article, we delve into the integration of Finite State Machines within the Aiogram 3 framework, a powerful option for Telegram bot development in Python. Aiogram, renowned for its simplicity and flexibility, empowers developers to build feature-rich bots effortlessly. By using FSM, it can become even more seamless, offering developers a structured approach to handling complex bot behavior.\n\nA Finite State Machine (FSM) is a computational model used to describe the behavior of a system by dividing it into a finite number of states, along with transitions between these states based on certain conditions or events. At its core, an FSM consists of the following components:\n‚Ä¢ States: These represent the distinct conditions or modes that the system can be in at any given time. Each state encapsulates a specific set of behaviors or actions that the system can perform while in that state.\n‚Ä¢ Transitions: These define the conditions or events that trigger a change in state. When a transition occurs, the system moves from one state to another, potentially altering its behavior or internal configuration.\n‚Ä¢ Inputs/Events: These are the stimuli or signals that drive the transitions between states. Inputs can come from various sources, such as user interactions, sensor readings, or external events. In Aiogram 3, the integration of Finite State Machines offers developers a remarkable opportunity to manage the intricate flow of user inputs with ease. By guiding users through a sequence of defined states and handling each state separately, FSMs empower developers to create Telegram bots that gracefully navigate through complex interaction scenarios. This capability allows for the systematic handling of user inputs, ensuring a seamless conversational experience for bot users.\n\nTo better comprehend the theoretical aspects of Finite State Machines (FSM) in Aiogram, let‚Äôs embark on a practical journey. Imagine we‚Äôre creating a form within our Telegram bot where we sequentially ask users a series of questions, concluding with a confirmation of the collected answers. In Aiogram, FSMs are represented as StatesGroups, serving as the foundation for organizing bot behavior into distinct states and managing transitions between them. The schema below illustrates the sequential flow of our form within the FSM framework: Starting with the creation of a StatesGroup, we establish a structured environment for managing the flow of user interactions. Each state within the StatesGroup corresponds to a specific stage in our form, guiding users through a sequence of questions and responses. As users progress through the form, transitions between states occur based on their inputs, ensuring a smooth and intuitive user experience. Now, let‚Äôs delve into the implementation details. Below, you‚Äôll find the code snippet illustrating the creation of the StatesGroup with Aiogram: After defining the StatesGroup for our form, the next step is to establish handlers to manage user interactions. Typically, a conversation with the bot initiates with the /start command. Therefore, our first task is to handle this command and transition the user to the initial state of our form, Form.About.first_name. Below is a snippet showcasing the implementation of the handler for the /start command and the transition operation to the first state: We have added two buttons for this question ‚Äî ‚ÄúSkip‚Äù and ‚ÄúCancel‚Äù, we will cover them later. After the user answers the first question, we need to store the answer in the storage and move on to the next step. Code snippet to handler first state and transition to second state: In this handler, we‚Äôve successfully stored the user‚Äôs input for the first question and will now progress to the next question. Additionally, we‚Äôll incorporate an ‚ÄúGo back‚Äù button later, enabling users to make transition to the previous question. Following a consistent sequence, each subsequent handler will entail the same actions: saving the user‚Äôs response, transitioning to the subsequent step, and posing the subsequent question. Upon reaching the final state, Form.confirm, users will be presented with all collected information for review. With the implementation of the described logic, our bot is now equipped to traverse through all defined states, guiding users through each step of the form.\n\nIncorporating various options to enhance user flexibility during Finite State Machine (FSM) integration in Aiogram is crucial for providing a smoother user experience. Among these options is the ability to terminate the flow, facilitated by the addition of a ‚ÄúCancel‚Äù button. This button should be accessible from any state within the FSM, necessitating a single handler to manage its functionality. This handler will be responsible for clearing the current state and sending an appropriate message to the user, indicating the cancellation of the flow. @form_router.message(Command(\"cancel\"))\n\n@form_router.message(F.text.casefold() == \"cancel\")\n\nasync def cancel_handler(message: Message, state: FSMContext) -> None:\n\n \"\"\"\n\n Allow user to cancel any action\n\n \"\"\"\n\n current_state = await state.get_state()\n\n if current_state is None:\n\n return To introduce the ‚ÄúGo back‚Äù button functionality, enabling users to transition to the previous state, we need to implement an additional tool ‚Äî a list containing information about the states. For this, let‚Äôs outline a data structure representing the state information. Code snippet for this: Each element of the list will be represented as dataclass with state name, question for this state, in memory representative value, corresponding button (we will need it for future step) and keyboard buttons that need to be sent to user with state question. Code snippet for first state implementation in dataclass format: State(\n\n \"Form.About:first_name\",\n\n \"What's your first name?\",\n\n \"first_name\",\n\n \"First name\",\n\n [\n\n [KeyboardButton(text=\"Skip\")],\n\n [KeyboardButton(text=\"Cancel\")],\n\n ],\n\n), All following states will have similar structure, but with additional ‚ÄúGo back‚Äù button. Code snippet example for following states: State(\n\n \"Form.About:last_name\",\n\n \"What's your last name?\",\n\n \"last_name\",\n\n \"Last name\",\n\n [\n\n [KeyboardButton(text=\"Skip\"), KeyboardButton(text=\"Go back\")],\n\n [KeyboardButton(text=\"Cancel\")],\n\n ],\n\n), This list of states will allow us to track the state by name and manage all of its attributes to better understand it lets review code snippet for the ‚ÄúGo back‚Äù button handler: @form_router.message(Command(\"go back\"))\n\n@form_router.message(F.text.casefold() == \"go back\")\n\nasync def go_back_handler(message: Message, state: FSMContext) -> None:\n\n current_state = await state.get_state()\n\n logging.info(\"Going back from %r\", current_state)\n\n (\n\n previous_state,\n\n state_message,\n\n keyboard_buttons\n\n ) = get_previous_state(current_state)\n\n if previous_state is None:\n\n await message.answer(\n\n \"You are already at the first step.\",\n\n )\n\n else:\n\n await state.set_state(previous_state)\n\n await message.answer(\n\n state_message,\n\n reply_markup=ReplyKeyboardMarkup(\n\n keyboard=keyboard_buttons,\n\n resize_keyboard=True,\n\n ),\n\n ) In this handler we get the current_state and based on that we get the previous state information using the get_previous_state method. def get_previous_state(current_state: str) -> str:\n\n current_state_index = next(\n\n (i for i, obj in enumerate(STATES_LIST) if obj.state_name == current_state),\n\n None,\n\n )\n\n previous_state_index = current_state_index - 1\n\n if previous_state_index < 0:\n\n return None, None\n\n return (\n\n STATES_LIST[previous_state_index].state_name,\n\n STATES_LIST[previous_state_index].state_question,\n\n STATES_LIST[previous_state_index].keyboard_buttons,\n\n ) This method uses created STATES_LIST to receive current state (the state from which the user wants to go back) index and based on this returns information about previous state name, questions and keyboard buttons. After this we only need to set this state and send proper message to user. Implementation of this flow shown bellow.\n\nTransition to any state in flow Now when we can cancel flow and use transition to previous state we can try to implement even more complicated operations. For this lets implement confirmation for our form. Previously we have added ‚ÄúApprove‚Äù and ‚ÄúDisapprove‚Äù buttons for final step. Handler for ‚ÄúApprove‚Äù button is very simple. @form_router.message(Form.confirm, F.text.casefold() == \"approve\")\n\nasync def process_confirm(message: Message, state: FSMContext) -> None:\n\n await state.clear()\n\n await message.answer(\n\n \"Thank you for your Form!\",\n\n reply_markup=ReplyKeyboardRemove(),\n\n ) We will not save any customers data in this example, so all we need ‚Äî close state and send appropriate message. To implement ‚ÄúDisapprove‚Äù function lets add another state ‚Äî ‚Äúconfirm_reject‚Äù, after it our StatesGroup looks like this: Handler for ‚ÄúDisapprove‚Äù button will set this state and send message with proposition to change any of inputed data. @form_router.message(Form.confirm_reject, F.text.casefold() != \"cancel\")\n\nasync def process_reject(message: Message, state: FSMContext) -> None:\n\n required_state_index = next(\n\n (\n\n i\n\n for i, obj in enumerate(STATES_LIST)\n\n if obj.state_corresponding_button == message.text\n\n ),\n\n None,\n\n )\n\n if required_state_index is None:\n\n await message.answer(\n\n \"I don't understand you. Please, choose one of the options.\",\n\n )\n\n else:\n\n required_state = STATES_LIST[required_state_index]\n\n await state.update_data(reject=True)\n\n await state.set_state(required_state.state_name)\n\n await message.answer(\n\n required_state.state_question,\n\n reply_markup=ReplyKeyboardMarkup(\n\n keyboard=required_state.keyboard_buttons,\n\n resize_keyboard=True,\n\n ),\n\n ) In this handler firstly we validate if user selected one of available buttons, for this we are trying to find state by state_corresponding_button value in STATES_LIST. After this we need to receive required_state information, make transition to this step and send proper message. But logically ‚Äî after user will answer to this question we should send him to confirmation step again, for this we need to add ‚Äúreject‚Äù value to states data and also update our states handlers to handle this value. Updated ‚Äúfirst_name‚Äù state handler @form_router.message(Form.about.first_name)\n\nasync def process_first_name(message: Message, state: FSMContext) -> None:\n\n await state.update_data(first_name=message.text)\n\n data = await state.get_data()\n\n reject = data.get(\"reject\", False)\n\n if reject:\n\n await update_on_reject(message, state)\n\n else:\n\n await state.set_state(Form.about.last_name)\n\n await message.answer(\n\n \"What's your last name?\",\n\n reply_markup=ReplyKeyboardMarkup(\n\n keyboard=[\n\n [\n\n KeyboardButton(text=\"Skip\"),\n\n KeyboardButton(text=\"Go back\")\n\n ],\n\n [KeyboardButton(text=\"Cancel\")],\n\n ],\n\n resize_keyboard=True,\n\n ),\n\n ) As you can see we added only if else statement to handler reject, in case if reject is equal to True we are calling update_on_reject method: This method will make transition to confirmation state and send confirmation message again. On our state schema this operation is illustrated in two lines, firstly we perform transition from ‚ÄúConfirmation‚Äù to ‚ÄúFirst name‚Äù (with red arrow) and then back to ‚ÄúConfirmation‚Äù (with purple arrow). In Telegram flow it will looks like this:"
    },
    {
        "link": "https://stackoverflow.com/questions/77322329/setting-multiple-states-for-a-user-on-aiogram-3-x",
        "document": "I am working on Telegram Bot, using aiogram 3.1.1 and its FSM. I did define UserState, that can have two states\n\nThis is the way how i filter users, that are currently waiting for an answer from bot or have the dialogue mode enabled.\n\nAnd it works fine. But i encounter an issue, when i want to have another independent StatesGroup for users. For example:\n\nUsing this i want to filter if the user wants to receive answers from bot via text message or via voice message. Those StatesGroups are meant to be independent, meaning that the user can have \"Voice\" and \"Dialogue\" states at once.\n\nI did try giving a person either \"Voice\" or \"Text\" status at the start of the conversation by asking him a question via the /start command. Then the user could choose if he wants a dialogue mode or not (should the bot set \"Dialogue\" state). For filtering this i've built two functions, they went smth like:\n\nThe problem is - the second function does not seem to be working properly. It seems like a user in aiogram FSM can only have one state a time, even if multiple states are in different StateGroups.\n\nSo did i get something wrong? And if, sadly, i am right - what are the common solutions for this task?"
    },
    {
        "link": "https://docs.aiogram.dev/en/latest/dispatcher/finite_state_machine/index.html",
        "document": "An FSM is defined by a list of its states, its initial state, and the inputs that trigger each transition.\n\nIt is an abstract machine that can be in exactly one of a finite number of states at any given time. The FSM can change from one state to another in response to some inputs; the change from one state to another is called a transition.\n\nA finite-state machine (FSM) or finite-state automaton (FSA, plural: automata), finite automaton, or simply a state machine, is a mathematical model of computation.\n\nNot all functionality of the bot can be implemented as single handler, for example you will need to collect some data from user in separated steps you will need to use FSM.\n\nLet‚Äôs see how to do that step-by-step\n\nBefore handle any states you will need to specify what kind of states you want to handle And then write handler for each state separately from the start of dialog Here is dialog can be started only via command , so lets handle it and make transition user to state \"Hi there! What's your name?\" After that you will need to save some data to the storage and make transition to next step. Did you like to write bots?\" At the next steps user can make different answers, it can be , or any other Handle and soon we need to handle state What programming language did you use for it?\" And handle any other answers All possible cases of step was covered, let‚Äôs implement finally step \"Python, you say? That's the language that makes my circuits light up! üòâ\" \"you like to write bots with \"you don't like to write bots, so sad...\" And now you have covered all steps from the image, but you can make possibility to cancel conversation, lets do that via command or text Allow user to cancel any action\n\n\"Hi there! What's your name?\" Allow user to cancel any action Did you like to write bots?\" What programming language did you use for it?\" \"Python, you say? That's the language that makes my circuits light up! üòâ\" \"you like to write bots with \"you don't like to write bots, so sad...\" # Initialize Bot instance with default bot properties which will be passed to all API calls"
    },
    {
        "link": "https://docs.aiogram.dev/en/v3.16.0/dispatcher/finite_state_machine",
        "document": "An FSM is defined by a list of its states, its initial state, and the inputs that trigger each transition.\n\nIt is an abstract machine that can be in exactly one of a finite number of states at any given time. The FSM can change from one state to another in response to some inputs; the change from one state to another is called a transition.\n\nA finite-state machine (FSM) or finite-state automaton (FSA, plural: automata), finite automaton, or simply a state machine, is a mathematical model of computation.\n\nNot all functionality of the bot can be implemented as single handler, for example you will need to collect some data from user in separated steps you will need to use FSM.\n\nLet‚Äôs see how to do that step-by-step\n\nBefore handle any states you will need to specify what kind of states you want to handle And then write handler for each state separately from the start of dialog Here is dialog can be started only via command , so lets handle it and make transition user to state \"Hi there! What's your name?\" After that you will need to save some data to the storage and make transition to next step. Did you like to write bots?\" At the next steps user can make different answers, it can be , or any other Handle and soon we need to handle state What programming language did you use for it?\" And handle any other answers All possible cases of step was covered, let‚Äôs implement finally step \"Python, you say? That's the language that makes my circuits light up! üòâ\" \"you like to write bots with \"you don't like to write bots, so sad...\" And now you have covered all steps from the image, but you can make possibility to cancel conversation, lets do that via command or text Allow user to cancel any action\n\n\"Hi there! What's your name?\" Allow user to cancel any action Did you like to write bots?\" What programming language did you use for it?\" \"Python, you say? That's the language that makes my circuits light up! üòâ\" \"you like to write bots with \"you don't like to write bots, so sad...\" # Initialize Bot instance with default bot properties which will be passed to all API calls"
    }
]