[
    {
        "link": "https://dev.epicgames.com/documentation/en-us/unreal-engine/configuration-files-in-unreal-engine",
        "document": "Configuration Files or Config Files provide the initial settings for Unreal Engine (UE). At their most basic level, they contain lists of key-value pairs organized into sections. These files are used to set default values for objects and properties that are loaded upon startup of Unreal Engine for all builds and platforms. Configuration files use the file extension.\n\nConfiguration files are structured as follows:\n\nEvery config variable must belong to a and consist of a followed by the symbol. For example, in :\n\nThe can be empty in a config variable, so it is possible to have:\n\nSection names are alphabetic strings you can set to any value. The config system loads all declarations in configuration files whether a config variable exists in your project code or not.\n\nSection headings for configurable objects contained in modules use the syntax:\n‚Ä¢ : the name of the module containing the configurable object.\n‚Ä¢ : the name of the class within the module containing the configurable object.\n\nSection headings for configurable objects contained in plugins use the syntax:\n‚Ä¢ : the name of the plugin containing the configurable object.\n‚Ä¢ : the name of the class within the plugin containing the configurable object.\n\nSection headings for configurable assets contained in blueprints use the syntax:\n‚Ä¢ : the path to your asset.\n‚Ä¢ : the name of the asset in containing the configurable object.\n\nAny alphabetic string can be used as a custom category name. For example, if you want a category named \"MyConfigSection\", write\n\nWhen you use custom section names, you must manually query the config variables contained in the section. See the Manually Apply Configuration Settings to Variables section for more information.\n\nPrepend a semicolon ( ) to any line to create a comment in your configuration file. This also works for commenting out key-value pairs as opposed to deleting them from a file.\n\nConfiguration keys can represent a variety of different types of information:\n\nArray structures in configuration files provide a mechanism for you to combine, accumulate, or override information across multiple configuration files in the configuration file hierarchy. For example, you can add multiple entries to a single configuration array object across multiple files in the hierarchy, such as and in your engine directory, and in your project directory.\n\nThe lines in this example perform the following operations:\n‚Ä¢ : remove everything from array then append 7\n‚Ä¢ : clear the array of all entries\n\nIn the end, contains .\n\nConfiguration files support changing struct properties in a config object. The syntax for setting a struct is\n\nQuotes support the use of specially escaped characters, hexadecimal, and UTF sequences. This is helpful for localization and internationalization. For example, the following section is contained in :\n\nThere are a few important considerations when using configuration files in your project. These include:\n‚Ä¢ What categories of configuration files does Unreal Engine recognize?\n‚Ä¢ How do files within the same category interact with one another?\n\nUnreal Engine recognizes several typical \"known\" categories of configuration files.\n\nThere can be multiple different configuration files within each category. For example, the directory contains:\n\nThese files are part of the configuration file category. Each provides an additional layer of customization.\n\nConfiguration files within the same category are organized into a hierarchical structure. If there are duplicate key-value pairs among files in the same category, key-value assignments in latter files override those from files earlier in the hierarchy. Configuration files stored in the directory apply to all projects using this Engine distribution. Configuration files located in the apply only to that particular project. Similarly, configuration files located in directories apply only to that particular platform.\n\nCategory configuration files are loaded in the following order:\n\nTo illustrate how the hierarchy works, suppose that you have a project named and in the configuration file, you have:\n\nSuppose that you have the following config setting in :\n\nSince the file in your project directory supersedes the file in your engine directory, the value of when your project starts up is .\n\nYou can automatically apply config variables to and or manually read them from the config manager.\n\nYou can define a class to automatically load values from within the config file hierarchy.\n\nTo automatically load a config setting in your module code, format as:\n‚Ä¢ is the name of the module where the class is defined.\n‚Ä¢ is the name of the class where the variable in question is defined.\n\nSuppose that you have a module named that has a class named , and that contains a member variable you want to be able to change in configuration files named .\n‚Ä¢ Configure which config file category to read in the declaration. This example uses the category:\n‚Ä¢ Mark any member variable in the class that you want to be configurable as :\n‚Ä¢ Set the preceding variables anywhere in the hierarchy of your chosen config file category. For example, since this example uses the category, the following configuration can be set within in the project directory:\n\nYour class should look something like this:\n\nAs previously mentioned, the config system loads all declarations in configuration files whether an actual config variable exists in your C++ code or not. This means that you can query a config variable in any section. For example, say you have the following config in :\n\nYou can read this value into any file you want using the following code:\n\nThe value of in your game code is now 2.\n\nThere are several options for functions to retrieve a variable as well as the configuration file category to retrieve said variable from.\n\nThe following functions can be found in located in .\n\nThe configuration category is identified as . For example, the category is referenced as . The values can be found in located in .\n\nYou can change your configuration settings by either:\n‚Ä¢ Editing configuration values in an appropriate file.\n‚Ä¢ Editing configuration values exposed in the Project Settings within Unreal Editor.\n\nYou can save your configuration settings from your game code with .\n\nSuppose that you have the same code as in the example in the section Steps to Automatically Load Config Variables:\n\nSomewhere in your code, suppose that you edit this configurable variable:\n\nYou can save this new config value to the config file with absolute path as:\n\nYou can see the value of any configuration setting with the console command. This command helps you to view the value of any configuration setting, including settings for platforms other than the one you are currently using. This command only searches loaded configuration files, so if the setting is in a configuration file that is not loaded, your query might fail.\n\nThe argument is optional. If this is not supplied, defaults to the platform you are currently using.\n\nTo find the value of the key in the section of the hierarchy on Windows, run:\n\nUnreal Engine provides a mechanism by which you can override configuration settings through command-line arguments.\n\nOverride the specified with the provided contained in the given of the configuration file . For a full list of available configuration file categories, see the Configuration File Categories section of this page.\n\nOverride the value of contained in the section of the category hierarchy, no matter the previous value. Same for the .\n\nOverride the file with the file where is the specific configuration file type you wish to override. For a full list of available configuration file categories, see the Configuration File Categories section of this page.\n\noverrides the configuration file. For a full list of available configuration file categories, see the Configuration File Categories section of this page.\n\nOverride all configuration files in the given . For a full list of available configuration file categories, see the Configuration File Categories section of this page.\n\noverrides all other files. For a full list of available configuration file categories, see the Configuration File Categories section of this page.\n\nOverride the config file with the matching suffix path.\n\noverrides the configuration file . For a full list of available configuration file categories, see the Configuration File Categories section of this page.\n\nOverride all config files being loaded and parsed. Read-only.\n\nis the only configuration file loaded, nothing else.\n\nConfiguration Files provide another mechanism for specifying console variables. Some console variables can be set in general configuration categories whereas others should be set in specific configuration categories. Generally, console variables are set in the section in within your project directory.\n\nThe following table describes the specific categories of console variables that should be set in particular sections:\n\nUseful Source Files for More Information\n\nThe following engine files provide more information about the config system and its components:"
    },
    {
        "link": "https://forums.unrealengine.com/t/read-and-write-from-file-config/127776",
        "document": "HI all, i‚Äôm trying to read data from new config file\n\nprotected:\n\n // Called when the game starts or when spawned\n\n virtual void BeginPlay() override;\n\n// Sets default values\n\n AShip::AShip()\n\n {\n\n // Set this actor to call Tick() every frame. You can turn this off to improve performance if you don‚Äôt need it.\n\n PrimaryActorTick.bCanEverTick = true;\n\n Mesh = CreateDefaultSubobject<UStaticMeshComponent>(‚ÄúMyMesh‚Äù);\n\n// Called when the game starts or when spawned\n\n void AShip::BeginPlay()\n\n {\n\n Super::BeginPlay();\n\n }\n\nit‚Äôs don‚Äôt,work someone know why ?"
    },
    {
        "link": "https://forums.unrealengine.com/t/plugin-configs/683565",
        "document": "This page shows it should be possible to add Configs to each plugin. So if I have a plugin named MyPlugin I tried creating a file under Config/DefaultMyPlugin.ini However none of the settings set in there seem to take effect. I‚Äôm not sure this is completely right or working.\n\nI use GConfig which is a FConfigCacheIni (FConfigCacheIni | Unreal Engine Documentation) It saves the config in the users project rather than the plugin folder - I thought that was more in line with UE - it‚Äôs easy enough to create ‚ÄúImport from another project‚Äù features. Then it‚Äôs this easy to set something:\n\nThis is my own plugin that I‚Äôm building in C++ and I‚Äôm trying to figure out how to make my plugin come with its own default config so you don‚Äôt have to remember to add these configs to the game every time you add it. Ideally I‚Äôd want this to be the default setting unless it‚Äôs overridden by the game. Otherwise the plugin isn‚Äôt just, Drop in and Plug and Play. You have to add all these additional cumbersome steps like, ‚ÄúDon‚Äôt forget to copy paste this into your DefaultGame.ini‚Äù Also this is a plugin that lives in the game‚Äôs Plugins folder. It could potentially be in the engine plugins, but for this I‚Äôm choosing to make it live with the game. I actually figured out how to work with unreal plugins and C++ pretty well, but am struggling with this config issue.\n\nI was having this issue with Gameplay Tags and ended up defining all the gameplay tags in a table asset and have to add the file in the project settings. I found that I could add code into the module startup to add an ini file to the tags search path. However, I ran into an issue where if my plugin loaded the configs at plugin load time the gameplay tags were loaded too late for some things the engine required. It sounds like RecourseDesign‚Äôs code might work too.\n\nThanks. Yeah in my case I tried a bunch of things. In my particular scenario I couldn‚Äôt load the config file with , but since i know where that file is in relation to my plugin‚Äôs base directory, i was able to do: Then using RecourseDesign‚Äôs suggestion to access my sections and strings within that section. I also did this in my plugin‚Äôs function\n\nI had the same issue with the platform traits and Common UI. The way I fixed it was to set my module‚Äôs load phase to pre default: The reason why that works is because is set to load in the default phase: So by forcing our plugin to load earlier, the game tags are available by the time CommonUI (or whatever plugin might use your tags/config) loads. Of course that only works if your target plugin does load after the PreDefault phase. If you don‚Äôt that, the load order isn‚Äôt guaranteed and your tags might not be available."
    },
    {
        "link": "https://michaeljcole.github.io/wiki.unrealengine.com/Config_Files,_Read_&_Write_to_Config_Files",
        "document": "In this tutorial I am showing you working code samples you can plug into your player controller class (or any class if you remove the ClientMessage() parts).\n\nIn these samples I retrieve various bits of information, including the Near Clip Pane value, from the Game and Engine inis, and I also write a new section into the Game.ini called Victory.Core and store some data there.\n\nThe main advantage of config files is that the user can go in and edit the data in a human-readible format any time they want!\n\nPlease note that when you write out info to config files, the data is not stored in YourGame\\Config where the defaultconfig files are.\n\nYour data will be written to\n\nHere's were you can edit the data outside your game and then launch your game and read that changed data into your game system üòÉ\n\nCheck out this header for all the function definitions and options available to you, for writing out arrays or reading in entire file as a FString, many, many useful functions\n\n\" There is a bunch of globals that you can use here to quickly grab the core configuration files:\n\nThis is very useful info!\n\nYou will see in the functions below I rely on these global FStrings to more quickly write out the filename function parameter\n\n//in your player controller class void AVictoryController::VictoryConfigGetTests() { //Basic Syntax /* bool GetString( const TCHAR* Section, const TCHAR* Key, FString& Value, const FString& Filename ); */ if(!GConfig) return; //~~ //Retrieve Default Game Type FString ValueReceived; GConfig->GetString( TEXT(\"/Script/Engine.WorldInfo\"), TEXT(\"GlobalDefaultGameType\"), ValueReceived, GGameIni ); ClientMessage(\"GlobalDefaultGameType\"); ClientMessage(ValueReceived); //Retrieve Max Objects not considered by GC int32 IntValueReceived = 0; GConfig->GetInt( TEXT(\"Core.System\"), TEXT(\"MaxObjectsNotConsideredByGC\"), IntValueReceived, GEngineIni ); ClientMessage(\"MaxObjectsNotConsideredByGC\"); ClientMessage(FString::FromInt(IntValueReceived)); //Retrieve Near Clip Plane (how close things can get to camera) float floatValueReceived = 0; GConfig->GetFloat( TEXT(\"/Script/Engine.Engine\"), TEXT(\"NearClipPlane\"), floatValueReceived, GEngineIni ); ClientMessage(\"NearClipPlane\"); ClientMessage(FString::SanitizeFloat(floatValueReceived)); }\n\n//write to existing Game.ini //the results get stored in YourGameDir\\Saved\\Config\\Windows void AVictoryController::VictoryConfigSetTests() { if(!GConfig) return; //~~ //New Section to Add FString VictorySection = \"Victory.Core\"; //String GConfig->SetString ( *VictorySection, TEXT(\"RootDir\"), TEXT(\"E:\\UE4\\IsAwesome\"), GGameIni ); //FColor GConfig->SetColor ( *VictorySection, TEXT(\"Red\"), FColor(255,0,0,255), GGameIni ); //FVector GConfig->SetVector ( *VictorySection, TEXT(\"PlayerStartLocation\"), FVector(0,0,512), GGameIni ); //FRotator GConfig->SetRotator ( *VictorySection, TEXT(\"SunRotation\"), FRotator(-90,0,0), GGameIni ); //ConfigCacheIni.h //void Flush( bool Read, const FString& Filename=TEXT(\"\") ); GConfig->Flush(false,GGameIni); }\n\nThis line is very important\n\nSometimes the config file wont save changes if you don't call this function after you've set all your config keys.\n\nMany thanks to Solid Snake for telling me about this, I might have spent an hour or two trying to figure out why my config file was only saving sometimes!\n\nNow you know how to retrieve or edit any config file you want!\n\nAnd you can even add new sections to existing config files!"
    },
    {
        "link": "https://unrealcommunity.wiki/config-files-read-and-write-to-config-files-zuoaht01",
        "document": ""
    },
    {
        "link": "https://unrealcode.net/UsingReflection.html",
        "document": "Reflection is the ability to inspect C++ classes and objects at runtime and gather information about their data types and properties. Normally C++ does not maintain programmer-accessible information about, say, what members a struct or class has. Unreal Engine uses macros such as UCLASS and UPROPERTY to create information about classes, structs, methods, properties, and to make that information available to C++ at runtime.\n\nThis enables a program to introspect an object and find out, for example, what properties that object has, what the types of those properties are, and given an instance of that object, what the values of those properties are.\n\nThe notes here were made in the course of creating a plugin which checks a project configuration against a known-good collection of configuration settings, for example to check that all the settings required for hardware raytracing have their correct values, and have to options to display and change the current settings, as shown here:\n\nThis plugin needs to:\n‚Ä¢ identify Unreal Engine classes which are used for project settings\n‚Ä¢ retrieve the current values of those properties\n‚Ä¢ change the current values of those properties\n\nThe classes which Unreal Engine uses for project settings cannot be hard-coded because they depend on which plugins the user has loaded; so reflection is a good way of retrieving the required information.\n\nUnreal Engine uses macros which are embedded in the c++ class declarations to create reflection data.\n\nA class defined using the UCLASS macro like the one below will have reflection data:\n\nThe UCLASS macro has many parameters which control how Unreal Engine treats the class, for example whether it can be accessed using Blueprints. The parameters are defined in https://docs.unrealengine.com. At runtime these parameters can be retrieved from using a c++ API.\n\nOther c++ objects such as enum declarations, functions and properties have corresponding macros (namely UENUM, UFUNCTION and UPROPERTY) which are used in a similar way as the UCLASS macro.\n\nThe entry point for reflection data is using iterators. To iterate over the reflection data for all classes which are derived from UObject you use this:\n\nTo limit the search to classes which are derived from a base class such as UDeveloperSettings you do this:\n\nHaving obtained a UClass* using an iterator as described above, you can do various useful things including:\n\nFrom a UClass* you can retrieve information about the properties, also using a iterator like so:\n\nSimilar to dealing with a property, you can call various functions on a property:\n\nYou can retrieve elements of the UPROPERTY declaration. For example given this property declaration:\n\nyou can test if the property is a config property declared with UPROPERTY(config) like this:\n\nand retrieve variables from the metadata like this:\n\nThe type of a property can be retrieved by either:\n‚Ä¢ calling to return the type as a string, or\n‚Ä¢ testing it by casting like so:\n\nLooking at the Unreal Engine source code casting seems to be the preferred way.\n\nThe code examples above deal with the static reflection data for properties and classes. They do not need a specific instance of a class object to access that data, it is accessed from static instances such as .\n\nTo extract a property value from an actual instance of a class requires retrieving the memory address where that property value is stored. Given an instance of a class and a property pointer retrieved as shown above, we can do this to find the memory address where the property is stored:\n\nwe can then cast the property pointer to its derived property class and retrieve the property value using the data address:\n\nSome types of property require more work, for instance numeric properties can be different types, as shown here:\n\nEnum properties have functions for getting a string representation derived from the enum value, like so:\n\nFor an enum declared like this:\n\nwith a property value of the GetSignedIntPropertyValue() call will return 1 and the GetAuthoredNameStringByValue(1) call will return the string \"DefaultGraphicsRHI_DX11\".\n\nThe process of writing property values is much the same as reading them, firstly we need to get the address where the data is stored like so:\n\nAgain we cast the property pointer to see what type it is and set the value using the address:\n\nEach type of property has different methods for setting it. For example setting an enum property from a string value involves calling GetIndexByNameString() to get the int representation of that string:\n\nPlease leave any feedback about this article here"
    },
    {
        "link": "https://forums.unrealengine.com/t/unreal-property-system-some-questions/348258",
        "document": "Reflection is the ability of a program to examine itself at runtime. This is hugely useful and is a foundational technology of the Unreal engine, powering many systems such as detail panels in the editor, serialization, garbage collection, network..."
    },
    {
        "link": "https://dev.epicgames.com/documentation/en-us/unreal-engine/reflection-system-in-unreal-engine",
        "document": "The Unreal Engine Reflection System encapsulates your classes with various macros that provide engine and editor functionality. When programming with Unreal Engine(UE), it is possible to have standard C++ classes, functions, and variables.\n‚Ä¢ The base class for objects in Unreal is UObject. Each class defines a template for a new Actor or Object.\n‚Ä¢ You can use the macro to tag classes derived from so that the UObject handling system is aware of them.\n‚Ä¢ TSubclassOf is a template class that provides type safety. It is useful for assigning classes that derive from a specific type. For example, you may expose this variable to Blueprint where a designer can assign which weapon class is spawned for a Player Character.\n‚Ä¢ Classes can contain structs. Structs are data structures that help with the organization and manipulation of their related member properties. Structs can be defined on their own using the macro.\n‚Ä¢ The Unreal Smart Pointer Library is a custom implementation of C++11 smart pointers designed to ease the burden of memory allocation and tracking. This implementation includes the industry standard Shared Pointers, Weak Pointers, Unique Pointers, and Shared References which act like non-nullable Shared Pointers.\n‚Ä¢ Interfaces provide functions and additional gameplay behavior you can implement in multiple or different classes. Your player character can interact with a variety of Actors in the world. Each of these interactions can cause a different reaction to an event.\n‚Ä¢ Metadata Specifiers control how classes, interfaces, structs, enums, functions, or properties interact with various aspects of the engine and editor. Each type of data structure or member has its own list of Metadata Specifiers.\n‚Ä¢ UFUNCTION, and UPROPERTY macros make UE aware of new classes, functions, and variables. These macros are garbage collected by the engine. When specifying macros, you can edit and display them within the Unreal Editor."
    },
    {
        "link": "https://forums.unrealengine.com/t/is-using-reflection-unreal-property-system-bad/380484",
        "document": "Hello all! Hello Unreal devs!\n\nI very love to use meta-programming in different languages.\n\nBut my colleague says me:\n\nI like use something tools in such as or to get is implemented if I use them in something.\n\nSo, situation: base logics can be used in C++ and secondary logics (for game designers used in child blueprint). However I need to take control for something realisation of logics in blueprint from C++. Is it good practice? What you think about that?\n\nI see, the UE4 is fully metaprogrammed engine (Code generation, reflection, macros). And I think thats great! But what about game logics? Is good to use reflection in game mechanics?"
    },
    {
        "link": "https://forums.unrealengine.com/t/using-uproperty-reflection-system-to-create-data-driven-events/33201",
        "document": "OnPropertyChanged or similiar, does it exist?\n\nIs there a way to detect when changes have been made to an object in the editor? Like a virtual function named ‚ÄúOnPropertyChanged‚Äù or something like that. I‚Äôm sure it exists, just can‚Äôt find it. Edit: So I happened to find something called..."
    },
    {
        "link": "https://forums.unrealengine.com/t/how-to-add-custom-settings-in-project-settings/146330",
        "document": "In this post we're going to see how to create a game module for Unreal Engine 4. Imagine that modules are containers for a collection of related classes. After you're done with this tutorial you can read more about the pros and cons of multiple..."
    },
    {
        "link": "https://reddit.com/r/unrealengine/comments/18ty536/unreal_engine_perforce_avoid_multiple_users",
        "document": "Hi all, our UE perforce users are using custom python paths (not everyone uses same paths) and also altering the AA settings on the project per user (which also alters the defaultengine.ini). Is there a way to avoid the users syncing their ini files inside config folder back to the depot? Like i'd like them to be able to DL from the depot if they choose to sync for latest updates, but i don't want them putting altered config folder INIs back on depot. I can outright block it on perforce admin, but then it throws errors on the submit and doens't go through. I kind of want to treat it like a p4ignore function, where even if a file gets updates and submitted, it just ignores it and keeps the original on the server the same, instead of updating, but allows the submit to go through? Hopefully that makes sense. Any tips appreciated."
    },
    {
        "link": "https://forums.unrealengine.com/t/plugin-configs/683565",
        "document": "This page shows it should be possible to add Configs to each plugin. So if I have a plugin named MyPlugin I tried creating a file under Config/DefaultMyPlugin.ini However none of the settings set in there seem to take effect. I‚Äôm not sure this is completely right or working.\n\nI use GConfig which is a FConfigCacheIni (FConfigCacheIni | Unreal Engine Documentation) It saves the config in the users project rather than the plugin folder - I thought that was more in line with UE - it‚Äôs easy enough to create ‚ÄúImport from another project‚Äù features. Then it‚Äôs this easy to set something:\n\nThis is my own plugin that I‚Äôm building in C++ and I‚Äôm trying to figure out how to make my plugin come with its own default config so you don‚Äôt have to remember to add these configs to the game every time you add it. Ideally I‚Äôd want this to be the default setting unless it‚Äôs overridden by the game. Otherwise the plugin isn‚Äôt just, Drop in and Plug and Play. You have to add all these additional cumbersome steps like, ‚ÄúDon‚Äôt forget to copy paste this into your DefaultGame.ini‚Äù Also this is a plugin that lives in the game‚Äôs Plugins folder. It could potentially be in the engine plugins, but for this I‚Äôm choosing to make it live with the game. I actually figured out how to work with unreal plugins and C++ pretty well, but am struggling with this config issue.\n\nI was having this issue with Gameplay Tags and ended up defining all the gameplay tags in a table asset and have to add the file in the project settings. I found that I could add code into the module startup to add an ini file to the tags search path. However, I ran into an issue where if my plugin loaded the configs at plugin load time the gameplay tags were loaded too late for some things the engine required. It sounds like RecourseDesign‚Äôs code might work too.\n\nThanks. Yeah in my case I tried a bunch of things. In my particular scenario I couldn‚Äôt load the config file with , but since i know where that file is in relation to my plugin‚Äôs base directory, i was able to do: Then using RecourseDesign‚Äôs suggestion to access my sections and strings within that section. I also did this in my plugin‚Äôs function\n\nI had the same issue with the platform traits and Common UI. The way I fixed it was to set my module‚Äôs load phase to pre default: The reason why that works is because is set to load in the default phase: So by forcing our plugin to load earlier, the game tags are available by the time CommonUI (or whatever plugin might use your tags/config) loads. Of course that only works if your target plugin does load after the PreDefault phase. If you don‚Äôt that, the load order isn‚Äôt guaranteed and your tags might not be available."
    },
    {
        "link": "https://forums.unrealengine.com/t/server-client-whats-the-proper-way-to-synchronize-movement/414212",
        "document": "Hello, I've recently finished my first good-looking version of moving my Pawn(simple plane) around. This resulted in moving and rotating(with quaternions) my rootcomponent, and locally rotating some subobjects of my pawn. Now I want to take all..."
    },
    {
        "link": "https://tomlooman.com/unreal-engine-developer-settings",
        "document": "You might be placing all your settings and tweakable options in Blueprints or even hard-coded in C++. Unreal Engine does have the option to easily add more configuration settings in the INI config file system using the Developer Settings class. You are probably familiar with the existence of these configuration INI files already. DefaultGame.ini, DefaultEngine.ini, etc. are built using this class and the Unreal Editor‚Äôs Project Settings and Editor Settings use this system.\n\nThis system requires some (basic) C++ to define the variables, so even without programming experience, it‚Äôs relatively easy to use.\n\nBy deriving a new C++ class from UDeveloperSettings you can easily add your own. The [CategoryName] will be your Project + ClassName: [/Script/ActionRoguelike.SaveGameSettings] in the case of my open-source Action Roguelike GitHub project.\n\nConfiguration Files use key-value pairs Key=Value and support file paths and even arrays. We‚Äôll be filling an FString and asset path to assign a DataTable via the INI file.\n\nBelow you‚Äôll find an example from the sample project, make sure you expose it to the editor as well (EditAnywhere) so it shows up in your Project Settings automatically (see screenshot below).\n‚Ä¢ Config ‚Äì Exposes the variable to the INI file specified in the UCLASS in the top (Game = DefaultGame.ini)\n‚Ä¢ EditAnywhere ‚Äì Exposes it to the Project Settings window.\n‚Ä¢ BlueprintReadOnly ‚Äì Exposes variables to be accessed in Blueprint Graph via the ‚ÄúGetClassDefaults‚Äù node.\n‚Ä¢ defaultconfig ‚Äì ‚ÄúSave object config only to Default INIs, never to local INIs.‚Äù (local INIs are in your MyProject/Saved/Config/‚Ä¶ folder)\n\nTo access the developer settings in C++ we use the CDO (Class Default Object) as that is already automatically instanced for us and accessed using GetDefault<T>();\n\nWe can‚Äôt store direct pointers to content files, but we can use soft asset paths and resolve them in code once we need them. Make sure you actually load in the asset manually as otherwise it may or may not sit in memory yet (eg. when you already opened the asset once in your current editor session).\n\nThe neat thing about configuration files is that the values are stored as plain text and not compiled to binary, unlike C++ and Blueprint. They can be changed easily even after you already packaged your game.\n\nGetting read-only access to the configuration settings is very easy using the GetClassDefaults node. Make sure you mark your variables BlueprintReadOnly for them to show up.\n\nIf you want to store player configurable settings there is a different class available: GameUserSettings. This class already includes a bunch of settings including graphical options. Here you might want to add mouse sensitivity, FOV, etc.\n\nThis new class lets us bind console variables to project settings and easily change and store defaults either per developer or project-wide. In practice this means we can define default values in the INI files and at runtime change them using console variables.\n\nAn example of this can be found in the Lyra Starter Game which was released with UE5.0. The LyraWeaponsDebugSettings has several properties for debugging trace hits. By using DeveloperSettingsBackedByCVars and the ConsoleVariable meta-specifier you can bind the variables together.\n\nThe Console Variable is still defined elsewhere. In the example, you can find the CVar inside LyraGameplayAbility_RangedWeapon.cpp:\n\nThen access the CVar by using the Namespace and the static float, not the variable in the Settings file.\n\nFrom testing this out in the Action Roguelike project, it‚Äôs important to manually apply the CVARs from INI during with the example below or check out the RogueDeveloperSettings.\n\nThis new addition can be quite nice to easily set defaults in your project settings that are either per-user or per project. The shown example specifies to have this stored per developer.\n\nFor more details and examples we‚Äôre using Developer Settings to configure a SaveGame system in my Unreal Engine C++ Pro Course. The project source is available to browse on GitHub. Make sure you check it out!\n\nFollow me on Twitter for more Unreal-related content or have a look at my other C++ Tutorials and tricks such as an easy way to Auto-detect optimal graphics settings."
    }
]