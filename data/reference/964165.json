[
    {
        "link": "https://docs.ton.org/v3/guidelines/dapps/tutorials/nft-minting-guide",
        "document": "Non-fungible tokens (NFTs) have become one of the hottest topics in the world of digital art and collectibles. NFTs are unique digital assets that use blockchain technology to verify ownership and authenticity. They have opened up new possibilities for creators and collectors to monetize and trade digital art, music, videos, and other forms of digital content. In recent years, the NFT market has exploded, with some high-profile sales reaching millions of dollars. In this article, we will build an NFT collection on TON step by step.\n\nThis is the beautiful collection of ducks you will create by the end of this tutorial:\n‚Ä¢ You will mint NFT collection on TON.\n‚Ä¢ You will understand how NFTs on TON works.\n‚Ä¢ You will put NFT on sale.\n‚Ä¢ You will upload metadata to pinata.cloud.\n\nYou must already have a testnet wallet with at least 2 TON in it. You can get testnet coins from @testgiver_ton_bot.\n\nWe will use Pinata as our IPFS storage system, so you also need to create an account on pinata.cloud and get api_key & api_secreat. Official Pinata documentation tutorial can help with that. Once you have these API tokens, I‚Äôll be waiting for you here!\n\nBefore starting the main part of our tutorial, we need to understand how NFTs work on TON in general terms. Unexpectedly, we will start with an explanation of how NFTs work on Ethereum (ETH), to understand the uniqueness of NFT implementation on TON compared to other blockchains in the industry.\n\nThe implementation of the NFT in ETH is extremely simple - there is 1 main contract of the collection, which stores a simple hashmap, which in turn stores the data of the NFT from this collection. All requests related to this collection (if any user wants to transfer the NFT, put it up for sale, etc.) are sent specifically to this single contract of the collection.\n\nThe problems of such an implementation in the context of TON are perfectly described by the NFT standard in TON:\n‚Ä¢ Unpredictable gas consumption. In TON, gas consumption for dictionary operations depends on exact set of keys. Also, TON is an asynchronous blockchain. This means that if you send a message to a smart contract, then you do not know how many messages from other users will reach the smart contract before your message. Thus, you do not know what the size of the dictionary will be at the moment when your message reaches the smart contract. This is OK with a simple wallet -> NFT smart contract interaction, but not acceptable with smart contract chains, e.g. wallet -> NFT smart contract -> auction -> NFT smart contract. If we cannot predict gas consumption, then a situation may occur like that the owner has changed on the NFT smart contract, but there were no enough Toncoins for the auction operation. Using smart contracts without dictionaries gives deterministic gas consumption.\n‚Ä¢ Does not scale (becomes a bottleneck). Scaling in TON is based on the concept of sharding, i.e. automatic partitioning of the network into shardchains under load. The single big smart contract of the popular NFT contradicts this concept. In this case, many transactions will refer to one single smart contract. The TON architecture provides for sharded smart contracts(see whitepaper), but at the moment they are not implemented.\n\nTL;DR ETH solution it's not scalable and not suitable for asynchronous blockchain like TON.\n\nOn TON, we have on master contract - smart contract of our collection, that store it's metadata and address of it's owner and the main thing - that if we want to create(\"mint\") new NFT Item - we just need to send message to this collection contract. This collection contract will then deploy a new NFT item contract for us, using the data we provide.\n‚Ä¢ Add script to build & start our app to\n‚Ä¢ Create file and add your own data based on this template\n\nYou can get toncenter api key from @tonapibot and choose mainnet or testnet. In variable store 24 words of collection owner wallet seed phrase.\n\nGreat! Now we are ready to start writing code for our project.\n\nFirstly let's create function in , that will open our wallet by mnemonic and return publicKey/secretKey of it.\n\nWe get a pair of keys based on 24 words(seed phrase):\n\nNice, after that we will create main entrypoint for our project - . Here will use just created function and call our main function . Thats enough for now.\n\nAnd by the end, let's create file in directory, in which we will create function to wait until increases.\n\nMetadata - is just a simple information that will describe our NFT or collection. For example it's name, it's description, etc.\n\nFirstly, we need to store images of our NFT's in with name , , ... for photo of items, and for avatar of our collection. You can easily download pack with ducks images or put your images into that folder. And also we will store all our metadata files in folder.\n\nMost products on TON supports such metatadata specifications to store information about NFT collection:\n\nBased on this info, let's create our own metadata file , that will describe the metadata of our collection!\n\nNote that we didn't write the \"image\" parameter, you will know why a bit later, just wait!\n\nAfter creation of collection metadata file we need to create metadata of our NFT's\n\nAfter that, you can create as many files of NFT item with their metadata as you want.\n\nNow let's write some code, that will upload our metadata files to IPFS. Create file in directory and add all needed imports:\n\nAfter that, we need to create function, that will actually upload all files from our folder to IPFS:\n\nExcellent! Let's return to the question at hand: why did we leave the \"image\" field in the metadata files empty? Imagine a situation where you want to create 1000 NFTs in your collection and, accordingly, you have to manually go through each item and manually insert a link to your picture. This is really inconvenient and wrong, so let's write a function that will do this automatically!\n\nHere we firstly read all of the files in specified folder:\n\nIterate over each file and get its content\n\nAfter that, we assign the value to the image field if it's not last file in the folder, otherwise and actually rewrite our file with new data.\n\nGreat, let's call this methods in our app.ts file. Add imports of our functions:\n\nSave variables with path to the metadata/images folder and call our functions to upload metadata.\n\nAfter that you can run and see link to your deployed metadata!\n\nHow will link to our metadata files stored in smart contract? This question can be fully answered by the Token Data Standart. In some cases, it will not be enough to simply provide the desired flag and provide the link as ASCII characters, which is why let's consider an option in which it will be necessary to split our link into several parts using the snake format.\n\nFirstly create function in , that will convert our buffer into chunks:\n\nAnd create function, that will bind all the chunks into 1 snake-cell:\n\nFinally, we need to create function that will encode offchain content into cell using this functions:\n\nWhen our metadata is ready and already uploaded to IPFS, we can start with deploying our collection!\n\nWe will create file, that will store all logic related to our collection in file. As always will start with imports:\n\nAnd declare type wich will describe init data that we need for our collection:\n\nFirstly let's write private method, that will return cell with code of our collection.\n\nIn this code, we just read Cell from base64 representation of collection smart contract.\n\nOkey, remained only cell with init data of our collection. Basicly, we just need to store data from collectionData in correct way. Firstly we need to create an empty cell and store there collection owner address and index of next item that will be minted. Let's write next private method:\n\nNext after that, we creating an empty cell that will store content of our collection, and after that store ref to the cell with encoded content of our collection. And right after that store ref to contentCell in our main data cell.\n\nAfter that we just create cell of code of NFT item's, that will be created in our collection, and store ref to this cell in dataCell\n\nRoyalty params stored in smart contract by royaltyFactor, royaltyBase, royaltyAddress. Percentage of royalty can be calculated with the formula . So if we know royaltyPercent it's not a problem to get royaltyFactor.\n\nAfter our calculations we need to store royalty data in separate cell and provide ref to this cell in dataCell.\n\nNow let's actually write getter, that will return StateInit of our collection:\n\nAnd getter, that will calculate Address of our collection(address of smart contract in TON is just hash of it's StateInit)\n\nIt remains only to write method, that will deploy the smart contract to the blockchain!\n\nDeploy of new smart contract in our case - it's just sending a message from our wallet to the collection address(which one we can calculate if we have StateInit), with its StateInit!\n\nWhen owner mint a new NFT, the collection accepts the owner's message and sends a new message to the created NFT smart contract(which requires paying a fee), so let's write a method that will replenish the balance of the collection based on the number of nfts for a mint:\n\nPerfect, let's now add few include to our :\n\nAnd add few lines to the end of function to deploy new collection:\n\nWhen our collection is ready, we can start minting our NFT! We will store code in\n\nUnexpectedly, but now we need to go back to the . And add this type near to at the top of the file.\n\nAnd create method in NftCollection class, that will construct body for the deploy of our NFT Item. Firstly store bit, that will indicate to collection smart contract that we want to create new NFT. After that just store queryId & index of this NFT Item.\n\nLater on create an empty cell and store owner address of this NFT:\n\nAnd store ref in this cell(with NFT Item content) ref to the metadata of this item:\n\nStore ref to cell with item content in our body cell:\n\nGreat! Now we can comeback to . All we have to do is just send message to our collection contract with body of our NFT.\n\nBy the end, we will write short method, that will get address of NFT by it's index.\n\nStart with creation of client variable, that will help us to call get-method of collection.\n\nThen we will call get-method of collection, that will return address of NFT in this collection with such index\n\nNow let's add some code in , to automate the minting process of each NFT:\n\nFirstly read all of the files in folder with our metadata:\n\nSecondly top up balance of our collection:\n\nEventually, go through each file with metadata, create instance and call deploy method. After that we need to wait a bit, until the seqno increases:\n\nIn order to put the nft for sale, we need two smart contracts.\n‚Ä¢ Marketplace, which is responsible only for logic of creating new sales\n‚Ä¢ Sale contract, which is responsible for the logic of buying/cancelling a sale\n\nCreate new file in . As usual create basic class, which will accept address of owner of this marketplace and create cell with code(we will use basic version of NFT-Marketplace smart contract) of this smart contract & initial data.\n\nAnd let's create method, that will calculate address of our smart contract based on StateInit:\n\nAfter that we need to create method, that will deploy our marketplace actually:\n\nAs you can see, this code does not differ from the deployment of other smart contracts (nft-item smart contract, from the deployment of a new collection). The only thing is that you can see that we initially replenish our marketplace not by 0.05 TON, but by 0.5. What is the reason for this? When a new smart sales contract is deployed, the marketplace accepts the request, processes it, and sends a message to the new contract (yes, the situation is similar to the situation with the NFT collection). Which is why we need a little extra tone to pay fees.\n\nBy the end, let's add few lines of code to our file, to deploy our marketplace:\n\nGreat! Right now we can already deploy smart contract of our NFT sale. How it will works? We need to deploy new contract, and after that \"transfer\" our nft to sale contract(in other words, we just need to change owner of our NFT to sale contract in item data). In this tutorial we will use nft-fixprice-sale-v2 sale smart contract.\n\nCreate new file in . First of all let's declare new type, that will describe data of our sale smart contract:\n\nAnd now let's create class, and basic method, that will create init data cell for our smart contract.\n\nWe will begin with creation of cell with the fees information. We need to store address that will receive fee's for marketplace, amount of TON to send to the marketplace as fee. Store address that will receive royalty from the sell and royalty amount.\n\nFollowing that we can create an empty cell and just store in it information from saleData in correct order and right after that store ref to the cell with the fees information:\n\nAnd as always add methods to get stateInit, init code cell and address of our smart contract.\n\nIt remains only to form a message that we will send to our marketplace to deploy sale contract and actually send this message\n\nFirstly, we will create an cell, that will store StateInit of our new sale contract\n\nCreate cell with the body for our message. Firstly we need to set op-code to 1(to indicate marketplace, that we want to deploy new sale smart contract). After that we need to store coins, that will be sent to our new sale smart contract. And last of all we need to store 2 ref to stateInit of new smart contract, and a body, that will be sent to this new smart contract.\n\nAnd at the end let's send our message:\n\nPerfect, when sale smart contract is deployed all that's left is to change owner of our NFT Item to address of this sale.\n\nWhat does it mean to transfer an item? Simply send a message from the owner's wallet to the smart contract with information about who the new owner of the item is.\n\nGo to and create new static method in NftItem class, that will create body for such message:\n\nJust create an empty cell and fill the data.\n\nIn addition to the op-code, query-id and address of the new owner, we must also store the address where to send a response with confirmation of a successful transfer and the rest of the incoming message coins. The amount of TON that will come to the new owner and whether he will receive a text payload.\n\nAnd create a transfer function to transfer the NFT.\n\nNice, now we can we are already very close to the end. Back to the and let's get address of our nft, that we want to put on sale:\n\nCreate variable, that will store information about our sale.\n\nAdd to the beggining of the :\n\nNote, that we set to null, because if we will do so, our sale contract would just accept our coins on deploy.\n\nNow we can launch our project and enjoy the process!\n\nGo to https://testnet.getgems.io/collection/{YOUR_COLLECTION_ADDRESS_HERE} and look to this perfect ducks!\n\nToday you have learned a lot of new things about TON and even created your own beautiful NFT collection in the testnet! If you still have any questions or have noticed an error - feel free to write to the author - @coalus"
    },
    {
        "link": "https://docs.ton.org/v3/documentation/smart-contracts/func/overview",
        "document": "FunC, a high-level language, is used to program smart contracts on TON.\n\nFunC is a domain-specific, C-like, statically typed language. Here is a simple example of a method for sending money written in FunC:\n\nFunC programs are compiled into Fift assembler code, which generates the corresponding bytecode for the TON Virtual Machine.\n\nhis bytecode (essentially a tree of cells, like any other data in the TON Blockchain) can then be used to create smart contracts on the blockchain or can be run on a local instance of the TVM.\n\nThe most convenient and quickest way to begin developing and compiling smart contracts is by using the Blueprint framework. Read more in the Blueprint section.\n\nIf you want to use the native TON compiler, FunC, locally, you need to set up the binaries on your machine. FunC compiler binaries for Windows, macOS (Intel/M1), and Ubuntu can be downloaded from:\n\nThe TON Blockchain Course is a comprehensive guide to TON Blockchain development.\n\nAdditional materials graciously provided by experts from the community:\n‚Ä¢ üö© Challenge 5: Create UI to interact with the contract in 5 minutes\n‚Ä¢ TON Hello World: Step-by-step guide for writing your first smart contract\n‚Ä¢ TON Hello World: Step by step guide for testing your first smart contract\n‚Ä¢ FunC Quiz by Vadim‚ÄîGood for selfcheck. It will take 10‚Äì15 minutes. The questions are mainly about Fun–° with a few general questions about TON\n\nParticipating in contests is a great way to learn FunC.\n\nYou can also study previous competitions for learning purposes.\n\nStandard basic smart contracts, like wallets, electors (which manage validation on TON), multi-signature wallets, etc., can serve as references when studying."
    },
    {
        "link": "https://docs.ton.org/v3/documentation/ton-documentation",
        "document": "Welcome to the official TON Blockchain development documentation!\n\nThis resource aims to provide all the necessary information you'll need to build, test, and deploy applications on the TON Blockchain.\n\nThis is a collaborative, open-source initiative, and contributions are always welcome. All documentation can be edited via GitHub ‚Äî follow these instructions.\n‚Ä¢ TON Hello World series provides detailed step-by-step guides to wallets, smart contracts, mini apps, and testing & debugging smart contracts on TON.\n‚Ä¢ Get Started with TON is a step-by-step guide to interacting with TON Blockchain. (video tutorial included)\n\nThis course introduces blockchain basics, with a special focus on practical skills in the TON ecosystem. You will understand how blockchain functions and its diverse applications.\n\nWe're proud to present the TON Blockchain Course, which is a comprehensive guide to the TON Blockchain. The course is designed for developers who want to learn how to create smart contracts and decentralized applications on the TON Blockchain in engaging and interactive ways.\n\nIt consists of 9 modules and covers the basics of the TON Blockchain, the FunC programming language, and the TON Virtual Machine (TVM).\n\nIf you're new to TON Blockchain development, it's recommended that you start from the beginning and work your way through these topics.\n‚Ä¢ Transactions and Phases - A detailed explanation of transactions and phases.\n‚Ä¢ Run a Full Node - A detailed explanation of how to run a node.\n\nSmart contracts are the building blocks of decentralized applications (DApps) on TON Blockchain. If you're looking to develop your own dApps, it's essential to understand how smart contracts work.\n\nThe following resources provide valuable information for TON smart contract development:\n‚Ä¢ TON Hello World: Step-by-step guide for writing your first smart contract - An accessible and concise explanation of the fundamentals with JS.\n‚Ä¢ How to work with wallet smart contracts - Detailed and careful explanations of smart contract basics with the use of JS and GO.\n\nDecentralized applications (DApps) are applications that run on a peer-to-peer network of computers rather than a single computer (TON Blockchain). They are similar to traditional web applications, but they are built on top of a blockchain network. This means that DApps are decentralized, meaning that no single entity controls them.\n\nTake your first steps in DApps development with a comprehensive DApps building guide:\n‚Ä¢ TON Hello World: Step by step guide for building your first web client\n\nGo to the Frequently Asked Questions section."
    },
    {
        "link": "https://docs.ton.org/v3/guidelines/get-started-with-ton",
        "document": "Set up your first application on TON Blockchain from scratch and discover its speed, reliability, and essential concepts of asynchronous thinking.\n\nThis learning path contains 5 modules and should take you around 45 minutes.\n\nIn this tutorial, you'll learn how to easily make blockchain transactions using JavaScript. While you could learn to do it without this tutorial, this approach is convenient and user-friendly.\n‚Ä¢ You will make your own TON Wallet with Tonkeeper\n‚Ä¢ You will use a Testnet faucet to top up your wallet for testing.\n‚Ä¢ You will understand essential concepts of TON smart contracts (Addresses, Cells)\n‚Ä¢ You will learn how to interact with TON using TypeScript SDK and API provider\n‚Ä¢ You will compile your first transaction using NFT Miner console application\n\nYou're going to mine an NFT rocket achievement!!!\n\nAs the first miners on TON, you will go through the Proof-of-Work smart contract and finally mine a secret reward for your TON wallet. Check it out:\n\nOur goal for today is to mine an NFT! This achievement will stay with you forever.\n\nFinally, you are able to mine this NFT achievement even in mainnet. (it costs only 0,05 TON!).\n\nFor a smoother walkthrough, check out this carefully crafted video tutorial by Vladimir Alefman.\n\nToday, we are going to teach our prospective builders how to mine on TON Blockchain. This experience will allow all of you to understand the significance of mining and why Bitcoin mining helped revolutionize the industry.\n\nAlthough the PoW Giver smart contract framework, which defined the initial mining process that laid the foundation for TON, was completed at launch, the last TON was mined in June 2022 to conclude TON‚Äôs Proof of Work (PoW) token distribution mechanism. That said, with our recent transition to Proof of Stake (PoS), the era of staking on TON has just begun.\n‚Ä¢ Dive deeper into our economic model and mining on TON\n\nNow, let‚Äôs focus on the first steps to becoming a TON Developer and learn how to mine an NFT on TON! Below is an example of what we're aiming to create.\n\nIt‚Äôs possible to create a miner in about half an hour if we keep focused on the task at hand.\n\nTo get started, all developers will make use of the following components:\n‚Ä¢ Wallet: You need a non-custodial wallet to store an NFT in Testnet mode.\n‚Ä¢ Repository: We‚Äôll use a ready-made template designed specifically for you.\n‚Ä¢ Developer Environment: Developers will need to determine whether they want to mine using a local or cloud environment.\n\nTo start, you‚Äôll need a non-custodial wallet that allows you to receive and store your TON. For this guide, we are using Tonkeeper. You‚Äôll need to enable Testnet mode within the wallet to be able to receive Testnet Toncoins. These tokens will be used later on to send a final minting transaction to the smart contract.\n\nTo download and create a TON wallet follow these simple steps:\n‚Ä¢ Install the Tonkeeper app on your smartphone. It can be downloaded here.\n‚Ä¢ Next, you‚Äôll need to enable test mode within Tonkeeper.\n\nEasy! Let's go to the development now.\n\nTo make your life easier and skip routine low-level tasks, we will use a boilerplate.\n\nPlease use the ton-onboarding-challenge template to create your project by clicking the ‚ÄúUse this template‚Äù button and selecting the ‚ÄúCreate a new repository‚Äù tab as shown below:\n\nAfter completing this step, you‚Äôll have access to a highly performant repository that can serve as your miner's core. Congratulations! ‚ú®\n\nThe next step is to choose which developer environment is best suited to your needs, experience level, and overall skill-set. As you can see, it is possible to carry out this process by using either a cloud-based or local environment. Developing on the cloud is often considered simpler and easier to get started. Below, we‚Äôll outline the steps required for both approaches.\n‚Ä¢ For users unfamiliar with JavaScript, it can be challenging to use a JavaScript IDE, especially if your computer and tooling systems are not configured for this purpose.\n‚Ä¢ However, if you're familiar with NodeJS and Git and know how to work with , you may find it more comfortable to use a local environment.\n\nIf you choose the cloud development environment it's easy to get started by first selecting the Code tab and then by clicking on the Create codespace on master button within the GitHub repository like shown below:\n\nAfter completing this step, GitHub will create a special cloud workspace that allows you to access the VSCode Online IDE (Visual Studio Code Online Integrated Development Environment).\n\nOnce access is granted (the codespace typically starts in about 30 seconds), you'll have everything required to begin without the need to install Git, Node.js, or other developer tools.\n\nTo set up a local development environment, you'll require access to these three essential tools:\n‚Ä¢ Git: Git is an essential tool that every developer needs to work with repositories. It can be downloaded here.\n‚Ä¢ NodeJS: Node.js is the JavaScript and TypeScript runtime environment typically used for application development on TON. It can be downloaded here.\n‚Ä¢ JavaScript IDE. JavaScript IDE‚Äôs are typically used for development within local development environments. An example of this case is Visual Studio Code (VSCode).\n\nTo get started, you‚Äôll need to clone your GitHub repository boilerplate and open the correct repository in your Integrated Development Environment (IDE).\n\nIn this guide, you'll need to run TypeScript scripts. All commands, such as running scripts or installing modules, are executed through the command line, which is located in the IDE's Terminal workspace. This workspace is typically found at the bottom of the IDE.\n\nFor example, in the Cloud Codespaces, you should open the Terminal workspace (if it is not already open):\n\nEnter commands in this window and execute them with Enter:\n\nThe Terminal is also available as a separate application. Please choose the appropriate version based on your IDE and OS.\n\nGreat! After these steps you're ready to get deeper into TON Blockchain secrets. üëÄ\n\nOkay, what do you need to connect to TON Blockchain?\n‚Ä¢ Smart contract address as a point of destination. Our goal is to mine an NFT from the proof-of-work smart contract, so we need an address to get current mining complexity.\n‚Ä¢ API provider to make requests to TON Blockchain. TON has multiple API types for different purposes. We will use the testnet version of toncenter.com API.\n‚Ä¢ JavaScript SDK: A JavaScript SDK (recall that an SDK is a Software Development Kit) is needed to parse the smart contract address being used and prepare it to create an API request. To better understand TON addresses and why they need to be parsed to carry out this process, please see this resource to understand why should we parse it. To carry out this procedure, we'll use .\n\nIn the next section we‚Äôll describe how users send their initial requests to TON Blockchain using the TONCenter API and to receive data from the PoW smart contract.\n\nFor the miner to work correctly, we need to add two different smart contract address types. These include:\n‚Ä¢ Wallet address: A wallet address is required, because it is necessary for the miner to receive their mining reward (in this case, we must use the Tonkeeper Testnet mode).\n‚Ä¢ Collection address: A collection address is required to act as a smart contract to correctly mine an NFT (to carry out this process copy the NFT collection address, under the TON onboarding challenge collection name from the Getgems website).\n\nNext, we‚Äôll open the file in your miner and create a function composed of initial constants as follows:\n\nLater in the process of creating a TON NFT Miner, several requests will be executed to the public API to relay responses to the correct string of code in exchange for the desired instructions. By leveraging the async/await function, code simplicity is improved dramatically.\n\nOn TON, smart contract addresses come in different forms that employ the use of numerous flag types. In this context specifically, we‚Äôll make use of the user-friendly address form. That said, if you are curious to learn more about the different smart contract address types, feel free to check out this additional resource in our documentation.\n\nFor the miner to work correctly, we need to add two different smart contract address types. These include:\n\nThe method located in the SDK allows the developer to create an address object to convert addresses from one form to another in a simplified manner.\n\nIn this step, we'll connect with TON via TONCenter (which is hosted on toncenter.com) API provider using specific commands in the script.\n\nThe simplest way to do it is buy just specifying testnet endpoint .\n\nWe are adding and in the script using TonClient and testnet Toncenter endpoint :\n\nFinally, the next step in the process is to retrieve specific mining data from TON Blockchain.\n\nBy consulting the README file needed to complete the TON onboarding challenge, the latest TON mining data is obtained by running the method. Once initiated, the result will be as follows:\n\nAs a result we should receive an array with these fields:\n\nUsing it is possible to run the function. Running this code will result in the following console output:\n\nFurthermore, to run the script, it is necessary to enter the following command in the terminal:\n\nGood! As long as the above processes were executed correctly, successful connection to the API will be achieved and the necessary data will be displayed in the console. The correct console output should be initiated as follows:\n\nThe output above shows the data related to the execution of a process, with a collection of numerical (int) values. The current focus is to convert this numerical output into a format that is more practical for use.\n\nWe need to convert the hex output to something useful.\n\nNow, let's return to the tutorial!\n\nIn the section above where we discuss numerical (int) values needed to receive mining data. Before processing further received data must be converted into a more easily understandable and usable format.\n\nAs it is clear when examining the given output, numbers can be quite substantial in size. To deal with them we will use (the big number implementation in JavaScript). used to work with large numbers that are larger than the maximum integer values. Let‚Äôs use this example to get a better idea of the Mining Data required for this process:\n\nAs shown above, the different components of miningData use a stack-based numbers for different parameters (which will be introduced in the section below). To achieve the desired value outcome, we used function to read a from stack.\n\nAfter this process is complete, we may print values to the console. Try to run the script again by running the command:\n\nHere is an example output:\n\nLet's cover the Mining Data command that is used to translate different data parameters when programming mining data into TON Blockchain. These include:\n‚Ä¢ is the most important number for miners. It's a Proof-of-Work complexity for the values. You're successful if the final hash is less than complexity.\n‚Ä¢ is a unix timestamp date and time representation that keeps track of the last mining transaction on TON. Each time the last_success metric changes, it's necessary to run the miner again because the seed also changes during this process.\n‚Ä¢ denotes a unique value generated by a smart contract to calculate the desired hash. To better understand this process and learn more about how the seed changes and why, have a look at the project files folder by using the ctx_seed keyword (Ctrl+F with keyword \"ctx_seed\").\n‚Ä¢ , and won't be used in our tutorial. But you can always read more about how they are used in smart contracts to calculate proof-of-work complexity in the source files of the collection in your project.\n\nNow that we understand the different parameters discussed above, we have the values( , , ) which we will use in our NFT Miner in the next chapter.\n\nAfter connecting to TON and retrieving the necessary mining data from the blockchain to create an NFT Miner, let‚Äôs focus on the next steps in this process to achieve our goal.\n\nIn this chapter you will prepare a mining message and calculate a hash of the message. After that, you will find a hash that's less( ) than the complexity we got from the smart contract.\n\nThat is what a miner is! Simple, isn't it?\n\nFirst, we must prepare a mining message by ensuring the correct parameters to ensure the validity and data integrity of this process.\n\nThankfully, the README file allows us to retrieve the correct guidelines needed to achieve this goal. As you can see, the above README file comprises a table with certain fields and Cell types (titled ‚ÄúLayout of Proof of Work Cell‚Äô) to help achieve our desired result.\n\nFortunately, all the data structures used in this tutorial are already written in TypeScript. Use the object from NftGiver.data.ts to build a transaction with Queries:\n\nProbably, you have a question: where are the op and data2 from the table?\n‚Ä¢ In the table, the numerical value of data1 must be equal to that of data2. In order to omit filling the data2 value, the transaction builder performs a low-level process (see Queries.mine() sources).\n‚Ä¢ Because the classification is always constant, it is already implemented in transaction builder Queries and in OpCodes. You can find the op code by going to the source code of method.\n\nNow that we have completed the process to prepare messages for our TON miner, let‚Äôs jump into the initial process to actually create a miner. First, let‚Äôs consider this line of code:\n\nAbove we compiled a value. The idea of mining is to find a hash that will be less than from the last received get_mining_data(). We can increment as many times as we need.\n\nThe pure miner will continue to run indefinitely, as long as is bigger than (message hash is larger than PoW mining complexity).\n\nHere is an example of the code running as it relates to in TypeScript:\n\nWe convert hash from the to with function. This is done to use this hash in comparison with .\n\nThough the miner will work properly after the completion of the above steps, it will have a visually unappealing appearance (try ). Therefore, we must address this issue. Let‚Äôs jump in.\n\nWe want to make the miner look sexy now! How do we do it?\n\nJust follow me, my friend, follow me.\n\nTo achieve our goal, we‚Äôll add these commands:\n\nJust check it out! Let‚Äôs execute the command:\n\nAfter these commands are executed correctly, we‚Äôll have a visually appealing NFT miner. In the next section, we‚Äôll focus on connecting a wallet to the miner to create a payment channel that can accept and receive transactions from TON Blockchain.\n\nNext, we‚Äôll outline the steps to compile a message and send it to the blockchain with your Tonkeeper wallet. The upcoming steps will guide you in completing the process of mining an NFT on TON.\n\nTo proceed to the next step, we need to acquire some TON testnet tokens. This can be achieved by making use of the testnet faucet found here.\n\nIn order to ensure that the NFT mining process is carried out correctly, and that the user can store their NFT properly, we will use Blueprint to simultaneously interact with TON Blockchain and the Tonkeeper wallet.\n\nTo achieve this goal, we‚Äôll use standard function to run to the creation the transaction and send it:\n\nLet‚Äôs run the above script to send transaction:\n\nNote that we are using instead of . This is because we need to leverage advantages of blueprint (under the hood is called).\n\nAfter running this command answer to questions as shown below to connect your Tonkeeper wallet:\n\nScan the QR code shown in the terminal with your Tonkeeper wallet to establish a connection, no transaction will be sent yet. Once connected, confirm the transaction in Tonkeeper.\n\nDo you sense the experience in the air? That's you, on your way to becoming a TON developer.\n\nThere are two main ways to mine an NFT on TON:\n\nBelow are the steps needed to initiate your first Testnet transaction to mine your NFT:\n‚Ä¢ Input our testnet wallet address from Tonkeeper into variable in the\n‚Ä¢ Input address of the NFT collection from Testnet into variable in the\n\nIn order to successfully mine an NFT rocket on Testnet, it is necessary to follow these steps:\n‚Ä¢ Open the Tonkeeper wallet on your phone (it should hold some newly received TON Testnet tokens).\n‚Ä¢ Select scan mode in the wallet to scan the QR code.\n‚Ä¢ Run your miner to acquire the correct hash (this process takes between 30 and 60 seconds).\n‚Ä¢ Scan the generated QR code from the miner.\n‚Ä¢ Confirm the transaction in your Tonkeeper wallet.\n\nSoon after initiating this process, you will have successfully mined your very first NFT on TON (it should appear in your Tonkeeper wallet).\n\nWelcome aboard, a true TON Developer! You did it. üõ≥\n\nHey! For those who wish to mine an NFT on TON Mainnet, these instructions should be followed:\n‚Ä¢ You have activated mainnet mode in your Tonkeeper (it should hold at least 0.1 TON).\n‚Ä¢ Input our mainnet wallet address from Tonkeeper into variable in the\n‚Ä¢ Input address of the NFT collection from the Mainnet into variable in the\n\nLike we outlined in the testnet NFT rocket mining process, in order to successfully mine an NFT rocket on mainnet, it is necessary to follow these steps:\n‚Ä¢ Open the Tonkeeper wallet on your phone (remember, it should hold some TON tokens).\n‚Ä¢ Select scan mode in the wallet to scan the QR code.\n‚Ä¢ Run your miner to acquire the correct hash (this process takes between 30 and 60 seconds).\n‚Ä¢ Scan the generated QR code from the miner.\n‚Ä¢ Confirm the transaction in your Tonkeeper wallet.\n\nAfter some time, you will have mined your NFT and become a TON Developer in TON Blockchain. The ritual is complete. Look at your NFT in Tonkeeper.\n\nWelcome aboard, a TON Developer! You did it. üõ≥\n\nFirst, take a rest! You did a big task! You are a TON developer now. But it's only the beginning of the long way.\n\nAfter finishing the TON onboarding challenge where we successfully mined an NFT, consider taking a look at some of these materials that detail different portions of TON's Ecosystem:\n‚Ä¢ What is blockchain? What is a smart contract? What is gas?\n‚Ä¢ TON Hello World: Step-by-step guide for writing your first smart contract\n‚Ä¢ How to work with wallet smart contracts"
    },
    {
        "link": "https://pinata.cloud/blog/how-to-mint-an-nft-on-ton",
        "document": "How to Organize User-Generated Content On IPFS With Groups\n\nOne of the challenges of building apps is organizing data in an efficient and logical way. This has historically been even more difficult with IPFS. IPFS, as an immutable and peer-to-peer file storage protocol, leaves data organization to developers to handle. Fortunately, Pinata‚Äôs Groups feature makes this much simpler."
    },
    {
        "link": "https://docs.ton.org/v3/guidelines/smart-contracts/guidelines",
        "document": "This page navigates within the TON smart contracts guidelines.\n\nThe TON blockchain course is a comprehensive guide to blockchain development.\n‚Ä¢ Module 2 is dedicated to TVM, transactions, scalability and business cases."
    },
    {
        "link": "https://docs.ton.org/v3/documentation/smart-contracts/contracts-specs/examples",
        "document": "On this page, you can find TON smart contract references implemented for various program software.\n\nMake sure you have thoroughly tested contracts before using them in a production environment. This is a critical step to ensure the proper functioning and security of your software.\n\nIf you want to share a new example smart contract, make your PR for this page.\n‚Ä¢ How to work with wallet smart contracts"
    },
    {
        "link": "https://slowmist.medium.com/slowmist-best-practices-for-toncoin-smart-contract-security-df209eb19d08",
        "document": "TON (The Open Network) is a decentralized blockchain platform initially designed and developed by the Telegram team, which gained significant attention upon its launch. TON aims to offer a high-performance and scalable blockchain to support large-scale decentralized applications (DApps) and smart contracts. For a foundational understanding of TON, including accounts, tokens, transactions, and asset security, refer to the guide: *Introduction to TON*.\n\nWhat sets TON apart from other blockchains is its unique architecture. TON smart contracts are primarily programmed in the FunC language but can also be written in higher-level languages like Tact or lower-level ones like Fift. These are highly original languages, making the security of smart contracts on the platform a critical concern.\n\nThe SlowMist Security Team has combined security practices shared by the TON community with its own extensive experience in security audits to release the ‚ÄúBest Practices for Toncoin Smart Contract Security.‚Äù This guide is designed to help developers better understand the security risks associated with Toncoin smart contracts and offer practical solutions to mitigate potential threats.\n\nDue to space constraints, only a portion of the ‚ÄúBest Practices for Toncoin Smart Contract Security‚Äù is listed here. For the full guide, feel free to Watch, Fork, and Star the project on GitHub: https://github.com/slowmist/Toncoin-Smart-Contract-Security-Best-Practices\n\n- Description: Func variables and functions can contain nearly any legal character, which can lead to confusion. - Attack Scenario: Names like ‚Äúvar++‚Äù, ‚Äú~bits‚Äù, or ‚Äúfoo-bar+baz‚Äù are valid but potentially confusing. - Recommendation: Use Linter tools to check Func code for clarity.\n\nDescription: In the computation phase, smart contract code is executed, followed by actions such as sending messages, modifying code, or updating libraries. Unlike Ethereum-based blockchains, if you expect a message to fail, you won‚Äôt see the exit code in the computation phase, as messages are not executed during this phase but in the subsequent operation phase. Attack Scenario: Unexpected behavior may occur when a message fails during the operation phase, leading to incorrect assumptions about the transaction state. Recommendation: Understand that each transaction consists of up to five phases: storage phase, credit phase, computation phase, operation phase, and bounce phase. Ensure that assumptions about transaction outcomes account for these phases.\n\n14. Cannot Fetch Data from Other Contracts\n\nBy following these best practices, developers can enhance the security of their smart contracts and mitigate potential risks. In the rapidly evolving blockchain space, security remains paramount. We hope these practices will help developers create safe and reliable smart contracts, contributing to the healthy development of blockchain technology.\n\nAt SlowMist, we pride ourselves on being a frontrunner in blockchain security, dedicating years to mastering threat intelligence. Our expertise is grounded in providing comprehensive security audits and advanced anti-money laundering tracking to a diverse clientele. We‚Äôve established a robust network for threat intelligence collaboration, positioning ourselves as a key player in the global blockchain security landscape. We offer tailor-made security solutions that span from identifying threats to implementing effective defense mechanisms. This holistic approach has garnered the trust of numerous leading and recognized projects worldwide, including names like Huobi, OKX, Binance, imToken, Crypto.com, Amber Group, Klaytn, EOS, 1inch, PancakeSwap, TUSD, Alpaca Finance, MultiChain, and Cheers UP. Our mission is to ensure the blockchain ecosystem is not only innovative but also secure and reliable.\n\nWe offers a variety of services that include but are not limited to security audits, threat intelligence, defense deployment, security consultants, and other security-related services. We also offer AML (Anti-money laundering) solutions, Vulpush (Vulnerability monitoring) , SlowMist Hacked (Crypto hack archives), FireWall.x (Smart contract firewall) , Safe Staking and other SaaS products. We have partnerships with domestic and international firms such as Akamai, BitDefender, FireEye, RC¬≤, TianJi Partners, IPIP, etc.\n\nBy delivering a comprehensive security solution customized to individual projects, we can identify risks and prevent them from occurring. Our team was able to find and publish several high-risk blockchain security flaws. By doing so, we wish to help spread awareness and raise the security standards in the blockchain ecosystem."
    },
    {
        "link": "https://krayondigital.com/blog/smart-contract-access-control-best-practices",
        "document": "Smart contract access control is crucial for blockchain security. It determines who can do what within a contract, protecting it from unauthorized actions and potential attacks.\n\nAccess control sets rules for function execution in smart contracts. Without it, anyone could alter important code or steal funds. Proper implementation is vital to prevent exploits and financial losses.\n\nFollowing these practices can significantly enhance your smart contract's security and reduce unauthorized access risks.\n\nAccess control in smart contracts sets rules for who can do what within the contract. It's key for keeping contracts safe from attacks.\n\nThe main idea is limiting who can run certain functions. This protects important contract parts from unwanted changes.\n\nBasic ways to do this:\n‚Ä¢ Roles: Different addresses have different access levels\n‚Ä¢ Whitelists: Only approved addresses can use certain functions\n\nThe simplest method. One address (usually the creator) has full control.\n\nAllows more complex setups. Different addresses have different roles with varying access levels.\n\nKeeps a list of approved addresses that can use certain functions.\n\nEven with access control, things can go wrong:\n‚Ä¢ Spelling mistakes: Using the wrong modifier name by accident.\n‚Ä¢ Too much power: Giving one role too many permissions.\n\nIn March 2023, HospoWise was hacked due to a public token burn function. Anyone could call it, leading to fund loss. This shows why proper access control matters.\n‚Ä¢ Use clear naming for roles and modifiers\n‚Ä¢ Follow the principle of least privilege - only give needed permissions\n\nGives one address full control. Simple but limited:\n\nAllows more complex setups by assigning different roles:\n\nChoose the pattern that fits your needs. Start simple, then add complexity as needed. Always follow the principle of least privilege.\n\nSmart contracts can use more complex methods to boost security and flexibility:\n‚Ä¢ Allows stakeholders to review changes\n\nUse proxy patterns for safe updates without losing data:\n\nThis setup allows fixing bugs and adding features without disrupting the contract's address or stored data.\n\nThese techniques offer powerful tools for enhancing security, but require careful planning and implementation.\n\nSeparate duties among roles to improve security and organization.\n\nConcentrating power creates a single point of failure. The DAO hack in 2016 partly resulted from this issue.\n\nFailing to validate inputs can lead to vulnerabilities. The HospoWise hack in 2021 exemplifies this issue.\n‚Ä¢ Use fuzz testing for random inputs and interactions\n‚Ä¢ Initialization functions that could allow ownership takeover\n‚Ä¢ Public functions that should have restricted access\n\nChoose based on your contract's needs, required flexibility, and potential for future upgrades.\n\nThese examples show small oversights can lead to massive losses. Proper access control, thorough audits, and best practices are crucial for protecting smart contracts and assets.\n\nDID systems are changing personal data handling in smart contracts:\n\nExample: Estonia's e-Residency program shows DID working at a national level.\n\nSolidityScan uses AI to find and fix vulnerabilities in smart contract code.\n\nPlanning now is crucial for future smart contract security.\n\nAccess control in smart contracts needs constant attention. As blockchain evolves, so do security challenges.\n\nPoor access control can be severe. The Parity Multi-sig bug led to a $30 million loss.\n\nLooking ahead, trends like decentralized identity and AI-enhanced security will shape access control. Staying informed and applying best practices will build more secure blockchain systems.\n\nHow to use OpenZeppelin access control?\n‚Ä¢ Follow the principle of least privilege"
    },
    {
        "link": "https://linkedin.com/pulse/ton-token-development-ultimate-guide-building-tokens-atkinson-adndc",
        "document": "What Is the TON Blockchain, and Why Does It Matter?\n\nThe Roadmap to Your Token: Where to Start and What You Need\n\nCrafting the Heart of Your Token: The Smart Contract\n\nTaking It Live: Deploying and Verifying Your Smart Contract\n‚Ä¢ Compile Your Smart Contract: Before anything else, your contract needs to be compiled into a language that the blockchain understands. On TON, this is done through specialized development tools like the TON SDK and IDE. These tools allow you to test and optimize your contract before hitting the big red button.\n‚Ä¢ Get Some Toncoin: You‚Äôll need Toncoin to pay for gas fees, which are necessary for deploying your contract on the network. These fees ensure that every action on the blockchain is accounted for and prevent network abuse. Make sure your wallet is loaded with enough Toncoin to cover the costs.\n‚Ä¢ Submit the Contract to the Network: This is where the magic happens. Using the TON development tools, you‚Äôll send your compiled smart contract to the TON blockchain. The network will validate and approve it, making your token official.\n‚Ä¢ Monitor the Deployment: After submission, keep an eye on the deployment process to ensure everything goes smoothly. Most development tools provide real-time feedback, so you‚Äôll know immediately if there‚Äôs an issue. Once the deployment is successful, your smart contract will be live on the TON Blockchain, ready for transactions and interactions.\n\nLaunching Your Token to the World\n\nBuilding Hype: The Art of Social Media and Community Engagement\n\nBeyond the Launch: Scaling Your Token on TON\n\nThe Tools You Need for TON Token Development"
    }
]