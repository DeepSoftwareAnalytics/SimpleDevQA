[
    {
        "link": "https://stackoverflow.com/questions/66592082/how-to-find-a-point-of-an-elliptic-curve-in-crypto-with-given-x-or-how-to-c",
        "document": "Although you already have valid and simple answer, I still decided to implement my own solution from scratch in pure C++, because your task is very interesting.\n\nMy quite large solution doesn't use Crypto++, but tries to implement all algorithms from scratch in C++. It is intended only for curiosity and scientific and educational purpose. It is not intended to be as fast and as simple as pure Crypto++ solution.\n\nIt is known that if modulus is any prime of any form, then square root can be found through well known and very fast algorithm of Tonelli Shanks. It is main part of code that follows below.\n\nAlso if modulus is a prime of form then its root also can be found easily by formula . Which is much shorter than Shanks Tonelli algorithm, but Shanks Tonelli works for all cases, even when .\n\nBesides mentioned above algorithms I also used Modular Exponentation by Squaring and Euler's Criterion.\n\nParams of curve Secp256k1 were taken from here and here:\n\nMy code can be run straight away after compilation and it shows all timings and results on console, see example output after code below. For test purpose I iterate all X in range [0..50] and show which of them give valid root for Y. As it is known around 50% values of X will give correct solution.\n\nTo compile my program besides standard C++ library I use only GMP library for arbitrary integer arithmetics. It can be installed in Linux through . And in Windows after install VCPKG package manager you can do , plus Windows will need to provide manually vckpg include path and libraries for linking. I tested compilation and work of program in CLang and MSVC.\n\nAlso click link below to test run of program online on GodBolt servers."
    },
    {
        "link": "https://stackoverflow.com/questions/51922135/generate-private-public-pair-key-using-ecc-elliptic-curves",
        "document": "The goal is to write a program in C or bash, which will take as input a hash composed of 128 characters in hexadecimal\n\n and which will generate from the a private key and a public key of type Elliptic Curve and display the key pair generated.\n\nCan someone clarify for me the problem. I can't understand why we need a hash(or any string) to generate a pair key, as I found In many online solution like this one ther's no need to give a hash. Maybe is it a parphase ? Maybe It's the curve key or somthing similar.\n\nI think all we need is to do something like this for the private key:\n\n and for the public key generation:\n\nThe question is : why we need an input a hash composed of 128 to generate our pair keys? Is it a passphrase for security reason? how made the trick with openssl ?"
    },
    {
        "link": "https://wiki.openssl.org/index.php/Command_Line_Elliptic_Curve_Operations",
        "document": "OpenSSL provides two command line tools for working with keys suitable for Elliptic Curve (EC) algorithms:\n\nThe only Elliptic Curve algorithms that OpenSSL currently supports are Elliptic Curve Diffie Hellman (ECDH) for key agreement and Elliptic Curve Digital Signature Algorithm (ECDSA) for signing/verifying.\n\nx25519, ed25519 and ed448 aren't standard EC curves so you can't use or subcommands to work with them. If you need to generate x25519 or ed25519 keys then see the subcommand.\n\nBy default OpenSSL will work with PEM files for storing EC private keys. These are text files containing base-64 encoded data. A typical traditional format private key file in PEM format will look something like the following, in a file with a \".pem\" extension:\n\nOr, in an encrypted form like this:\n\nYou may also encounter PKCS8 format private keys in PEM files. These look like this:\n\nOr, in an encrypted form like this:\n\nPKCS8 private key files, like the above, are capable of holding many different types of private key - not just EC keys.\n\nYou can convert between these formats if you like. All of the conversion commands can read either the encrypted or unencrypted forms of the files however you must specify whether you want the output to be encrypted or not. To convert a PKCS8 file to a traditional encrypted EC format use:\n\nYou can replace the first argument \"aes-128-cbc\" with any other valid openssl cipher name (see Manual:enc(1) for a list of valid cipher names). To convert a PKCS8 file to a traditional unencrypted EC format, just drop the first argument:\n\nOr to convert from a traditional EC format to an encrypted PKCS8 format use:\n\nOr to a non-encrypted PKCS8 format use:\n\nNote that by default in the above traditional format EC Private Key files are not encrypted (you have to explicitly state that the file should be encrypted, and what cipher to use), whilst for PKCS8 files the opposite is true. The default is to encrypt - you have to explicitly state that you do not want encryption applied if appropriate using the \"-nocrypt\" option.\n\nAs well as PEM format all of the above types of key file can also be stored in DER format. This is a binary format and so is not directly human readable - unlike a PEM file. A PEM file is essentially just DER data encoded using base 64 encoding rules with a header and footer added. Often it is more convenient to work with PEM files for this reason.\n\nThe openssl commands typically have options \"-inform DER\" or \"-outform DER\" to specify that the input or output file is DER respectively. So for example the command to convert a PKCS8 file to a traditional encrypted EC format in DER is the same as above, but with the addition of \"-outform DER\":\n\nNote that you cannot encrypt a traditional format EC Private Key in DER format (and in fact if you attempt to do so the argument is silently ignored!). The same is not true for PKCS8 files - these can still be encrypted even in DER format. So for example the following will convert a traditional format key file to an ecrypted PKCS8 format DER encoded key:\n\nEC Public Keys are also stored in PEM files. A typical EC public key looks as follows:\n\nThis format is used to store all types of public keys in OpenSSL not just EC keys.\n\nIt is possible to create a public key file from a private key file (although obviously not the other way around!):\n\nAs above a DER encoded version can be created using \"-outform DER\":\n\nAn EC Parameters file contains all of the information necessary to define an Elliptic Curve that can then be used for cryptographic operations (for OpenSSL this means ECDH and ECDSA). OpenSSL contains a large set of pre-defined curves that can be used. The full list of built-in curves can be obtained through the following command:\n\nAn EC parameters file can then be generated for any of the built-in named curves as follows:\n\nReplace secp256k1 in the above with whichever curve you are interested in.\n\nKeys can be generated from the ecparam command, either through a pre-existing parameters file or directly by selecting the name of the curve. To generate a private/public key pair from a pre-eixsting parameters file use the following:\n\nOr to do the equivalent operation without a parameters file use the following:\n\nInformation on the parameters that have been used to generate the key are embedded in the key file itself.\n\nBy default, when creating a parameters file, or generating a key, openssl will only store the name of the curve in the generated parameters or key file, not the full set of explicit parameters associated with that name. For example:\n\nThis will simply confirm the name of the curve in the parameters file by printing out the following:\n\nIf you wish to examine the specific details of the parameters associated with a particular named curve then this can be achieved as follows:\n\nThe above command shows the details for a built-in named curve from a file, but this can also be done directly using the \"-name\" argument instead of \"-in\". The output will look similar to the following:\n\nThe meaning of each of these parameters is discussed further on this page.\n\nParameters and key files can be generated to include the full explicit parameters instead of just the name of the curve if desired. This might be important if, for example, not all the target systems know the details of the named curve. In OpenSSL version 1.0.2 new named curves have been added such as brainpool512t1. Attempting to use a parameters file or key file in versions of OpenSSL less than 1.0.2 with this curve will result in an error:\n\nThis problem can be avoided if explicit parameters are used instead. So under OpenSSL 1.0.2 you could create a parameters file like this:\n\nLooking at the parameters file you will notice that it is now much longer:\n\nThe full parameters are included rather than just the name. This can now be processed by versions of OpenSSL less than 1.0.2. So under 1.0.1:\n\nThis will correctly display the parameters, even though this version of OpenSSL does not know about this curve.\n\nThe same is true of key files. So to generate a key with explicit parameters:\n\nThis key file can now be processed by versions of openssl that do not know about the brainpool curve.\n\nIt should be noted however that once the parameters have been converted from the curve name format into explicit parameters it is not possible to change them back again, i.e. there is no utility to take a set of explicit parameters and work out which named curve they are associated with."
    },
    {
        "link": "https://crypto.stackexchange.com/questions/83312/how-are-points-on-an-elliptic-curve-discretized",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://nantenaina.xyz/posts/basic-implementation-of-an-elliptic-curve-in-cpp",
        "document": "A short anecdote, I once participated in a cryptography challenge, in which most of the questions were breaking ECDH. There are many tools out there but my problem is that instead of using it, I ended up learning to use it. What I mean is that, let say I want to factorize a number and the tool uses brute force to find factor but if I already knew some sets that wont divide the number, of course I would skip them but the tools did not give me that freedom.\n\nIn this post, I am going to share a very basic implementation of an Elliptic Curve over a finite field in C++. Using a library for arithmetic and algebraic computation Givaro, this is one of the back-end of Sagemath.\n\nI consider the reduced Weierstrass form (field I am going to use is of characteristic different from 2 and 3).\n\nTo follow along, you might need a basic understanding of and how to use makefile, also I assume that you know what an Elliptic Curve is. In this post I consider an elliptic curve over a finite field which is actually a group. For not going so deep, just consider it as a set of rational point. Also I am going to use affine coordinates representation, of course one can tweak the code to use projective coordinates depending on what is your need, in here lets just keep it simple.\n\nTo install Givaro, you could use the instruction here, this is the first requirement. To confirm the installation, grab one of the examples in the source code.\n\nTake a 10 second to breath ðŸ˜Ž. What do we need? good question.\nâ€¢ None Point : Only the element We then implement the operation on the Elliptic Curve.\nâ€¢ None Few theory to refresh our memory about the group operation. \\(K\\) be a field of char \\(\n\neq 2,3\\) Let \\(P(x_1,y_1)\\), \\(Q(x_2,y_2)\\) points of \\(E(\\mathbb{K})\\) and \\(\\mathcal{O}\\) the identity.\nâ€¢ Inverse of \\(P\\) is \\(-P\\) of coordinate \\((x_1, -y_1)\\) the slope of the tangent line at \\(P\\) is \\(m = \\frac{3x_1^2 + A}{2y_1}\\) so if \\(R(x_3,y_3) = P + Q\\) then we have \\[x_3 = m^2 - 2x_1\\] \\[y_3 = m(x_1 - x_3) - y_1\\] the slope of the line pass through \\(PQ\\) is \\(m = \\frac{y_2 - y_1}{x_2 - x_1}\\) so if \\(R(x_3,y_3) = P + Q\\) then we have \\[x_3 = m^2 - (x_1 + x_2)\\] \\[y_3 = m(x_1 - x_3) - y_1\\]\n\nChoose any directory to work in, mine I call it , inside make two directories and , and a to make our life easy ðŸ˜Ž and code like a boss.\n\nIn the first place, I create a common header, name it inside . Here is the content\n\nLeave it like this for now, we can update it later on if needed. Of course, what are they? we are going to use modular-integer, for further information, please see the Givaro documentation. The new type are just the Integer Modulo \\(Z_n\\) and its element.\n\nNow we are ready to code the project.\n\nI just thought that its funnier to have the check of non-singularity in here.\n\nNow we are ready to test the code. create another file where we add the main, I call mine with the following content\n\nOne last thing, letâ€™s create a simple makefile. This is totally optional, I just want to have a clean structure and easy workflow.\n\nNow go to you terminal and hit you should see a very cool picture of yourself ðŸ˜‚. Well it should work smoothly. In case it doesnt, join me in the comment section. Also you can always check the gitrepo.\nâ€¢ Try more example for testing, use other tool to verify the result.\nâ€¢ If you have any suggestion and need help to make it, just use the comment section.\nâ€¢ Next step? I do not know yet."
    },
    {
        "link": "https://docs.vultr.com/cpp/examples/find-g-c-d-using-recursion",
        "document": "C++ Program to Find G.C.D Using Recursion\n\nThe Greatest Common Divisor (G.C.D), also known as the Greatest Common Factor (G.C.F) or Highest Common Factor (H.C.F), is the largest positive integer that divides two or more integers without leaving a remainder. In programming, calculating the G.C.D is a common task that can be efficiently implemented using recursion, especially in C++ due to its performance benefits with recursive functions.\n\nIn this article, you will learn how to leverage recursion in C++ to find the G.C.D of two numbers. Demonstrated through clear examples, you will discover how recursive functions streamline code in implementing mathematical algorithms such as the Euclidean algorithm for computing G.C.D.\n\nThe Euclidean algorithm is based on the principle that the G.C.D of two numbers also divides their difference. This key insight reduces the problem size at each step, making it particularly suitable for a recursive solution in C++.\nâ€¢ None Identify base cases for recursion. In the context of G.C.D calculation:\nâ€¢ If the second number is zero, the G.C.D is the first number.\nâ€¢ None Formulate the recursive function. If both numbers are non-zero, recursively call the function by passing the smaller number and the remainder of the division of the larger number by the smaller number. In this C++ program, the function is defined to calculate the G.C.D of two integers, and . If is zero, it returns . Otherwise, it calls itself with and the remainder of divided by . The function initializes two numbers, calls , and outputs the result.\nâ€¢ The function decreases the problem size at every recursive call by using the remainder operation, which ensures that the smaller argument is gradually reduced towards zero.\nâ€¢ One of the major strengths of this approach is its succinctness and clarity, closely mirroring the mathematical definition and process of the Euclidean algorithm.\n\nAdvanced Example: Handling Negative Numbers and Zero\nâ€¢ None Adjust the base case to handle negative numbers, by returning the absolute value of the number.\nâ€¢ None Test the extended gcd function with different pairs including zero and negative values. // Include cmath for using the abs function \"G.C.D of -36 and 24 is: \" \"G.C.D of 0 and 45 is: \" \"G.C.D of 0 and 0 is: \" In these examples, negative numbers are handled by the function which ensures the return of a non-negative G.C.D. The function is also tested with zero inputs, demonstrating its robustness in different scenarios.\n\nLeveraging recursion in C++ for calculating the G.C.D of two numbers with the Euclidean algorithm is an elegant and efficient approach. As you've seen through the examples, a correct base case and the recursive formulation are crucial to crafting a functional recursive solution. This method not only follows the mathematical logic closely but also optimizes handling cases like negative numbers and zeros. Begin incorporating these recursive strategies in mathematical algorithms to make your C++ programs more efficient and maintainable."
    },
    {
        "link": "https://stackoverflow.com/questions/72705340/effective-way-of-finding-gcd-of-2-numbers-using-recursive-approach",
        "document": "I have been recently solving a problem to find GCD/HCF of two numbers using Recursion. The first solution that came to my mind was something like given below.\n\nI saw other people's solutions and one approach was very common which was something like given below.\n\nWhat is the difference between the Time Complexities of these two programs? How can I optimise the former solution and how can we say that the latter solution is efficient than any other algorithm?"
    },
    {
        "link": "https://stackoverflow.com/questions/64071475/is-there-a-better-way-to-get-the-gcd-than-using-the-euclidean-algorithm",
        "document": "Though this algorithm is not that bad (and the number of iterations is always small), you can try the Stein's variant, which trades divisions for much faster shifts.\n\nAnyway, this does not improve the asymptotic complexity."
    },
    {
        "link": "https://geeksforgeeks.org/gcd-in-cpp",
        "document": "GCD of Two Numbers in C++\n\nGCD (Greatest Common Divisor) or HCF (Highest Common Factor) of two numbers is the largest number that exactly divides both numbers. In this article, we will learn to write a C++ program to find the GCD of two numbers.\n\nInput: a = 12, b = 16\n\nOutput: 4\n\nExplanation: As 4 is the largest number which divide both 12 and 16 Input: a = 11, b = 9\n\nOutput: 1\n\nExplanation: As 1 is the largest number which divide both 11 and 9\n\nFollowing are the different methods to find the GCD of two numbers in C++:\n\nThe idea is to find the common divisor by checking the divisibility of both numbers using the (%) modulo operator with all the numbers starting from the minimum number to 1.\n\nTime Complexity: O(min(a,b)), where a and b are the given two numbers.\n\nAuxiliary Space: O(1)\n\nThe Euclidean algorithm is an efficient method to find the GCD of two numbers. It works on the principle that the GCD of two numbers remains the same if the greater number is replaced by the difference between the two numbers.\n\nTime Complexity: O(log (min(a,b)) ), where a and b are the given two numbers.\n\nAuxiliary Space: O(log (min(a,b)) )\n\nIn C++ Standard Library, there are two standard library functions: __gcd() and gcd() which is used for calculating the GCD of two numbers but they are present since C++ 14 and C++ 17 standard only. __gcd() is defined inside <algorithm> header file and gdc() is defined inside <numeric> header file.\nâ€¢ None Return the GCD of given two numbers."
    },
    {
        "link": "https://freecodecamp.org/news/euclidian-gcd-algorithm-greatest-common-divisor",
        "document": "For this topic you must know about Greatest Common Divisor (GCD) and the MOD operation first.\n\nThe GCD of two or more integers is the largest integer that divides each of the integers such that their remainder is zero.\n\nExample-\n\nGCD of 20, 30 = 10 (10 is the largest number which divides 20 and 30 with remainder as 0)\n\nGCD of 42, 120, 285 = 3 (3 is the largest number which divides 42, 120 and 285 with remainder as 0)\n\nThe mod operation gives you the remainder when two positive integers are divided. We write it as follows-\n\n\n\nThis means, dividing A by B gives you the remainder R, this is different than your division operation which gives you the quotient.\n\nExample-\n\n7 mod 2 = 1 (Dividing 7 by 2 gives the remainder 1)\n\n42 mod 7 = 0 (Dividing 42 by 7 gives the remainder 0)\n\nWith the above two concepts understood you will easily understand the Euclidean Algorithm.\n\nThe Euclidean Algorithm finds the GCD of 2 numbers.\n\nYou will better understand this Algorithm by seeing it in action. Assuming you want to calculate the GCD of 1220 and 516, lets apply the Euclidean Algorithm-\n\nAssuming you want to calculate the GCD of 1220 and 516, lets apply the Euclidean Algorithm-\n\nPseudo Code of the Algorithm-\n\nStep 1: Let be the two numbers\n\nStep 2: \n\nStep 3: Let and \n\nStep 4: Repeat Steps 2 and 3 until is greater than 0\n\nStep 5: GCD = b\n\nStep 6: Finish\n\nC code to perform GCD using recursion\n\nYou can also use the Euclidean Algorithm to find GCD of more than two numbers. Since, GCD is associative, the following operation is valid-\n\nCalculate the GCD of the first two numbers, then find GCD of the result and the next number. Example-\n\nYou can find GCD of numbers in the same way.\n\nWhat is the Extended Euclidean Algorithm?\n\nThis is an extension of Euclidean algorithm. It also calculates the coefficients x, y such that\n\nx and y are also known as coefficients of BÃ©zout's identity."
    },
    {
        "link": "https://stackoverflow.com/questions/23967334/biginteger-numbers-implementation-and-performance",
        "document": "I have written a BigInteger class in C++ that should be able to do operations on all numbers with any size. Currently I am trying to achieve a very fast multiplication method by comparing the existing algorithms and test for which amount of digits they work best and I ran into very unexpected results.I tried to do 20 multiplications of 500-digit and I timed them. This was the result:\n\nIt follows that, for sufficiently large n, Karatsuba's algorithm will perform fewer shifts and single-digit additions than longhand multiplication, even though its basic step uses more additions and shifts than the straightforward formula. For small values of n, however, the extra shift and add operations may make it run slower than the longhand method. The point of positive return depends on the computer platform and context. As a rule of thumb, Karatsuba is usually faster when the multiplicands are longer than 320â€“640 bits.\n\nSince my numbers are at least 1500 bits long this is quite unexpected because wikipedia said karatsuba should run faster. I believe that my problem might be in my addition algorithm but I don't see how I could make it faster because it's already running in O(n). Ill post my code below so that you can check my implementations. I'll leave the irrelevant parts out of it.\n\n I was also thinking that maybe the structure I used was not the best possible. I represented each data segment in little endian. So for example if I have the number 123456789101112 stored into data segments of length 3 it would look like this:\n\nso this is why I am asking now what the best structure and best way to implement a BigInteger class is? And why is the karatsuba algorithm slower than the long multiplication one ?\n\nThis is my code: (I'm sorry for the length)"
    },
    {
        "link": "https://labex.io/tutorials/cpp-how-to-manage-large-number-calculations-419002",
        "document": "This comprehensive tutorial delves into the intricate world of managing large number calculations using C++. Designed for developers and computational experts, the guide explores advanced techniques for handling complex numerical computations beyond standard data type limitations. By understanding fundamental strategies and performance optimization methods, programmers can effectively tackle challenging mathematical problems that require precision and efficiency.\n\n%%%%{init: {'theme':'neutral'}}%%%% flowchart RL cpp((\"C++\")) -.-> cpp/AdvancedConceptsGroup([\"Advanced Concepts\"]) cpp((\"C++\")) -.-> cpp/StandardLibraryGroup([\"Standard Library\"]) cpp((\"C++\")) -.-> cpp/SyntaxandStyleGroup([\"Syntax and Style\"]) cpp/AdvancedConceptsGroup -.-> cpp/pointers(\"Pointers\") cpp/AdvancedConceptsGroup -.-> cpp/templates(\"Templates\") cpp/StandardLibraryGroup -.-> cpp/math(\"Math\") cpp/SyntaxandStyleGroup -.-> cpp/code_formatting(\"Code Formatting\") subgraph Lab Skills cpp/pointers -.-> lab-419002{{\"How to manage large number calculations\"}} cpp/templates -.-> lab-419002{{\"How to manage large number calculations\"}} cpp/math -.-> lab-419002{{\"How to manage large number calculations\"}} cpp/code_formatting -.-> lab-419002{{\"How to manage large number calculations\"}} end"
    },
    {
        "link": "https://stackoverflow.com/questions/4433891/optimizing-modular-arithmetic-computations-in-c",
        "document": "Yes. It is possible. What you want to look up is \"expression templates\" and start from there. From that point you're going to have to build some metaprogram logic to optimize/simplify the expression. Far from a trivial task, but that's not what you asked.\n\nIf you were smart though, you'd put the use of % in the constructor for modular so it's always modular; you'd also put checks in to make sure LH and RH are compatible along with SFINAE crap to keep the operators from killing it for any time at all. You might also make modulus a template parameter and provide metafunctions to access it. At any rate...there you go.\n\nEdit: BTW, you can use this same technique to make your matrices calculate faster. Instead of creating a new matrix for each operation in a string of operations, you make these things and then finally do the math, element by element, when you assign the result. There's papers on it on the internet and everything, comparing it to FORTRAN and such. Was one of the first uses of metaprogramming like template use in C++. Also in the book http://www.amazon.com/Scientific-Engineering-Introduction-Advanced-Techniques/dp/0201533936 <- keep in mind though that \"advanced techniques\" was in 94 :p. It's not as relevant today."
    },
    {
        "link": "https://labex.io/tutorials/cpp-how-to-handle-integer-modulo-operations-419563",
        "document": "This comprehensive tutorial explores integer modulo operations in C++, providing developers with essential insights into handling mathematical calculations efficiently. By understanding modulo arithmetic patterns and implementation strategies, programmers can enhance their computational skills and solve complex algorithmic challenges with precision and performance.\n\n%%%%{init: {'theme':'neutral'}}%%%% flowchart RL cpp((\"C++\")) -.-> cpp/BasicsGroup([\"Basics\"]) cpp((\"C++\")) -.-> cpp/ControlFlowGroup([\"Control Flow\"]) cpp((\"C++\")) -.-> cpp/FunctionsGroup([\"Functions\"]) cpp((\"C++\")) -.-> cpp/StandardLibraryGroup([\"Standard Library\"]) cpp/BasicsGroup -.-> cpp/operators(\"Operators\") cpp/ControlFlowGroup -.-> cpp/conditions(\"Conditions\") cpp/ControlFlowGroup -.-> cpp/for_loop(\"For Loop\") cpp/ControlFlowGroup -.-> cpp/while_loop(\"While Loop\") cpp/FunctionsGroup -.-> cpp/function_parameters(\"Function Parameters\") cpp/FunctionsGroup -.-> cpp/recursion(\"Recursion\") cpp/StandardLibraryGroup -.-> cpp/math(\"Math\") subgraph Lab Skills cpp/operators -.-> lab-419563{{\"How to handle integer modulo operations\"}} cpp/conditions -.-> lab-419563{{\"How to handle integer modulo operations\"}} cpp/for_loop -.-> lab-419563{{\"How to handle integer modulo operations\"}} cpp/while_loop -.-> lab-419563{{\"How to handle integer modulo operations\"}} cpp/function_parameters -.-> lab-419563{{\"How to handle integer modulo operations\"}} cpp/recursion -.-> lab-419563{{\"How to handle integer modulo operations\"}} cpp/math -.-> lab-419563{{\"How to handle integer modulo operations\"}} end"
    },
    {
        "link": "https://quora.com/How-would-one-run-calculations-with-large-integers-in-C++",
        "document": "Something went wrong. Wait a moment and try again."
    }
]