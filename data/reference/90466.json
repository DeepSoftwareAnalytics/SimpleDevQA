[
    {
        "link": "https://st.com/resource/en/application_note/an4899-stm32-microcontroller-gpio-hardware-settings-and-lowpower-consumption-stmicroelectronics.pdf",
        "document": ""
    },
    {
        "link": "https://st.com/resource/en/reference_manual/dm00031020-stm32f405-415-stm32f407-417-stm32f427-437-and-stm32f429-439-advanced-arm-based-32-bit-mcus-stmicroelectronics.pdf",
        "document": ""
    },
    {
        "link": "https://controllerstech.com/stm32-gpio-input-configuration",
        "document": "In the previous tutorial, we covered how to use the GPIO pin as output using Registers. This tutorial will cover how to configure the pin as input, and then how to read itâ€™s state.\n\nI will use a button to read the input state of the pin. In order to configure the pin in the input mode, we need to follow the steps mentioned below /************** STEPS TO FOLLOW ***************** 1. Enable GPIOA clock 2. Set the PIN PA5 as input 3. Configure the Pull UP / Pull Down mode ************************************************/ The GPIO clock can be enabled in the RCC_AHB1ENR Register As you can see above, the 0th bit of RCC_AHB1ENR Register enables the clock for the GPIOA. Thatâ€™s why we need to write a 1 in the 0th position To configure the pin as input, we will modify the GPIOx_MODER Register. This register is responsible for configuring different modes for the GPIO, and in this case we will configure it as the input mode Since I am using pin PA1, I need to modify the pins 2 and 3. This basically works like, if the PIN is â€˜yâ€˜, the we need to configure the bits â€˜2yâ€™ and â€˜2y+1â€™\n\nAlso, in order to set the pin as input, we need to set the bits (3:2) as 0:0. This means that we need to write a â€˜0â€™ in the 2nd and 3rd positions I am going to configure the pin as the Pull-Up pin. The reason for the same is that the button is connected as shown below When the button will be pressed, the current from the PA1 will sink into the ground, and the PA1 will go LOW To configure the Pull UP / Pull DOWN, we need to modify the GPIOx_PUPDR Register As we need to configure the Pull-UP for the the pin PA1, we need to modify respective bits (3:2). I want to set the Pull-up here, so i need to configure the bits (3:2) as 0:1 Thatâ€™s all for the configuration of the GPIO as input pin. To configure the Pin as the input in F1 series, the steps are shown below /*************>>>>>>> STEPS FOLLOWED <<<<<<<<************ 1. Enable GPIO Clock 2. Set the required Pin in the INPUT Pull-up/ Pull-down Mode 3. Configure the ODR (1-> Pull UP, 0-> Pull down) ********************************************************/ Letâ€™s cover them all one by one Since we are using the pin PA1 as the input, The GPIOA clock can be enabled in the RCC_APB2ENR Register As you can see the 2nd bit of APB2ENR Register controls the GPIOA Clock. So to enable the clock, we will write a â€˜1â€™ in this position To control the mode of the pin, we need to modify the Control Register GPIOx_CR This Control Register is divided into 2 Registers of 32 bits each i.e CRL(pins 0 to 7) and CRH(pins 8 to 15). Since we are using PA1, we will modify the CRL Register\nâ€¢ As you can see above, each pin can be controlled using the 4 bits. For PA1, these bits are 7:6:5:4\nâ€¢ The lower 2 bits can be used to select the mode i.e output or input\nâ€¢ The Higher bits can be used to configure this mode\nâ€¢ Also note that the reset state for the CNF bits is 0:1, so we need to clear the bits before setting a new value there Here we have selected the input mode with Pull-up/Pull-down mode, but to select the either mode, there is no special register here. This description is provided in the table 20: Port bit configuration table as per the instructions in the picture above. This table can be seen below To set the Pull-up register, we need to write a â€˜1â€™ in the Output Data Register (GPIOx_ODR) GPIOA->ODR |= (1<<1); // --> PA1 is in Pull UP mode This completes the GPIO Configuration for the F1 Series How to Read the Pin State To read the state of the pin, we will check the Input Data Register (IDR) IDR is a read only register. The respective bit either set or reset depending on the state of the PIN. Now since I am using the Pull-UP for pin PA1 here, the 1st bit of IDR will always be HIGH. When the button is pressed, the current from PA1 will sink into the ground, and the pin will be LOW, and so does the bit 1. So basically we wait for the 1st bit of the IDR to go LOW. And when it is low, indicating the button has been pressed, we can do the processing. int count = 0; int main () { SysClockConfig (); GPIOConfig (); while (1) { if (!(GPIOA->IDR &(1<<1))) { while (!(GPIOA->IDR &(1<<1))); count++; } } } Here we check for the bit 1 of the IDR, if it is low, we increment the count variable.\n\nSo whenever the button is pressed, the count variable will increment As you can see above, the count variable increments to 9, indicating the button has been pressed 9 times You can help with the development by Below.\n\nTo download the project, click the button."
    },
    {
        "link": "https://wiki.stmicroelectronics.cn/stm32mcu/wiki/Getting_started_with_GPIO",
        "document": "This article explains what GPIO is and how to use it through examples.\n\nGPIO stands for general purpose input/output. It is a type of pin found on an integrated circuit that does not have a specific function. While most pins have a dedicated purpose, such as sending a signal to a certain component, the function of a GPIO pin is customizable and can be controlled by the software.\nâ€¢ Pin Mode : Each port bit of the general-purpose I/O (GPIO) ports can be individually configured by software in several modes:\nâ€¢ Pin characteristics :\nâ€¢ Input : no pull-up and no pull-down or pull-up or pull-down\nâ€¢ Output : push-pull or open-drain with pull-up or pull-down capability\nâ€¢ Alternate function : push-pull or open-drain with pull-up or pull-down capability.\nâ€¢ Change the rising and falling edge when the pin state changes from high to low or low to high.\nâ€¢ A higher GPIO speed increases the EMI noise from STM32 and increases the STM32 consumption.\nâ€¢ It is good to adapt the GPIO speed to the peripheral speed. For example, low speed is optimal for toggling GPIO at 1 Hz, while using SPI at 45 MHz requires very high speed setting.\n\nLearn how to Toggle a pin on STM32L476 Nucleo board using Hardware Abstraction Layer (HAL) library and learn how to setup the pin and GPIO port in STM32CubeIDE.\n\n\n\n\n\n This example uses the NUCLEO-L476RG board.\nâ€¢ Select NUCLEO-L476RG using the Board Selector as shown in the figure below:\n\n\n\n\n\nIn case you haven't downloaded the STM32L476 Cube library, it will be downloaded automatically. This however may take some time.\nâ€¢ You will then get a popup asking if you want to initialize peripherals to their default configuration.\nâ€¢ No need to configure any peripheral as only the core/Flash/SRAMs are used (default peripherals).\nâ€¢ If you want to start the project with a board, the LED pin is already selected (PA5 on NucleoL476RG. For other boards refer to the user manual).\nâ€¢ Output speed set to very high is important for faster peripherals such as SPI or USART.\n\nThe easiest way to generate the code is to save your current project : Ctrl + S \n\n The code is generated so you can see it in the left side of the screen in the project explorer \n\n \n\n Now, open the main.c file which is the main source file for this application\nâ€¢ The LED toggling is done with a HAL function inside main.c\nâ€¢ Click on Debug button (to run step by step)\nâ€¢ Or on Run button (to execute) \n\n\n\nEvery 500 ms the green LED state changes."
    },
    {
        "link": "https://hainguyen7050.medium.com/microcontroller-101-1e08c2dd1ce6",
        "document": "In the last episodeâ€¦\n\nIn the last episode, I have introduced the idea, the motivation, and the philosophy of this series. We also went thru the installation of the toolchain, which is STM32CubeIDE.\n\nIn this episode, we will learn how to set up a pin as:\nâ€¢ GPIO input (reading the state of the button) thru two methods: polling and interrupt\n\nAfter starting STM32CubeIDE, we are at the landing page:\n\nIn the landing page, there are default options:\nâ€¢ Start new STM32 project: it is obvious that this option let us create a new project from scratch.\nâ€¢ Start new project from STM32CubeMX .ioc file: this option allows us to open a configuration file from another project.\nâ€¢ Import SW4STM32 or TrueSTUDIO project: this option lets us import the project either from SW4STM32 or TrueSTUDIO, which is one of the supported IDEs.\n\nWe will start our project from scratch so, letâ€™s click on the option of Start new STM32 project. You will be prompted to the next window to select the target (microcontroller).\n\nTarget Selection window allows us to choose the microcontroller by selecting different parameters. Since we are using the evaluation board, we move to the Board Selector tab and select as following:\n\nYou are prompted to a new window asking for Project Name:\n\nGive your project a name, for my case, it is p3_BlinkyLED, and click Finish.\n\nYou will be prompted to a new window, this is where you will configure your MCU.\n\nIf you have a look at the toolbar which is marked red in the picture above, you will see, there are multiple tabs:\nâ€¢ Pinout and configuration: This tab lets you activate/deactivate the peripherals on the microcontroller and allocate the pins for those peripherals.\nâ€¢ Clock Configuration: let you set up the clock for the microcontroller and its peripherals.\nâ€¢ Project Manager: let you configure the general settings of the project.\nâ€¢ Tools: allows us to estimate the power consumption of the MCU with the given conditions.\nâ€¢ Additional Software: let you add Middlewares to your project.\n\nLetâ€™s switch back to the Pinout & Configuration tab. We will learn how to configure a peripheral and assign it to the pins.\n\nFirst, we clear the default pinout setup, so we will have a â€œcleanâ€ pinout. Under Pinout option on the top menu bar, choose Clear Pinouts.\n\nAfter doing that, you will have a clear pinout as the picture below:\n\nTo briefly show you how to activate a peripheral (we will go into detail later when we use the peripherals), for example, USART1, letâ€™s do the following things:\nâ€¢ On the left side of STM32CubeIDE, expand the Connectivity tab, and choose USART1. In the Mode option, choose Asynchronous from the drop-down menu.\nâ€¢ After choosing Asynchronous, the pins for USART1 are automatically activated at pin PA9, PA10 in the MCU pinout.\nâ€¢ If for some reason the pin PA10 and/or PA9 are blocked by other peripherals, there is still an option to move them to the other pins.\nâ€¢ Click Ctrl + Left-Click on the pin you want to move, the tool will highlight a new position for the pin in the blue color (see picture below). To move to the new position, we keep doing the Ctrl + Left-Click and dragging the pin to its new place.\nâ€¢ We donâ€™t need USART1 for now, so we will deactivate it. To do that, go back to the peripheral configuration on the left side, under UASRT1, Mode, choose Disable.\n\nIf you still remember our holy goal is doing the infamous blinking LED, you will wonder why there is no peripheral called â€œLEDâ€, â€œPin on/offâ€, etc. in the configuration. Yes, you are correct, it is not there! To turn on and off an LED, i.e. providing some voltage to the controllerâ€™s pins, we need a peripheral called GPIO (General Purpose Input Output).\n\nGPIO can be activated directly in the MCU pinout:\nâ€¢ On the evaluation kit, there is an LED called LD2. The only thing we need to find out is to which pin this LED is connected. If you still remember the boardâ€™s document, on page 23, it is described:\nâ€¢ So, with simple 1-minute reading, we know the LED is connected to pin PA5 of the MCU. To activate that pin as a GPIO, we hover our mouse to pin PA5 in the MCU pinout, left-click â†’ choose GPIO_Output. The pin will be activated as a GPIO and given the name GPIO_Output.\nâ€¢ If you are a picky guy/girl and you think that the name GPIO_Output is not intuitive enough, there is an option to change the name. Hovering the mouse to the pin, right-click â†’ choose Enter User Lable and give it a name. I will call it LED2.\n\nGreat! We have activated and configured one pin as a GPIO. Next step, we will configure the clock configuration.\n\nA microcontroller needs a clock to operate. It is applied the same for your Laptop or PC. Whenever you read a description like core i7 2.1 GHz blah blah, it means your processor is running at the speed of 2.1 GHz. Obviously, the higher the speed, the faster the processor (and physically, the more power it will take).\n\nIf you are a bit into PC stuff, you will know the term â€œOverclockingâ€, a.k.a increasing (and decreasing, but no one does that) your processor clock. It is applied to the microcontroller in same the manner. You can also adjust the clock of your microcontroller (even choose different clock sources). The major difference is, unlike overclocking your PC, you donâ€™t have to worry about the temperature of the microcontroller and donâ€™t even need a cooling system for it.\n\nBack to STM32CubeIDE, letâ€™s move to the next configuration tab-Clock Configuration. At the first look, you will ask yourself, what the heck you have gotten yourself into??\n\nThis is called a clock tree of a microcontroller. It describes all the clock sources available for the microcontroller and all kinds of possible adjustments in terms of clock speed. At the first look, it is quite scary, but letâ€™s take a deep breath and use our engineering logic to find out what is going on there.\nâ€¢ By just focusing only on the area covered by the red square, we can guess/assume that there are some clock sources called LSE, LSI, MSI, HSI, HSE, and RC. With that information, we could have already deduced that LSE and HSE are external clock sources (surprise? E stands for External) and the rest should be internal clocks.\nâ€¢ Letâ€™s shift our red square a bit to the right, we can see that the LCD and RTC peripheral can only receive clock source from HSE, LSE, or LSI. The IWDG can take the clock only from LSI. The PLL (Phase-locked loop) receives the clock only from HSE or HSI.\nâ€¢ Letâ€™s shift our red window again to the right, we can observe that the system clock (mother of all) can take clock from sources: MSI, HSI, HSE and PLLCLK.\nâ€¢ Letâ€™s do a final shift to the right. The system clock provides the clock to â€œother part of the systemâ€, for example, FCLK, HCLK, APB1. We can also see that some peripherals â€” USART, I2C, etc. can take from other clock sources than the system clock. They are grey out because we didnâ€™t activate them.\n\nThatâ€™s was a lot for clock but this was only our assumption. To verify all the information above, please open the MCU reference manual (link), and read from page 174â€“185. It is only 12 pages (with some pictures) but all the knowledge is there. Just for your information, these are the names of the clock sources:\n\nTheoretically, we can set up the clock manually, but we are only using a GPIO and no communication buses or timers so we can practically let the tool automatically set the clock for us.\nâ€¢ In the box HCLK (picture below), enter the number 32 ( 32 MHz, we will run the clock at maximum speed) and press enter. The tool will report that there is no solution with the current clock source and it is asking you for the permission to choose another one. Press OK.\nâ€¢ After a while, STM32CubeIDE comes up with a solution, letâ€™s check what it proposes to us.\nâ€¢ Going from right to left, we see system clock derived from the PLLCLK clock with the Prescaler of 1. The PLLCLK clock reached 32MHz by adjusting the PLLMul and PLLDiv. Then, the source for the PLL is the HSI clock.\n\nClocking part is over but we do not finish yet. Letâ€™s return to the Pinout & Configuration tab.\n\nLetâ€™s switch to Pinout & Configuration tab and navigate to the GPIO configuration as the picture below.\nâ€¢ GPIO output level: this means, after initialization, the pin will state in logic level high or low( output voltage 3.3V or 0V).\nâ€¢ GPIO mode: can be Output Push-pull or Output Open Drain\nâ€¢ GPIO Pull-up/Pull-down: the pin is internally pulled up to the VCC line (3.3V for example), pulled down (to the ground), or floating. This relates to the first point-GPIO output level. For example, if the pin is pulled-up, the logic level 0 will be 3.3V and logic level 1 will be 0V. It is applied the other way around for pulled-down.\nâ€¢ Maximum out speed: this will setup the rising/falling time of a pin, in other words, how long does it take for a pin to change the stage from low to high and high to low. For GPIO, it doesnâ€™t have to be very fast but for any communication bus, it must be fast. But, this will be taken care of by STM32CubeIDE.\nâ€¢ User label: store the modified name of the pin.\n\nSo far so good, we have all we need, letâ€™s generate the code from the configuration and add some code.\n\nRemember, we want to use the LL library, right? Change everything from HAL to LL.\n\nClicking the generate button to generate our code.\n\nBefore looking at the code, letâ€™s compile the program to be sure that the generation process causes no error.\n\nTo compile the program, click on the hammer button\n\nAfter the compilation, there should be no error (If you run into any error, please describe it in the comment).\n\nNow, letâ€™s have a look at the generated code. Please open the main.c file, this is where your application code start. I emphasized the word application because the code start in the startup file (.s file for your information) but what we have generated is mostly located in the main.c .\n\nScrolling down to the main function approximately at line 65, we see three functions and not to mention the infamous loop. We will have a look inside each function to see what does it do and to check if it acts according to what we have configured. To do that, highlight the function â†’right-click â†’choose Open Declaration.\n\nWe will start with\n\nBy skimming through the , we can conclude that STM32CubeIDE not only generates what we have configured but also generates a lot of hidden things to make the system running. Hopefully, this convinces you that STM32CubeIDE does what we told it to do so we donâ€™t have to take a look at the function. (but you should on your own to make sure that I am not talking bullshit :P ).\n\nSo, at this point, you should ask me which function to use to set the pin on/off. The answer lies within the LL API documentation, but normally I am using another version which can be found in:\n\nIf you open that document and go exactly to the location I show in the picture below, you will find a function called . This is what we need to turn the pin on/off. The parameters of the function are the port, which is GPIOA (If you give it a name it will become PIN_NAME_GPIO_Port) and the PinMask, which is LL_GPIO_PIN_x (again, if you give it a name, it will become PIN_NAME_Pin).\n\nThe only problem left is where to put this function. If you are experience with the embedded systems and the microcontrollers, you will immediately know that the function has to be in the loop. If you donâ€™t know that, donâ€™t worry (be happy). It is located in an infinite loop because we want to execute the code forever.\n\nBut be cautious!!!! If you, again, remember that we are using a tool that automatically generates our code, how can it know that which is its code, and which is our code, where to delete and where to add code? If you pay attention when skimming through the main.c file (and other files if you encounter them in the future), you will see there are some areas with a pair comment/* USER CODE BEGINâ€¦*/ and /* USER CODE ENDâ€¦*/. These two lines act as a place holder for user code and tell the STMCubeIDE that, the userâ€™s code is located there, DO NOT DELETE IT.\n\nSo, the plan is, we will go to the loop, at the toggle function between 2 place holders. This place is located at line 102 (if you have not touched anything in the main.c). My function will be:\n\nIs there anything missing? How can we see the blinking if the code is executed in a blink of the eye (approx. 32 million times/s)? We need a delay function to make it blink slowly. In the same document, where we found the toggle function, the delay function is located at:\n\nHence, our code will become\n\nIn the end, the loop looks like this\n\nLetâ€™s compile the code. It should show no error. To debug the code, we have to connect the evaluation kit to the PC and press the bug button\n\nThe IDE will prompt you to a new window called Debug window. There, you press the play button to execute the code and you should see the green LED blinking on the evaluation board.\n\nNow, you can play a bit with the blinking period by changing the delay time, compiling the code, and executing it. If you get lost, donâ€™t worry, this is the github repo for the code in the whole tutorial.\n\nOne last point I want to mention is, if you are a paranoid guy and donâ€™t trust the Code Generator to generate your code, you can write the peripheral configuration code on your own. Letâ€™s do it!.\n\nGo back to your main.c file, at line 93, we comment out the GPIO configuration function and write our code right after it, at line 95. If you still recall the configuration of a pin to work as an output pin, you will know that, you need some function to enable the clock for the pin, set output level, set pin mode, set pulled-up/pulled-down, and set speed. These functions are located at the same place where you find the toggle function.\n\nThis is what I have written for the pin configuration:\n\nAfter compiling and executing the application, you will see the same result, i.e. it is working with our own configuration.\n\nTo give you an idea of setting a pin as input is just an opposite direction of setting a pin as an output, we will start from the same project, where we write our GPIO configuration. The final piece, which is missing, is which pin the button is connected to. To find that, we can open the schematic of the board on the board manual. At page 23 of the board manual, it is stated that:\n\nTherefore, we have to configure pin PC13 as an input pin. We open file main.c and add the following snippet at line 113 (right after the GPIO output configuration).\n\nThe code is more or less self-explained. It enabled the clock, configured pin PC13 as input pin with no pull-up or pull-down.\n\nNext, in the while(1) loop, we replace the old code with the following snippet:\n\nIt did nothing else than checking the status of pin PC13. If the state of the pin is high or 1, we will turn on the LED and vice versa.\n\nThis method is called Polling because it involves constantly checking for the status of something and set the action according to that. You can also imagine, this method is like driving the car with an annoying kid to the theme park and the kid is constantly asking you â€œare we there yet? are we there yet?â€ and you have to answer every time, â€œyesâ€ or â€œnoâ€.\n\nThis method is pretty straight forward, easy to understand and implement. But for every quick and dirty trick, there are always drawbacks.\nâ€¢ Firstly, we will waste our CPU power just to poll for the status.\nâ€¢ Secondly, while checking for the desired state, we may miss something more important, for example, some message on the communication bus.\n\nLetâ€™s go back to out annoying kid, meanwhile answering to him â€œyesâ€ or â€œnoâ€, you could have missed a red light ðŸ˜œ.\n\nYou may ask yourself, wait, is there something to let the peripherals, kind of, checking the states itself and only inform you when it reaches the some defined states?. Yes, there is something like that, and it is called interrupt.\n\nAs mentioned above, the savior of our problem is called interrupt. Shortly explain, interrupt is a signal that lets the CPU inside the microcontroller know that, something is happening and the CPU should stop what it is doing (normally code section in the while(1)) to handle the signal.\n\nWhenever an interrupt happens (interrupt request), as soon as the CPU finishes its current instruction, it saves the address of the next instruction, status register, etc. and jumps to a section of code that handles the interrupt request (this section is called interrupt service routine or ISR).\n\nThe transition from the current code section to the interrupt code section is called interrupt latency. Of course, the shorter the latency, the better it is. After finishing the ISR, the CPU jumps back to where it left and continues from there. the rule of thumb for the ISR is, the code should be short and clean.\n\nThis is only a very brief explanation of how interrupt works. Each MCU architecture, each MCU vendor has a different way to handle the interrupt so please take a look at the datasheet to have a better understanding. I have found this article about interrupt pretty useful, please have a look if you are fancy about interrupting ðŸ˜† link (in fact, most of my explanation is based on it).\n\nBack to our STM32 controller, most of the work is taking care of by STM32CubeIDE, so the thing we have to do is knowing how to configure interrupt, filling the right code at the right place, and thatâ€™s it.\n\nLetâ€™s create a new project with STM32CubeIDE, I hope you have already known the basic steps of how to do that.\n\nFor this application, we need two GPIOs, PA5 to drive the LED and PC13 for the button.\n\nWe set the PA5 pin as GPIO output and change its name to LED2 as the picture below:\n\nOn the PC13, we initialize it as GPIO_EXTI13. Besides, it is given a name BUTTON.\n\nAlthough we have configured the PC13 as an external interrupt, we have to activate that function in the configuration tab. Therefore, go to System view â†’ NVIC â†’ Activate EXT line 4 to 15 interrupts\n\nWhy do I know that it is line 4 to 15 I have to activate? The answer is in the reference manual, page 289. As you can see in Table 54, the EXTI line 0 â€“15 are tied to GPIO.\n\nEverything is set and done, letâ€™s generate the project and add some code.\n\nBefore filling the code letâ€™s go to function to check what is the difference between using the polling method and interrupt method. The noticeable thing is that PC13 is configured as GPIO Input, exactly the same as what we have done in the previous section. Additionally, externally interrupt line 13 is activated and configured as rising edge triggering (code below).\n\nSo, we have only to look for the ISR, fill in the code and the job is done.\n\nThe ISR is located in the file stm32l0xx_it.c. Open that file, look for the function and fill in the code as below to toggle the LED:\n\nSoâ€¦thatâ€™s it to toggle LED whenever we press the button, no more polling for the status of the pin connected to the button.\n\nWe are able to control the GPIO and the question is, what is the usage of it? Some of the recommendations are:\nâ€¢ Control the relay instead of the LED\nâ€¢ Show the status of the system, e.g. the LED blinks fast - error; the LED blinks slow - system is running; the LED is constantly on -the System is in configuration phase, etc.\n\nWe have learned how to set up GPIO in STM32CubeIDE and generate the project. We also learned how to control the GPIO using LL APIs.\n\nIn the next episode, we will learn about UART."
    },
    {
        "link": "https://iotality.com/blink-led-arm-assembly",
        "document": "If you are like me, you always have the urge to understand ARM Cortex-M architecture in more details. You want to write a small code in assembly language to reach closer to the hardware. But you struggle to find a good how-to-guide for assembly programming. Most of the examples you find are written in higher level languages like C/C++. Donâ€™t give up yet. Read on this post which will help you take the first step in learning ARM assembly programming.\n\nAfter exploring how startup code works for an STM32F4 microcontroller, it is now time to do something useful. For an embedded system, the time tested tradition for saying Hello World! is to blink an LED. Keeping with the tradition, letâ€™s try to blink an LED in ARM assembly. Using the STM32F4 Discovery board, we will see how to blink all the on-board LEDs.\n\nThings you need to blink an LED in ARM Assembly\n\nYou will need a few things in order to enjoy coding in ARM assembly.\nâ€¢ None Software - KEIL MDK - The code presented here uses ARM assembler instead of GNU assembler. The ARM assembler is part of MDK (Microcontroller Development Kit) toolchain. The MDK-ARM bundles the toolchain, uVision IDE and required software packs. You can download the Lite edition from Keil website for free.\nâ€¢ None Hardware - STM32F4 discovery board - The STM32F4 Discovery board from ST Micro is based on STM32F407VGT6, an ARM Cortex-M4 microcontroller. The board provides 4 user controllable LEDs in addition to other peripherals. An ST-Link debugger on-board helps you flash and debug your code, single step through it from within Keil IDE. We will blink all these 4 LEDs with our ARM assembly code.\n\nNote: If you donâ€™t have discovery board, you can use the simulator in Keil IDE. This post however sticks to using the discovery board.\nâ€¢ Documents - I refer to these documents while explaining code in this post. These documents are also available from within Keil uVision IDE from the Books tab in project window.\n\nBefore we understand the assembly code to blink an LED, letâ€™s directly go to the execution phase. To make it easier for you, the source code and instructions to execute code are available on GitHub.\n\nEssentially the steps to execute the code are:\nâ€¢ Install Keil MDK Lite and open the project in Keil uVision\nâ€¢ Build and download code to the board and see the LEDs blinking\n\nSo, go ahead and clone the GitHub repo, follow the README and see yourself all 4 LEDs on board blinking at 500msec interval. The video below shows execution of the code.\n\nNow that you have seen the execution, letâ€™s take it apart piece by piece and understand how the ARM assembly code to blink an LED works.\n\nBlinking an LED involves controlling some hardware. Therefore, we need to get acquainted with it before starting to code. The STM32F4 discovery board comes with 4 onboard LEDs connected to PD12 to PD15. These are the GPIO port D pins 12, 13, 14 and 15 respectively. The port pins connect to anodes of LEDs through a resistor with no external driving circuitry. Hence, to blink the LEDs, we need to switch these GPIO pins high and low with a time delay. Switching a pin to logic high will turn on the LED. Conversely switching it to logic low will turn off the LED. We configure the pins in push-pull mode. Consequently, we wonâ€™t need any pull-up or pull-down resistors. For more details refer to the STM32F4 Discovery board user manual.\n\nTo blink an LED in ARM assembly, we use startup code from STM32F4 software pack and put the application logic in the file LED.s. The startup code provides initialization of stack, heap areas and provides a framework for exception handlers including reset handler. We are not going to use heap or stack in our code. However, it is a good practice to keep the startup code separate. You can get more details on how a startup code works in an earlier post\n\nThe startup code calls two functions - and (referred to as main in this post). We therefore provide definition for these two functions in our application code in ARM assembly in file LED.s. Letâ€™s now explore the application logic in these functions to blink the LEDs.\n\nTowards top of this file, we have a constant value.\n\nEQU is an ARM assembler directive which defines a constant. Assembler writes this constant value into a memory location in code space with a DCD or DCW directive. The data thus written in memory is accessible in code with the LDR (Load data from memory to register) instruction. I shall explain the calculation of this value shortly.\n\nNext there are some register definitions which are the addresses of these registers in STM32F4. Again, the assembler writes these values as data in the code space with DCD or DCW directives.\n\nLetâ€™s get familiar with these registers as it will prove useful to understand the code. We will get into more details later in the post.\nâ€¢ (RCC AHB1 peripheral clock enable register) enables or disables clock supply to various peripherals. AHB1 indicates these peripherals are on AHB1 bus of processor. To use GPIO port D, we need to enable clock for GPIO-D via this register.\nâ€¢ (GPIO-D Mode register) controls the mode for port D pins. We can configure each pin independently as either of these modes:\nâ€¢ (GPIO-D Output Type register) controls whether the pin works in push-pull mode or as an open-drain pin. In case of open drain, we need external pull-up or pull-down.\nâ€¢ (GPIO-D Output Speed register) controls the maximum switching speed on the port pin. The maximum speed also depends on supply voltage, current drawn from pin and load capacitance. We can configure the speed as low / medium / high / very high.\nâ€¢ (GPIO-D Pull-up / Pull-down register) enables internal pull-up or pull-down resistor for each port D pin.\nâ€¢ (GPIO-D Output Data register) is the register to write data to output on the port pins.\n\nThe registers in STM32F4 are memory mapped so every register has an address associated with it. However, neither the reference manual nor the datasheet mentions these addresses explicitly. So let me elaborate about how to find (or rather form) the address of a register.\n\nFirst of all, navigate to description of the register in STM32F407 reference manual and note the register offset. Next, navigate to memory map (section 2.3) in the manual. You will find boundary address range of the peripheral associated with the register. Finally, form the address of the register by adding the offset to base address of boundary range.\n\nAs an example letâ€™s find out the address of register RCC_AHB1ENR. This register is part of the RCC registers (Reset and Clock control). The offset of this register is 0x30 as described in section 7.3.10 of reference manual. The memory map shows the RCC boundary address range as 0x4002 3800 to 0x4002 3BFF. Therefore the address of RCC_AHB1ENR register is 0x4002 3830.\n\nSimilarly, the boundary address range for GPIO-D registers is 0x4002 0C00 to 0x4002 0FFF. So we can calculate addresses for all GPIO-D registers by adding their corresponding offsets to the base address 0x4002 0C00. So GPIOD_MODER register address is 04002 0C00 since it has an offset of 0x00. You can verify addresses for remaining GPIO-D registers. Section 8.4.1 of the reference manual contains description for GPIO-D registers.\n\nLetâ€™s now move to the actual code. The processor startup code calls SystemInit function when it starts to execute but before calling the main function. This function contains all the required initialization for our application. In our example this code enables clock for GPIO-D peripheral and further configures the GPIO-D registers. We configure pins PD12 to PD15 as output in push-pull mode with pull-up/pull-down disabled.\n\nTo configure a register we follow a read-modify-write cycle. Letâ€™s illustrate this with the code to update the register RCC_AHB1ENR.\n\nThe instruction LDR loads address of the register into R0. LDR is an instruction to load data from memory. In this case, the data stored in memory is the address of register with statement earlier. Note the use of prefix in the value to be loaded in R0. This prefix indicates that the value to be loaded is explicitly stored in memory (with or etc. directives). If the value is an immediate constant then we prefix it with . In that case the assembler itself adds a or or similar directive to store the constant in memory.\n\nThe next LDR instruction reads data from the address contained in R1, which is the address of register. So this instruction reads current value of the register and puts the data in R0.\n\nLetâ€™s go through the details of RCC_AHB1ENR register to understand which bits we need to modify.\n\nAs you can see, setting bit 3 of this register enables clock for GPIO-D. Hence we bitwise OR the contents of R0 to set this bit with the instruction . The suffix in this instruction tells the processor to OR the entire word.\n\nFinally the instruction stores the the contents of R0 to the address contained in R1, which is the address of RCC_AHB1ENR register in our case.\n\nYou can see that the code uses same pattern of instructions for all the registers. All we need to do is find out the required value for respective registers. Here are the layouts of registers we need to configure with the relevant bits.\n\nEach port pin associates with two bits in the mode register. With these two mode bits, we can configure the corresponding port pin in one of the four possible modes as listed below.\n\nAs shown in the layout, setting the bits to 01b configures the corresponding pin as an output. We need to bitwise AND to clear odd bits between 24 to 31 (AND with 0x55FF FFFF). In addition, we also need to bitwise OR to set even bits between 24 to 31 (OR with 0x5500 0000). Here is the code to update the mode register.\n\nThe output type register allows individual port pins output output configuration as either push-pull or open-drain type.\n\nSetting a bit configures open drain mode while clearing it configures the corresponding pin in open drain mode. Since we are going to use push-pull mode, we bitwise AND the register value with 0xFFFF 0FFF. This clears bits 12 to 15. Here is the code to update this register.\n\nThe output speed register allows us to configure the maximum output switching speed for the port pins. The actual maximum speed depends on other factors such as supply voltage, load capacitance etc. As per STM32F407 datasheet, the maximum speed in slow speed is between 2MHz to 8MHz. We configure the speed to slow mode because out blinking frequency (2 Hz) is much lesser than this.\n\nSetting the bits to â€˜00bâ€™ configures the corresponding port pins for slow speed. Thus here is the code that updates this register.\n\nSTM32F407 provides configurable internal pull-up / pull-down resistors for each pin. This register allows to enable or disable these internal resistors. We donâ€™t need any pull-up or pull-down to drive the LEDs.\n\nClearing the bits disables pull-up/pull-down for the corresponding pin. So we carry out a bitwise AND with 0x00FF FFFF to configure the pins. Here is the required code.\n\nAfter initialization, the main loop repeats these steps infinitely:\n\nTo turn on the LEDs, we need to write a 1 to the corresponding bit in register . In contrast, clearing the bit turns the LED off. The process of writing to is exactly same as we followed earlier to configure the registers. We read current value of and do a bitwise OR to set the bits, while a bitwise AND to clear the bits.\n\nThe delay loop is a blocking loop which decrements the DELAY_INTERVAL until it becomes zero.\n\nloads the value of DEALY_INTERVAL into register R2. instruction jumps to the label specified if the contents of specified register are zero. With , if R2 has become zero then the code will jump to label turnOFF and turn the LEDs off. Otherwise it continues to the next instruction which decrements R2 and stores the result back to R2. Next instruction is an unconditional branch instruction. The code simply jumps back to start of the loop with for the next iteration.\n\nThe delay loop executes 3 instructions repeatedly as many number of times as the DELAY_COUNTER value loaded in R2. We need to find out execution time for each of these instructions. We can then calculate total delay.\n\nThe first two instructions and take one cycle each to execute. Furthermore the unconditional branch instruction takes 3 cycles. As a result, we have a total of 5 cycles in one loop of the delay. You can get more details about instruction timing from the Technical Reference Manual for ARMV7-M (which the Cortex-M4 processor is based on) .\n\nWe have used the default internal 16MHz clock. Timing for one clock cycle is therefore 62.5 nsec. At this speed, one iteration of the delay loop will take (5*62.5) = 312.5 nsec . Rounding off to 313nsec, the number of loops for a 500msec delay is = 500msec/313nsec. This results into 1597444 decimal or 0x186004 in hexadecimal. We can ignore overhead of additional instructions since it is negligible compared to blinking interval.\n\nWe explored this small ARM assembly code to blink an LED using very few number of instructions. I must confess that this is neither a foolproof nor a good way to code. In particular the blocking delay loop is not the best use of processor. However, the purpose of this post was to get a fair idea of assembly language programming on an ARM processor. In real world applications, you will use exceptions, interrupts and much smarter ways of coding.\n\nProgramming in assembly helps you get intimate with the microcontroller hardware. As a result you get to learn more about internals of a microcontroller / processor. Assembly may not be the preferred choice when it comes to large complex programs due to the complications involved. Yet learning assembly programming does help in debugging and optimizing your code.\n\nIn conclusion, this code example can be a good base to learn assembly programming for ARM Cortex-M. As a suggestion, you can try switching on the 4 LEDs one by one with a time delay in between. You can also implement a binary counter from 0x0000 to 0xFFFF using the 4 LEDs.\n\nIn one of the next blog posts, I will explain how to make use of interrupts and avoid blocking processor. Till then stay tuned and do let me know your suggestions and comments about this post!"
    },
    {
        "link": "https://stackoverflow.com/questions/26832993/arm-assembly-cannot-access-gpio",
        "document": "First of all, I want to make sure you know this site. Get the \"Programming Manual\" from the left column, if you don't have it already. But what's more important is that you get the \"User's Manual\".\n\nNow, in order to get good documentation on the ARM Cortex-M instruction set (which is provided by ARM), go to the ARM Information Center and look in the Cortex-M4 Generic User Guide. There's also timing information in the Cortex-M4 Technical Reference Manual\n\nUnfortunately I cannot provide you with a direct answer to the problem, as I do not have experience with STM microcontrollers, but I can help you a little anyway.\n\nFor information on the GPIO pins, open the User's Manual (DM00031020.pdf) also called RM0090 and read Chapter 8.\n\nI also found a GPIO tutorial, which may be helpful.\n\nThough I have not yet used STM, I think they make fine microcontrollers; and it's not the worst documentation I've seen (so you're quite lucky).\n\nFrom what I can tell by reading the resources I've provided, you need to...\nâ€¢ Very important: Turn on clock power for the GPIO. If you don't, you can't access any registers; this could be what's wrong.\nâ€¢ Set the speed of the GPIO pins you're about to use (see the reference manual)\nâ€¢ Configure the pins (it seems you've got that under control)\nâ€¢ Write the pin values to change them or read the state of the pins.\n\nAs my knowledge aren't specific on this product, I can't really go much further. -But you may also find help at my.st.com and the ARM Connected Community"
    },
    {
        "link": "https://embetronicx.com/tutorials/microcontrollers/stm32/stm32-gpio-tutorial",
        "document": "This is the Series of tutorials on the STM32 Microcontroller. The aim of this series is to provide easy and practical examples that anyone can understand. Basically, you can write GPIO codes in multiple ways (Using HAL, the GPIO driver).\n\nUsing that HAL you can finish your job in very few lines of code. But I would suggest you, learn to program using the bare-metal code (without any HAL or driver) initially. This is the STM32 GPIO Tutorial without HAL.\n\nThe tutorial series covers STM32 microcontroller programming, focusing on GPIO operations without using the Hardware Abstraction Layer (HAL) or drivers. It aims to provide practical examples for easy understanding. The tutorials cover a variety of topics related to STM32 GPIO:\n\nThis tutorial aims to help beginners understand the basics of STM32 GPIO programming without relying on higher-level abstractions, making it suitable for those who want to learn the fundamentals of microcontroller interaction.\n\nYou can also read, Getting Started with STM32 RTOS, PIC16F877A GPIO tutorial, GPIO Linux device driver, and STM32 GPIO RTOS tutorial.\n\nBefore starting this STM32 GPIO Tutorial, Please go through the below tutorials.\nâ€¢ Create a New Project for STM32 in Keil\n\nIn this tutorial, we are going to see the timer for the below three STM32 controllers. If you have any one of the controllers or ARM cortex, you can use that. Please click the controller-specific tab and see the content properly.\n\nWe have our own EmbeTronicX Store called ChipTronicX. You can purchase the hardware from ChipTronicX.\n\nIn this post, we have used three microcontrollers (STM32F1, STM32F4, STM32F7) for demonstration. You can go to the section directly based on the microcontroller that you have.\n\nI think we have covered almost all the registers. Now we will just put them all together and make our hands dirty by playing with the LEDs. Letâ€™s dive into the programming part.\n\nYou can refer to the respective User manual for a better understanding.\n\nIn the below example, I am going to toggle the Onboard LED which is connected to the PC13. I have set the PC13 as an output. and toggling that with some delay. You can also find the complete project on GitHub. /***************************************************************************//** * \\file main.c * * \\details Blinking Onboard LED with some random delay - STM32 GPIO Tutorial * * \\author EmbeTronicX * * \\This code is verified with STM32411CE Board * *******************************************************************************/ #include \"stm32f4xx.h\" #define DELAY_COUNT ( 80000 ) /* delay count */ /***************************************************************************//** \\details Providing Delay by running empty for loop \\return void \\retval none *******************************************************************************/ static void delay( void ) { uint32_t i = 0; for( i=0; i<=DELAY_COUNT; i++ ); } /***************************************************************************//** \\details The main function. It should not return. \\return void \\retval none *******************************************************************************/ int main(void) { /* Enable the AHB clock all GPIO port C */ SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOCEN); /* set all Port C as output */ GPIOC->MODER = 0x55555555; /* Endless loop */ while(1) { /* Turn ON the LED of PC13 */ GPIOC->BSRR |= GPIO_BSRR_BS13; delay(); /* Turn OFF the LED of PC13 */ GPIOC->BSRR |= GPIO_BSRR_BR13; delay(); } } In the below example, I am going to toggle the Onboard LED which is connected to the PC13. I have set the PC13 as an output. and toggling that with some delay. You can also find the complete project on GitHub. /***************************************************************************//** * \\file main.c * * \\details Blinking Onboard LED with some random delay - STM32 GPIO Tutorial * * \\author EmbeTronicX * * \\This code is verified with STM32F103CBT6 Board * *******************************************************************************/ #include \"stm32f10x.h\" #define DELAY_COUNT ( 80000 ) /* delay count */ /***************************************************************************//** \\details Providing Delay by running empty for loop \\return void \\retval none *******************************************************************************/ static void delay( void ) { uint32_t i = 0; for( i=0; i<=DELAY_COUNT; i++ ); } /***************************************************************************//** \\details The main function. It should not return. \\return void \\retval none *******************************************************************************/ int main(void) { /* Enable the APB clock all GPIO port C */ SET_BIT(RCC->APB2ENR, RCC_APB2ENR_IOPCEN); /* PC13 as output */ GPIOC->CRH &= ~(GPIO_CRH_MODE13|GPIO_CRH_CNF13); /* Clear MODE13 and CNF13 fields */ GPIOC->CRH |= GPIO_CRH_MODE13_1|GPIO_CRH_MODE13_0; /* Set MODE13 to 3 (Output) */ /* Endless loop */ while(1) { /* Turn ON the LED of PC13 */ GPIOC->BSRR |= GPIO_BSRR_BS13; delay(); /* Turn OFF the LED of PC13 */ GPIOC->BSRR |= GPIO_BSRR_BR13; delay(); } } In the below example, I am going to toggle the Onboard LEDs which are connected to PB0 (Green LED), PB7 (Blue LED), and PB14 (Red LED). I have set the PB0, PB7, and PB14 as output, and toggling those with some delay. You can also find the complete project on GitHub. /***************************************************************************//** * \\file main.c * * \\details Blinking Onboard LED with some random delay - STM32 GPIO Tutorial * * \\author EmbeTronicX * * \\This code is verified with STM32F767Zi Nucleo Board * *******************************************************************************/ #include \"stm32f7xx.h\" #define DELAY_COUNT ( 80000 ) /* delay count */ /***************************************************************************//** \\details Providing Delay by running empty for loop \\return void \\retval none *******************************************************************************/ static void delay( void ) { uint32_t i = 0; for( i=0; i<=DELAY_COUNT; i++ ); } /***************************************************************************//** \\details The main function. It should not return. \\return void \\retval none *******************************************************************************/ int main(void) { /* Enable the AHB clock all GPIO port B */ SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOBEN); /* set Port B as output */ GPIOB->MODER |= 0x55555555; /* Set Port B as Push Pull */ GPIOB->OTYPER = 0x00000000; /* Set Low Speed */ GPIOB->OSPEEDR = 0x00000000; /* Endless loop */ while(1) { /* Turn ON the PB0 (Green LED), PB7 (Blue LED), PB14 (Red LED) */ GPIOB->BSRR |= GPIO_BSRR_BS0 | GPIO_BSRR_BS7 | GPIO_BSRR_BS14; delay(); /* Turn OFF the PB0 (Green LED), PB7 (Blue LED), PB14 (Red LED) */ GPIOB->BSRR |= GPIO_BSRR_BR0 | GPIO_BSRR_BR7 | GPIO_BSRR_BR14; delay(); } }\n\nPlease find the output of the example below.\n\nI have connected the button to the PA0 (Port A.0) and the LED to the PC13. You can also find the project on GitHub. /***************************************************************************//** * \\file main.c * * \\details Setting Port A0 as input and PORT C13 as output. * When we press the Port A0, we will turn on the LED in * PC13 - STM32 GPIO Tutorial * * \\author EmbeTronicX * * \\This code is verified with STM32411CE Board * *******************************************************************************/ #include \"stm32f4xx.h\" /***************************************************************************//** \\details The main function. It should not return. \\return void \\retval none *******************************************************************************/ int main(void) { /* Enable the AHB clock all GPIO Port C and Port A */ SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOCEN); SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOAEN); /* set Port C13 as output */ GPIOC->MODER &= ~( GPIO_MODER_MODER13 ); /* Clear MODER13 fields */ GPIOC->MODER |= ( GPIO_MODER_MODER13_0 ); /* Set MODER13 to 1 (Output) */ /* set Port A0 as input */ GPIOA->MODER &= ~( GPIO_MODER_MODER0 ); /* Clear MODER0 fields to 0 (input) */ /* Enable Pullup on PA0 */ GPIOA->PUPDR &= ~( GPIO_PUPDR_PUPDR0 ); /* Clear PUPDR0 fields (No Pullup, No Pull down) */ GPIOA->PUPDR |= GPIO_PUPDR_PUPDR0_0; /* Set PUPDR0 fields to 0x01 (Pullup) */ /* Endless loop */ while(1) { /* Button is connected to PA0. So we need to check bit 0 of IDR register. */ if( ( GPIOA->IDR & GPIO_IDR_ID0) == GPIO_IDR_ID0 ) { /* Turn ON the LED of PC13 */ GPIOC->BSRR |= GPIO_BSRR_BS13; } else { /* Turn OFF the LED of PC13 */ GPIOC->BSRR |= GPIO_BSRR_BR13; } } } I have connected the button to the PA0 (Port A.0) and the LED to the PC13. You can also find the project on GitHub. /***************************************************************************//** * \\file main.c * * \\details Setting Port A0 as input and PORT C13 as output. * When we press the Port A0, we will turn on the LED in * PC13 - STM32 GPIO Tutorial * * \\author EmbeTronicX * * \\This code is verified with STM32F103CBT6 Board * *******************************************************************************/ #include \"stm32f10x.h\" /***************************************************************************//** \\details The main function. It should not return. \\return void \\retval none *******************************************************************************/ int main(void) { /* Enable the APB clock all GPIO Port C and Port A */ SET_BIT(RCC->APB2ENR, RCC_APB2ENR_IOPCEN); SET_BIT(RCC->APB2ENR, RCC_APB2ENR_IOPAEN); /* PC13 as output */ GPIOC->CRH &= ~(GPIO_CRH_MODE13|GPIO_CRH_CNF13); /* Clear MODE13 and CNF13 fields */ GPIOC->CRH |= GPIO_CRH_MODE13_1|GPIO_CRH_MODE13_0; /* Set MODE13 to 3 (Output) */ /* PA0 as input with pullup */ GPIOA->CRL &= ~(GPIO_CRL_MODE0|GPIO_CRL_CNF0); /* Clear MODE0 and CNF0 fields */ GPIOA->CRL |= GPIO_CRL_CNF0_1; /* Set CNF0 to 10 (Input with pullup/pull down) */ GPIOA->ODR |= GPIO_IDR_IDR0; /* pull-up PA0 */ /* Endless loop */ while(1) { /* Button is connected to PA0. So we need to check bit 0 of IDR register. */ if( ( GPIOA->IDR & GPIO_IDR_IDR0 ) == GPIO_IDR_IDR0 ) { /* Turn ON the LED of PC13 */ GPIOC->BSRR |= GPIO_BSRR_BS13; } else { /* Turn OFF the LED of PC13 */ GPIOC->BSRR |= GPIO_BSRR_BR13; } } } I have connected the button to the PC13 (Port C.13) and LED to the PB0, PB7, and PB14. You can also find the project on GitHub. /***************************************************************************//** * \\file main.c * * \\details Setting Port B as output and PORT C13 as input. * When we press the Port C13, we will turn on the PB0, PB7, PB14 - STM32 GPIO Tutorial * * \\author EmbeTronicX * * \\This code is verified with STM32F767Zi Nucleo Board * *******************************************************************************/ #include \"stm32f7xx.h\" /***************************************************************************//** \\details The main function. It should not return. \\return void \\retval none *******************************************************************************/ int main(void) { /* Enable the AHB clock all GPIO Port B and Port C */ SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOBEN); SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOCEN); /* set Port B0, B7, B14 as output */ GPIOB->MODER &= ~( GPIO_MODER_MODER0 | GPIO_MODER_MODER7 | GPIO_MODER_MODER14 ); /* Clear MODER0, MODER7, MODER14 fields */ GPIOB->MODER |= ( GPIO_MODER_MODER0_0 | GPIO_MODER_MODER7_0 | GPIO_MODER_MODER14_0 ); /* Set MODER0, MODER7, MODER14 to 1 (Output) */ /* set Port C13 as input */ GPIOC->MODER &= ~( GPIO_MODER_MODER13 ); /* Clear MODER13 fields to 0 (input) */ /* Disable Pullup/Pulldown on PC13 */ GPIOC->PUPDR &= ~( GPIO_PUPDR_PUPDR13 ); /* Clear PUPDR13 fields (No Pullup, No Pull down) */ /* Set Port B as Push Pull */ GPIOB->OTYPER = 0x00000000; /* Set Low Speed */ GPIOB->OSPEEDR = 0x00000000; /* Endless loop */ while(1) { /* Button is connected to PC13. So we need to check bit 13 of IDR register. */ if( ( GPIOC->IDR & GPIO_IDR_ID13) == GPIO_IDR_ID13 ) { /* Turn ON the PB0 (Green LED), PB7 (Blue LED), PB14 (Red LED) */ GPIOB->BSRR |= GPIO_BSRR_BS0 | GPIO_BSRR_BS7 | GPIO_BSRR_BS14; } else { /* Turn OFF the PB0 (Green LED), PB7 (Blue LED), PB14 (Red LED) */ GPIOB->BSRR |= GPIO_BSRR_BR0 | GPIO_BSRR_BR7 | GPIO_BSRR_BR14; } } }\n\nPlease find the output of the example below.\n\nIf you want to use RTOS in STM32, you can refer to the STM32 GPIO with the RTOS tutorial. In our next tutorial, we will see the STM32 Timers and their registers with examples.\n\nPlease read the other STM32 Tutorials.\n\nYou can also read the below tutorials."
    },
    {
        "link": "https://svenssonjoel.github.io/pages-2021/cortex-m-assembler-4-clocks/index.html",
        "document": "When starting up the STM32F4-Discovery board (bare metal), it will not be configured to run at full potential. So in this post we will try to configure the MCU to run at 168MHz, which is what the STMF32F407 should be capable of. I noticed that the STM32F411 on the other hand maxes out at 100MHz, this is the MCU on my other discovery board. So, it is good to know if one has a STM32F407G-DISC1 or a STM32F411E-DISC0. I guess most of what we do here today will be in essence the same on all STM32F4 but the various speeds one can configure differ, so the details will be different on different boards.\n\nI think that knowing the speed of MCU may be an important thing going onwards. Say for example we want to talk to some external device and there is a timing aspect to that interface. To handle such things we need to be able to set up some ways to perform delays of a known duration or perhaps to measure time. Anyway! this post will just be about that attempt on configuring the clock, saving the rest for later.\n\nNow, a bit of a disclaimer, I am not an expert and you should not follow this as \"THE WAY\" to do things. This statement holds true for all my posts. I am just an enthusiast that experiments and shares my experiences in doing so.\n\nThe \"research\" used as a base for the code produced in this post comes from A LOT of reading in the reference manual together with LOADS of googling. Clock configuration seems to be a concept surrounded by a mist of mystique and there is a lot of confusing information out there. It feels like there is a lot of \"the blind leading the blind\" going on and unfortunately this post is no different. So please if you are an expert in this and you see a way to improve the presentation, all your hints tips and feedback will be much appreciated. If you are noob, like me, and trying this out on a board of your own, please share your experience as well. Together we learn more.\n\nPage 260 of the reference manual shows the clock tree of the STM32F4. This picture shows generated clocks pointing towards the right side of the picture and more-of-like \"IO\" functionality along the left edge. The middle is full of MUXes and logic. It is this middle area that we are going to be configuring.\n\nThe code we will write is concerned mostly will the following concepts from the clock tree:\nâ€¢ HSE oscillator. You find this along the left edge of the clock tree picture and it has an OSC IN and an OSC OUT signal. This is the clock signal generated by an external oscillator on the board.\nâ€¢ HSI oscillator. Is a 16MHz clock integrated into the MCU. This is what clocks the system after a reset until the clock tree is reconfigured.\nâ€¢ PLL. The PLL or \"phase locked loop\", is a box also towards the left in the picture. The PLL is used to transform an input clock signal in different ways. For example, there is the multiplicative factor and , and divisors. There is also a divisor on the input to the PLL, called . The input to the PLL is either or .\nâ€¢ The MUX in the middle controlled by\nâ€¢ The AHB and the APB1 and APB2 prescalers.\nâ€¢ SYSCLK. Right between the -MUX and the AHB prescaler there the note \"SYSCLK\".\n\nNon-essential, but very helpful for debugging, is to also look at the following concept.\nâ€¢ MCO2 is connected to a MUX that can be used to select a clock signal. One of the signals that can be selected is SYSCLK. MCO2 is connected to GPIO PC9 and provides a way to measure the clock frequency of the system using an oscilloscope. The GPIO cannot really handle 168MHz though (and neither can my oscilloscope), so the MCO2 unit will also apply a division to the frequency before feeding it out. The photos below show the setup for measuring the MCO2 signal.\n\nSo the goal here is to get the PLL to generate a 168MHz clock and to use the external crystal (HSE) as the input clock. A goal on the side is to also generate a 48Mhz clock (the PLL48CK in the clock tree picture as I understand it). This 48MHz clock is needed for USB for example. My understanding of those aspects is quite vague at the moment and we probably wont try to use USB anytime soon.\n\nInvolved in configuring this clock setup are the registered listed below.\nâ€¢ RCC_CR: RCC clock control register is described on page 224 of the reference manual.\nâ€¢ RCC_CFGR: RCC clock configuration register is described on page 165.\nâ€¢ RCC_PLLCFGR: RCC PLL configuration register is described on page 226.\n\nWe will also make use of registers:\nâ€¢ FLASH_ACR: FLASH access control register. Need to tweak this to set a wait-states number. As we run the CPU faster an access to the flash will take more clock cycles.\nâ€¢ RCC_AHB1ENR: AHB1 peripheral control register. Use this to active GPIO C.\nâ€¢ GPIOC_AFRH: GPIOC alternate function high register. Used to configure alternate function of PC9.\n\nRCC_CR is used to turn HSE and PLL on and also to poll their state. RCC_CFGR holds configuration information related to the AHB, APB1 and APB2 prescalers as well MCO configuration and status and control signals for the MUX controlled by the signals. RCC_PLLCFGR is where you can set the multiplier and divisor ratios for the PLL as well as selecting the input source of the PLL. To make all these registers a bit easier to work with let's define some constants.\n\nThe directive and some equates\n\nThe directive is used to define a name for a constant that you can later refer to in the assembler code. In earlier posts in this series we have seen code such as this:\n\nwith an we can make code like that much more readable.\n\nThe memory footprint and the cost of executing the two programs above are exactly the same. The benefit, however, is that the code is slightly more readable and somewhat self-documenting.\n\nSo to start out, the following declarations can be used to set up nice names for all the registers we will access.\n\nI also set up a bunch of s for some bit positions and a bit mask that will be used.\n\nThe reference manual states that in the RCC_PLLCFGR there are a bunch of \"reserved\" bits that should not be altered. The has a 1-bit on all of the locations of those \"reserved\" bits. This mask can be used to clear all the bits that we are allowed to change in the RCC_PLLCFGR register.\n\nThen there are some s with a 1-bit at the location of an enable or ready bit in the RCC_CR register. These will be used to turn on HSE, PLL and to poll for their respective ready state.\n\nLastly an that defines a name for the otherwise magical number representing the number of cycles to spend in a delay loop. The delay loop is only used in the code to blink a set of LEDs, it is not essential to the clock configuration.\nâ€¢ Configure the FLASH_ACR to introduce wait-states on the flash accesses.\nâ€¢ Configure the RCC_CFGR to output SYSCLK onto the MCO2 (so we can measure it using an oscilloscope).\nâ€¢ Set the AHB, APB1 and APB2 prescalars. My understanding is that what we set these to have no impact on the SYSCLK at all. So I have not looked very deeply into what it is they are for. It seems various peripherals may depend on these but we can look at that as they become interesting. For now I am going to set AHB prescaler to \"do not divide\", APB1 to divide by 4 and APB1 to divide by 2. These are number I have seen used when googling this topic.\nâ€¢ Turn on the HSE and wait for it to report it is RDY.\nâ€¢ Configure the PLL for 168MHz PLL and 48MHz PLL48CK and set the HSE as source.\nâ€¢ Enable PLL and wait for it to report it is RDY.\nâ€¢ Make PLL source for the SYSCLK and wait for that setting to take effect.\n\nStep 5, to configure the PLL for 168MHz and PLL48CK for 48MHz is done by setting values N, M, Q and P. M divides the input clock signal and the reference manual states that the input the PLL should be 1 - 2MHz. The external crystal on the discovery board is 8MHz, so to get 1MHz we should divide by 8. So let's do M = 8. The next interesting bit is that P divides the output from the PLL and this P value can only be set to 2,4,6 or 8. That is, there is no option to not divide the output. This means that the N value must be set to 336 to get a 168MHz clock out of the PLL with input div M = 8. So this sets up the PLL clock signal frequency as (8 / 8) * 336 / 2 = 168MHz. The PLL48CK clock, now, has to be derived from that 336MHz, this can be done by a division by 7 so PLLQ will be set to 7.\n\nAnother way to set the up the PLL would be like this, (8 / 4) * 168 / 2 = 168MHz but then there would be no way to obtain the PLL48CK clock since 168 / 48 = 3.5. The reference manual states that it would be better to have an input frequency of 2MHz to the PLL, but with that input clock it is not possible to run the SYSCLK at 168MHz and the PLL48CK at 48MHz.\n\nNow I think we should jump in the code!\n\nAs usual a lot of the code is similar to the code written in the previous post in the series. So let's jump directly to the point where the new stuff happens. Also, the complete source code will be given in full further down. Assume that we have all the s from the previous section.\n\nThe clock configuration code is run in the reset_handler right after a label called .\n\nJust like \"the plan\" stated we start out by tweaking the FLASH settings. The code above sets the bits 0 - 3 to the value 5 (5 wait states) and the bits 8, 9 and 10 are each set to one, this corresponds to the value loaded into r2 above. Bits 8,9 and 10 enables instruction cache, data cache and prefetch.\n\nThe reference manual claims that the \"reset value\" of the FLASH_ACR register is 0 (that is, all zeroes) as I understand it. As this code is the first thing we do to FLASH_ACR I assume it to be zero and there is no need to clear any bits before ing in the new values.\n\nNext we load the address of RCC_CFGR into r0 and starts to build a value in r2 that we can or into that register.\n\nThe first part sets the MCO2 settings to output SYSCLK / 5. The shift left by 27 bits comes from the reference manual and points out where the bits of the RCC_CFGR that correspond to MCO2 are.\n\nThen PPRE0 and PPRE1 configuration values are set. These are those prescalers related to APB1 and APB2 we talked about earlier.\n\nThe AHB prescaler will be set to 0x0, that is we wont put any value at all into RCC_CFGR related to that and thus there is no code above to deal with that aspect.\n\nThe instruction writes the settings we have created in r1 back into the RCC_CFGR register.\n\nBy now we have performed also step 2 and 3 of \"the plan\".\n\nNext in line is to turn on the HSE and this is done by writing a bit into the RCC_CR register.\n\nAfter writing the HSE_ON bit we should wait until a HSE_RDY flag turns on.\n\nThe code above loads the contents of RCC_CR into r1 and then turns HSE on (sets a bit) and then writes r1 back to RCC_CR. Then a loop executes that poll the HSE_RDY bit in every iteration until it is set.\n\nSo now it is time for step 5 where we actually set up for our 168MHz clock! This step starts out by loading RCC_PLLCFGR into r1 and then clears all bits that are not in the RESET_KEEP_MASK that we defined in the section.\n\nThe code above set the N, M, Q and P factors as derived in \"the plan\" section. The P factor is going to be set to 0, so there is no code for that explicitly here. Those P bits are already cleared as a result of the initial clearing of all non-keep bits. The shift values used ( instructions) can all be found in the reference manual.\n\nIn the code above the HSE is also set as the source for the PLL, just before storing the new configuration back into the RCC_PLLCFGR register.\n\nThat is the end of step 5.\n\nThe next step should enable the PLL in a process very similar to how we started the HSE.\n\nThe code above loads the RCC_CR into r1 and then sets the bit that enables the PLL. After setting the enable pin we go into loop that polls the PLL_RDY bit.\n\nLast step. In RCC_CFGR there are two bits that sets what to use the source of the SYSCLK. This is that very central MUX of the clock tree, the one with the control input. After setting a value on the control we should wait until that pattern is duplicated on another pair of pins and that is what the code below should be doing.\n\nPhew! Very obscure but there it is. At least my understanding of \"it\", is there.\n\nLastly, we should also configure PC 9 to use alternative function 0. This is done by first enabling GPIO C in the RCC_AHB1ENR register then setting up the GPIOC_MODER register so that PC9 is set to use alternatice function. Following that one should make sure that the GPIOC_AFRH is set so that PC9 is configured for alternative function 0. The alternative function is described using 4 bits, this is why there is a LOW and a HIGH alternative function register, just because a single 32bit register cannot hold 4 configuration bits for all 16 of GPIOC pins.\n\nI placed this configuration of GPIOC following the \"main\" label.\n\nBelow you can find the complete assembly code listing:\n\nFun stuff! I am pretty sure my MCU now runs at 168 MHz given that the oscilloscope output reads 33.6Mhz and 33.6 * 5 = 168. Remember that the MCO2 divisor was set to 5. Of course, the AHB, APB1 and APB2 are still a bit mysterious but once we need to understand that I am sure we can make it happen.\n\nWriting assembly is quite annoying, very error prone and very tedious. So, I hope to look at the following things soon so that we can build some abstractions.\n\nNow that we know how fast our MCU is going it would also be nice to try to come up with some more clever ways of doing delays. Would also be fun to see if we can set up a regularly occurring interrupt and fire off some interesting code every N time units.\n\nThe code is available at GitHub.\n\nThanks a lot for reading. I hope you are well and have a good day. As usual I would love to hear feedback, hints, tips, your experience... yeah anything. Be well!\n\nPlease contact me with questions, suggestions or feedback at blog (dot) joel (dot) svensson (at) gmail (dot) com or join the google group .\n\nThis page was generated using Pandoc."
    },
    {
        "link": "https://community.st.com/t5/stm32-mcus-products/assembly-code-example/td-p/533908/page/2",
        "document": "I got to M3 from ARM7/9, I have a bunch of ARM926 SoC and STR7, STR9 in there too, and it pushes some 30 years back from that to the original Acorn designs that ARM sprang from. I've worked through a lot of the ARM TRM's and found Joseph Yiu's book on the Cortex-M3 as a good contrasting source to those manuals.\n\nA technique I use, and another colleague better described, is triangulation, ie take a lot of books and documentation, digest/skim, and then establish a view based on multiple perspectives. And also leveraging existing knowledge into new spaces.\n\nI guess the clever tricks with ARM's ISA relate to the shifts and register side effects that make the instructions so powerful.\n\nMy mind's pretty fogged up with assembler for several dozen micros, so I'm probably not the best person to ask ''how do I start''. The assembler stuff I'm best known for is x86, but not many prospects there.\n\nMaybe the best way would you to kick out a few ideas of what examples or snippets might be immediately helpful, and would fit in 50-100 lines, and work through those as building blocks you and others can apply."
    },
    {
        "link": "https://stackoverflow.com/questions/68074054/stm32f407-assembly-str-not-writing-into-memory",
        "document": "You need to enable gpioc first in the RCC.\n\nThen you can:\n\nNote/FYI this is likely NOT to work due to a race condition:\n\nOne needs some number of clocks between the enable and that clock enable spinning up the gpio, but this should work\n\nOr just do things sequentially as above (prep the write with a few instructions).\n\nJust use binutils there is no reason to mess with gcc at all.\n\nVectors look good, it will not hang immediately\n\nI hate the unified syntax with a passion, certainly with binutils, but writing this:\n\nwithout the unified syntax under gnu assembler, actually produces the subs not sub and that confuses people (and they comment). So I used unified syntax above. If you are starting out probably should just enable unified syntax and learn it that way, sigh. (for where you are now, just enable it with that one line up front somewhere and keep doing what you are doing).\n\nI have no use for gdb but perhaps it works there too, but if you telnet into openocd you can certainly do this: Either defeat your code by having reset go right into an infinite loop, or depending on the debug tool just reset and not start the code, but then you can write these control registers over the debug interface and see them work before you write the code to do the same thing. One can save some time (or can take longer, depends on your coding/debugging style).\n\nand you should see the 0x4 there.\n\nThen mess with 0x40020818 to change the state of the output pin.\n\nDMA is not relevant here. You have the processor then its main ahb/etc bus and that goes through memory controller and other busses probably and such until it hits the logic that handles that control register. Then the enable for that clock goes through some number of gates to get to the clock enable for that logic block (gpioc in this case). It might take at least one clock for the enable to be latched and then probably at least another peripheral clock cycle to enable the clock gate to allow the clock through to the gpio. Now a particular contributor here would normally make this comment when seeing code like this. And some but not all of the STM32 documents specifically tell you how many us or ms you have to delay.\n\nWrites can be fire and forget, the address and data is part of the transaction, and the first level memory controller closest to the chip can technically take those two items and tell the processor the write is complete (even though it is not) allowing it to do the next thing (another STR for example). Something like the clock control logic and a peripheral like a GPIO may or may not be down the same set of busses, but eventually they split off.\n\nJust like sending two letters from your house to two addresses in the same town, you write the addresses on the envelope, put them in the mailbox, as far as you are concerned they are sent, you can go back in the house and do something else. These two might ride in the same trucks and planes all the way to the same post office in that destination town, but eventually will get split up and take different paths which can take a different amount of time.\n\nThis is called a race condition and they are very real and they happen more than we would like, but this is not something to start to panic about or worry about every time something does not work. In general the vendor will indicate in the docs or an errata that there is a race condition. Race as in track and field in the Olympics, a marathon, NASCAR, two or more things trying to get to the finish line first or in this case in order.\n\nThis is why simply removing a printf in some code, can have devastating results, as that printf caused a big delay between the thing before and after. Removing the delay, can cause a race.\n\nIt is not uncommon to have this specific situation where you have a control block, like a clock enable or something that controls address decoding (say you had a region of the processors address space that you can per their design point at something, but if you change what it points at then immediately try to talk the thing you just told it to point at you might have a race condition).\n\nWrites are fire and forget, but reads have to go all the way to the peripheral and back, so the worst case time/path. Now I have worked on logic where the read path and write path split and you can have a race there too, but more of an exception not the rule. So if you for example write some control register, then read it back, one would hope the designers serialize this and the read happens after the write, it does a complete trip to the peripheral and back, so by the time it comes back and lets the processor continue, that register is definitely written.\n\nIn this case you have the possibly delay for the write to the rcc plus possibly different buses to get at the rcc vs the gpio causing possible timing differences, allowing for this race.\n\nOn the part you have or on other stm32 parts, you can try the experiment hinted to above. do the rcc enable with a STR, then the next instruction do a STR to moder to change the pin to an output, then you can take your time to change the state of the pin to say turn an led on. If it does work when you have some number of clocks delayed between the stores, but does not work when they are back to back. There you go.\n\nThe great mystery is why does the read work, STR, LDR, STR worked on the chips I found a race condition for. That does not make sense. The next great mystery is that if you read the moder registers that are non-zero, ones that you can get a good feel that you are actually reading that register (GPIOA and GPIOB moder in this case), with the gpio disabled in the rcc clock enable. The correct value comes back. This seems like a hack to me to get around the race condition. This could very well be a case of they had some number of chips they had a library that is already out there being used, then the next chip is in design and does not work, not going to go and force a new update of the hal for everyone for this one part when you can make a quick solution in the design.\n\nSo I only tested a handful of different parts but\n\nWorked for the parts where\n\nSo let us think about say a PWM controller or a UART that have a small buffer, maybe only one value being used for that transaction/period and one value sitting in a transmit buffer waiting to be next. You as the programmer MIGHT depending on the design, have a few choices, have a loop of code that polls status registers waiting for an indication that says the holding register value is now being transmitted, and is now \"empty\". And then you ideally want/need to write the new value before the prior value is completely transmitted or that time period of the pwm or whatever happens.\n\nYou need to burn a lot of processing time if you want to keep the output of the peripheral at line rate or with no gaps or repeats or whatever that peripheral does. Now if your application is not doing anything else, and I will strongly argue if you are learning to use this peripheral, this is where you start. But the next option might be an interrupt you setup a handler and when the interrupt happens you pull from a larger buffer you are maintaining (in ram) to feed this peripheral, if you can insure that the handler is fast enough and no other higher priority things delay the handler starting (real time) then this will work.\n\nThe third thing which is not always available is DMA. You in some way tell the peripheral or a third party dma controller, that here is the block of data I want to send, and here is where I want it sent, the logic has to be designed with a connection to trigger the dma, causing one or whatever number of items to move into the peripheral. There can still be contention that causes delays and a race condition, but this is your best bet if you want/need to feed something into a peripheral every cycle.\n\nA same similar concept where you hear about dma and folks also think this one is free to as it magically happens in the background and does not affect the processor. Say a memory transfer, setup a DMA engine that may be part of some system to do a transfer or data from one place to another, rather than having to do a memcpy or some other such thing (often used for things like moving a frame of pixel data to a video card or some other such thing, these days the video cards do a lot of the work for you generating pixels). Some systems this was free, many others it was not as it uses the same buses, so it causes the processor to have to stall if the bus is being used by the dma engine, definitely affecting the processor.\n\nI have seen some where the processor is stopped/stalled completely while the dma transfer is happening, and I saw one wasteful one where the bus was some three quarters thing, at all times there was a clock cycle every so many that was reserved for dma if you happened to want to do a transfer and that cycle/block of time would then get used. Basically you were always being affected by the dma even if it was not happening (that was a DSP where execution consistency is very important and clearly more important than having code go as fast as you can).\n\nDMA is used for many things, the m is wrong it does not always mean memory, it might be from one fifo (okay technically an sram) to some peripheral. It generally means, despite the name, another bus controller that can initiate bus transactions so that you do not have to create those transactions through the main processor via code.\n\nHonestly you are not ready for DMA yet, nor interrupts. Poll your way through, create lots of throwaway code, even if you are working toward a specific project. For each peripheral for each feature you are going after, create one or more ad-hoc applications and figure out how that thing works. If you get into a mystery situation where everything is working and you add or remove even a single line of code that should have absolutely nothing to do with it and the thing breaks then if it were compiled code then question the output of the compiler, examine it.\n\nIf it is asm (or high level) it could be a race condition of some sort (it could be something else). They really are rare, often documented (eventually), BUT when they strike they can take a long time to figure out and sometimes you never are really sure but adding a delay fixed it, or reading the thing three times and taking the two that match, or whatever hack, and you move on with life. I was just warning you about something very real about a percentage of these STM32 designs. That could lead you to the same head scratching as what brought you here in the first place."
    },
    {
        "link": "https://controllerstech.com/stm32-gpio-input-configuration",
        "document": "In the previous tutorial, we covered how to use the GPIO pin as output using Registers. This tutorial will cover how to configure the pin as input, and then how to read itâ€™s state.\n\nI will use a button to read the input state of the pin. In order to configure the pin in the input mode, we need to follow the steps mentioned below /************** STEPS TO FOLLOW ***************** 1. Enable GPIOA clock 2. Set the PIN PA5 as input 3. Configure the Pull UP / Pull Down mode ************************************************/ The GPIO clock can be enabled in the RCC_AHB1ENR Register As you can see above, the 0th bit of RCC_AHB1ENR Register enables the clock for the GPIOA. Thatâ€™s why we need to write a 1 in the 0th position To configure the pin as input, we will modify the GPIOx_MODER Register. This register is responsible for configuring different modes for the GPIO, and in this case we will configure it as the input mode Since I am using pin PA1, I need to modify the pins 2 and 3. This basically works like, if the PIN is â€˜yâ€˜, the we need to configure the bits â€˜2yâ€™ and â€˜2y+1â€™\n\nAlso, in order to set the pin as input, we need to set the bits (3:2) as 0:0. This means that we need to write a â€˜0â€™ in the 2nd and 3rd positions I am going to configure the pin as the Pull-Up pin. The reason for the same is that the button is connected as shown below When the button will be pressed, the current from the PA1 will sink into the ground, and the PA1 will go LOW To configure the Pull UP / Pull DOWN, we need to modify the GPIOx_PUPDR Register As we need to configure the Pull-UP for the the pin PA1, we need to modify respective bits (3:2). I want to set the Pull-up here, so i need to configure the bits (3:2) as 0:1 Thatâ€™s all for the configuration of the GPIO as input pin. To configure the Pin as the input in F1 series, the steps are shown below /*************>>>>>>> STEPS FOLLOWED <<<<<<<<************ 1. Enable GPIO Clock 2. Set the required Pin in the INPUT Pull-up/ Pull-down Mode 3. Configure the ODR (1-> Pull UP, 0-> Pull down) ********************************************************/ Letâ€™s cover them all one by one Since we are using the pin PA1 as the input, The GPIOA clock can be enabled in the RCC_APB2ENR Register As you can see the 2nd bit of APB2ENR Register controls the GPIOA Clock. So to enable the clock, we will write a â€˜1â€™ in this position To control the mode of the pin, we need to modify the Control Register GPIOx_CR This Control Register is divided into 2 Registers of 32 bits each i.e CRL(pins 0 to 7) and CRH(pins 8 to 15). Since we are using PA1, we will modify the CRL Register\nâ€¢ As you can see above, each pin can be controlled using the 4 bits. For PA1, these bits are 7:6:5:4\nâ€¢ The lower 2 bits can be used to select the mode i.e output or input\nâ€¢ The Higher bits can be used to configure this mode\nâ€¢ Also note that the reset state for the CNF bits is 0:1, so we need to clear the bits before setting a new value there Here we have selected the input mode with Pull-up/Pull-down mode, but to select the either mode, there is no special register here. This description is provided in the table 20: Port bit configuration table as per the instructions in the picture above. This table can be seen below To set the Pull-up register, we need to write a â€˜1â€™ in the Output Data Register (GPIOx_ODR) GPIOA->ODR |= (1<<1); // --> PA1 is in Pull UP mode This completes the GPIO Configuration for the F1 Series How to Read the Pin State To read the state of the pin, we will check the Input Data Register (IDR) IDR is a read only register. The respective bit either set or reset depending on the state of the PIN. Now since I am using the Pull-UP for pin PA1 here, the 1st bit of IDR will always be HIGH. When the button is pressed, the current from PA1 will sink into the ground, and the pin will be LOW, and so does the bit 1. So basically we wait for the 1st bit of the IDR to go LOW. And when it is low, indicating the button has been pressed, we can do the processing. int count = 0; int main () { SysClockConfig (); GPIOConfig (); while (1) { if (!(GPIOA->IDR &(1<<1))) { while (!(GPIOA->IDR &(1<<1))); count++; } } } Here we check for the bit 1 of the IDR, if it is low, we increment the count variable.\n\nSo whenever the button is pressed, the count variable will increment As you can see above, the count variable increments to 9, indicating the button has been pressed 9 times You can help with the development by Below.\n\nTo download the project, click the button."
    },
    {
        "link": "https://iotality.com/blink-led-arm-assembly",
        "document": "If you are like me, you always have the urge to understand ARM Cortex-M architecture in more details. You want to write a small code in assembly language to reach closer to the hardware. But you struggle to find a good how-to-guide for assembly programming. Most of the examples you find are written in higher level languages like C/C++. Donâ€™t give up yet. Read on this post which will help you take the first step in learning ARM assembly programming.\n\nAfter exploring how startup code works for an STM32F4 microcontroller, it is now time to do something useful. For an embedded system, the time tested tradition for saying Hello World! is to blink an LED. Keeping with the tradition, letâ€™s try to blink an LED in ARM assembly. Using the STM32F4 Discovery board, we will see how to blink all the on-board LEDs.\n\nThings you need to blink an LED in ARM Assembly\n\nYou will need a few things in order to enjoy coding in ARM assembly.\nâ€¢ None Software - KEIL MDK - The code presented here uses ARM assembler instead of GNU assembler. The ARM assembler is part of MDK (Microcontroller Development Kit) toolchain. The MDK-ARM bundles the toolchain, uVision IDE and required software packs. You can download the Lite edition from Keil website for free.\nâ€¢ None Hardware - STM32F4 discovery board - The STM32F4 Discovery board from ST Micro is based on STM32F407VGT6, an ARM Cortex-M4 microcontroller. The board provides 4 user controllable LEDs in addition to other peripherals. An ST-Link debugger on-board helps you flash and debug your code, single step through it from within Keil IDE. We will blink all these 4 LEDs with our ARM assembly code.\n\nNote: If you donâ€™t have discovery board, you can use the simulator in Keil IDE. This post however sticks to using the discovery board.\nâ€¢ Documents - I refer to these documents while explaining code in this post. These documents are also available from within Keil uVision IDE from the Books tab in project window.\n\nBefore we understand the assembly code to blink an LED, letâ€™s directly go to the execution phase. To make it easier for you, the source code and instructions to execute code are available on GitHub.\n\nEssentially the steps to execute the code are:\nâ€¢ Install Keil MDK Lite and open the project in Keil uVision\nâ€¢ Build and download code to the board and see the LEDs blinking\n\nSo, go ahead and clone the GitHub repo, follow the README and see yourself all 4 LEDs on board blinking at 500msec interval. The video below shows execution of the code.\n\nNow that you have seen the execution, letâ€™s take it apart piece by piece and understand how the ARM assembly code to blink an LED works.\n\nBlinking an LED involves controlling some hardware. Therefore, we need to get acquainted with it before starting to code. The STM32F4 discovery board comes with 4 onboard LEDs connected to PD12 to PD15. These are the GPIO port D pins 12, 13, 14 and 15 respectively. The port pins connect to anodes of LEDs through a resistor with no external driving circuitry. Hence, to blink the LEDs, we need to switch these GPIO pins high and low with a time delay. Switching a pin to logic high will turn on the LED. Conversely switching it to logic low will turn off the LED. We configure the pins in push-pull mode. Consequently, we wonâ€™t need any pull-up or pull-down resistors. For more details refer to the STM32F4 Discovery board user manual.\n\nTo blink an LED in ARM assembly, we use startup code from STM32F4 software pack and put the application logic in the file LED.s. The startup code provides initialization of stack, heap areas and provides a framework for exception handlers including reset handler. We are not going to use heap or stack in our code. However, it is a good practice to keep the startup code separate. You can get more details on how a startup code works in an earlier post\n\nThe startup code calls two functions - and (referred to as main in this post). We therefore provide definition for these two functions in our application code in ARM assembly in file LED.s. Letâ€™s now explore the application logic in these functions to blink the LEDs.\n\nTowards top of this file, we have a constant value.\n\nEQU is an ARM assembler directive which defines a constant. Assembler writes this constant value into a memory location in code space with a DCD or DCW directive. The data thus written in memory is accessible in code with the LDR (Load data from memory to register) instruction. I shall explain the calculation of this value shortly.\n\nNext there are some register definitions which are the addresses of these registers in STM32F4. Again, the assembler writes these values as data in the code space with DCD or DCW directives.\n\nLetâ€™s get familiar with these registers as it will prove useful to understand the code. We will get into more details later in the post.\nâ€¢ (RCC AHB1 peripheral clock enable register) enables or disables clock supply to various peripherals. AHB1 indicates these peripherals are on AHB1 bus of processor. To use GPIO port D, we need to enable clock for GPIO-D via this register.\nâ€¢ (GPIO-D Mode register) controls the mode for port D pins. We can configure each pin independently as either of these modes:\nâ€¢ (GPIO-D Output Type register) controls whether the pin works in push-pull mode or as an open-drain pin. In case of open drain, we need external pull-up or pull-down.\nâ€¢ (GPIO-D Output Speed register) controls the maximum switching speed on the port pin. The maximum speed also depends on supply voltage, current drawn from pin and load capacitance. We can configure the speed as low / medium / high / very high.\nâ€¢ (GPIO-D Pull-up / Pull-down register) enables internal pull-up or pull-down resistor for each port D pin.\nâ€¢ (GPIO-D Output Data register) is the register to write data to output on the port pins.\n\nThe registers in STM32F4 are memory mapped so every register has an address associated with it. However, neither the reference manual nor the datasheet mentions these addresses explicitly. So let me elaborate about how to find (or rather form) the address of a register.\n\nFirst of all, navigate to description of the register in STM32F407 reference manual and note the register offset. Next, navigate to memory map (section 2.3) in the manual. You will find boundary address range of the peripheral associated with the register. Finally, form the address of the register by adding the offset to base address of boundary range.\n\nAs an example letâ€™s find out the address of register RCC_AHB1ENR. This register is part of the RCC registers (Reset and Clock control). The offset of this register is 0x30 as described in section 7.3.10 of reference manual. The memory map shows the RCC boundary address range as 0x4002 3800 to 0x4002 3BFF. Therefore the address of RCC_AHB1ENR register is 0x4002 3830.\n\nSimilarly, the boundary address range for GPIO-D registers is 0x4002 0C00 to 0x4002 0FFF. So we can calculate addresses for all GPIO-D registers by adding their corresponding offsets to the base address 0x4002 0C00. So GPIOD_MODER register address is 04002 0C00 since it has an offset of 0x00. You can verify addresses for remaining GPIO-D registers. Section 8.4.1 of the reference manual contains description for GPIO-D registers.\n\nLetâ€™s now move to the actual code. The processor startup code calls SystemInit function when it starts to execute but before calling the main function. This function contains all the required initialization for our application. In our example this code enables clock for GPIO-D peripheral and further configures the GPIO-D registers. We configure pins PD12 to PD15 as output in push-pull mode with pull-up/pull-down disabled.\n\nTo configure a register we follow a read-modify-write cycle. Letâ€™s illustrate this with the code to update the register RCC_AHB1ENR.\n\nThe instruction LDR loads address of the register into R0. LDR is an instruction to load data from memory. In this case, the data stored in memory is the address of register with statement earlier. Note the use of prefix in the value to be loaded in R0. This prefix indicates that the value to be loaded is explicitly stored in memory (with or etc. directives). If the value is an immediate constant then we prefix it with . In that case the assembler itself adds a or or similar directive to store the constant in memory.\n\nThe next LDR instruction reads data from the address contained in R1, which is the address of register. So this instruction reads current value of the register and puts the data in R0.\n\nLetâ€™s go through the details of RCC_AHB1ENR register to understand which bits we need to modify.\n\nAs you can see, setting bit 3 of this register enables clock for GPIO-D. Hence we bitwise OR the contents of R0 to set this bit with the instruction . The suffix in this instruction tells the processor to OR the entire word.\n\nFinally the instruction stores the the contents of R0 to the address contained in R1, which is the address of RCC_AHB1ENR register in our case.\n\nYou can see that the code uses same pattern of instructions for all the registers. All we need to do is find out the required value for respective registers. Here are the layouts of registers we need to configure with the relevant bits.\n\nEach port pin associates with two bits in the mode register. With these two mode bits, we can configure the corresponding port pin in one of the four possible modes as listed below.\n\nAs shown in the layout, setting the bits to 01b configures the corresponding pin as an output. We need to bitwise AND to clear odd bits between 24 to 31 (AND with 0x55FF FFFF). In addition, we also need to bitwise OR to set even bits between 24 to 31 (OR with 0x5500 0000). Here is the code to update the mode register.\n\nThe output type register allows individual port pins output output configuration as either push-pull or open-drain type.\n\nSetting a bit configures open drain mode while clearing it configures the corresponding pin in open drain mode. Since we are going to use push-pull mode, we bitwise AND the register value with 0xFFFF 0FFF. This clears bits 12 to 15. Here is the code to update this register.\n\nThe output speed register allows us to configure the maximum output switching speed for the port pins. The actual maximum speed depends on other factors such as supply voltage, load capacitance etc. As per STM32F407 datasheet, the maximum speed in slow speed is between 2MHz to 8MHz. We configure the speed to slow mode because out blinking frequency (2 Hz) is much lesser than this.\n\nSetting the bits to â€˜00bâ€™ configures the corresponding port pins for slow speed. Thus here is the code that updates this register.\n\nSTM32F407 provides configurable internal pull-up / pull-down resistors for each pin. This register allows to enable or disable these internal resistors. We donâ€™t need any pull-up or pull-down to drive the LEDs.\n\nClearing the bits disables pull-up/pull-down for the corresponding pin. So we carry out a bitwise AND with 0x00FF FFFF to configure the pins. Here is the required code.\n\nAfter initialization, the main loop repeats these steps infinitely:\n\nTo turn on the LEDs, we need to write a 1 to the corresponding bit in register . In contrast, clearing the bit turns the LED off. The process of writing to is exactly same as we followed earlier to configure the registers. We read current value of and do a bitwise OR to set the bits, while a bitwise AND to clear the bits.\n\nThe delay loop is a blocking loop which decrements the DELAY_INTERVAL until it becomes zero.\n\nloads the value of DEALY_INTERVAL into register R2. instruction jumps to the label specified if the contents of specified register are zero. With , if R2 has become zero then the code will jump to label turnOFF and turn the LEDs off. Otherwise it continues to the next instruction which decrements R2 and stores the result back to R2. Next instruction is an unconditional branch instruction. The code simply jumps back to start of the loop with for the next iteration.\n\nThe delay loop executes 3 instructions repeatedly as many number of times as the DELAY_COUNTER value loaded in R2. We need to find out execution time for each of these instructions. We can then calculate total delay.\n\nThe first two instructions and take one cycle each to execute. Furthermore the unconditional branch instruction takes 3 cycles. As a result, we have a total of 5 cycles in one loop of the delay. You can get more details about instruction timing from the Technical Reference Manual for ARMV7-M (which the Cortex-M4 processor is based on) .\n\nWe have used the default internal 16MHz clock. Timing for one clock cycle is therefore 62.5 nsec. At this speed, one iteration of the delay loop will take (5*62.5) = 312.5 nsec . Rounding off to 313nsec, the number of loops for a 500msec delay is = 500msec/313nsec. This results into 1597444 decimal or 0x186004 in hexadecimal. We can ignore overhead of additional instructions since it is negligible compared to blinking interval.\n\nWe explored this small ARM assembly code to blink an LED using very few number of instructions. I must confess that this is neither a foolproof nor a good way to code. In particular the blocking delay loop is not the best use of processor. However, the purpose of this post was to get a fair idea of assembly language programming on an ARM processor. In real world applications, you will use exceptions, interrupts and much smarter ways of coding.\n\nProgramming in assembly helps you get intimate with the microcontroller hardware. As a result you get to learn more about internals of a microcontroller / processor. Assembly may not be the preferred choice when it comes to large complex programs due to the complications involved. Yet learning assembly programming does help in debugging and optimizing your code.\n\nIn conclusion, this code example can be a good base to learn assembly programming for ARM Cortex-M. As a suggestion, you can try switching on the 4 LEDs one by one with a time delay in between. You can also implement a binary counter from 0x0000 to 0xFFFF using the 4 LEDs.\n\nIn one of the next blog posts, I will explain how to make use of interrupts and avoid blocking processor. Till then stay tuned and do let me know your suggestions and comments about this post!"
    },
    {
        "link": "https://embetronicx.com/tutorials/microcontrollers/stm32/stm32-gpio-tutorial",
        "document": "This is the Series of tutorials on the STM32 Microcontroller. The aim of this series is to provide easy and practical examples that anyone can understand. Basically, you can write GPIO codes in multiple ways (Using HAL, the GPIO driver).\n\nUsing that HAL you can finish your job in very few lines of code. But I would suggest you, learn to program using the bare-metal code (without any HAL or driver) initially. This is the STM32 GPIO Tutorial without HAL.\n\nThe tutorial series covers STM32 microcontroller programming, focusing on GPIO operations without using the Hardware Abstraction Layer (HAL) or drivers. It aims to provide practical examples for easy understanding. The tutorials cover a variety of topics related to STM32 GPIO:\n\nThis tutorial aims to help beginners understand the basics of STM32 GPIO programming without relying on higher-level abstractions, making it suitable for those who want to learn the fundamentals of microcontroller interaction.\n\nYou can also read, Getting Started with STM32 RTOS, PIC16F877A GPIO tutorial, GPIO Linux device driver, and STM32 GPIO RTOS tutorial.\n\nBefore starting this STM32 GPIO Tutorial, Please go through the below tutorials.\nâ€¢ Create a New Project for STM32 in Keil\n\nIn this tutorial, we are going to see the timer for the below three STM32 controllers. If you have any one of the controllers or ARM cortex, you can use that. Please click the controller-specific tab and see the content properly.\n\nWe have our own EmbeTronicX Store called ChipTronicX. You can purchase the hardware from ChipTronicX.\n\nIn this post, we have used three microcontrollers (STM32F1, STM32F4, STM32F7) for demonstration. You can go to the section directly based on the microcontroller that you have.\n\nI think we have covered almost all the registers. Now we will just put them all together and make our hands dirty by playing with the LEDs. Letâ€™s dive into the programming part.\n\nYou can refer to the respective User manual for a better understanding.\n\nIn the below example, I am going to toggle the Onboard LED which is connected to the PC13. I have set the PC13 as an output. and toggling that with some delay. You can also find the complete project on GitHub. /***************************************************************************//** * \\file main.c * * \\details Blinking Onboard LED with some random delay - STM32 GPIO Tutorial * * \\author EmbeTronicX * * \\This code is verified with STM32411CE Board * *******************************************************************************/ #include \"stm32f4xx.h\" #define DELAY_COUNT ( 80000 ) /* delay count */ /***************************************************************************//** \\details Providing Delay by running empty for loop \\return void \\retval none *******************************************************************************/ static void delay( void ) { uint32_t i = 0; for( i=0; i<=DELAY_COUNT; i++ ); } /***************************************************************************//** \\details The main function. It should not return. \\return void \\retval none *******************************************************************************/ int main(void) { /* Enable the AHB clock all GPIO port C */ SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOCEN); /* set all Port C as output */ GPIOC->MODER = 0x55555555; /* Endless loop */ while(1) { /* Turn ON the LED of PC13 */ GPIOC->BSRR |= GPIO_BSRR_BS13; delay(); /* Turn OFF the LED of PC13 */ GPIOC->BSRR |= GPIO_BSRR_BR13; delay(); } } In the below example, I am going to toggle the Onboard LED which is connected to the PC13. I have set the PC13 as an output. and toggling that with some delay. You can also find the complete project on GitHub. /***************************************************************************//** * \\file main.c * * \\details Blinking Onboard LED with some random delay - STM32 GPIO Tutorial * * \\author EmbeTronicX * * \\This code is verified with STM32F103CBT6 Board * *******************************************************************************/ #include \"stm32f10x.h\" #define DELAY_COUNT ( 80000 ) /* delay count */ /***************************************************************************//** \\details Providing Delay by running empty for loop \\return void \\retval none *******************************************************************************/ static void delay( void ) { uint32_t i = 0; for( i=0; i<=DELAY_COUNT; i++ ); } /***************************************************************************//** \\details The main function. It should not return. \\return void \\retval none *******************************************************************************/ int main(void) { /* Enable the APB clock all GPIO port C */ SET_BIT(RCC->APB2ENR, RCC_APB2ENR_IOPCEN); /* PC13 as output */ GPIOC->CRH &= ~(GPIO_CRH_MODE13|GPIO_CRH_CNF13); /* Clear MODE13 and CNF13 fields */ GPIOC->CRH |= GPIO_CRH_MODE13_1|GPIO_CRH_MODE13_0; /* Set MODE13 to 3 (Output) */ /* Endless loop */ while(1) { /* Turn ON the LED of PC13 */ GPIOC->BSRR |= GPIO_BSRR_BS13; delay(); /* Turn OFF the LED of PC13 */ GPIOC->BSRR |= GPIO_BSRR_BR13; delay(); } } In the below example, I am going to toggle the Onboard LEDs which are connected to PB0 (Green LED), PB7 (Blue LED), and PB14 (Red LED). I have set the PB0, PB7, and PB14 as output, and toggling those with some delay. You can also find the complete project on GitHub. /***************************************************************************//** * \\file main.c * * \\details Blinking Onboard LED with some random delay - STM32 GPIO Tutorial * * \\author EmbeTronicX * * \\This code is verified with STM32F767Zi Nucleo Board * *******************************************************************************/ #include \"stm32f7xx.h\" #define DELAY_COUNT ( 80000 ) /* delay count */ /***************************************************************************//** \\details Providing Delay by running empty for loop \\return void \\retval none *******************************************************************************/ static void delay( void ) { uint32_t i = 0; for( i=0; i<=DELAY_COUNT; i++ ); } /***************************************************************************//** \\details The main function. It should not return. \\return void \\retval none *******************************************************************************/ int main(void) { /* Enable the AHB clock all GPIO port B */ SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOBEN); /* set Port B as output */ GPIOB->MODER |= 0x55555555; /* Set Port B as Push Pull */ GPIOB->OTYPER = 0x00000000; /* Set Low Speed */ GPIOB->OSPEEDR = 0x00000000; /* Endless loop */ while(1) { /* Turn ON the PB0 (Green LED), PB7 (Blue LED), PB14 (Red LED) */ GPIOB->BSRR |= GPIO_BSRR_BS0 | GPIO_BSRR_BS7 | GPIO_BSRR_BS14; delay(); /* Turn OFF the PB0 (Green LED), PB7 (Blue LED), PB14 (Red LED) */ GPIOB->BSRR |= GPIO_BSRR_BR0 | GPIO_BSRR_BR7 | GPIO_BSRR_BR14; delay(); } }\n\nPlease find the output of the example below.\n\nI have connected the button to the PA0 (Port A.0) and the LED to the PC13. You can also find the project on GitHub. /***************************************************************************//** * \\file main.c * * \\details Setting Port A0 as input and PORT C13 as output. * When we press the Port A0, we will turn on the LED in * PC13 - STM32 GPIO Tutorial * * \\author EmbeTronicX * * \\This code is verified with STM32411CE Board * *******************************************************************************/ #include \"stm32f4xx.h\" /***************************************************************************//** \\details The main function. It should not return. \\return void \\retval none *******************************************************************************/ int main(void) { /* Enable the AHB clock all GPIO Port C and Port A */ SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOCEN); SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOAEN); /* set Port C13 as output */ GPIOC->MODER &= ~( GPIO_MODER_MODER13 ); /* Clear MODER13 fields */ GPIOC->MODER |= ( GPIO_MODER_MODER13_0 ); /* Set MODER13 to 1 (Output) */ /* set Port A0 as input */ GPIOA->MODER &= ~( GPIO_MODER_MODER0 ); /* Clear MODER0 fields to 0 (input) */ /* Enable Pullup on PA0 */ GPIOA->PUPDR &= ~( GPIO_PUPDR_PUPDR0 ); /* Clear PUPDR0 fields (No Pullup, No Pull down) */ GPIOA->PUPDR |= GPIO_PUPDR_PUPDR0_0; /* Set PUPDR0 fields to 0x01 (Pullup) */ /* Endless loop */ while(1) { /* Button is connected to PA0. So we need to check bit 0 of IDR register. */ if( ( GPIOA->IDR & GPIO_IDR_ID0) == GPIO_IDR_ID0 ) { /* Turn ON the LED of PC13 */ GPIOC->BSRR |= GPIO_BSRR_BS13; } else { /* Turn OFF the LED of PC13 */ GPIOC->BSRR |= GPIO_BSRR_BR13; } } } I have connected the button to the PA0 (Port A.0) and the LED to the PC13. You can also find the project on GitHub. /***************************************************************************//** * \\file main.c * * \\details Setting Port A0 as input and PORT C13 as output. * When we press the Port A0, we will turn on the LED in * PC13 - STM32 GPIO Tutorial * * \\author EmbeTronicX * * \\This code is verified with STM32F103CBT6 Board * *******************************************************************************/ #include \"stm32f10x.h\" /***************************************************************************//** \\details The main function. It should not return. \\return void \\retval none *******************************************************************************/ int main(void) { /* Enable the APB clock all GPIO Port C and Port A */ SET_BIT(RCC->APB2ENR, RCC_APB2ENR_IOPCEN); SET_BIT(RCC->APB2ENR, RCC_APB2ENR_IOPAEN); /* PC13 as output */ GPIOC->CRH &= ~(GPIO_CRH_MODE13|GPIO_CRH_CNF13); /* Clear MODE13 and CNF13 fields */ GPIOC->CRH |= GPIO_CRH_MODE13_1|GPIO_CRH_MODE13_0; /* Set MODE13 to 3 (Output) */ /* PA0 as input with pullup */ GPIOA->CRL &= ~(GPIO_CRL_MODE0|GPIO_CRL_CNF0); /* Clear MODE0 and CNF0 fields */ GPIOA->CRL |= GPIO_CRL_CNF0_1; /* Set CNF0 to 10 (Input with pullup/pull down) */ GPIOA->ODR |= GPIO_IDR_IDR0; /* pull-up PA0 */ /* Endless loop */ while(1) { /* Button is connected to PA0. So we need to check bit 0 of IDR register. */ if( ( GPIOA->IDR & GPIO_IDR_IDR0 ) == GPIO_IDR_IDR0 ) { /* Turn ON the LED of PC13 */ GPIOC->BSRR |= GPIO_BSRR_BS13; } else { /* Turn OFF the LED of PC13 */ GPIOC->BSRR |= GPIO_BSRR_BR13; } } } I have connected the button to the PC13 (Port C.13) and LED to the PB0, PB7, and PB14. You can also find the project on GitHub. /***************************************************************************//** * \\file main.c * * \\details Setting Port B as output and PORT C13 as input. * When we press the Port C13, we will turn on the PB0, PB7, PB14 - STM32 GPIO Tutorial * * \\author EmbeTronicX * * \\This code is verified with STM32F767Zi Nucleo Board * *******************************************************************************/ #include \"stm32f7xx.h\" /***************************************************************************//** \\details The main function. It should not return. \\return void \\retval none *******************************************************************************/ int main(void) { /* Enable the AHB clock all GPIO Port B and Port C */ SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOBEN); SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOCEN); /* set Port B0, B7, B14 as output */ GPIOB->MODER &= ~( GPIO_MODER_MODER0 | GPIO_MODER_MODER7 | GPIO_MODER_MODER14 ); /* Clear MODER0, MODER7, MODER14 fields */ GPIOB->MODER |= ( GPIO_MODER_MODER0_0 | GPIO_MODER_MODER7_0 | GPIO_MODER_MODER14_0 ); /* Set MODER0, MODER7, MODER14 to 1 (Output) */ /* set Port C13 as input */ GPIOC->MODER &= ~( GPIO_MODER_MODER13 ); /* Clear MODER13 fields to 0 (input) */ /* Disable Pullup/Pulldown on PC13 */ GPIOC->PUPDR &= ~( GPIO_PUPDR_PUPDR13 ); /* Clear PUPDR13 fields (No Pullup, No Pull down) */ /* Set Port B as Push Pull */ GPIOB->OTYPER = 0x00000000; /* Set Low Speed */ GPIOB->OSPEEDR = 0x00000000; /* Endless loop */ while(1) { /* Button is connected to PC13. So we need to check bit 13 of IDR register. */ if( ( GPIOC->IDR & GPIO_IDR_ID13) == GPIO_IDR_ID13 ) { /* Turn ON the PB0 (Green LED), PB7 (Blue LED), PB14 (Red LED) */ GPIOB->BSRR |= GPIO_BSRR_BS0 | GPIO_BSRR_BS7 | GPIO_BSRR_BS14; } else { /* Turn OFF the PB0 (Green LED), PB7 (Blue LED), PB14 (Red LED) */ GPIOB->BSRR |= GPIO_BSRR_BR0 | GPIO_BSRR_BR7 | GPIO_BSRR_BR14; } } }\n\nPlease find the output of the example below.\n\nIf you want to use RTOS in STM32, you can refer to the STM32 GPIO with the RTOS tutorial. In our next tutorial, we will see the STM32 Timers and their registers with examples.\n\nPlease read the other STM32 Tutorials.\n\nYou can also read the below tutorials."
    },
    {
        "link": "https://community.st.com/t5/stm32-mcus-products/assembly-code-example/td-p/533908/page/2",
        "document": "I got to M3 from ARM7/9, I have a bunch of ARM926 SoC and STR7, STR9 in there too, and it pushes some 30 years back from that to the original Acorn designs that ARM sprang from. I've worked through a lot of the ARM TRM's and found Joseph Yiu's book on the Cortex-M3 as a good contrasting source to those manuals.\n\nA technique I use, and another colleague better described, is triangulation, ie take a lot of books and documentation, digest/skim, and then establish a view based on multiple perspectives. And also leveraging existing knowledge into new spaces.\n\nI guess the clever tricks with ARM's ISA relate to the shifts and register side effects that make the instructions so powerful.\n\nMy mind's pretty fogged up with assembler for several dozen micros, so I'm probably not the best person to ask ''how do I start''. The assembler stuff I'm best known for is x86, but not many prospects there.\n\nMaybe the best way would you to kick out a few ideas of what examples or snippets might be immediately helpful, and would fit in 50-100 lines, and work through those as building blocks you and others can apply."
    }
]