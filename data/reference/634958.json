[
    {
        "link": "https://semaphoreci.com/blog/table-driven-unit-tests-go",
        "document": "Over the past years, table-driven tests have become a popular choice for unit tests within the Go community. They facilitate testing a function with a variety of inputs: A table-driven test consists of multiple rows of given inputs and expected outputs. You can keep these tests clean and efficient by following a set of simple guidelines. By ‚Äúefficient‚Äù, I mean testing as many inputs as possible with the least amount of overhead.\n\nThis is what a table-driven unit test should look like: A function ) int that takes two integers and returns their sum is tested with two test cases. A test case is represented by an anonymous struct consisting of two given input arguments and the expected result. Each test case is mapped against a unique name for that test case.\n\nAfter declaring the test cases via the map, the test function iterates over all the map entries, i.e. the test cases. The function is called in each iteration using the input arguments of the current test case. If the actual result doesn‚Äôt match the result expected by the test case, the test fails with an error message.\n\nThe example above is relatively simple, but there are some interesting details to it. In fact, this test function already applies a number of suggestions from this article.\n\nSometimes, test cases in a table-driven setup contain a field to uniquely identify and describe the test case. These test cases are then stored in a slice.\n\nWhile this approach works well from a technical point of view, storing the test cases inside a map is preferable. When a lot of complex test cases start occupying too much screen space, it‚Äôs convenient to collapse individual test cases within the IDE. When using a plain slice, the test name will disappear, but remain for the maps. Also, besides being easier to navigate, a map clearly separates the test name from its fixtures.\n\nAnother nice side effect of using a map is an undefined iteration order. Test cases might or might not be executed in the same order by the Go runtime, exposing faulty test setups where tests only pass when executed in a certain order. This can happen when there‚Äôs accidentally some state involved.\n\nThe example at the beginning only tests and compares primitive values using a builtin operator. When dealing with more complex comparisons, especially with comprehensive custom structs, this approach usually is too cumbersome. A library like Google‚Äôs go-cmp provides a convenient way for checking such values for equality.\n\nNot only does compare the values, it also returns the diff between the expected and the actual value as a string. Performing a comparison is simple ‚Äì if the diff string is not empty, the values are different.\n\nBecause the two provided arguments aren‚Äôt equal, the library reports a diff where indicates the expected value, and indicates the actual value.\n\nInstead of running the test cases directly inside the loop, our example uses the method for executing the test case as a so-called subtest.\n\nThese subtests change the behavior of the test function: Even if one or more of the test cases fail, all the other test cases will still be executed. A complete list of failing test cases (or a list of failing and passing test cases when the flag is used) will be printed when running a test function using subtests. In contrast, executing a failing test case directly inside the loop would cause the entire test function to exit, omitting the remaining test cases.\n\nThere is no need to print the test name in the error message when a test fails, because the test name has already been passed to . The aforementioned list of test cases will include the respective test names.\n\nAnother benefit of subtests is the ability to only run a particular test case. The following command, for example, exclusively runs the subtest:\n\nBeing able to run a specified subtest facilitates debugging that particular test and saves execution time.\n\nWhen an actual value doesn‚Äôt match an expected value in a comparison, there are two options. Either an error message is logged using or the test is terminated using f.\n\nThe first option only logs the error and marks the test case as failed, but proceeds with the test function and its consequent checks. The latter option cancels the entire test case immediately upon failure. It is good practice to use these two options considerately. By default, when a check fails, it is advisable to only log the failure using and continue with the remaining checks. Only if the checks are a precondition for subsequent checks and proceeding wouldn‚Äôt make any sense, should be used to fail immediately.\n\nThe test above aims to compare the contents of two slices, and . It does so by comparing the values in a loop. Accessing the indexes is only safe if the lengths of the slices are the same, so the test immediately fails with if this precondition isn‚Äôt met.\n\nIf the lengths are the same, the values within the slices are compared index by index. An error is logged using if the elements don‚Äôt match, which will mark the test as failed but continue with the comparisons within the loop.\n\nA test case can become quite large for functions with many parameters or many dependencies that need to be set up. To keep these complex test cases clear and manageable, it might make sense to outsource the input parameters and the expected results into their own helper structs.\n\nThe given input parameters are stored in a dedicated struct, and the expected result is stored in an struct. The test case is still an anonymous struct but only contains these two fields. Of course, this approach is better suited for test cases that have a higher complexity than the example.\n\nNote that both helper structs are defined inside the function. That way, a and an type can be defined for every test function in the package. Declaring a third struct for storing mocked dependencies can be helpful, too.\n\nTable-driven tests are a good indicator for the complexity of a function. Test cases getting too convoluted is a sign that the function that needs to be tested either has too many dependencies or too many duties. If your function retrieves data from a third-party service, forwards this data to another service, and writes the data into a local database at the same time, chances are that the function is doing too many things at once. In this case, the function should be split into multiple smaller functions with clearly separated concerns.\n\nSplitting the function into smaller pieces will simplify the test cases for these functions, and it will lower the effort for adding new test cases. Both the function itself and the test cases will be easier to reason about.\n\nTesting your functions using the table-driven approach enables the testing of a large number and variety of input arguments with comparably little overhead. However, table-driven tests don‚Äôt guarantee sound test setups and clean test functions. By following the guidelines demonstrated here, you will be able to keep your tests as clean and efficient as possible. For a full example, check out the table-driven-tests repository."
    },
    {
        "link": "https://semaphore.io/blog/table-driven-unit-tests-go",
        "document": "Over the past years, table-driven tests have become a popular choice for unit tests within the Go community. They facilitate testing a function with a variety of inputs: A table-driven test consists of multiple rows of given inputs and expected outputs. You can keep these tests clean and efficient by following a set of simple guidelines. By ‚Äúefficient‚Äù, I mean testing as many inputs as possible with the least amount of overhead.\n\nThis is what a table-driven unit test should look like: A function ) int that takes two integers and returns their sum is tested with two test cases. A test case is represented by an anonymous struct consisting of two given input arguments and the expected result. Each test case is mapped against a unique name for that test case.\n\nAfter declaring the test cases via the map, the test function iterates over all the map entries, i.e. the test cases. The function is called in each iteration using the input arguments of the current test case. If the actual result doesn‚Äôt match the result expected by the test case, the test fails with an error message.\n\nThe example above is relatively simple, but there are some interesting details to it. In fact, this test function already applies a number of suggestions from this article.\n\nSometimes, test cases in a table-driven setup contain a field to uniquely identify and describe the test case. These test cases are then stored in a slice.\n\nWhile this approach works well from a technical point of view, storing the test cases inside a map is preferable. When a lot of complex test cases start occupying too much screen space, it‚Äôs convenient to collapse individual test cases within the IDE. When using a plain slice, the test name will disappear, but remain for the maps. Also, besides being easier to navigate, a map clearly separates the test name from its fixtures.\n\nAnother nice side effect of using a map is an undefined iteration order. Test cases might or might not be executed in the same order by the Go runtime, exposing faulty test setups where tests only pass when executed in a certain order. This can happen when there‚Äôs accidentally some state involved.\n\nThe example at the beginning only tests and compares primitive values using a builtin operator. When dealing with more complex comparisons, especially with comprehensive custom structs, this approach usually is too cumbersome. A library like Google‚Äôs go-cmp provides a convenient way for checking such values for equality.\n\nNot only does compare the values, it also returns the diff between the expected and the actual value as a string. Performing a comparison is simple ‚Äì if the diff string is not empty, the values are different.\n\nBecause the two provided arguments aren‚Äôt equal, the library reports a diff where indicates the expected value, and indicates the actual value.\n\nInstead of running the test cases directly inside the loop, our example uses the method for executing the test case as a so-called subtest.\n\nThese subtests change the behavior of the test function: Even if one or more of the test cases fail, all the other test cases will still be executed. A complete list of failing test cases (or a list of failing and passing test cases when the flag is used) will be printed when running a test function using subtests. In contrast, executing a failing test case directly inside the loop would cause the entire test function to exit, omitting the remaining test cases.\n\nThere is no need to print the test name in the error message when a test fails, because the test name has already been passed to . The aforementioned list of test cases will include the respective test names.\n\nAnother benefit of subtests is the ability to only run a particular test case. The following command, for example, exclusively runs the subtest:\n\nBeing able to run a specified subtest facilitates debugging that particular test and saves execution time.\n\nWhen an actual value doesn‚Äôt match an expected value in a comparison, there are two options. Either an error message is logged using or the test is terminated using f.\n\nThe first option only logs the error and marks the test case as failed, but proceeds with the test function and its consequent checks. The latter option cancels the entire test case immediately upon failure. It is good practice to use these two options considerately. By default, when a check fails, it is advisable to only log the failure using and continue with the remaining checks. Only if the checks are a precondition for subsequent checks and proceeding wouldn‚Äôt make any sense, should be used to fail immediately.\n\nThe test above aims to compare the contents of two slices, and . It does so by comparing the values in a loop. Accessing the indexes is only safe if the lengths of the slices are the same, so the test immediately fails with if this precondition isn‚Äôt met.\n\nIf the lengths are the same, the values within the slices are compared index by index. An error is logged using if the elements don‚Äôt match, which will mark the test as failed but continue with the comparisons within the loop.\n\nA test case can become quite large for functions with many parameters or many dependencies that need to be set up. To keep these complex test cases clear and manageable, it might make sense to outsource the input parameters and the expected results into their own helper structs.\n\nThe given input parameters are stored in a dedicated struct, and the expected result is stored in an struct. The test case is still an anonymous struct but only contains these two fields. Of course, this approach is better suited for test cases that have a higher complexity than the example.\n\nNote that both helper structs are defined inside the function. That way, a and an type can be defined for every test function in the package. Declaring a third struct for storing mocked dependencies can be helpful, too.\n\nTable-driven tests are a good indicator for the complexity of a function. Test cases getting too convoluted is a sign that the function that needs to be tested either has too many dependencies or too many duties. If your function retrieves data from a third-party service, forwards this data to another service, and writes the data into a local database at the same time, chances are that the function is doing too many things at once. In this case, the function should be split into multiple smaller functions with clearly separated concerns.\n\nSplitting the function into smaller pieces will simplify the test cases for these functions, and it will lower the effort for adding new test cases. Both the function itself and the test cases will be easier to reason about.\n\nTesting your functions using the table-driven approach enables the testing of a large number and variety of input arguments with comparably little overhead. However, table-driven tests don‚Äôt guarantee sound test setups and clean test functions. By following the guidelines demonstrated here, you will be able to keep your tests as clean and efficient as possible. For a full example, check out the table-driven-tests repository."
    },
    {
        "link": "https://dwarvesf.hashnode.dev/unit-testing-best-practices-in-golang",
        "document": ""
    },
    {
        "link": "https://syafdia.medium.com/unit-test-in-go-8d17d3910818",
        "document": "Let‚Äôs get started by writing unit tests with the built-in Go standard library.\n\nAssume we have a function that calculates the factorial of a positive integer that we put in a file called .\n\nThen we create test function called on file in the same folder of .\n\nWe declare with an anonymous struct inside the test function to store our table-driven test cases. We run each test case on its own subtest which a Go‚Äôs package construct that divides our test functions into granular test processes. It executes our test case in a separate goroutine and waits for our function to complete.\n\nUsing the Go equals operator, we simply compare the expected and actual results. If you require more advanced assertion, a third-party library such as Testify can be used.\n\nLet‚Äôs run our code with command, all test cases will run successfully and our test coverage for will be displayed.\n\nTo make sure we are writing the right code, let‚Äôs make our test fail by adding a new case, where we‚Äôll use 5 as the n value and expect it to return 0, and it will, of course, fail on the case.\n\nWe should not talk to the database during unit testing, so if our function calls another function that performs a database query, we could mock the database query functionality. To mock an external resource in our function or method, we should never directly call the function that is responsible for accessing the external resource. We could use Dependency Injection, with the parameter based on abstractions and use Go interfaces as abstraction instead of concrete implementations.\n\nFor example, we had an application to create articles that was accessible via an HTTP end point. The file structure will look like this because we use Clean Architecture to organize our code structure.\n\nThe is not dependent on any other layer; it is simply a struct that holds our data. The is in charge of accessing external resources (Redis, PostgreSQL, API calls, etc.) and relies on libraries to do so, such as go-redis, sql, and http.\n\nThe layer is in charge of executing our business logic and should only rely on the module. The last layer, the layer, is in charge of determining how the data should be presented to users. Because our app exposes an HTTP end point, the delivery layer will include some sort of HTTP handler, which will be determined by our layer.\n\nOn our example application, the repository layer will connect to a PostgreSQL database by using sqlx library. Since Go has implicit interface, we could extract sqlx function to an interface, and inject it to out repository layer, or we could use go-sqlmock to to simulate any sql driver behavior in tests, without needing a real database connection. I prefer using go-sqlmock library, since it already implementing sql/driver on Go standard library and also compatible with sqlx.\n\nThe repository layer in our example application will connect to a PostgreSQL database via the library. We could extract the function to an interface and inject it into our repository layer, or we could use to simulate any SQL driver behavior in tests without requiring a real database connection. I prefer the library because it already implements on the Go standard library and is also compatible.\n\nAnd here is our test for implementation, which we put in .\n\nAs in the previous example, we create table-driven test cases and run each test case on a subtest. However, within our subtest, we create a instance and set it to so that we can control the behavior of our query using the instance. And for each test case, we add a hook and inject the instance via our hook, so that each test case can access its own instance to prepare for expected behavior. When we run our test, all of the cases will succeed, and if we change the expected result to an invalid one, it will fail as expected.\n\nAs you can see, we don‚Äôt connect to the real database in the test file, and we don‚Äôt even set up the actual DB connection in our main code yet. If you prefer to use Test Driven Development on your project, you can first write the test and prepare the expected query before proceeding with the actual implementation.\n\nThis can be applied to a variety of resources (i.e. Redis, API call, Kafka, etc).\n\nIf you can‚Äôt find a suitable library, you can use Go‚Äôs implicit interface feature to create your own interface for those libraries and your own mock.\n\nBecause the UseCase layer is dependent on our repository layer, we must first mock our repository before testing the UseCase layer. We could simply create another implementation to be used for testing because our repository is built on interfaces.\n\nWe could create custom implementation of our repository based on our test cases. But it a repetitive task since for each test case we need to create new implementation, by using gomock we could generate source code for a mock implementation based on given interface to be mocked. Remember how we use sqlmock on previous section? By using gomock we could create a universal mock of our repository and control the behavior based on our need.\n\nBased on our test cases, we could create a custom implementation of our repository. However, because we need to create a new implementation for each test case, using allows us to generate source code for a mock implementation based on the given interface to be mocked. Remember how we used in the previous section? We could use to create a universal mock of our repository and control the behavior based on our requirements.\n\nHere is interface and implementation of our use case, let‚Äôs call it , the use case is responsible for registering new user. So we will need as a dependency on that use case.\n\nHere is the interface and implementation of our use case, which we‚Äôll call because it‚Äôs in charge of registering new users. As a result, will be required as a dependency on that UseCase.\n\nAfter installing gomock, let‚Äôs create the mock of our so we can use it on by running this command on our terminal.\n\nBy running this command on our terminal after installing , we can create a mock of our to use on .\n\nIt will generate our mock file on . For simplicity, I just create the mock file on same package as implementation. Some people prefer to put the mock file on difference package, but feel free to adjust the file location and package based on your need. Here is the example of newly generated mock file by gomock.\n\nIt will create our mock file on the . To keep things simple, I create the mock file in the same package as the implementation. Some people prefer to place the mock file in a different package, but you are free to change the file location and package to suit your needs. Here‚Äôs an example of a newly generated mock file generated by .\n\nOn , we create new test function for testing .\n\nWe inject instance of to our use case, and we can control its behavior on hook since mockgen provide us some additional method to instance. You can see list of generated method on gomock github repository.\n\nWe inject a instance into our use case, and we can control its behavior on the hook because provides us with some additional methods to instances. The list of generated methods can be found in the github repository.\n\nBecause our application is exposed via HTTP, we define as an end point for registering new users. Let‚Äôs write the HTTP handler for that endpoint.\n\nWe must generate a mock for using , just as we did for our . Furthermore, Go standard library already provide use with package, so we don‚Äôt have to create mock for .\n\nWe simulate success and failure scenarios by injecting the mock implementation and comparing the status, headers, and body of the HTTP response provided by . Then, when we run our test file, all of the tests should pass."
    },
    {
        "link": "https://linkedin.com/pulse/using-table-driven-tests-unit-testing-go-auber-mardegan-rihbf",
        "document": "Unit testing is an essential part of software development, helping ensure that your code behaves as expected. In Go, one of the most effective and maintainable ways to write tests is through table-driven tests. This method organizes test cases into a table (slice of structs) and iterates through them, running each case with the corresponding input and expected output. üõ†Ô∏è\n‚Ä¢ Create a Test File: place your test functions in a file with the _test.go suffix. For example, if you‚Äôre testing main.go, your test file should be named main_test.go.\n‚Ä¢ Write a Test Function: Each test function must start with Test followed by the name of the function you‚Äôre testing, like this: func TestFunctionName(t *testing.T) { // Test logic here }\n‚Ä¢ Use Assertions: Inside your test function, compare the result of the function being tested with the expected result. If they don‚Äôt match, call t.Errorf() or t.Fail() to indicate a test failure\n\nOnce you‚Äôve written your test functions, you can run them with the command go test. This command will automatically find all the _test.go files in your package, run the test functions, and report the results.\n‚Ä¢ You define a series of test cases in a table (slice of structs).\n‚Ä¢ Each test case has input data and the expected result.\n‚Ä¢ The tests iterate over the table and run for each case.\n\nLet‚Äôs start with a simple example: testing a function that adds two numbers. Here is content of the add.go file and the test_add.go\n‚Ä¢ We define a testCases slice that holds all the test scenarios, including the inputs (a and b) and the expected output.\n‚Ä¢ Inside the loop, t.Run() runs each test case with a descriptive name.\n‚Ä¢ The t.Errorf() function reports any failures when the result does not match the expected value.\n‚Ä¢ Scalability: Adding new test cases is as simple as adding a new struct entry to the table.\n‚Ä¢ Readability: Test cases are neatly organized, and their intention is clear.\n‚Ä¢ Flexibility: You can extend this approach to test more complex scenarios or edge cases.\n\nLet‚Äôs take this concept a step further and apply it to a more complex example: testing a function that sorts a slice of integers."
    },
    {
        "link": "https://github.com/go-ozzo/ozzo-validation",
        "document": "ozzo-validation is a Go package that provides configurable and extensible data validation capabilities. It has the following features:\n‚Ä¢ use normal programming constructs rather than error-prone struct tags to specify how data should be validated.\n‚Ä¢ can validate data of different types, e.g., structs, strings, byte slices, slices, maps, arrays.\n‚Ä¢ can validate custom data types as long as they implement the interface.\n‚Ä¢ can validate data types that implement the interface (e.g. ).\n‚Ä¢ provide a rich set of validation rules right out of box.\n‚Ä¢ extremely easy to create and use custom validation rules.\n\nFor an example on how this library is used in an application, please refer to go-rest-api which is a starter kit for building RESTful APIs in Go.\n\nGo 1.13 or above.\n\nThe ozzo-validation package mainly includes a set of validation rules and two validation methods. You use validation rules to describe how a value should be considered valid, and you call either or to validate the value.\n\nRun the following command to install the package:\n\nFor a simple value, such as a string or an integer, you may use to validate it. For example,\n\nThe method will run through the rules in the order that they are listed. If a rule fails the validation, the method will return the corresponding error and skip the rest of the rules. The method will return nil if the value passes all validation rules.\n\nFor a struct value, you usually want to check if its fields are valid. For example, in a RESTful application, you may unmarshal the request payload into a struct and then validate the struct fields. If one or multiple fields are invalid, you may want to get an error describing which fields are invalid. You can use to achieve this purpose. A single struct can have rules for multiple fields, and a field can be associated with multiple rules. For example,\n\nNote that when calling to validate a struct, you should pass to the method a pointer to the struct instead of the struct itself. Similarly, when calling to specify the rules for a struct field, you should use a pointer to the struct field.\n\nWhen the struct validation is performed, the fields are validated in the order they are specified in . And when each field is validated, its rules are also evaluated in the order they are associated with the field. If a rule fails, an error is recorded for that field, and the validation will continue with the next field.\n\nSometimes you might need to work with dynamic data stored in maps rather than a typed model. You can use in this situation. A single map can have rules for multiple keys, and a key can be associated with multiple rules. For example,\n\nWhen the map validation is performed, the keys are validated in the order they are specified in . And when each key is validated, its rules are also evaluated in the order they are associated with the key. If a rule fails, an error is recorded for that key, and the validation will continue with the next key.\n\nThe method returns validation errors found in struct fields in terms of which is a map of fields and their corresponding errors. Nil is returned if validation passes.\n\nBy default, uses the struct tags named to determine what names should be used to represent the invalid fields. The type also implements the interface so that it can be marshaled into a proper JSON object. For example,\n\nYou may modify to use a different struct tag name.\n\nIf you do not like the magic that determines error keys based on struct field names or corresponding tag values, you may use the following alternative approach:\n\nIn the above example, we build a by a list of names and the corresponding validation results. At the end we call to remove from all nils which correspond to those successful validation results. The method will return nil if is empty.\n\nThe above approach is very flexible as it allows you to freely build up your validation error structure. You can use it to validate both struct and non-struct values. Compared to using to validate a struct, it has the drawback that you have to redundantly specify the error keys while can automatically find them out.\n\nInternal errors are different from validation errors in that internal errors are caused by malfunctioning code (e.g. a validator making a remote call to validate some data when the remote service is down) rather than the data being validated. When an internal error happens during data validation, you may allow the user to resubmit the same data to perform validation again, hoping the program resumes functioning. On the other hand, if data validation fails due to data error, the user should generally not resubmit the same data again.\n\nTo differentiate internal errors from validation errors, when an internal error occurs in a validator, wrap it into by calling . The user of the validator can then check if a returned error is an internal error or not. For example,\n\nA type is validatable if it implements the interface.\n\nWhen is used to validate a validatable value, if it does not find any error with the given validation rules, it will further call the value's method.\n\nSimilarly, when is validating a struct field whose type is validatable, it will call the field's method after it passes the listed rules.\n\nIn the following example, the field of is validatable because implements . Therefore, when validating a struct with , validation will \"dive\" into the field.\n\nSometimes, you may want to skip the invocation of a type's method. To do so, simply associate a rule with the value being validated.\n\nWhen validating an iterable (map, slice, or array), whose element type implements the interface, the method will call the method of every non-nil element. The validation errors of the elements will be returned as which maps the keys of the invalid elements to their corresponding validation errors. For example,\n\nWhen using to validate a struct, the above validation procedure also applies to those struct fields which are map/slices/arrays of validatables.\n\nThe validation rule allows you to apply a set of rules to each element of an array, slice, or map.\n\nWhen a value being validated is a pointer, most validation rules will validate the actual value pointed to by the pointer. If the pointer is nil, these rules will skip the validation.\n\nAn exception is the and rules. When a pointer is nil, they will report a validation error.\n\nIf a data type implements the interface (e.g. ), the built-in validation rules will handle it properly. In particular, when a rule is validating such data, it will call the method and validate the returned value instead.\n\nWhen validating input values, there are two different scenarios about checking if input values are provided or not.\n\nIn the first scenario, an input value is considered missing if it is not entered or it is entered as a zero value (e.g. an empty string, a zero integer). You can use the rule in this case.\n\nIn the second scenario, an input value is considered missing only if it is not entered. A pointer field is usually used in this case so that you can detect if a value is entered or not by checking if the pointer is nil or not. You can use the rule to ensure a value is entered (even if it is a zero value).\n\nThe method will properly validate a struct that contains embedded structs. In particular, the fields of an embedded struct are treated as if they belong directly to the containing struct. For example,\n\nIn the above code, we use to specify the validation of the field of the embedded struct . And the validation error uses as the key for the error associated with the field as if a field directly belonging to .\n\nIf implements the interface, we can also use the following code to validate , which generates the same validation result:\n\nSometimes, we may want to validate a value only when certain condition is met. For example, we want to ensure the struct field is not empty only when the field is not empty; or we may want to ensure either or is provided. The so-called conditional validation can be achieved with the help of . The following code implements the aforementioned examples:\n\nNote that and can take a list of validation rules. These rules will be executed only when the condition is true (When) or false (Else).\n\nThe above code can also be simplified using the shortcut :\n\nAll built-in validation rules allow you to customize their error messages. To do so, simply call the method of the rules. For example,\n\nYou can also customize the pre-defined error(s) of a built-in rule such that the customization applies to every instance of the rule. For example, the rule uses the pre-defined error . You can customize it during the application initialization:\n\nThe errors returned by the validation rules implement the interface which contains the method to provide the error code information. While the message of a validation error is often customized, the code is immutable. You can use error code to programmatically check a validation error or look for the translation of the corresponding message.\n\nIf you are developing your own validation rules, you can use to create a validation error which implements the aforementioned interface.\n\nCreating a custom rule is as simple as implementing the interface. The interface contains a single method as shown below, which should validate the value and return the validation error, if any:\n\nIf you already have a function with the same signature as shown above, you can call to turn it into a validation rule. For example,\n\nIf your validation function takes additional parameters, you can use the following closure trick:\n\nWhen a combination of several rules are used in multiple places, you may use the following trick to create a rule group so that your code is more maintainable.\n\nIn the above example, we create a rule group which consists of two validation rules. We then use this rule group to validate both and .\n\nWhile most validation rules are self-contained, some rules may depend dynamically on a context. A rule may implement the interface to support the so-called context-aware validation.\n\nTo validate an arbitrary value with a context, call . The parameter will be passed along to those rules that implement .\n\nTo validate the fields of a struct with a context, call .\n\nYou can define a context-aware rule from scratch by implementing both and . You can also use to turn a function into a context-aware rule. For example,\n\nWhen performing context-aware validation, if a rule does not implement , its will be used instead.\n\nThe following rules are provided in the package:\n‚Ä¢ : checks if a value can be found in the given list of values.\n‚Ä¢ : checks if a value is NOT among the given list of values.\n‚Ä¢ : checks if the length of a value is within the specified range. This rule should only be used for validating strings, slices, maps, and arrays.\n‚Ä¢ : checks if the length of a string is within the specified range. This rule is similar as except that when the value being validated is a string, it checks its rune length instead of byte length.\n‚Ä¢ and : checks if a value is within the specified range. These two rules should only be used for validating int, uint, float and time.Time types.\n‚Ä¢ : checks if a value matches the specified regular expression. This rule should only be used for strings and byte slices.\n‚Ä¢ : checks if a string value is a date whose format is specified by the layout. By calling and/or , you can check additionally if the date is within the specified range.\n‚Ä¢ : checks if a value is not empty (neither nil nor zero).\n‚Ä¢ : checks if a pointer value is not nil. Non-pointer values are considered valid.\n‚Ä¢ : checks if a value is a nil pointer or a non-empty value. This differs from in that it treats a nil pointer as valid.\n‚Ä¢ : checks if a value is a nil pointer.\n‚Ä¢ : checks if a value is empty. nil pointers are considered valid.\n‚Ä¢ : this is a special rule used to indicate that all rules following it should be skipped (including the nested ones).\n‚Ä¢ : checks if the value is a multiple of the specified range.\n‚Ä¢ : checks the elements within an iterable (map/slice/array) with other rules.\n‚Ä¢ : validates with the specified rules only when the condition is true.\n‚Ä¢ : must be used with , validates with the specified rules only when the condition is false.\n\nThe sub-package provides a list of commonly used string validation rules that can be used to check if the format of a value satisfies certain requirements. Note that these rules only handle strings and byte slices and if a string or byte slice is empty, it is considered valid. You may use a rule to ensure a value is not empty. Below is the whole list of the rules provided by the package:\n‚Ä¢ : validates if a string is an email or not. It also checks if the MX record exists for the email domain.\n‚Ä¢ : validates if a string is an email or not. It does NOT check the existence of the MX record.\n‚Ä¢ : validates if a string contains English letters only (a-zA-Z)\n‚Ä¢ : validates if a string contains digits only (0-9)\n‚Ä¢ : validates if a string contains English letters and digits only (a-zA-Z0-9)\n‚Ä¢ : validates if a string contains unicode letters only\n‚Ä¢ : validates if a string contains unicode decimal digits only\n‚Ä¢ : validates if a string contains unicode letters and numbers only\n‚Ä¢ : validates if a string contains unicode number characters (category N) only\n‚Ä¢ : validates if a string contains lower case unicode letters only\n‚Ä¢ : validates if a string contains upper case unicode letters only\n‚Ä¢ : validates if a string is a valid RGB color in the form of rgb(R, G, B)\n‚Ä¢ : validates if a string is an ISBN version 10\n‚Ä¢ : validates if a string is an ISBN version 13\n‚Ä¢ : validates if a string is an ISBN (either version 10 or 13)\n‚Ä¢ : validates if a string is in valid JSON format\n‚Ä¢ : validates if a string contains ASCII characters only\n‚Ä¢ : validates if a string contains printable ASCII characters only\n‚Ä¢ : validates if a string contains both full-width and half-width characters\n‚Ä¢ : validates if a string is encoded in Base64\n‚Ä¢ : validates if a string is a valid dial string that can be passed to Dial()\n‚Ä¢ : validates if a string is a valid IP address (either version 4 or 6)\n‚Ä¢ : validates if a string is valid DNS name\n‚Ä¢ : validates if a string is a valid IP (both v4 and v6) or a valid DNS name\n\nThe sub-package wraps the excellent validators provided by the govalidator package."
    },
    {
        "link": "https://pkg.go.dev/github.com/go-ozzo/ozzo-validation/v4",
        "document": "ozzo-validation is a Go package that provides configurable and extensible data validation capabilities. It has the following features:\n‚Ä¢ use normal programming constructs rather than error-prone struct tags to specify how data should be validated.\n‚Ä¢ can validate data of different types, e.g., structs, strings, byte slices, slices, maps, arrays.\n‚Ä¢ can validate custom data types as long as they implement the interface.\n‚Ä¢ can validate data types that implement the interface (e.g. ).\n‚Ä¢ provide a rich set of validation rules right out of box.\n‚Ä¢ extremely easy to create and use custom validation rules.\n\nFor an example on how this library is used in an application, please refer to go-rest-api which is a starter kit for building RESTful APIs in Go.\n\nGo 1.13 or above.\n\nThe ozzo-validation package mainly includes a set of validation rules and two validation methods. You use validation rules to describe how a value should be considered valid, and you call either or to validate the value.\n\nRun the following command to install the package:\n\nFor a simple value, such as a string or an integer, you may use to validate it. For example,\n\nThe method will run through the rules in the order that they are listed. If a rule fails the validation, the method will return the corresponding error and skip the rest of the rules. The method will return nil if the value passes all validation rules.\n\nFor a struct value, you usually want to check if its fields are valid. For example, in a RESTful application, you may unmarshal the request payload into a struct and then validate the struct fields. If one or multiple fields are invalid, you may want to get an error describing which fields are invalid. You can use to achieve this purpose. A single struct can have rules for multiple fields, and a field can be associated with multiple rules. For example,\n\nNote that when calling to validate a struct, you should pass to the method a pointer to the struct instead of the struct itself. Similarly, when calling to specify the rules for a struct field, you should use a pointer to the struct field.\n\nWhen the struct validation is performed, the fields are validated in the order they are specified in . And when each field is validated, its rules are also evaluated in the order they are associated with the field. If a rule fails, an error is recorded for that field, and the validation will continue with the next field.\n\nSometimes you might need to work with dynamic data stored in maps rather than a typed model. You can use in this situation. A single map can have rules for multiple keys, and a key can be associated with multiple rules. For example,\n\nWhen the map validation is performed, the keys are validated in the order they are specified in . And when each key is validated, its rules are also evaluated in the order they are associated with the key. If a rule fails, an error is recorded for that key, and the validation will continue with the next key.\n\nThe method returns validation errors found in struct fields in terms of which is a map of fields and their corresponding errors. Nil is returned if validation passes.\n\nBy default, uses the struct tags named to determine what names should be used to represent the invalid fields. The type also implements the interface so that it can be marshaled into a proper JSON object. For example,\n\nYou may modify to use a different struct tag name.\n\nIf you do not like the magic that determines error keys based on struct field names or corresponding tag values, you may use the following alternative approach:\n\nIn the above example, we build a by a list of names and the corresponding validation results. At the end we call to remove from all nils which correspond to those successful validation results. The method will return nil if is empty.\n\nThe above approach is very flexible as it allows you to freely build up your validation error structure. You can use it to validate both struct and non-struct values. Compared to using to validate a struct, it has the drawback that you have to redundantly specify the error keys while can automatically find them out.\n\nInternal errors are different from validation errors in that internal errors are caused by malfunctioning code (e.g. a validator making a remote call to validate some data when the remote service is down) rather than the data being validated. When an internal error happens during data validation, you may allow the user to resubmit the same data to perform validation again, hoping the program resumes functioning. On the other hand, if data validation fails due to data error, the user should generally not resubmit the same data again.\n\nTo differentiate internal errors from validation errors, when an internal error occurs in a validator, wrap it into by calling . The user of the validator can then check if a returned error is an internal error or not. For example,\n\nA type is validatable if it implements the interface.\n\nWhen is used to validate a validatable value, if it does not find any error with the given validation rules, it will further call the value's method.\n\nSimilarly, when is validating a struct field whose type is validatable, it will call the field's method after it passes the listed rules.\n\nIn the following example, the field of is validatable because implements . Therefore, when validating a struct with , validation will \"dive\" into the field.\n\nSometimes, you may want to skip the invocation of a type's method. To do so, simply associate a rule with the value being validated.\n\nWhen validating an iterable (map, slice, or array), whose element type implements the interface, the method will call the method of every non-nil element. The validation errors of the elements will be returned as which maps the keys of the invalid elements to their corresponding validation errors. For example,\n\nWhen using to validate a struct, the above validation procedure also applies to those struct fields which are map/slices/arrays of validatables.\n\nThe validation rule allows you to apply a set of rules to each element of an array, slice, or map.\n\nWhen a value being validated is a pointer, most validation rules will validate the actual value pointed to by the pointer. If the pointer is nil, these rules will skip the validation.\n\nAn exception is the and rules. When a pointer is nil, they will report a validation error.\n\nIf a data type implements the interface (e.g. ), the built-in validation rules will handle it properly. In particular, when a rule is validating such data, it will call the method and validate the returned value instead.\n\nWhen validating input values, there are two different scenarios about checking if input values are provided or not.\n\nIn the first scenario, an input value is considered missing if it is not entered or it is entered as a zero value (e.g. an empty string, a zero integer). You can use the rule in this case.\n\nIn the second scenario, an input value is considered missing only if it is not entered. A pointer field is usually used in this case so that you can detect if a value is entered or not by checking if the pointer is nil or not. You can use the rule to ensure a value is entered (even if it is a zero value).\n\nThe method will properly validate a struct that contains embedded structs. In particular, the fields of an embedded struct are treated as if they belong directly to the containing struct. For example,\n\nIn the above code, we use to specify the validation of the field of the embedded struct . And the validation error uses as the key for the error associated with the field as if a field directly belonging to .\n\nIf implements the interface, we can also use the following code to validate , which generates the same validation result:\n\nSometimes, we may want to validate a value only when certain condition is met. For example, we want to ensure the struct field is not empty only when the field is not empty; or we may want to ensure either or is provided. The so-called conditional validation can be achieved with the help of . The following code implements the aforementioned examples:\n\nNote that and can take a list of validation rules. These rules will be executed only when the condition is true (When) or false (Else).\n\nThe above code can also be simplified using the shortcut :\n\nAll built-in validation rules allow you to customize their error messages. To do so, simply call the method of the rules. For example,\n\nYou can also customize the pre-defined error(s) of a built-in rule such that the customization applies to every instance of the rule. For example, the rule uses the pre-defined error . You can customize it during the application initialization:\n\nThe errors returned by the validation rules implement the interface which contains the method to provide the error code information. While the message of a validation error is often customized, the code is immutable. You can use error code to programmatically check a validation error or look for the translation of the corresponding message.\n\nIf you are developing your own validation rules, you can use to create a validation error which implements the aforementioned interface.\n\nCreating a custom rule is as simple as implementing the interface. The interface contains a single method as shown below, which should validate the value and return the validation error, if any:\n\nIf you already have a function with the same signature as shown above, you can call to turn it into a validation rule. For example,\n\nIf your validation function takes additional parameters, you can use the following closure trick:\n\nWhen a combination of several rules are used in multiple places, you may use the following trick to create a rule group so that your code is more maintainable.\n\nIn the above example, we create a rule group which consists of two validation rules. We then use this rule group to validate both and .\n\nWhile most validation rules are self-contained, some rules may depend dynamically on a context. A rule may implement the interface to support the so-called context-aware validation.\n\nTo validate an arbitrary value with a context, call . The parameter will be passed along to those rules that implement .\n\nTo validate the fields of a struct with a context, call .\n\nYou can define a context-aware rule from scratch by implementing both and . You can also use to turn a function into a context-aware rule. For example,\n\nWhen performing context-aware validation, if a rule does not implement , its will be used instead.\n\nThe following rules are provided in the package:\n‚Ä¢ : checks if a value can be found in the given list of values.\n‚Ä¢ : checks if a value is NOT among the given list of values.\n‚Ä¢ : checks if the length of a value is within the specified range. This rule should only be used for validating strings, slices, maps, and arrays.\n‚Ä¢ : checks if the length of a string is within the specified range. This rule is similar as except that when the value being validated is a string, it checks its rune length instead of byte length.\n‚Ä¢ and : checks if a value is within the specified range. These two rules should only be used for validating int, uint, float and time.Time types.\n‚Ä¢ : checks if a value matches the specified regular expression. This rule should only be used for strings and byte slices.\n‚Ä¢ : checks if a string value is a date whose format is specified by the layout. By calling and/or , you can check additionally if the date is within the specified range.\n‚Ä¢ : checks if a value is not empty (neither nil nor zero).\n‚Ä¢ : checks if a pointer value is not nil. Non-pointer values are considered valid.\n‚Ä¢ : checks if a value is a nil pointer or a non-empty value. This differs from in that it treats a nil pointer as valid.\n‚Ä¢ : checks if a value is a nil pointer.\n‚Ä¢ : checks if a value is empty. nil pointers are considered valid.\n‚Ä¢ : this is a special rule used to indicate that all rules following it should be skipped (including the nested ones).\n‚Ä¢ : checks if the value is a multiple of the specified range.\n‚Ä¢ : checks the elements within an iterable (map/slice/array) with other rules.\n‚Ä¢ : validates with the specified rules only when the condition is true.\n‚Ä¢ : must be used with , validates with the specified rules only when the condition is false.\n\nThe sub-package provides a list of commonly used string validation rules that can be used to check if the format of a value satisfies certain requirements. Note that these rules only handle strings and byte slices and if a string or byte slice is empty, it is considered valid. You may use a rule to ensure a value is not empty. Below is the whole list of the rules provided by the package:\n‚Ä¢ : validates if a string is an email or not. It also checks if the MX record exists for the email domain.\n‚Ä¢ : validates if a string is an email or not. It does NOT check the existence of the MX record.\n‚Ä¢ : validates if a string contains English letters only (a-zA-Z)\n‚Ä¢ : validates if a string contains digits only (0-9)\n‚Ä¢ : validates if a string contains English letters and digits only (a-zA-Z0-9)\n‚Ä¢ : validates if a string contains unicode letters only\n‚Ä¢ : validates if a string contains unicode decimal digits only\n‚Ä¢ : validates if a string contains unicode letters and numbers only\n‚Ä¢ : validates if a string contains unicode number characters (category N) only\n‚Ä¢ : validates if a string contains lower case unicode letters only\n‚Ä¢ : validates if a string contains upper case unicode letters only\n‚Ä¢ : validates if a string is a valid RGB color in the form of rgb(R, G, B)\n‚Ä¢ : validates if a string is an ISBN version 10\n‚Ä¢ : validates if a string is an ISBN version 13\n‚Ä¢ : validates if a string is an ISBN (either version 10 or 13)\n‚Ä¢ : validates if a string is in valid JSON format\n‚Ä¢ : validates if a string contains ASCII characters only\n‚Ä¢ : validates if a string contains printable ASCII characters only\n‚Ä¢ : validates if a string contains both full-width and half-width characters\n‚Ä¢ : validates if a string is encoded in Base64\n‚Ä¢ : validates if a string is a valid dial string that can be passed to Dial()\n‚Ä¢ : validates if a string is a valid IP address (either version 4 or 6)\n‚Ä¢ : validates if a string is valid DNS name\n‚Ä¢ : validates if a string is a valid IP (both v4 and v6) or a valid DNS name\n\nThe sub-package wraps the excellent validators provided by the govalidator package."
    },
    {
        "link": "https://go-ozzo.github.io/ozzo-validation",
        "document": "ozzo-validation is a Go package that provides configurable and extensible data validation capabilities. It has the following features:\n‚Ä¢ use normal programming constructs rather than error-prone struct tags to specify how data should be validated.\n‚Ä¢ can validate data of different types, e.g., structs, strings, byte slices, slices, maps, arrays.\n‚Ä¢ can validate custom data types as long as they implement the interface.\n‚Ä¢ can validate data types that implement the interface (e.g. ).\n‚Ä¢ provide a rich set of validation rules right out of box.\n‚Ä¢ extremely easy to create and use custom validation rules.\n\nFor an example on how this library is used in an application, please refer to go-rest-api which is a starter kit for building RESTful APIs in Go.\n\nGo 1.13 or above.\n\nThe ozzo-validation package mainly includes a set of validation rules and two validation methods. You use validation rules to describe how a value should be considered valid, and you call either or to validate the value.\n\nRun the following command to install the package:\n\nFor a simple value, such as a string or an integer, you may use to validate it. For example,\n\nThe method will run through the rules in the order that they are listed. If a rule fails the validation, the method will return the corresponding error and skip the rest of the rules. The method will return nil if the value passes all validation rules.\n\nFor a struct value, you usually want to check if its fields are valid. For example, in a RESTful application, you may unmarshal the request payload into a struct and then validate the struct fields. If one or multiple fields are invalid, you may want to get an error describing which fields are invalid. You can use to achieve this purpose. A single struct can have rules for multiple fields, and a field can be associated with multiple rules. For example,\n\nNote that when calling to validate a struct, you should pass to the method a pointer to the struct instead of the struct itself. Similarly, when calling to specify the rules for a struct field, you should use a pointer to the struct field.\n\nWhen the struct validation is performed, the fields are validated in the order they are specified in . And when each field is validated, its rules are also evaluated in the order they are associated with the field. If a rule fails, an error is recorded for that field, and the validation will continue with the next field.\n\nSometimes you might need to work with dynamic data stored in maps rather than a typed model. You can use in this situation. A single map can have rules for multiple keys, and a key can be associated with multiple rules. For example,\n\nWhen the map validation is performed, the keys are validated in the order they are specified in . And when each key is validated, its rules are also evaluated in the order they are associated with the key. If a rule fails, an error is recorded for that key, and the validation will continue with the next key.\n\nThe method returns validation errors found in struct fields in terms of which is a map of fields and their corresponding errors. Nil is returned if validation passes.\n\nBy default, uses the struct tags named to determine what names should be used to represent the invalid fields. The type also implements the interface so that it can be marshaled into a proper JSON object. For example,\n\nYou may modify to use a different struct tag name.\n\nIf you do not like the magic that determines error keys based on struct field names or corresponding tag values, you may use the following alternative approach:\n\nIn the above example, we build a by a list of names and the corresponding validation results. At the end we call to remove from all nils which correspond to those successful validation results. The method will return nil if is empty.\n\nThe above approach is very flexible as it allows you to freely build up your validation error structure. You can use it to validate both struct and non-struct values. Compared to using to validate a struct, it has the drawback that you have to redundantly specify the error keys while can automatically find them out.\n\nInternal errors are different from validation errors in that internal errors are caused by malfunctioning code (e.g. a validator making a remote call to validate some data when the remote service is down) rather than the data being validated. When an internal error happens during data validation, you may allow the user to resubmit the same data to perform validation again, hoping the program resumes functioning. On the other hand, if data validation fails due to data error, the user should generally not resubmit the same data again.\n\nTo differentiate internal errors from validation errors, when an internal error occurs in a validator, wrap it into by calling . The user of the validator can then check if a returned error is an internal error or not. For example,\n\nA type is validatable if it implements the interface.\n\nWhen is used to validate a validatable value, if it does not find any error with the given validation rules, it will further call the value‚Äôs method.\n\nSimilarly, when is validating a struct field whose type is validatable, it will call the field‚Äôs method after it passes the listed rules.\n\nIn the following example, the field of is validatable because implements . Therefore, when validating a struct with , validation will ‚Äúdive‚Äù into the field.\n\nSometimes, you may want to skip the invocation of a type‚Äôs method. To do so, simply associate a rule with the value being validated.\n\nWhen validating an iterable (map, slice, or array), whose element type implements the interface, the method will call the method of every non-nil element. The validation errors of the elements will be returned as which maps the keys of the invalid elements to their corresponding validation errors. For example,\n\nWhen using to validate a struct, the above validation procedure also applies to those struct fields which are map/slices/arrays of validatables.\n\nThe validation rule allows you to apply a set of rules to each element of an array, slice, or map.\n\nWhen a value being validated is a pointer, most validation rules will validate the actual value pointed to by the pointer. If the pointer is nil, these rules will skip the validation.\n\nAn exception is the and rules. When a pointer is nil, they will report a validation error.\n\nIf a data type implements the interface (e.g. ), the built-in validation rules will handle it properly. In particular, when a rule is validating such data, it will call the method and validate the returned value instead.\n\nWhen validating input values, there are two different scenarios about checking if input values are provided or not.\n\nIn the first scenario, an input value is considered missing if it is not entered or it is entered as a zero value (e.g. an empty string, a zero integer). You can use the rule in this case.\n\nIn the second scenario, an input value is considered missing only if it is not entered. A pointer field is usually used in this case so that you can detect if a value is entered or not by checking if the pointer is nil or not. You can use the rule to ensure a value is entered (even if it is a zero value).\n\nThe method will properly validate a struct that contains embedded structs. In particular, the fields of an embedded struct are treated as if they belong directly to the containing struct. For example,\n\nIn the above code, we use to specify the validation of the field of the embedded struct . And the validation error uses as the key for the error associated with the field as if a field directly belonging to .\n\nIf implements the interface, we can also use the following code to validate , which generates the same validation result:\n\nSometimes, we may want to validate a value only when certain condition is met. For example, we want to ensure the struct field is not empty only when the field is not empty; or we may want to ensure either or is provided. The so-called conditional validation can be achieved with the help of . The following code implements the aforementioned examples:\n\nNote that and can take a list of validation rules. These rules will be executed only when the condition is true (When) or false (Else).\n\nThe above code can also be simplified using the shortcut :\n\nAll built-in validation rules allow you to customize their error messages. To do so, simply call the method of the rules. For example,\n\nYou can also customize the pre-defined error(s) of a built-in rule such that the customization applies to every instance of the rule. For example, the rule uses the pre-defined error . You can customize it during the application initialization:\n\nThe errors returned by the validation rules implement the interface which contains the method to provide the error code information. While the message of a validation error is often customized, the code is immutable. You can use error code to programmatically check a validation error or look for the translation of the corresponding message.\n\nIf you are developing your own validation rules, you can use to create a validation error which implements the aforementioned interface.\n\nCreating a custom rule is as simple as implementing the interface. The interface contains a single method as shown below, which should validate the value and return the validation error, if any:\n\nIf you already have a function with the same signature as shown above, you can call to turn it into a validation rule. For example,\n\nIf your validation function takes additional parameters, you can use the following closure trick:\n\nWhen a combination of several rules are used in multiple places, you may use the following trick to create a rule group so that your code is more maintainable.\n\nIn the above example, we create a rule group which consists of two validation rules. We then use this rule group to validate both and .\n\nWhile most validation rules are self-contained, some rules may depend dynamically on a context. A rule may implement the interface to support the so-called context-aware validation.\n\nTo validate an arbitrary value with a context, call . The parameter will be passed along to those rules that implement .\n\nTo validate the fields of a struct with a context, call .\n\nYou can define a context-aware rule from scratch by implementing both and . You can also use to turn a function into a context-aware rule. For example,\n\nWhen performing context-aware validation, if a rule does not implement , its will be used instead.\n\nThe following rules are provided in the package:\n‚Ä¢ : checks if a value can be found in the given list of values.\n‚Ä¢ : checks if a value is NOT among the given list of values.\n‚Ä¢ : checks if the length of a value is within the specified range. This rule should only be used for validating strings, slices, maps, and arrays.\n‚Ä¢ : checks if the length of a string is within the specified range. This rule is similar as except that when the value being validated is a string, it checks its rune length instead of byte length.\n‚Ä¢ and : checks if a value is within the specified range. These two rules should only be used for validating int, uint, float and time.Time types.\n‚Ä¢ : checks if a value matches the specified regular expression. This rule should only be used for strings and byte slices.\n‚Ä¢ : checks if a string value is a date whose format is specified by the layout. By calling and/or , you can check additionally if the date is within the specified range.\n‚Ä¢ : checks if a value is not empty (neither nil nor zero).\n‚Ä¢ : checks if a pointer value is not nil. Non-pointer values are considered valid.\n‚Ä¢ : checks if a value is a nil pointer or a non-empty value. This differs from in that it treats a nil pointer as valid.\n‚Ä¢ : checks if a value is a nil pointer.\n‚Ä¢ : checks if a value is empty. nil pointers are considered valid.\n‚Ä¢ : this is a special rule used to indicate that all rules following it should be skipped (including the nested ones).\n‚Ä¢ : checks if the value is a multiple of the specified range.\n‚Ä¢ : checks the elements within an iterable (map/slice/array) with other rules.\n‚Ä¢ : validates with the specified rules only when the condition is true.\n‚Ä¢ : must be used with , validates with the specified rules only when the condition is false.\n\nThe sub-package provides a list of commonly used string validation rules that can be used to check if the format of a value satisfies certain requirements. Note that these rules only handle strings and byte slices and if a string or byte slice is empty, it is considered valid. You may use a rule to ensure a value is not empty. Below is the whole list of the rules provided by the package:\n‚Ä¢ : validates if a string is an email or not. It also checks if the MX record exists for the email domain.\n‚Ä¢ : validates if a string is an email or not. It does NOT check the existence of the MX record.\n‚Ä¢ : validates if a string contains English letters only (a-zA-Z)\n‚Ä¢ : validates if a string contains digits only (0-9)\n‚Ä¢ : validates if a string contains English letters and digits only (a-zA-Z0-9)\n‚Ä¢ : validates if a string contains unicode letters only\n‚Ä¢ : validates if a string contains unicode decimal digits only\n‚Ä¢ : validates if a string contains unicode letters and numbers only\n‚Ä¢ : validates if a string contains unicode number characters (category N) only\n‚Ä¢ : validates if a string contains lower case unicode letters only\n‚Ä¢ : validates if a string contains upper case unicode letters only\n‚Ä¢ : validates if a string is a valid RGB color in the form of rgb(R, G, B)\n‚Ä¢ : validates if a string is an ISBN version 10\n‚Ä¢ : validates if a string is an ISBN version 13\n‚Ä¢ : validates if a string is an ISBN (either version 10 or 13)\n‚Ä¢ : validates if a string is in valid JSON format\n‚Ä¢ : validates if a string contains ASCII characters only\n‚Ä¢ : validates if a string contains printable ASCII characters only\n‚Ä¢ : validates if a string contains both full-width and half-width characters\n‚Ä¢ : validates if a string is encoded in Base64\n‚Ä¢ : validates if a string is a valid dial string that can be passed to Dial()\n‚Ä¢ : validates if a string is a valid IP address (either version 4 or 6)\n‚Ä¢ : validates if a string is valid DNS name\n‚Ä¢ : validates if a string is a valid IP (both v4 and v6) or a valid DNS name\n\nThe sub-package wraps the excellent validators provided by the govalidator package."
    },
    {
        "link": "https://github.com/go-ozzo/ozzo-validation/blob/master/README.md",
        "document": "ozzo-validation is a Go package that provides configurable and extensible data validation capabilities. It has the following features:\n‚Ä¢ use normal programming constructs rather than error-prone struct tags to specify how data should be validated.\n‚Ä¢ can validate data of different types, e.g., structs, strings, byte slices, slices, maps, arrays.\n‚Ä¢ can validate custom data types as long as they implement the interface.\n‚Ä¢ can validate data types that implement the interface (e.g. ).\n‚Ä¢ provide a rich set of validation rules right out of box.\n‚Ä¢ extremely easy to create and use custom validation rules.\n\nFor an example on how this library is used in an application, please refer to go-rest-api which is a starter kit for building RESTful APIs in Go.\n\nGo 1.13 or above.\n\nThe ozzo-validation package mainly includes a set of validation rules and two validation methods. You use validation rules to describe how a value should be considered valid, and you call either or to validate the value.\n\nRun the following command to install the package:\n\nFor a simple value, such as a string or an integer, you may use to validate it. For example,\n\nThe method will run through the rules in the order that they are listed. If a rule fails the validation, the method will return the corresponding error and skip the rest of the rules. The method will return nil if the value passes all validation rules.\n\nFor a struct value, you usually want to check if its fields are valid. For example, in a RESTful application, you may unmarshal the request payload into a struct and then validate the struct fields. If one or multiple fields are invalid, you may want to get an error describing which fields are invalid. You can use to achieve this purpose. A single struct can have rules for multiple fields, and a field can be associated with multiple rules. For example,\n\nNote that when calling to validate a struct, you should pass to the method a pointer to the struct instead of the struct itself. Similarly, when calling to specify the rules for a struct field, you should use a pointer to the struct field.\n\nWhen the struct validation is performed, the fields are validated in the order they are specified in . And when each field is validated, its rules are also evaluated in the order they are associated with the field. If a rule fails, an error is recorded for that field, and the validation will continue with the next field.\n\nSometimes you might need to work with dynamic data stored in maps rather than a typed model. You can use in this situation. A single map can have rules for multiple keys, and a key can be associated with multiple rules. For example,\n\nWhen the map validation is performed, the keys are validated in the order they are specified in . And when each key is validated, its rules are also evaluated in the order they are associated with the key. If a rule fails, an error is recorded for that key, and the validation will continue with the next key.\n\nThe method returns validation errors found in struct fields in terms of which is a map of fields and their corresponding errors. Nil is returned if validation passes.\n\nBy default, uses the struct tags named to determine what names should be used to represent the invalid fields. The type also implements the interface so that it can be marshaled into a proper JSON object. For example,\n\nYou may modify to use a different struct tag name.\n\nIf you do not like the magic that determines error keys based on struct field names or corresponding tag values, you may use the following alternative approach:\n\nIn the above example, we build a by a list of names and the corresponding validation results. At the end we call to remove from all nils which correspond to those successful validation results. The method will return nil if is empty.\n\nThe above approach is very flexible as it allows you to freely build up your validation error structure. You can use it to validate both struct and non-struct values. Compared to using to validate a struct, it has the drawback that you have to redundantly specify the error keys while can automatically find them out.\n\nInternal errors are different from validation errors in that internal errors are caused by malfunctioning code (e.g. a validator making a remote call to validate some data when the remote service is down) rather than the data being validated. When an internal error happens during data validation, you may allow the user to resubmit the same data to perform validation again, hoping the program resumes functioning. On the other hand, if data validation fails due to data error, the user should generally not resubmit the same data again.\n\nTo differentiate internal errors from validation errors, when an internal error occurs in a validator, wrap it into by calling . The user of the validator can then check if a returned error is an internal error or not. For example,\n\nA type is validatable if it implements the interface.\n\nWhen is used to validate a validatable value, if it does not find any error with the given validation rules, it will further call the value's method.\n\nSimilarly, when is validating a struct field whose type is validatable, it will call the field's method after it passes the listed rules.\n\nIn the following example, the field of is validatable because implements . Therefore, when validating a struct with , validation will \"dive\" into the field.\n\nSometimes, you may want to skip the invocation of a type's method. To do so, simply associate a rule with the value being validated.\n\nWhen validating an iterable (map, slice, or array), whose element type implements the interface, the method will call the method of every non-nil element. The validation errors of the elements will be returned as which maps the keys of the invalid elements to their corresponding validation errors. For example,\n\nWhen using to validate a struct, the above validation procedure also applies to those struct fields which are map/slices/arrays of validatables.\n\nThe validation rule allows you to apply a set of rules to each element of an array, slice, or map.\n\nWhen a value being validated is a pointer, most validation rules will validate the actual value pointed to by the pointer. If the pointer is nil, these rules will skip the validation.\n\nAn exception is the and rules. When a pointer is nil, they will report a validation error.\n\nIf a data type implements the interface (e.g. ), the built-in validation rules will handle it properly. In particular, when a rule is validating such data, it will call the method and validate the returned value instead.\n\nWhen validating input values, there are two different scenarios about checking if input values are provided or not.\n\nIn the first scenario, an input value is considered missing if it is not entered or it is entered as a zero value (e.g. an empty string, a zero integer). You can use the rule in this case.\n\nIn the second scenario, an input value is considered missing only if it is not entered. A pointer field is usually used in this case so that you can detect if a value is entered or not by checking if the pointer is nil or not. You can use the rule to ensure a value is entered (even if it is a zero value).\n\nThe method will properly validate a struct that contains embedded structs. In particular, the fields of an embedded struct are treated as if they belong directly to the containing struct. For example,\n\nIn the above code, we use to specify the validation of the field of the embedded struct . And the validation error uses as the key for the error associated with the field as if a field directly belonging to .\n\nIf implements the interface, we can also use the following code to validate , which generates the same validation result:\n\nSometimes, we may want to validate a value only when certain condition is met. For example, we want to ensure the struct field is not empty only when the field is not empty; or we may want to ensure either or is provided. The so-called conditional validation can be achieved with the help of . The following code implements the aforementioned examples:\n\nNote that and can take a list of validation rules. These rules will be executed only when the condition is true (When) or false (Else).\n\nThe above code can also be simplified using the shortcut :\n\nAll built-in validation rules allow you to customize their error messages. To do so, simply call the method of the rules. For example,\n\nYou can also customize the pre-defined error(s) of a built-in rule such that the customization applies to every instance of the rule. For example, the rule uses the pre-defined error . You can customize it during the application initialization:\n\nThe errors returned by the validation rules implement the interface which contains the method to provide the error code information. While the message of a validation error is often customized, the code is immutable. You can use error code to programmatically check a validation error or look for the translation of the corresponding message.\n\nIf you are developing your own validation rules, you can use to create a validation error which implements the aforementioned interface.\n\nCreating a custom rule is as simple as implementing the interface. The interface contains a single method as shown below, which should validate the value and return the validation error, if any:\n\nIf you already have a function with the same signature as shown above, you can call to turn it into a validation rule. For example,\n\nIf your validation function takes additional parameters, you can use the following closure trick:\n\nWhen a combination of several rules are used in multiple places, you may use the following trick to create a rule group so that your code is more maintainable.\n\nIn the above example, we create a rule group which consists of two validation rules. We then use this rule group to validate both and .\n\nWhile most validation rules are self-contained, some rules may depend dynamically on a context. A rule may implement the interface to support the so-called context-aware validation.\n\nTo validate an arbitrary value with a context, call . The parameter will be passed along to those rules that implement .\n\nTo validate the fields of a struct with a context, call .\n\nYou can define a context-aware rule from scratch by implementing both and . You can also use to turn a function into a context-aware rule. For example,\n\nWhen performing context-aware validation, if a rule does not implement , its will be used instead.\n\nThe following rules are provided in the package:\n‚Ä¢ : checks if a value can be found in the given list of values.\n‚Ä¢ : checks if a value is NOT among the given list of values.\n‚Ä¢ : checks if the length of a value is within the specified range. This rule should only be used for validating strings, slices, maps, and arrays.\n‚Ä¢ : checks if the length of a string is within the specified range. This rule is similar as except that when the value being validated is a string, it checks its rune length instead of byte length.\n‚Ä¢ and : checks if a value is within the specified range. These two rules should only be used for validating int, uint, float and time.Time types.\n‚Ä¢ : checks if a value matches the specified regular expression. This rule should only be used for strings and byte slices.\n‚Ä¢ : checks if a string value is a date whose format is specified by the layout. By calling and/or , you can check additionally if the date is within the specified range.\n‚Ä¢ : checks if a value is not empty (neither nil nor zero).\n‚Ä¢ : checks if a pointer value is not nil. Non-pointer values are considered valid.\n‚Ä¢ : checks if a value is a nil pointer or a non-empty value. This differs from in that it treats a nil pointer as valid.\n‚Ä¢ : checks if a value is a nil pointer.\n‚Ä¢ : checks if a value is empty. nil pointers are considered valid.\n‚Ä¢ : this is a special rule used to indicate that all rules following it should be skipped (including the nested ones).\n‚Ä¢ : checks if the value is a multiple of the specified range.\n‚Ä¢ : checks the elements within an iterable (map/slice/array) with other rules.\n‚Ä¢ : validates with the specified rules only when the condition is true.\n‚Ä¢ : must be used with , validates with the specified rules only when the condition is false.\n\nThe sub-package provides a list of commonly used string validation rules that can be used to check if the format of a value satisfies certain requirements. Note that these rules only handle strings and byte slices and if a string or byte slice is empty, it is considered valid. You may use a rule to ensure a value is not empty. Below is the whole list of the rules provided by the package:\n‚Ä¢ : validates if a string is an email or not. It also checks if the MX record exists for the email domain.\n‚Ä¢ : validates if a string is an email or not. It does NOT check the existence of the MX record.\n‚Ä¢ : validates if a string contains English letters only (a-zA-Z)\n‚Ä¢ : validates if a string contains digits only (0-9)\n‚Ä¢ : validates if a string contains English letters and digits only (a-zA-Z0-9)\n‚Ä¢ : validates if a string contains unicode letters only\n‚Ä¢ : validates if a string contains unicode decimal digits only\n‚Ä¢ : validates if a string contains unicode letters and numbers only\n‚Ä¢ : validates if a string contains unicode number characters (category N) only\n‚Ä¢ : validates if a string contains lower case unicode letters only\n‚Ä¢ : validates if a string contains upper case unicode letters only\n‚Ä¢ : validates if a string is a valid RGB color in the form of rgb(R, G, B)\n‚Ä¢ : validates if a string is an ISBN version 10\n‚Ä¢ : validates if a string is an ISBN version 13\n‚Ä¢ : validates if a string is an ISBN (either version 10 or 13)\n‚Ä¢ : validates if a string is in valid JSON format\n‚Ä¢ : validates if a string contains ASCII characters only\n‚Ä¢ : validates if a string contains printable ASCII characters only\n‚Ä¢ : validates if a string contains both full-width and half-width characters\n‚Ä¢ : validates if a string is encoded in Base64\n‚Ä¢ : validates if a string is a valid dial string that can be passed to Dial()\n‚Ä¢ : validates if a string is a valid IP address (either version 4 or 6)\n‚Ä¢ : validates if a string is valid DNS name\n‚Ä¢ : validates if a string is a valid IP (both v4 and v6) or a valid DNS name\n\nThe sub-package wraps the excellent validators provided by the govalidator package."
    },
    {
        "link": "https://pkg.go.dev/github.com/go-ozzo/ozzo-validation",
        "document": "ozzo-validation is a Go package that provides configurable and extensible data validation capabilities. It has the following features:\n‚Ä¢ use normal programming constructs rather than error-prone struct tags to specify how data should be validated.\n‚Ä¢ can validate data of different types, e.g., structs, strings, byte slices, slices, maps, arrays.\n‚Ä¢ can validate custom data types as long as they implement the interface.\n‚Ä¢ can validate data types that implement the interface (e.g. ).\n‚Ä¢ provide a rich set of validation rules right out of box.\n‚Ä¢ extremely easy to create and use custom validation rules.\n\nGo 1.8 or above.\n\nThe ozzo-validation package mainly includes a set of validation rules and two validation methods. You use validation rules to describe how a value should be considered valid, and you call either or to validate the value.\n\nRun the following command to install the package:\n\nFor a simple value, such as a string or an integer, you may use to validate it. For example,\n\nThe method will run through the rules in the order that they are listed. If a rule fails the validation, the method will return the corresponding error and skip the rest of the rules. The method will return nil if the value passes all validation rules.\n\nFor a struct value, you usually want to check if its fields are valid. For example, in a RESTful application, you may unmarshal the request payload into a struct and then validate the struct fields. If one or multiple fields are invalid, you may want to get an error describing which fields are invalid. You can use to achieve this purpose. A single struct can have rules for multiple fields, and a field can be associated with multiple rules. For example,\n\nNote that when calling to validate a struct, you should pass to the method a pointer to the struct instead of the struct itself. Similarly, when calling to specify the rules for a struct field, you should use a pointer to the struct field.\n\nWhen the struct validation is performed, the fields are validated in the order they are specified in . And when each field is validated, its rules are also evaluated in the order they are associated with the field. If a rule fails, an error is recorded for that field, and the validation will continue with the next field.\n\nThe method returns validation errors found in struct fields in terms of which is a map of fields and their corresponding errors. Nil is returned if validation passes.\n\nBy default, uses the struct tags named to determine what names should be used to represent the invalid fields. The type also implements the interface so that it can be marshaled into a proper JSON object. For example,\n\nYou may modify to use a different struct tag name.\n\nIf you do not like the magic that determines error keys based on struct field names or corresponding tag values, you may use the following alternative approach:\n\nIn the above example, we build a by a list of names and the corresponding validation results. At the end we call to remove from all nils which correspond to those successful validation results. The method will return nil if is empty.\n\nThe above approach is very flexible as it allows you to freely build up your validation error structure. You can use it to validate both struct and non-struct values. Compared to using to validate a struct, it has the drawback that you have to redundantly specify the error keys while can automatically find them out.\n\nInternal errors are different from validation errors in that internal errors are caused by malfunctioning code (e.g. a validator making a remote call to validate some data when the remote service is down) rather than the data being validated. When an internal error happens during data validation, you may allow the user to resubmit the same data to perform validation again, hoping the program resumes functioning. On the other hand, if data validation fails due to data error, the user should generally not resubmit the same data again.\n\nTo differentiate internal errors from validation errors, when an internal error occurs in a validator, wrap it into by calling . The user of the validator can then check if a returned error is an internal error or not. For example,\n\nA type is validatable if it implements the interface.\n\nWhen is used to validate a validatable value, if it does not find any error with the given validation rules, it will further call the value's method.\n\nSimilarly, when is validating a struct field whose type is validatable, it will call the field's method after it passes the listed rules.\n\nIn the following example, the field of is validatable because implements . Therefore, when validating a struct with , validation will \"dive\" into the field.\n\nSometimes, you may want to skip the invocation of a type's method. To do so, simply associate a rule with the value being validated.\n\nWhen validating an iterable (map, slice, or array), whose element type implements the interface, the method will call the method of every non-nil element. The validation errors of the elements will be returned as which maps the keys of the invalid elements to their corresponding validation errors. For example,\n\nWhen using to validate a struct, the above validation procedure also applies to those struct fields which are map/slices/arrays of validatables.\n\nAn other option is to use the method. This method allows you to define the rules for the iterables within a struct.\n\nWhen a value being validated is a pointer, most validation rules will validate the actual value pointed to by the pointer. If the pointer is nil, these rules will skip the validation.\n\nAn exception is the and rules. When a pointer is nil, they will report a validation error.\n\nIf a data type implements the interface (e.g. ), the built-in validation rules will handle it properly. In particular, when a rule is validating such data, it will call the method and validate the returned value instead.\n\nWhen validating input values, there are two different scenarios about checking if input values are provided or not.\n\nIn the first scenario, an input value is considered missing if it is not entered or it is entered as a zero value (e.g. an empty string, a zero integer). You can use the rule in this case.\n\nIn the second scenario, an input value is considered missing only if it is not entered. A pointer field is usually used in this case so that you can detect if a value is entered or not by checking if the pointer is nil or not. You can use the rule to ensure a value is entered (even if it is a zero value).\n\nThe method will properly validate a struct that contains embedded structs. In particular, the fields of an embedded struct are treated as if they belong directly to the containing struct. For example,\n\nIn the above code, we use to specify the validation of the field of the embedded struct . And the validation error uses as the key for the error associated with the field as if a field directly belonging to .\n\nIf implements the interface, we can also use the following code to validate , which generates the same validation result:\n\nThe following rules are provided in the package:\n‚Ä¢ : checks if a value can be found in the given list of values.\n‚Ä¢ : checks if the length of a value is within the specified range. This rule should only be used for validating strings, slices, maps, and arrays.\n‚Ä¢ : checks if the length of a string is within the specified range. This rule is similar as except that when the value being validated is a string, it checks its rune length instead of byte length.\n‚Ä¢ and : checks if a value is within the specified range. These two rules should only be used for validating int, uint, float and time.Time types.\n‚Ä¢ : checks if a value matches the specified regular expression. This rule should only be used for strings and byte slices.\n‚Ä¢ : checks if a string value is a date whose format is specified by the layout. By calling and/or , you can check additionally if the date is within the specified range.\n‚Ä¢ : checks if a value is not empty (neither nil nor zero).\n‚Ä¢ : checks if a pointer value is not nil. Non-pointer values are considered valid.\n‚Ä¢ : checks if a value is a nil pointer or a non-empty value. This differs from in that it treats a nil pointer as valid.\n‚Ä¢ : this is a special rule used to indicate that all rules following it should be skipped (including the nested ones).\n‚Ä¢ : checks if the value is a multiple of the specified range.\n‚Ä¢ : checks the elements within an iterable (map/slice/array) with other rules.\n\nThe sub-package provides a list of commonly used string validation rules that can be used to check if the format of a value satisfies certain requirements. Note that these rules only handle strings and byte slices and if a string or byte slice is empty, it is considered valid. You may use a rule to ensure a value is not empty. Below is the whole list of the rules provided by the package:\n‚Ä¢ : validates if a string is an email or not\n‚Ä¢ : validates if a string contains English letters only (a-zA-Z)\n‚Ä¢ : validates if a string contains digits only (0-9)\n‚Ä¢ : validates if a string contains English letters and digits only (a-zA-Z0-9)\n‚Ä¢ : validates if a string contains unicode letters only\n‚Ä¢ : validates if a string contains unicode decimal digits only\n‚Ä¢ : validates if a string contains unicode letters and numbers only\n‚Ä¢ : validates if a string contains unicode number characters (category N) only\n‚Ä¢ : validates if a string contains lower case unicode letters only\n‚Ä¢ : validates if a string contains upper case unicode letters only\n‚Ä¢ : validates if a string is a valid RGB color in the form of rgb(R, G, B)\n‚Ä¢ : validates if a string is an ISBN version 10\n‚Ä¢ : validates if a string is an ISBN version 13\n‚Ä¢ : validates if a string is an ISBN (either version 10 or 13)\n‚Ä¢ : validates if a string is in valid JSON format\n‚Ä¢ : validates if a string contains ASCII characters only\n‚Ä¢ : validates if a string contains printable ASCII characters only\n‚Ä¢ : validates if a string contains both full-width and half-width characters\n‚Ä¢ : validates if a string is encoded in Base64\n‚Ä¢ : validates if a string is a valid dial string that can be passed to Dial()\n‚Ä¢ : validates if a string is a valid IP address (either version 4 or 6)\n‚Ä¢ : validates if a string is valid DNS name\n‚Ä¢ : validates if a string is a valid IP (both v4 and v6) or a valid DNS name\n\nAll built-in validation rules allow you to customize error messages. To do so, simply call the method of the rules. For example,\n\nCreating a custom rule is as simple as implementing the interface. The interface contains a single method as shown below, which should validate the value and return the validation error, if any:\n\nIf you already have a function with the same signature as shown above, you can call to turn it into a validation rule. For example,\n\nIf your validation function takes additional parameters, you can use the following closure trick:\n\nWhen a combination of several rules are used in multiple places, you may use the following trick to create a rule group so that your code is more maintainable.\n\nIn the above example, we create a rule group which consists of two validation rules. We then use this rule group to validate both and .\n\nThe sub-package wraps the excellent validators provided by the govalidator package."
    }
]