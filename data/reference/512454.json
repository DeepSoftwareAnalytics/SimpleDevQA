[
    {
        "link": "https://router.vuejs.org/guide/advanced/composition-api",
        "document": "The introduction of Vue's Composition API opened up new possibilities, but to be able to get the full potential out of Vue Router, we will need to use a few new functions to replace access to and in-component navigation guards.\n\nBecause we don't have access to inside of , we cannot directly access or . Instead, we use the and composables:\n\nThe object is a reactive object. In most scenarios, you should avoid watching the whole object. Instead, you can directly watch the properties you are expecting to change:\n\nNote we still have access to and in templates, so there's no need to use or if we only need those objects in the template.\n\nComposition API guards can also be used in any component rendered by , they don't have to be used directly on the route component like in-component guards.\n\nVue Router exposes the internal behavior of RouterLink as a composable. It accepts a reactive object like the props of and exposes low-level properties to build your own component or generate custom links:\n\nNote that the RouterLink's gives access to the same properties as the composable."
    },
    {
        "link": "https://vuemastery.com/blog/vue-router-a-tutorial-for-vue-3",
        "document": "If you‚Äôre looking to learn the new Vue Router that uses Vue 3, you‚Äôre in the right place. Many things are the same in Vue 3 using Vue Router, but there are a few small differences from Vue 2. In this article, my aim is to give you an introduction to Vue Router for Vue 3, while highlighting the differences for those of you already familiar with the Router. We will cover:\n\nVue is powerful for creating Single Page Applications: highly interactive webpages that don‚Äôt refresh when you change from page to page. If your website has multiple pages (or ‚Äúviews‚Äù) and you‚Äôre using Vue, that‚Äôs why you need Vue Router.\n\nI‚Äôm going to be building Vue 3 routing by starting with a basic Vue 3 app that I created using the Vue 3 CLI. Feel free to code along. From the command line I‚Äôll need the most up-to-date CLI. You can do this by running:\n\nThis will give us a screen where we‚Äôre going to choose to use ‚ÄúVue 3 Preview‚Äù:\n\nThis will create a base Vue 3 application, and we can ensure it works by going into the directory and running the server:\n\nThen when we go to we should see our server running.\n\nTo install Vue Router into our base Vue 3 project (as we created above) or into an existing project that already uses Vue 3, we‚Äôll follow the steps below:\n‚Ä¢ Install the Vue 3 Router from the Command Line\n\nNotice that we create our in an array, where we specify for each route a few important items:\n‚Ä¢ Path - the URL path where this route can be found.\n‚Ä¢ Name - An optional name to use when we link to this route.\n‚Ä¢ Component - Which component to load when this route is called.\n\nBelow this array you‚Äôll notice we create the Router itself, using the and we also pass in . This is used to switch from using to inside your browser, using the HTML5 history API. The way we configure this is a little different then we did in Vue 2.\n\nNotice we export this at the bottom because we‚Äôll need to import it in our main.js file.\n\nNext we‚Äôll need to edit our file to use our router in our application.\n\nHere we‚Äôre importing our router file, and then we the router when creating our application. The way our application is created in this file has changed in Vue 3.\n\nThere are two directives our Vue application gives us to use in our template:\n\n- When a route is navigated to in the browser, this is where the component is rendered. For example, in our code going to will render the Home component where we list .\n\n- This is the directive we use to create links between our different component pages, instead of using . See below.\n\nThese both can be used in our simple example in App.vue like so: (FYI, I erased what was already in the App.vue).\n\nWe‚Äôll need to create our Home and About components which we referenced above. Instead of putting them in our directory, I‚Äôm going to create a new directory. They‚Äôre going to be really simple for our example:\n\nAnd now if we fire up our server and head up to we should see the following:\n\nMuch of the above configuration and setup you can actually have Vue 3 do for you from the CLI, but it‚Äôs valuable to know how to do it on your own. If you create a new Vue Project:\n\nThe latest version of Vue Router will be installed, and it will pre-generate most of the same configuration we‚Äôve created above.\n\nIn our router we specified optional names in our routes: and . If we wanted to use route names instead of paths, we could write our s like so:\n\nNow our navigation works the same as before, but we‚Äôre not using paths. This can be useful if our URL paths change in the future. We wouldn‚Äôt have to change all the if the path changes, since they‚Äôre referencing using name.\n\nIf we want to create a path URL which has a variable, like or where the ‚Äògregg‚Äô or ‚Äò5‚Äô can be any name or any number, we need a Dynamic Segment. This is done JUST like we used to do it in Vue 2.\n\nIn the router, we specify in our route with the denoting the variable.\n\nTo access that dynamic segment in the view itself, we could now write:\n\nAnd sure enough we get:\n\nAlso just like Vue 2, I can opt to have the dynamic segment passed into my component as a prop, but specifying .\n\nNow inside my component, I can have:\n\nNotice I have to specify that my component is expecting a prop.\n\nI get the same result:\n\nSince we have a single page application, you‚Äôll notice that if we go to any URL that doesn‚Äôt have a route mapped in the routing file we get an incomplete page. It loads up our App.vue, but no component. We‚Äôll need to tell our router what to do when it doesn‚Äôt match any routes, and the way we do this is a little different in Vue 3.\n\nWe‚Äôll need a route at the bottom of our routing list that looks like this:\n\nNotice the dynamic segment and the regular expression. is the dynamic segment and is a regular expression, which essentially matches against anything. So if none of the routes above this one match, it will use this one. Also, I‚Äôve imported a new component called which looks like this:\n\nNow when I try to go to , I get:\n\nIf you weren‚Äôt familiar with Vue Routing before, hopefully this gives you an idea just how easy it is to get going. If you are familiar, hopefully this comforts you to see there‚Äôs not a whole lot of differences between Vue 2 and Vue 3.\n\nTo dive deeper into Vue Router, I‚Äôve created a full Touring Vue Router course here on Vue Mastery, and you can start watching it now for free."
    },
    {
        "link": "https://v3.router.vuejs.org",
        "document": "The official router for Vue.js.\n\nVue Router is the official router for Vue.js (opens new window). It deeply integrates with Vue.js core to make building Single Page Applications with Vue.js a breeze. Features include:\n‚Ä¢ HTML5 history mode or hash mode, with auto-fallback in IE9\n\nGet started or play with the examples (opens new window) (see (opens new window) to run them)."
    },
    {
        "link": "https://stackoverflow.com/questions/60755676/how-to-use-router-in-vue-composition-api",
        "document": "and I use from to get the data.\n\nthe problem is when the route change to another , by navigate to another user, the user in the html template not changed as what I expected. also it doesn't do redirect when the the user is not in the list.\n\nSo what I can do to fix that?\n\nhere is my code:"
    },
    {
        "link": "https://vueschool.io/articles/vuejs-tutorials/how-to-use-vue-router-a-complete-tutorial",
        "document": "You can see that when we load the application for the first time it loads an script. When you navigate to route or route you can see no new javascript is being loaded. This is because all the JavaScript code for those components was already loaded with . In a smaller application, this is not a problem. However, what if we have a large application. In that case, loading all the JS code in one go can make the page load time significantly longer. Lazy loading is used to avoid this.\n\nTake a look at line 17 of . Do you recall this from an earlier example? The component here is being imported with an arrow function. This is an example of lazy loading. Unlike , and component the component is not loaded with the . The component will only get loaded when a user visits the route. This is all we have to do to implement lazy load. This lazy loading is being done through Rollup's code splitting feature. Under the hood Vue uses Vite, and vite uses Rollup as a bundler. You can learn more about advanced Vue features such as code splitting, Vite configuration etc. in depth in our Vue 3 Masterclass course."
    },
    {
        "link": "https://vuejs.org/guide/essentials/component-basics",
        "document": "Components allow us to split the UI into independent and reusable pieces, and think about each piece in isolation. It's common for an app to be organized into a tree of nested components:\n\nThis is very similar to how we nest native HTML elements, but Vue implements its own component model that allows us to encapsulate custom content and logic in each component. Vue also plays nicely with native Web Components. If you are curious about the relationship between Vue Components and native Web Components, read more here.\n\nWhen using a build step, we typically define each Vue component in a dedicated file using the extension - known as a Single-File Component (SFC for short):\n\nWhen not using a build step, a Vue component can be defined as a plain JavaScript object containing Vue-specific options:\n\nThe template is inlined as a JavaScript string here, which Vue will compile on the fly. You can also use an ID selector pointing to an element (usually native elements) - Vue will use its content as the template source.\n\nThe example above defines a single component and exports it as the default export of a file, but you can use named exports to export multiple components from the same file.\n\nTo use a child component, we need to import it in the parent component. Assuming we placed our counter component inside a file called , the component will be exposed as the file's default export:\n\nIt's also possible to globally register a component, making it available to all components in a given app without having to import it. The pros and cons of global vs. local registration is discussed in the dedicated Component Registration section.\n\nComponents can be reused as many times as you want:\n\nNotice that when clicking on the buttons, each one maintains its own, separate . That's because each time you use a component, a new instance of it is created.\n\nIn SFCs, it's recommended to use tag names for child components to differentiate from native HTML elements. Although native HTML tag names are case-insensitive, Vue SFC is a compiled format so we are able to use case-sensitive tag names in it. We are also able to use to close a tag.\n\nIf you are authoring your templates directly in a DOM (e.g. as the content of a native element), the template will be subject to the browser's native HTML parsing behavior. In such cases, you will need to use and explicit closing tags for components:\n\nSee in-DOM template parsing caveats for more details.\n\nIf we are building a blog, we will likely need a component representing a blog post. We want all the blog posts to share the same visual layout, but with different content. Such a component won't be useful unless you can pass data to it, such as the title and content of the specific post we want to display. That's where props come in.\n\nProps are custom attributes you can register on a component. To pass a title to our blog post component, we must declare it in the list of props this component accepts, using the option macro:\n\nA component can have as many props as you like and, by default, any value can be passed to any prop.\n\nOnce a prop is registered, you can pass data to it as a custom attribute, like this:\n\nIn a typical app, however, you'll likely have an array of posts in your parent component:\n\nThen want to render a component for each one, using :\n\nNotice how syntax ( ) is used to pass dynamic prop values. This is especially useful when you don't know the exact content you're going to render ahead of time.\n\nThat's all you need to know about props for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on Props.\n\nAs we develop our component, some features may require communicating back up to the parent. For example, we may decide to include an accessibility feature to enlarge the text of blog posts, while leaving the rest of the page at its default size.\n\nIn the parent, we can support this feature by adding a data propertyref:\n\nWhich can be used in the template to control the font size of all blog posts:\n\nNow let's add a button to the component's template:\n\nThe button doesn't do anything yet - we want clicking the button to communicate to the parent that it should enlarge the text of all posts. To solve this problem, components provide a custom events system. The parent can choose to listen to any event on the child component instance with or , just as we would with a native DOM event:\n\nThen the child component can emit an event on itself by calling the built-in method, passing the name of the event:\n\nThanks to the listener, the parent will receive the event and update the value of .\n\nWe can optionally declare emitted events using the option macro:\n\nThis documents all the events that a component emits and optionally validates them. It also allows Vue to avoid implicitly applying them as native listeners to the child component's root element.\n\nThat's all you need to know about custom component events for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on Custom Events.\n\nJust like with HTML elements, it's often useful to be able to pass content to a component, like this:\n\nWhich might render something like:\n\nThis can be achieved using Vue's custom element:\n\nAs you'll see above, we use the as a placeholder where we want the content to go ‚Äì and that's it. We're done!\n\nThat's all you need to know about slots for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on Slots.\n\nSometimes, it's useful to dynamically switch between components, like in a tabbed interface:\n\nThe above is made possible by Vue's element with the special attribute:\n\nIn the example above, the value passed to can contain either:\n‚Ä¢ the name string of a registered component, OR\n\nYou can also use the attribute to create regular HTML elements.\n\nWhen switching between multiple components with , a component will be unmounted when it is switched away from. We can force the inactive components to stay \"alive\" with the built-in component.\n\nIf you are writing your Vue templates directly in the DOM, Vue will have to retrieve the template string from the DOM. This leads to some caveats due to browsers' native HTML parsing behavior.\n\nHTML tags and attribute names are case-insensitive, so browsers will interpret any uppercase characters as lowercase. That means when you‚Äôre using in-DOM templates, PascalCase component names and camelCased prop names or event names all need to use their kebab-cased (hyphen-delimited) equivalents:\n\nWe have been using self-closing tags for components in previous code samples:\n\nThis is because Vue's template parser respects as an indication to end any tag, regardless of its type.\n\nIn in-DOM templates, however, we must always include explicit closing tags:\n\nThis is because the HTML spec only allows a few specific elements to omit closing tags, the most common being and . For all other elements, if you omit the closing tag, the native HTML parser will think you never terminated the opening tag. For example, the following snippet:\n\nwill be parsed as:\n\nSome HTML elements, such as , , and have restrictions on what elements can appear inside them, and some elements such as , , and can only appear inside certain other elements.\n\nThis will lead to issues when using components with elements that have such restrictions. For example:\n\nThe custom component will be hoisted out as invalid content, causing errors in the eventual rendered output. We can use the special attribute as a workaround:\n\nThat's all you need to know about in-DOM template parsing caveats for now - and actually, the end of Vue's Essentials. Congratulations! There's still more to learn, but first, we recommend taking a break to play with Vue yourself - build something fun, or check out some of the Examples if you haven't already.\n\nOnce you feel comfortable with the knowledge you've just digested, move on with the guide to learn more about components in depth."
    },
    {
        "link": "https://medium.com/@davisaac8/design-patterns-and-best-practices-with-the-composition-api-in-vue-3-77ba95cb4d63",
        "document": "Vue.js has long been one of the most popular JavaScript frameworks for UI development. Since its initial release in 2014, Vue has gained an enthusiastic community and has stood out for its ease of use, performance, and ability to integrate with other libraries or existing projects. In September 2020, Vue 3 was released, bringing a series of improvements and new features, with the most notable being the Composition API.\n\nComposition API is a new way of writing components in Vue 3. Introduced as an alternative to the Options API, which has been the foundation of development in Vue since its inception, the Composition API allows for better organization and reuse of component logic.\n\nThe Composition API makes it easy to extract and reuse component logic via composable functions, allowing you to share functionality between different components more efficiently.\n\nWith the Composition API, related logic can be grouped within the setup method, rather than being scattered across different component options (such as data, methods, computed, etc.). This makes the code more modular and readable.\n\nBy allowing logic to be split into independent functions, the Composition API makes components easier to maintain and test. This is especially beneficial in large and complex applications.\n\nThe Composition API integrates better with Typescript, providing a more robust and less error-prone development experience.\n\nWhile the Options API organizes the component logic into specific sections (data, methods, computed, watch, etc.), the Composition API groups related logic into functions within the setup method. This allows for greater flexibility and better management of shared logic and state.\n\nAs can be observed, the Composition API allows defining state, computed properties, and methods within the setup function, providing a more cohesive and logical structure.\n\nThe Composition API in Vue 3 represents a significant change in the way components are written, offering greater flexibility and modularity. Throughout this article, we will explore design patterns and best practices for effectively using the Composition API, helping you create cleaner, maintainable, and scalable Vue applications."
    },
    {
        "link": "https://vuejs.org/api/sfc-script-setup",
        "document": "is a compile-time syntactic sugar for using Composition API inside Single-File Components (SFCs). It is the recommended syntax if you are using both SFCs and Composition API. It provides a number of advantages over the normal syntax:\n‚Ä¢ More succinct code with less boilerplate\n‚Ä¢ Ability to declare props and emitted events using pure TypeScript\n‚Ä¢ Better runtime performance (the template is compiled into a render function in the same scope, without an intermediate proxy)\n‚Ä¢ Better IDE type-inference performance (less work for the language server to extract types from code)\n\nTo opt-in to the syntax, add the attribute to the block:\n\nThe code inside is compiled as the content of the component's function. This means that unlike normal , which only executes once when the component is first imported, code inside will execute every time an instance of the component is created.\n\nWhen using , any top-level bindings (including variables, function declarations, and imports) declared inside are directly usable in the template:\n\nImports are exposed in the same fashion. This means you can directly use an imported helper function in template expressions without having to expose it via the option:\n\nReactive state needs to be explicitly created using Reactivity APIs. Similar to values returned from a function, refs are automatically unwrapped when referenced in templates:\n\nValues in the scope of can also be used directly as custom component tag names:\n\nThink of as being referenced as a variable. If you have used JSX, the mental model is similar here. The kebab-case equivalent also works in the template - however PascalCase component tags are strongly recommended for consistency. It also helps differentiating from native custom elements.\n\nSince components are referenced as variables instead of registered under string keys, we should use dynamic binding when using dynamic components inside :\n\nNote how the components can be used as variables in a ternary expression.\n\nAn SFC can implicitly refer to itself via its filename. E.g. a file named can refer to itself as in its template.\n\nNote this has lower priority than imported components. If you have a named import that conflicts with the component's inferred name, you can alias the import:\n\nYou can use component tags with dots like to refer to components nested under object properties. This is useful when you import multiple components from a single file:\n\nGlobally registered custom directives just work as normal. Local custom directives don't need to be explicitly registered with , but they must follow the naming scheme :\n\nIf you're importing a directive from elsewhere, it can be renamed to fit the required naming scheme:\n\nTo declare options like and with full type inference support, we can use the and APIs, which are automatically available inside :\n‚Ä¢ None and are compiler macros only usable inside . They do not need to be imported, and are compiled away when is processed.\n‚Ä¢ None accepts the same value as the option, while accepts the same value as the option.\n‚Ä¢ None and provide proper type inference based on the options passed.\n‚Ä¢ None The options passed to and will be hoisted out of setup into module scope. Therefore, the options cannot reference local variables declared in setup scope. Doing so will result in a compile error. However, it can reference imported bindings since they are in the module scope as well.\n\nProps and emits can also be declared using pure-type syntax by passing a literal type argument to or :\n‚Ä¢ None or can only use either runtime declaration OR type declaration. Using both at the same time will result in a compile error.\n‚Ä¢ None When using type declaration, the equivalent runtime declaration is automatically generated from static analysis to remove the need for double declaration and still ensure correct runtime behavior.\n‚Ä¢ None In dev mode, the compiler will try to infer corresponding runtime validation from the types. For example here is inferred from the type. If the type is a reference to an imported type, the inferred result will be (equal to type) since the compiler does not have information of external files.\n‚Ä¢ None In prod mode, the compiler will generate the array format declaration to reduce bundle size (the props here will be compiled into )\n‚Ä¢ None In version 3.2 and below, the generic type parameter for were limited to a type literal or a reference to a local interface. This limitation has been resolved in 3.3. The latest version of Vue supports referencing imported and a limited set of complex types in the type parameter position. However, because the type to runtime conversion is still AST-based, some complex types that require actual type analysis, e.g. conditional types, are not supported. You can use conditional types for the type of a single prop, but not the entire props object.\n\nIn Vue 3.5 and above, variables destructured from the return value of are reactive. Vue's compiler automatically prepends when code in the same block accesses variables destructured from :\n\nThe above is compiled to the following equivalent:\n\nIn addition, you can use JavaScript's native default value syntax to declare default values for the props. This is particularly useful when using the type-based props declaration:\n\nIn 3.5 and above, default values can be naturally declared when using Reactive Props Destructure. But in 3.4 and below, Reactive Props Destructure is not enabled by default. In order to declare props default values with type-based declaration, the compiler macro is needed:\n\nThis will be compiled to equivalent runtime props options. In addition, the helper provides type checks for the default values, and ensures the returned type has the optional flags removed for properties that do have default values declared.\n‚Ä¢ Only available in 3.4+\n\nThis macro can be used to declare a two-way binding prop that can be consumed via from the parent component. Example usage is also discussed in the Component guide.\n\nUnder the hood, this macro declares a model prop and a corresponding value update event. If the first argument is a literal string, it will be used as the prop name; Otherwise the prop name will default to . In both cases, you can also pass an additional object which can include the prop's options and the model ref's value transform options.\n\nTo access modifiers used with the directive, we can destructure the return value of like this:\n\nWhen a modifier is present, we likely need to transform the value when reading or syncing it back to the parent. We can achieve this by using the and transformer options:\n\nLike and , can also receive type arguments to specify the types of the model value and the modifiers:\n\nComponents using are closed by default - i.e. the public instance of the component, which is retrieved via template refs or chains, will not expose any of the bindings declared inside .\n\nTo explicitly expose properties in a component, use the compiler macro:\n\nWhen a parent gets an instance of this component via template refs, the retrieved instance will be of the shape (refs are automatically unwrapped just like on normal instances).\n\nThis macro can be used to declare component options directly inside without having to use a separate block:\n‚Ä¢ This is a macro. The options will be hoisted to module scope and cannot access local variables in that are not literal constants.\n\nThis macro can be used to provide type hints to IDEs for slot name and props type checking.\n\nonly accepts a type parameter and no runtime arguments. The type parameter should be a type literal where the property key is the slot name, and the value type is the slot function. The first argument of the function is the props the slot expects to receive, and its type will be used for slot props in the template. The return type is currently ignored and can be , but we may leverage it for slot content checking in the future.\n\nIt also returns the object, which is equivalent to the object exposed on the setup context or returned by .\n\nUsage of and inside should be relatively rare, since you can access them directly as and in the template. In the rare case where you do need them, use the and helpers respectively:\n\nand are actual runtime functions that return the equivalent of and . They can be used in normal composition API functions as well.\n\ncan be used alongside normal . A normal may be needed in cases where we need to:\n‚Ä¢ Declare options that cannot be expressed in , for example or custom options enabled via plugins (Can be replaced by in 3.3+).\n‚Ä¢ Run side effects or create objects that should only execute once.\n\nSupport for combining and in the same component is limited to the scenarios described above. Specifically:\n‚Ä¢ Do NOT use a separate section for options that can already be defined using , such as and .\n‚Ä¢ Variables created inside are not added as properties to the component instance, making them inaccessible from the Options API. Mixing APIs in this way is strongly discouraged.\n\nIf you find yourself in one of the scenarios that is not supported then you should consider switching to an explicit function, instead of using .\n\nTop-level can be used inside . The resulting code will be compiled as :\n\nIn addition, the awaited expression will be automatically compiled in a format that preserves the current component instance context after the .\n\nImport statements in vue follow ECMAScript module specification. In addition, you can use aliases defined in your build tool configuration:\n\nGeneric type parameters can be declared using the attribute on the tag:\n\nThe value of works exactly the same as the parameter list between in TypeScript. For example, you can use multiple parameters, constraints, default types, and reference imported types:\n\nIn order to use a reference to a generic component in a you need to use the library as won't work.\n‚Ä¢ Due to the difference in module execution semantics, code inside relies on the context of an SFC. When moved into external or files, it may lead to confusion for both developers and tools. Therefore, cannot be used with the attribute."
    },
    {
        "link": "https://stackoverflow.com/questions/73941599/vue-3-understanding-examples-from-setup-function-and-applying-them-in-setup-tag",
        "document": "In syntax, Home.vue would look like this:\n\nThe note you quoted draws attention to the template of any page/view contents needing to be wrapped in a wrapper for the layout to function as intended, like in their examples.\n\nFor the above layout, you'd need to import all used components:\n\nWith you don't need to declare them as local components, detects them and does it for you, behind the scenes. They're available for usage inside the once imported.\n\nThe component is also inferred by from the name of the file. In the above case, it would be .\n\nTo sum up: behind the scenes, takes its contents and wraps it in a\n\nFor this to be possible, some helpers were added ( , ), which allow declaring those parts of Options API inside the function.\n\nMost notably, in this syntax no longer needs a value. All variables declared or imported inside it are made available to .\n\nImportant: is a useful tool, designed to reduce boilerplate in the majority of cases, not to replace completely. Read more about it in the docs."
    },
    {
        "link": "https://dev.to/jacobandrewsky/good-practices-and-design-patterns-for-vue-composables-24lk",
        "document": "Top 10 Vue.js libraries you should be using in 2025\n\nI recently had a great discussion with my team at Vue Storefront about patterns for writing Vue composables. In the case of our system, composables are responsible for storing the main business logic (like calculations, actions, processess) so they are a crucial part of the application. Unfortunately over the time, we didn't have that much time to create some sort of and because of that few of our composables are not really composables üòâ\n\nI am really happy that right now we have this time to refactor our approach to building new composables so that they are maintainable, easy to test, and actually useful.\n\nIn this article, I will summarise ideas that we have created and also merge them with good practices and design patterns that I read about in few articles.\n\nSo this article will be divided into three sections:\n\nEnjoy and also, let me know what patterns and practices you are using in your projects üöÄ\n\nThe best source in my opinion to learn about patterns for building composables is actually a Vue.js Documentation that you can check out here\n\nVue documentation shows following example of a useMouse composable:\n\n\n\nThat can be later used in the component like following:\n\n\n\nThat can be then used in the component like following:\n\n\n\nBased on the examples above, here is the contract that all composables should follow:\n‚Ä¢ Composable file names should start with use for example\n‚Ä¢ It can accept input arguments that can be primitive types like strings or can accept refs and getters but it requires to use toValue helper\n‚Ä¢ Composable should return a ref value that can be accessed after destructuring the composable like\n‚Ä¢ Composables can hold global state that can be access and modified across the app.\n‚Ä¢ Composable can cause side effects such as adding window event listeners but they should be cleaned when the component is unmounted.\n‚Ä¢ Composables should only be called in or the hook. They should also be called synchronously in these contexts. In some cases, you can also call them in lifecycle hooks like .\n‚Ä¢ Composables should wrap certain logic inside and when too complex, they should be extracted into separate composables for easier testing.\n\nI have built multiple composables for my work projects and Open Source projects - NuxtAlgolia, NuxtCloudinary, NuxtMedusa, so based on these, I would like to add few points to the contract above that are based on my experience.\n\nAt certain point of code standarization, you may come into a conclusion that you would like to make a decision about the state hold in the composables.\n\nThe easiest functions to test are those who do not store any state (i.e. they are simple input/output functions), for example a composable that would be responsible for converting bytes to human readable value. It accepts a value and returns a different value - it doesn't store any state.\n\nDon't get me wrong, you don't have to make a decision . You can completely keep both stateful and stateless composables. But this should be a written decision so that it is easier to work with them later on üôÇ\n\nWe wanted to implement unit tests with Vitest for our Frontend application. When working in the backend, having unit tests code coverage is really useful because there you mainly focus on the logic. However, on the frontend you usually work with visuals.\n\nBecause of that, we decided that unit testing whole components may not be the best idea because we will be basically unit testing the framework itself (if a button was pressed, check if a state changed or modal opened).\n\nThanks to the fact that we have moved all the business logic inside the composables (which are basically TypeScript functions) they are very easy to test with Vitest and allows us also to have more stable system.\n\nSome time ago, in VueStorefront we have developed our own approach to composables (way before they were actually called like that actually üòÑ). In our approach, we have beed using composables to map business domain of E-Commerce like following:\n\n\n\nThis approach was definitely useful as it allowed to wrap the domain in one function. And in the simpler examples such as or this was relatively simple to implement and maintain. However, as you can see here with the example of when wrapping a domain that contains much more logic than just data fetching, this composable was growing into a shape that was really difficult to develop and maintain.\n\nAt this point, I started contributing into Nuxt ecosystem where different approach was introduced. In this new approach, each composable is responsible for one thing only. So instead of building a huge composable, the idea is to build composables for each functionality i.e. , , , etc.\n\nThanks to that, it should be much easier to maintain and test these composables üôÇ\n\nThat will be all from my research. If you would like to learn more about this topic, make sure to check out the following articles:"
    }
]