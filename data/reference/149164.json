[
    {
        "link": "https://wiki.st.com/stm32mcu/wiki/Getting_started_with_GPIO",
        "document": "There are 1 incomplete or pending task to finish installation of Semantic MediaWiki . An administrator or user with sufficient rights can complete it. This should be done before adding new data to avoid inconsistencies.\n\nThis message will disappear after all relevant tasks have been resolved.\n\nThis article explains what GPIO is and how to use it through examples.\n\nGPIO stands for general purpose input/output. It is a type of pin found on an integrated circuit that does not have a specific function. While most pins have a dedicated purpose, such as sending a signal to a certain component, the function of a GPIO pin is customizable and can be controlled by the software.\n‚Ä¢ Pin Mode : Each port bit of the general-purpose I/O (GPIO) ports can be individually configured by software in several modes:\n‚Ä¢ Pin characteristics :\n‚Ä¢ Input : no pull-up and no pull-down or pull-up or pull-down\n‚Ä¢ Output : push-pull or open-drain with pull-up or pull-down capability\n‚Ä¢ Alternate function : push-pull or open-drain with pull-up or pull-down capability.\n‚Ä¢ Change the rising and falling edge when the pin state changes from high to low or low to high.\n‚Ä¢ A higher GPIO speed increases the EMI noise from STM32 and increases the STM32 consumption.\n‚Ä¢ It is good to adapt the GPIO speed to the peripheral speed. For example, low speed is optimal for toggling GPIO at 1 Hz, while using SPI at 45 MHz requires very high speed setting.\n\nLearn how to Toggle a pin on STM32L476 Nucleo board using Hardware Abstraction Layer (HAL) library and learn how to setup the pin and GPIO port in STM32CubeIDE.\n\n\n\n\n\n This example uses the NUCLEO-L476RG board.\n‚Ä¢ Select NUCLEO-L476RG using the Board Selector as shown in the figure below:\n\n\n\n\n\nIn case you haven't downloaded the STM32L476 Cube library, it will be downloaded automatically. This however may take some time.\n‚Ä¢ You will then get a popup asking if you want to initialize peripherals to their default configuration.\n‚Ä¢ No need to configure any peripheral as only the core/Flash/SRAMs are used (default peripherals).\n‚Ä¢ If you want to start the project with a board, the LED pin is already selected (PA5 on NucleoL476RG. For other boards refer to the user manual).\n‚Ä¢ Output speed set to very high is important for faster peripherals such as SPI or USART.\n\nThe easiest way to generate the code is to save your current project : Ctrl + S \n\n The code is generated so you can see it in the left side of the screen in the project explorer \n\n \n\n Now, open the main.c file which is the main source file for this application\n‚Ä¢ The LED toggling is done with a HAL function inside main.c\n‚Ä¢ Click on Debug button (to run step by step)\n‚Ä¢ Or on Run button (to execute) \n\n\n\nEvery 500 ms the green LED state changes."
    },
    {
        "link": "https://deepbluembedded.com/stm32-gpio-write-pin-digital-output-lab",
        "document": "In this tutorial, we‚Äôll configure an STM32 GPIO pin to be output. Then, we‚Äôll create our first STM32 GPIO Example project (LED Blinking) with a blue pill board. You‚Äôll learn all the steps to configure the STM32 CubeMX & flash the code from STM32CubeIDE to the blue pill board.\n\nWe‚Äôll also dive deeper into the STM32 HAL GPIO functions used to control the GPIO output pins in STM32 microcontrollers. Such as the HAL_GPIO_Write() function, HAL_GPIO_TogglePin() function, and more. Without further ado, let‚Äôs get right into it!\n\nObjectives of This STM32 LED Blinking Example Project:\n‚Ä¢ Use function to change an output pin state\n‚Ä¢ Use function to toggle the state of a GPIO pin\n‚Ä¢ Use The & Know How It Works\n\nOpen STM32CubeMX, create a new project, and select the STM32F103C8T6 target microcontroller. Note that the STM32 BluePill board has two common target microcontrollers (STM32F103C8T6 & STM32F103C6T6). So you need to select the exact target microcontroller on your hardware board.\n\nThis example project should work flawlessly on any STM32 target microcontroller, you just need to select the target MCU that matches your hardware board.\n\nGo to the RCC clock configuration page and enable the HSE external crystal oscillator input.\n\nClick on the PA8 GPIO pin in the ‚ÄúPinout View‚Äù and select it to be in GPIO_Output mode. Note: you can use any other pin you want instead.\n\nGo to the clock configurations page, and select the HSE as a clock source, PLL output, and type in 72MHz for the desired output system frequency. Hit the ‚Äú Enter‚Äù key, and let the application solve for the required PLL dividers/multipliers to achieve the desired clock rate.\n\nThe reason behind this: using the external onboard oscillator on the BluePill board provides a more accurate and stable clock, and using a 72MHz as a system clock pushes the microcontroller to its limits, so we get the maximum performance out of it. As long as we don‚Äôt care about the application‚Äôs power consumption.\n\nFinally, go to the Project Manager, give your project a name, select the toolchain/IDE to be STM32CubeIDE, and click on the Generate Code button.\n\nThe STM32CubeMX tool will generate the initialization code & the project main files and it‚Äôll prompt you to open the project in STM32CubeIDE. Select, open project, and let‚Äôs move to the next step.\n\nThen, open the project in the IDE you‚Äôre using. And head over to the main.c file. So we can start writing the application code and have a look at the initialization code generated by the STM32 CubeMX tool.\n\nCopy the following code into your main.c file replacing the auto-generated code from the beginning of the fill till the main function. You should leave everything else under the main() function in the main.c file as is.\n\nThis code example uses the STM32 HAL_GPIO_TogglePin() function.\n\nThis code example uses the STM32 HAL_GPIO_TogglePin() function.\n\nYou can use any of the previous code examples. Both are doing the exact same functionality (blink an LED every 100ms).\n\nThe auto-generated main.c file in the source code directory within our projects was as shown below.\n\nBoth functions SystemClock_Config() and MX_GPIO_Init() are generated by CubeMX to configure the system clock as we‚Äôve done in the GUI before and the GPIO pin which we‚Äôve selected to be an output pin. The implementation of both functions is found in the file after the main function.\n\nWe call each of them before the main loop while(1) as well as the HAL_Init function. The HAL_Init must be called at the beginning of your application. Its functionality is clarified in the HAL Documentation as shown below.\n\nAnd most importantly it initializes the SysTick timer, whose ticks are used by the HAL_Delay(). The SysTick timer is set to tick @ 1000Hz or every 1mSec. So the HAL_Delay function will give you multiples of milliseconds delay.\n\nBesides the delay function, we also need to know the HAL APIs for controlling the GPIO pins. To do basic stuff like pin read or write or port read/write, and so on.\n\nSo we‚Äôll head over again to the HAL documentation and search for the GPIO chapter, where we‚Äôll find this listing for the available APIs. The APIs are hyperlinked in the documentation file, so you can click the name of the function to go directly to its detailed description.\n\nSo, let‚Äôs take a closer look at the GPIO_WritePin() function, for example.\n\nMore details on all functions can be found in the STM32 HAL documentation that you can easily find on the STMicroelectronics website.\n\nConnect The ST-Link To The USB Port & SWD Pins On Board\n\nClick The Debug Button To Compile The Code & Flash It To The Board & Start A Debugging Session\n\nYou Can Stop The Debugging Session Or Keep It Going. But You Need To Restart The MCU Once To Run The New Application At The Booting Process.\n\nAll the example Code/LABs/Projects in this STM32 Series of Tutorials are done using the Dev boards & Electronic Parts Below:\n\n‚òÖ Check The Links Below For The Full Course Kit List & LAB Test Equipment Required For Debugging ‚òÖ\n\nYou can download all attachment files for this Article/Tutorial (project files, schematics, code, etc..) using the link below. Please consider supporting our work through the various support options listed in the link down below. Every small donation helps to keep this website up and running and ultimately supports the whole community.\n\nIn conclusion, it was quite easy to create our first STM32 LED blinking project using the HAL GPIO WritePin or TogglePin functions. You can play with different settings like delay period, multiple IO pins, and so on.\n\nIf you‚Äôre just getting started with STM32, you need to check out the STM32 Getting Started Tutorial here.\n\nFollow this STM32 Series of Tutorials to learn more about STM32 Microcontrollers Programming."
    },
    {
        "link": "https://community.st.com/t5/stm32-mcus-embedded-software/how-to-configure-any-gpio-pin-individually-using-hal/td-p/292853",
        "document": "I am trying to modify the demonstartion application in the NUCLEO-G47RE board. There is this comment in the main header file:\n\nI went to the Description of STM32G4 HAL and low-layer dirvers found in:\n\nIn pages 354 and 355, you can see the GPIO_Pins which can be called with GPIO_PIN_x where is x is between 0 to 15. But I do not understand why the the first pin is Pin 0 when in the datasheet the pinout starts from Pin 1. Also why is the last pin to be configured Pin 15 when 52 pins are GPIOs. Any help would be really appreciated.\n\nP.D. My MCU is using the LQFP64 package. That's the pinout I'm referring to."
    },
    {
        "link": "https://hainguyen7050.medium.com/microcontroller-101-1e08c2dd1ce6",
        "document": "In the last episode‚Ä¶\n\nIn the last episode, I have introduced the idea, the motivation, and the philosophy of this series. We also went thru the installation of the toolchain, which is STM32CubeIDE.\n\nIn this episode, we will learn how to set up a pin as:\n‚Ä¢ GPIO input (reading the state of the button) thru two methods: polling and interrupt\n\nAfter starting STM32CubeIDE, we are at the landing page:\n\nIn the landing page, there are default options:\n‚Ä¢ Start new STM32 project: it is obvious that this option let us create a new project from scratch.\n‚Ä¢ Start new project from STM32CubeMX .ioc file: this option allows us to open a configuration file from another project.\n‚Ä¢ Import SW4STM32 or TrueSTUDIO project: this option lets us import the project either from SW4STM32 or TrueSTUDIO, which is one of the supported IDEs.\n\nWe will start our project from scratch so, let‚Äôs click on the option of Start new STM32 project. You will be prompted to the next window to select the target (microcontroller).\n\nTarget Selection window allows us to choose the microcontroller by selecting different parameters. Since we are using the evaluation board, we move to the Board Selector tab and select as following:\n\nYou are prompted to a new window asking for Project Name:\n\nGive your project a name, for my case, it is p3_BlinkyLED, and click Finish.\n\nYou will be prompted to a new window, this is where you will configure your MCU.\n\nIf you have a look at the toolbar which is marked red in the picture above, you will see, there are multiple tabs:\n‚Ä¢ Pinout and configuration: This tab lets you activate/deactivate the peripherals on the microcontroller and allocate the pins for those peripherals.\n‚Ä¢ Clock Configuration: let you set up the clock for the microcontroller and its peripherals.\n‚Ä¢ Project Manager: let you configure the general settings of the project.\n‚Ä¢ Tools: allows us to estimate the power consumption of the MCU with the given conditions.\n‚Ä¢ Additional Software: let you add Middlewares to your project.\n\nLet‚Äôs switch back to the Pinout & Configuration tab. We will learn how to configure a peripheral and assign it to the pins.\n\nFirst, we clear the default pinout setup, so we will have a ‚Äúclean‚Äù pinout. Under Pinout option on the top menu bar, choose Clear Pinouts.\n\nAfter doing that, you will have a clear pinout as the picture below:\n\nTo briefly show you how to activate a peripheral (we will go into detail later when we use the peripherals), for example, USART1, let‚Äôs do the following things:\n‚Ä¢ On the left side of STM32CubeIDE, expand the Connectivity tab, and choose USART1. In the Mode option, choose Asynchronous from the drop-down menu.\n‚Ä¢ After choosing Asynchronous, the pins for USART1 are automatically activated at pin PA9, PA10 in the MCU pinout.\n‚Ä¢ If for some reason the pin PA10 and/or PA9 are blocked by other peripherals, there is still an option to move them to the other pins.\n‚Ä¢ Click Ctrl + Left-Click on the pin you want to move, the tool will highlight a new position for the pin in the blue color (see picture below). To move to the new position, we keep doing the Ctrl + Left-Click and dragging the pin to its new place.\n‚Ä¢ We don‚Äôt need USART1 for now, so we will deactivate it. To do that, go back to the peripheral configuration on the left side, under UASRT1, Mode, choose Disable.\n\nIf you still remember our holy goal is doing the infamous blinking LED, you will wonder why there is no peripheral called ‚ÄúLED‚Äù, ‚ÄúPin on/off‚Äù, etc. in the configuration. Yes, you are correct, it is not there! To turn on and off an LED, i.e. providing some voltage to the controller‚Äôs pins, we need a peripheral called GPIO (General Purpose Input Output).\n\nGPIO can be activated directly in the MCU pinout:\n‚Ä¢ On the evaluation kit, there is an LED called LD2. The only thing we need to find out is to which pin this LED is connected. If you still remember the board‚Äôs document, on page 23, it is described:\n‚Ä¢ So, with simple 1-minute reading, we know the LED is connected to pin PA5 of the MCU. To activate that pin as a GPIO, we hover our mouse to pin PA5 in the MCU pinout, left-click ‚Üí choose GPIO_Output. The pin will be activated as a GPIO and given the name GPIO_Output.\n‚Ä¢ If you are a picky guy/girl and you think that the name GPIO_Output is not intuitive enough, there is an option to change the name. Hovering the mouse to the pin, right-click ‚Üí choose Enter User Lable and give it a name. I will call it LED2.\n\nGreat! We have activated and configured one pin as a GPIO. Next step, we will configure the clock configuration.\n\nA microcontroller needs a clock to operate. It is applied the same for your Laptop or PC. Whenever you read a description like core i7 2.1 GHz blah blah, it means your processor is running at the speed of 2.1 GHz. Obviously, the higher the speed, the faster the processor (and physically, the more power it will take).\n\nIf you are a bit into PC stuff, you will know the term ‚ÄúOverclocking‚Äù, a.k.a increasing (and decreasing, but no one does that) your processor clock. It is applied to the microcontroller in same the manner. You can also adjust the clock of your microcontroller (even choose different clock sources). The major difference is, unlike overclocking your PC, you don‚Äôt have to worry about the temperature of the microcontroller and don‚Äôt even need a cooling system for it.\n\nBack to STM32CubeIDE, let‚Äôs move to the next configuration tab-Clock Configuration. At the first look, you will ask yourself, what the heck you have gotten yourself into??\n\nThis is called a clock tree of a microcontroller. It describes all the clock sources available for the microcontroller and all kinds of possible adjustments in terms of clock speed. At the first look, it is quite scary, but let‚Äôs take a deep breath and use our engineering logic to find out what is going on there.\n‚Ä¢ By just focusing only on the area covered by the red square, we can guess/assume that there are some clock sources called LSE, LSI, MSI, HSI, HSE, and RC. With that information, we could have already deduced that LSE and HSE are external clock sources (surprise? E stands for External) and the rest should be internal clocks.\n‚Ä¢ Let‚Äôs shift our red square a bit to the right, we can see that the LCD and RTC peripheral can only receive clock source from HSE, LSE, or LSI. The IWDG can take the clock only from LSI. The PLL (Phase-locked loop) receives the clock only from HSE or HSI.\n‚Ä¢ Let‚Äôs shift our red window again to the right, we can observe that the system clock (mother of all) can take clock from sources: MSI, HSI, HSE and PLLCLK.\n‚Ä¢ Let‚Äôs do a final shift to the right. The system clock provides the clock to ‚Äúother part of the system‚Äù, for example, FCLK, HCLK, APB1. We can also see that some peripherals ‚Äî USART, I2C, etc. can take from other clock sources than the system clock. They are grey out because we didn‚Äôt activate them.\n\nThat‚Äôs was a lot for clock but this was only our assumption. To verify all the information above, please open the MCU reference manual (link), and read from page 174‚Äì185. It is only 12 pages (with some pictures) but all the knowledge is there. Just for your information, these are the names of the clock sources:\n\nTheoretically, we can set up the clock manually, but we are only using a GPIO and no communication buses or timers so we can practically let the tool automatically set the clock for us.\n‚Ä¢ In the box HCLK (picture below), enter the number 32 ( 32 MHz, we will run the clock at maximum speed) and press enter. The tool will report that there is no solution with the current clock source and it is asking you for the permission to choose another one. Press OK.\n‚Ä¢ After a while, STM32CubeIDE comes up with a solution, let‚Äôs check what it proposes to us.\n‚Ä¢ Going from right to left, we see system clock derived from the PLLCLK clock with the Prescaler of 1. The PLLCLK clock reached 32MHz by adjusting the PLLMul and PLLDiv. Then, the source for the PLL is the HSI clock.\n\nClocking part is over but we do not finish yet. Let‚Äôs return to the Pinout & Configuration tab.\n\nLet‚Äôs switch to Pinout & Configuration tab and navigate to the GPIO configuration as the picture below.\n‚Ä¢ GPIO output level: this means, after initialization, the pin will state in logic level high or low( output voltage 3.3V or 0V).\n‚Ä¢ GPIO mode: can be Output Push-pull or Output Open Drain\n‚Ä¢ GPIO Pull-up/Pull-down: the pin is internally pulled up to the VCC line (3.3V for example), pulled down (to the ground), or floating. This relates to the first point-GPIO output level. For example, if the pin is pulled-up, the logic level 0 will be 3.3V and logic level 1 will be 0V. It is applied the other way around for pulled-down.\n‚Ä¢ Maximum out speed: this will setup the rising/falling time of a pin, in other words, how long does it take for a pin to change the stage from low to high and high to low. For GPIO, it doesn‚Äôt have to be very fast but for any communication bus, it must be fast. But, this will be taken care of by STM32CubeIDE.\n‚Ä¢ User label: store the modified name of the pin.\n\nSo far so good, we have all we need, let‚Äôs generate the code from the configuration and add some code.\n\nRemember, we want to use the LL library, right? Change everything from HAL to LL.\n\nClicking the generate button to generate our code.\n\nBefore looking at the code, let‚Äôs compile the program to be sure that the generation process causes no error.\n\nTo compile the program, click on the hammer button\n\nAfter the compilation, there should be no error (If you run into any error, please describe it in the comment).\n\nNow, let‚Äôs have a look at the generated code. Please open the main.c file, this is where your application code start. I emphasized the word application because the code start in the startup file (.s file for your information) but what we have generated is mostly located in the main.c .\n\nScrolling down to the main function approximately at line 65, we see three functions and not to mention the infamous loop. We will have a look inside each function to see what does it do and to check if it acts according to what we have configured. To do that, highlight the function ‚Üíright-click ‚Üíchoose Open Declaration.\n\nWe will start with\n\nBy skimming through the , we can conclude that STM32CubeIDE not only generates what we have configured but also generates a lot of hidden things to make the system running. Hopefully, this convinces you that STM32CubeIDE does what we told it to do so we don‚Äôt have to take a look at the function. (but you should on your own to make sure that I am not talking bullshit :P ).\n\nSo, at this point, you should ask me which function to use to set the pin on/off. The answer lies within the LL API documentation, but normally I am using another version which can be found in:\n\nIf you open that document and go exactly to the location I show in the picture below, you will find a function called . This is what we need to turn the pin on/off. The parameters of the function are the port, which is GPIOA (If you give it a name it will become PIN_NAME_GPIO_Port) and the PinMask, which is LL_GPIO_PIN_x (again, if you give it a name, it will become PIN_NAME_Pin).\n\nThe only problem left is where to put this function. If you are experience with the embedded systems and the microcontrollers, you will immediately know that the function has to be in the loop. If you don‚Äôt know that, don‚Äôt worry (be happy). It is located in an infinite loop because we want to execute the code forever.\n\nBut be cautious!!!! If you, again, remember that we are using a tool that automatically generates our code, how can it know that which is its code, and which is our code, where to delete and where to add code? If you pay attention when skimming through the main.c file (and other files if you encounter them in the future), you will see there are some areas with a pair comment/* USER CODE BEGIN‚Ä¶*/ and /* USER CODE END‚Ä¶*/. These two lines act as a place holder for user code and tell the STMCubeIDE that, the user‚Äôs code is located there, DO NOT DELETE IT.\n\nSo, the plan is, we will go to the loop, at the toggle function between 2 place holders. This place is located at line 102 (if you have not touched anything in the main.c). My function will be:\n\nIs there anything missing? How can we see the blinking if the code is executed in a blink of the eye (approx. 32 million times/s)? We need a delay function to make it blink slowly. In the same document, where we found the toggle function, the delay function is located at:\n\nHence, our code will become\n\nIn the end, the loop looks like this\n\nLet‚Äôs compile the code. It should show no error. To debug the code, we have to connect the evaluation kit to the PC and press the bug button\n\nThe IDE will prompt you to a new window called Debug window. There, you press the play button to execute the code and you should see the green LED blinking on the evaluation board.\n\nNow, you can play a bit with the blinking period by changing the delay time, compiling the code, and executing it. If you get lost, don‚Äôt worry, this is the github repo for the code in the whole tutorial.\n\nOne last point I want to mention is, if you are a paranoid guy and don‚Äôt trust the Code Generator to generate your code, you can write the peripheral configuration code on your own. Let‚Äôs do it!.\n\nGo back to your main.c file, at line 93, we comment out the GPIO configuration function and write our code right after it, at line 95. If you still recall the configuration of a pin to work as an output pin, you will know that, you need some function to enable the clock for the pin, set output level, set pin mode, set pulled-up/pulled-down, and set speed. These functions are located at the same place where you find the toggle function.\n\nThis is what I have written for the pin configuration:\n\nAfter compiling and executing the application, you will see the same result, i.e. it is working with our own configuration.\n\nTo give you an idea of setting a pin as input is just an opposite direction of setting a pin as an output, we will start from the same project, where we write our GPIO configuration. The final piece, which is missing, is which pin the button is connected to. To find that, we can open the schematic of the board on the board manual. At page 23 of the board manual, it is stated that:\n\nTherefore, we have to configure pin PC13 as an input pin. We open file main.c and add the following snippet at line 113 (right after the GPIO output configuration).\n\nThe code is more or less self-explained. It enabled the clock, configured pin PC13 as input pin with no pull-up or pull-down.\n\nNext, in the while(1) loop, we replace the old code with the following snippet:\n\nIt did nothing else than checking the status of pin PC13. If the state of the pin is high or 1, we will turn on the LED and vice versa.\n\nThis method is called Polling because it involves constantly checking for the status of something and set the action according to that. You can also imagine, this method is like driving the car with an annoying kid to the theme park and the kid is constantly asking you ‚Äúare we there yet? are we there yet?‚Äù and you have to answer every time, ‚Äúyes‚Äù or ‚Äúno‚Äù.\n\nThis method is pretty straight forward, easy to understand and implement. But for every quick and dirty trick, there are always drawbacks.\n‚Ä¢ Firstly, we will waste our CPU power just to poll for the status.\n‚Ä¢ Secondly, while checking for the desired state, we may miss something more important, for example, some message on the communication bus.\n\nLet‚Äôs go back to out annoying kid, meanwhile answering to him ‚Äúyes‚Äù or ‚Äúno‚Äù, you could have missed a red light üòú.\n\nYou may ask yourself, wait, is there something to let the peripherals, kind of, checking the states itself and only inform you when it reaches the some defined states?. Yes, there is something like that, and it is called interrupt.\n\nAs mentioned above, the savior of our problem is called interrupt. Shortly explain, interrupt is a signal that lets the CPU inside the microcontroller know that, something is happening and the CPU should stop what it is doing (normally code section in the while(1)) to handle the signal.\n\nWhenever an interrupt happens (interrupt request), as soon as the CPU finishes its current instruction, it saves the address of the next instruction, status register, etc. and jumps to a section of code that handles the interrupt request (this section is called interrupt service routine or ISR).\n\nThe transition from the current code section to the interrupt code section is called interrupt latency. Of course, the shorter the latency, the better it is. After finishing the ISR, the CPU jumps back to where it left and continues from there. the rule of thumb for the ISR is, the code should be short and clean.\n\nThis is only a very brief explanation of how interrupt works. Each MCU architecture, each MCU vendor has a different way to handle the interrupt so please take a look at the datasheet to have a better understanding. I have found this article about interrupt pretty useful, please have a look if you are fancy about interrupting üòÜ link (in fact, most of my explanation is based on it).\n\nBack to our STM32 controller, most of the work is taking care of by STM32CubeIDE, so the thing we have to do is knowing how to configure interrupt, filling the right code at the right place, and that‚Äôs it.\n\nLet‚Äôs create a new project with STM32CubeIDE, I hope you have already known the basic steps of how to do that.\n\nFor this application, we need two GPIOs, PA5 to drive the LED and PC13 for the button.\n\nWe set the PA5 pin as GPIO output and change its name to LED2 as the picture below:\n\nOn the PC13, we initialize it as GPIO_EXTI13. Besides, it is given a name BUTTON.\n\nAlthough we have configured the PC13 as an external interrupt, we have to activate that function in the configuration tab. Therefore, go to System view ‚Üí NVIC ‚Üí Activate EXT line 4 to 15 interrupts\n\nWhy do I know that it is line 4 to 15 I have to activate? The answer is in the reference manual, page 289. As you can see in Table 54, the EXTI line 0 ‚Äì15 are tied to GPIO.\n\nEverything is set and done, let‚Äôs generate the project and add some code.\n\nBefore filling the code let‚Äôs go to function to check what is the difference between using the polling method and interrupt method. The noticeable thing is that PC13 is configured as GPIO Input, exactly the same as what we have done in the previous section. Additionally, externally interrupt line 13 is activated and configured as rising edge triggering (code below).\n\nSo, we have only to look for the ISR, fill in the code and the job is done.\n\nThe ISR is located in the file stm32l0xx_it.c. Open that file, look for the function and fill in the code as below to toggle the LED:\n\nSo‚Ä¶that‚Äôs it to toggle LED whenever we press the button, no more polling for the status of the pin connected to the button.\n\nWe are able to control the GPIO and the question is, what is the usage of it? Some of the recommendations are:\n‚Ä¢ Control the relay instead of the LED\n‚Ä¢ Show the status of the system, e.g. the LED blinks fast - error; the LED blinks slow - system is running; the LED is constantly on -the System is in configuration phase, etc.\n\nWe have learned how to set up GPIO in STM32CubeIDE and generate the project. We also learned how to control the GPIO using LL APIs.\n\nIn the next episode, we will learn about UART."
    },
    {
        "link": "https://deepbluembedded.com/stm32-hal-library-tutorial-examples",
        "document": "STMCube¬Æ is STMicroelectronics‚Äôs original initiative to ease and accelerate the development cycle of embedded products. STM32Cube covers the STM32 portfolio of microcontrollers.\n\nIt provides the developer with all the low-level drivers, APIs, and enables him/her to dedicate most of the effort to develop the application layer and any required middleware.\n\nThe STM32CubeMX, a graphical software configuration tool that allows generating C initialization code using graphical wizards.\n\nThe STM32Cube Hardware Abstraction Layer (HAL), an STM32 abstraction layer embedded software ensuring maximized portability across the STM32 microcontroller. The HAL is available for all the hardware peripherals.\n\nThe low-layer APIs (LL) offering a fast light-weight expert-oriented layer that is closer to the hardware than the HAL. The LL APIs are available only for a set of peripherals.\n\nThe HAL and LL are complementary and cover a wide range of applications requirements:\n‚Ä¢ None The HAL offers high-level and feature-oriented APIs, with a high-portability level. They hide the MCU and peripheral complexity to end-user.\n‚Ä¢ None The LL offers low-level APIs at registers level, with better optimization but less portability. They require deep knowledge of the MCU and peripherals specifications.\n\nThe source code of HAL and LL drivers is developed in Strict ANSI-C which makes it independent from the development tools. It is fully documented and is MISRA-C 2004 compliant.\n\nIn the same manner, there are low-level hardware drivers for almost all the hardware peripherals in the STM32 microcontrollers. Including Timers, ADC, USART, I2C, USB, DAC, Comparators, etc.\n\nWe‚Äôll configure these peripherals and generate the initialization C-Code using the CubeMX software tool. Here is a screenshot for what it looks like inside the interface where we configure the timer module for example.\n\nUsing the STM32 HAL device drivers can be advantageous in so many situations, and help shorten the development time. Especially for projects that fall in the category of ‚Äúproof of concept‚Äù. I think no one wants to spend so much time building a complete software stack for a specific target then it proves the main idea needs more refinement or the target itself does not perform well enough.\n\nHowever, the moderately high-level APIs provided by the HAL may have extra more features than what you may actually need in some situations. So you end up using more memory space and executing some tasks a little bit slower due to the overhead of the functionalities embedded in the libraries.\n\nYou can use the LL drivers and optimize more at the register level in order to enhance memory utilization or the speed of execution. However, the application at the end would not be easily portable across multiple targets.\n\nAll in all, we‚Äôll be using the STM32 CubeMX tool to generate HAL + LL drivers C-Code to initialize our hardware. Then we‚Äôll be developing the application layer and some middleware stuff on the way.\n\nMostly, we‚Äôll be focusing on the ECUAL layer building some firmware drivers, and testing them in different applications. Those drivers must be easily reconfigurable and completely portable.\n\nTo achieve reconfigurability, we‚Äôll use something called ‚ÄúLinking Configuration‚Äù that you‚Äôll learn in the next tutorials. And in order to achieve the portability requirement, the drivers will be totally based on the STM‚Äôs HAL + LL drivers that have uniformed APIs across all STM32 microcontrollers. In this way, you can use the code provided in the practical LABs in this series of tutorials and build it to your specific target microcontroller whatever it is, it should work!\n\nECUAL drivers we‚Äôll be building include: [ Servo Motors ‚Äì Keypad ‚Äì LCD ‚Äì HC-SR04 Ultrasonic ‚Äì Joystick ‚Äì and more.. ]. You can check them out if you‚Äôre curious or just keep following along with these tutorials.\n\nThat‚Äôs it for this short introduction to the STM32 HAL Library and CubeMX tool. In the next tutorial, we‚Äôll get to know the hardware GPIO ports and pins. How it works and the internal circuitry and functionalities you can configure in various applications. Thereafter we‚Äôll be able to start the first LAB in this series of tutorials and ‚ÄúBlink an LED!‚Äù."
    },
    {
        "link": "https://stackoverflow.com/questions/50243996/what-are-valid-values-of-hal-nvic-setpriority-when-using-stm32-and-freertos",
        "document": "After a rather difficult process of learning some things about interrupt priority, I am still a bit stuck trying to understand what values I am allowed to call for on the (which is the ISR calling the FreeRTOS scheduler every 1 ms).\n\nPart of me thinks that anything between (lowest priority possible) and (a bit higher) are allowed, and part of me thinks that anything between (lowest priority possible) and (quite a bit higher) is allowed. This is assuming that in FreeRTOSConfig.h is set to 5. The confusion lies in the fact that in FreeRTOS, higher numbers are higher priority, but in STM32, higher numbers are lower priority, and the documentation is pretty challenging to understand.\n\nTo prove I've made a valiant effort, and to help you help me fill in the blanks, here's my current understanding. I'm going to write a description of what I know to be true in such a way that it looks like I am teaching you, even though I'm seeking the answer to my above question, as well as correction, confirmation, or additional insight as you see fit.\n\nThough this probably applies to many of the STM32 microcontrollers or families, let's discuss it in terms of the STM32F207ZG in particular.\n\nIf you look at a standard FreeRTOSConfig.h file (ex: STM32Cube_FW_F2_V1.7.0/Projects/STM322xG_EVAL/Applications/FreeRTOS/FreeRTOS_ThreadCreation/Inc/FreeRTOSConfig.h) you'll see the following:\n\nis defined in STM32Cube_FW_F2_V1.7.0/Drivers/CMSIS/Device/ST/STM32F2xx/Include/stm32f217xx.h as since \"STM32F2XX uses 4 Bits for the Priority Levels\".\n\nFirst off, this is interesting because it means that only 4 of the available 8 priority bits are actually used! The STM32 HAL library call has a header that looks as follows, and seems to indicate you have 8 bits to set ( from 0 to 15 and from 0 to 15), but really you don't--you only have 4 bits to set.\n\nSo, you only have 4 bits to set, but it turns out you can decide how many are bits and how many are bits, as follows:\n\nFreeRTOS says in their documentation:\n\nSo, one of the very first things you should do in your code (at least before starting the FreeRTOS scheduler via or is:\n\nThis configures all 4 of your priority bits to be bits and none to be bits. This means any calls to the function will now always use 0 as the right-most parameter.\n\nYou should then essentially call (note: this is called via :\n\nwhere is the SysTick tick priority. Since we have all 4 bits available, this gives us a priority range of 0 to 15, with 15 being the lowest interrupt priority and 0 being the highest priority.\n\nWell, why are we setting SysTick to the lowest priority? Answer: because this is a good practice for the FreeRTOS scheduler, which the SysTick interrupt calls. As a matter of fact, giving it too high a priority will break FreeRTOS, according to their own documentation. Let's try to figure that out.\n\nWe know that our interrupt options now are 0 to 15 for the setting, but it's even narrower than that: we can only set our PreemptPriority for the SysTick interrupt to be 10 to 15 (I think--I need some help here). Why 10 to 15? Well, the FreeRTOS documentation (albeit this is super confusing) even expressly states:\n\nNow, refer back to FreeRTOSConfig.h at the top of this page. We know is 4 and we see that:\n\nis , which means it is .\n\nThe FreeRTOS documentation offers some valuable insight into why the left-shift (see the section titled \"Cortex-M Internal Priority Representation\"), but I can't discern beyond that.\n\nSo now making some educated guesses and knowing our priority options are 0 to 15 with 0 being highest and 15 being lowest, and knowing that configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY is 5, we maybe are allowed to use 15 - 5 = 10 as highest priority and 15 as lowest, or maybe 5 to 15 is ok but 0 to 4 is off-limits? I don't know...I'm confused..."
    },
    {
        "link": "https://hackmd.io/@hrbenitez/158_2s2223_Int_Tim",
        "document": "<center> <h4> EEE 158 1st Sem AY 2022-2023 </h4> <h1> STM32 Interrupts and Timers</h1> </center> *Notes before proceeding:* * The lengths of the required videos are indicated inside the parentheses for your reference. * The given sample codes are for reference only and are not meant to be run as they are unless otherwise stated. * The definitions of SFRs here are summarized; check the datasheet for more information. # Introduction For this week, we will explore 2 more peripherals that are essential for most MCU applications. The first is the interrupt controller which effectively allows multitasking by allowing asynchronous events trigger special subroutines and change MCU operation momentarily. Timers, on the other hand, provide further utility to the MCU as a precise source of delay or source of a periodic interrupt. # Learning Outcomes * Configure the STM32 interrupt controller. * Use external interrupts for asynchronous inputs. * Configure STM32 timer modules for precise delays and periodic subroutines. * Implement interrupts with the STM32 timers. # Summary of Activities <center> <table> <tr> <th width=20%>Topic</th> <th width=30%>Activity</th> <th width=30%>Assessment</th> <th width=20%>Estimated Time (hours)</th> </tr> <tr> <td rowspan=3>STM32 Interrupts</td> <td><a href=\"#STM32-Interrupts\">Video (Overview)</a></td> <td></td> <td>0.50</td> </tr> <tr> <td><a href=\"#Example-External-Interrupt\">Video (External Interrupt)</a></td> <td></td> <td>0.33</td> </tr> <tr> <td></td> <td><a href=\"#Exercise-1-Pushy-Pushy\">Coding Exercise</a></td> <td>0.75</td> </tr> <tr> <td rowspan=3>STM32 Timer Peripheral</td> <td><a href=\"#STM32-Timers\">Overview Handout</a></td> <td></td> <td>0.25</td> </tr> <tr> <td><a href=\"#Example-Delays-with-Timers\">Example Code</a></td> <td></td> <td>0.42</td> </tr> <tr> <td></td> <td><a href=\"#Exercise-1-Pushy-Pushy\">Coding Exercise</a></td> <td>0.75</td> </tr> <tr> <td></td> <td>Optional Synchronous Discussion/Consultation</td> <td> </td> <td>0.50</td> </tr> <tr> <th width=20%>Total</th> <th width=30%> </th> <th width=30%> </th> <th width=20%> 3.50 hours </th> </tr> </table> </center> # STM32 Interrupts ***Interrupts*** are asynchronous (i.e. can happen anytime) events that disrupt the normal flow of your program. This allows the microcontroller to focus on a key task and attend to these events (e.g. pressing a button) as they come without needing to wait for them. Professor Zhu provides us with an overview of interrupts in STM32 MCUs in [this video (20:42)](https://youtu.be/uFBNf7F3l60). ## Configuring an Interrupt Properly harnessing the power of interrupts may sound like a daunting task. However, any interrupt can be usually configured in 5 steps: 1. **Configure the peripheral** that would be generating the interrupt . 2. **Take note of the `position` and `acronym` of the interrupt** in Table 37 of Chapter 10 of the [STM32F411 reference manual](https://uvle.upd.edu.ph/mod/resource/view.php?id=345803). The `position` is also referred to as the *Interrupt Request Number* (`IRQn`) and the `acronym` will be useful to use predefined pointers/macros. 3. **Set the interrupt priority by writing on the interrupt priority register `NVIC->IP[IRQn]`**. Each interrupt is assigned one byte or 8 bits but only the 4 upper bits are used for the STM32F411 series. This means there are a total of 16 priority levels. 4. **Enable the interrupt itself by setting the appropriate `NVIC->ISER` bit**. Since the STM32F411 supports up to 85 different interrupt sources, `ISER` is actually an array of 3 registers. The following is the general *formula* to set the correct bit: `NVIC->ISER[IRQn >> 5] |= (1 << (IRQn % 32)`. 5. **Define your interrupt handler or also known as the Interrupt Service Routine (ISR)**. The name of the ISR is defined in the header files but is usually `acronym_IRQHandler`. The ISR is the function that is called whenever the interrupt is triggered and usually needs to acknowledge the triggering of the interrupt in some way. To learn more about the Nested Vector Interrupt Controller (NVIC) and its registers, you can watch [this video (optional)](https://youtu.be/K0vmH2YGbOY). The video also contains some CMSIS functions you can use to help with configuring the NVIC. ## Example: External Interrupt Of course, the best way to understand configuration is doing it yourself. To help you out, below is the sample code to configure the *external interrupt* for `PC13` or our onboard pushbutton: ```c= void Interrupt_Init(void){ EXTI15_10_Init(); // Step 1, this is defined elsewhere // Step 2: // EXTI15_10 is the acronym for the external interrupt for PC13 // EXTI15_10_IRQn = 40 since it is position 40 in Table 37 NVIC->IP[EXTI15_10_IRQn] = (1 << 4); // Step 3: Set priority to 1 NVIC->ISER[40 >> 5] |= (1 << (40 % 32)); // Step 4: Enable interrupt } // Step 5: Define EXTI15_10_IRQHandler void EXTI15_10_IRQHandler(void){ // Do something return; } ``` [This video (12:49)](https://youtu.be/uKwD3JuRWeA) goes over the details in configuring external interrupts and below is an example for the configuration for `PC13` based on the `SYSCFG` registers in Chapter 7 of [STM32F411 reference manual](https://uvle.upd.edu.ph/mod/resource/view.php?id=345803): ```c= void PB_Init(void){ RCC->AHB1ENR |= (1<<2); // Enables GPIOC peripheral GPIOC->MODER &= ~(3<<26); // PC13 as Input GPIOC->PUPDR &= ~(3<<26); // PC13 with NO pull-up, NO pulldown } void EXTI15_10_Init(void){ PB_Init(); // Initialize PA13 as input. RCC->APB2ENR |= (1<<14); // Enable System configuration controller SYSCFG->EXTICR[3] &= ~(1<<7); // Select Port C as source, EXTIx = 0b0010 SYSCFG->EXTICR[3] &= ~(1<<6); // Select Port C as source, EXTIx = 0b0010 SYSCFG->EXTICR[3] |= (1<<5); // Select Port C as source, EXTIx = 0b0010 SYSCFG->EXTICR[3] &= ~(1<<4); // Select Port C as source, EXTIx = 0b0010 EXTI->IMR |= (1<<13); // Disable interrupt request mask on EXTI line 13 EXTI->FTSR |= (1<<13); // Enable EXTI on Falling edge EXTI->RTSR &= ~(1<<13); // Disable EXTI on Rising edge RCC->APB2ENR &= ~(1<<14); // Disable System configuration controller } // Requirement for the IRQHandler void EXTI15_10_IRQHandler(void){ // Do something // ... // ... EXTI->PR |= (1<<13); // Clear PR to re-enable EXTI interrupt } ``` Note that for our configuration, we are only enabling the interrupt generation on the falling edge of the input. Recall that our input switch comes with a pull-up resistor and that pressing the switch causes a falling edge. Still, we only have the instructions to configure the interrupt. In order to actually use the interrupt, let us make the LED toggle states whenever the interrupt is called with the following extra code and modification of the ISR: ```c= void LD_Init(void){ RCC->AHB1ENR |= (1<<0); // Enables GPIOA peripheral GPIOA->MODER &= ~(1<<11); // PA5 as Output, MODER = 0b01 GPIOA->MODER |= (1<<10); // PA5 as Output, MODER = 0b01 GPIOA->OTYPER &= ~(1<<5); // Sets GPIOA, PIN 5 as push-pull GPIOA->ODR |= (1<<5); // PA5 initially HIGH } int main(void){ LD_Init(); Interrupt_Init(); /* Loop forever */ while(1); } // Final Definition void EXTI15_10_IRQHandler(void){ GPIOA->ODR ^= (1<<5); // Toggle LED EXTI->PR |= (1<<13); // Clear PR to re-enable EXTI interrupt } ``` By combining all of the sample code given above you should find that the LED toggles from being `ON` and being `OFF` on each button press like so: <center> <img src=\"https://drive.google.com/uc?export=view&id=1eBoiiPSb7NxnJbPO6EAznPg8fIeRdoLv\"/> <br /> </center> On TINA cloud, you can also upload your code and make use of the interactive transient mode. Alternatively, you may load up the [example circuit uploaded on UVLe](https://uvle.upd.edu.ph/mod/resource/view.php?id=349584) with the push button replaced by an electronically controlled switch. After a 5-second transient simulation, you should get the following result: <center> <img src=\"https://drive.google.com/uc?export=view&id=1eva4LUFJNdYBEdqK75ABv935WX0Qy0mh\"/> <br /> </center> `VG` is the control signal of the switch (i.e. when `VG` is *HIGH*, the button is pressed). `OB_B1` is the signal going into `PC13` and `OB_LD1` is the output at `PA5` which powers up the LED. Notice that when the button is pressed, a falling edge can be seen on `OB_B1`. *What do you think would we need to change if we had a switch with a pull-down resistor instead?* ## Semaphores Semaphores, in the context of MCU interrupts, are global variables that are modified by the interrupt handlers and read in the main code. An example would be `pressed` in the code below: ```c= volatile unsigned int pressed; int main(void){ pressed = 0; LD_Init(); Interrupt_Init(); /* Loop forever */ while(1) { if (pressed) { GPIOA->ODR ^= (1<<5); // Toggle LED pressed = 0; } } } // Definition with Semaphore void EXTI15_10_IRQHandler(void){ pressed = 1; EXTI->PR |= (1<<13); // Clear PR to re-enable EXTI interrupt } ``` In this example, we have exactly the same behavior as our code above but with a different code. Use of semaphores greatly reduces the overhead for interrupt handlers. Remember that the MCU can only really do one thing at once. If it is busy servicing an interrupt, then it is *not* doing its main thing. It also becomes more easier for us programmers to take note of multiple interrupts that could occur in our program especially if you would like to wait for a combination of interrupts to occur. # Exercise 1: Pushy Pushy (4 points) Either modify the code above or start from scratch, accomplish the following functionality: * On the *first button press*, the LED turns `ON` on the *moment of pressing* the button and *stays* `ON` when the button is released. * On the *second button press*, the LED turns OFF when the button is released. * Subsequent button presses will alternate between these (i.e. `ON` on the third button press, `OFF` on the fourth button release, and so on...). That looks like this on the board: <center> <img src=\"https://drive.google.com/uc?export=view&id=18qO-TGDS6jozPo7CZw17QStPSlKsL1rv\"/> <br /> </center> <br /> Or like this on TINA: <center> <img src=\"https://drive.google.com/uc?export=view&id=1GmVlZLbj87GCHaZrjW7t6JRPg3XsTns4\"/> <br /> </center> <br /> Some things that may or may not help: 1. Interrupts and peripherals can be configured and *re*-configured at *any* time during the program but be careful since interrupts can also get triggered during configuring of interrupts. 2. When using TINA, you may find the LED in a unexpected state or the pressing the switch does nothing during the start of your program and that's okay. 3. You can consider the MCU as a state machine. # STM32 Timers Timers, as the name suggests, allow the microcontroller to measure periods of time. It does this by counting the number of clock cycles that have elapsed since the timer was activated. Alternatively, timers are also used to generate interrupts after a programmed time period has elapsed. To learn how timers work, in general, you can watch [this video from the previous offering for EEE 153 (17:16)](https://youtu.be/KfWFrxRhHEY). STM32F411RE devices contain up to a total of 7 general purpose 16-bit timers (`TIM2` to `TIM5`, and `TIM9` to `TIM11`) plus one advanced purpose 16-bit timer (`TIM1`). For this module we will be focusing on the general purpose timers and use them to generate precise delays and the following are the essential registers to take note of: 1. **Timer Clock Enable** (`RCC->APBxENR[y]`): In order for a timer to time correctly, it needs a clock input. By default, our timers use the peripheral bus clock and to enable it for our timers, the specific `APBxENR` bit must be set. To know the specific bit to set, we can always consult the [STM32F411 reference manual](https://uvle.upd.edu.ph/mod/resource/view.php?id=345803) 2. **Timer Enable** (`TIMx->CR1[0]`): As with any other peripheral, our timer modules need to be enabled. Do note that timers can be enabled and disabled at any time. 3. **Timer Count Register** (`TIMx->CNT`): We can read the current counter value of the timer from this register. It is good practice to set this register to `0` before we enable the counter to ensure that we get our expected delay. 4. **Timer Auto-Reset Register** (`TIMx->ARR`): When the timer value reaches the value set on the period register, the timer value is reset to `0` and an interrupt is generated, if enabled. This register is also referred to as the timer *period register*. 5. **Update Generation Bit**(`TIM2->EGR[0]`): Set this bit to `1` in order to automatically reset all necessary registers to restart counting. 6. **Timer Prescaler Register** (`TIMx->PSC`): The prescaler *slows down* the input clock in order to generate delays that are several times higher than the input clock frequency. For the STM32, the effective input clock frequency ($F_{eff}$) to the timer can be calculated as: $$F_{eff} = \\frac{F_{in}}{PSC + 1}$$ where $F_{in}$ is the input clock frequency, usually $16MHz$, and $PSC$ is the prescaler value written on the `TIMx->PSC`. ## Example: Delays with Timers Consider the configuration of `TIM2` below: ```c= void Tim2_Init(void){ RCC->APB1ENR |= (1<<0); // Enable clock for TIM2 TIM2->PSC = 16000-1; // Set PSC+1 = 160000 TIM2->ARR = 0xFFFF; // Reset at maximum CNT value TIM2->EGR |= (1<<0); // Reset timer counter registers TIM2->CNT = 0; // Manually reset CNT (needed in TINA) TIM2->CR1 |= (1<<0); // Enable timer, CR1[0] = 1 } ``` At the given `PSC` value and assuming a peripheral clock of $16 MHz$, we get the following effective frequency: $$F_{eff} = \\frac{16 \\times 10^{6}}{16 \\times 10^{3}} = 1000 Hz$$ This means that each `CNT` corresponds to $1ms$ elapsing. So, if we modify our [main code earlier](https://hackmd.io/@hrbenitez/158_2s2223_Interrupts#Semaphores) like so: ```c= volatile unsigned int pressed; int main(void){ pressed = 0; LD_Init(); Interrupt_Init(); Tim2_Init(); /* Loop forever */ while(1) { if (pressed) { TIM2->EGR |= (1<<0); // Reset timer counter registers TIM2->CNT = 0; // Manually reset CNT (needed in TINA) TIM2->CR1 |= (1<<0); // Enable timer while (TIM2->CNT < 100) { // While CNT is below 100 GPIOA->ODR |= (1<<5); // LED ON } GPIOA->ODR &= ~(1<<5); // LED ON pressed = 0; // Clear Semaphore } } } ``` We can get the following behavior when we push the button: <center> <img src=\"https://drive.google.com/uc?export=view&id=18fL9pIIsFR_pnus6m7ns1IW9cH7PGSeM\"/> <br /> </center> <br /> *Blink and you'll miss it*. We can also run it on TINA and get the following waveform: <center> <img src=\"https://drive.google.com/uc?export=view&id=19-PvuYHUD2BPdamM5SNwVdiKZELMyTMh\"/> <br /> </center> <br /> Notice that the LED lights up for about $100ms$ at each button press. Try and modify the condition of the loop in line `14` above and observe what happens. Because of the prescaler value that we set, when `TIM2->CNT` reaches `100`, $100ms$ have elapsed and that is precisely the amount of time `LD1` is `ON`. So some might think why would we need to use timers if the `delay()` function we used previously works fine? Well that's because timers are generally more flexible and our main program can do other things while it waits for the timer to finish counting like this modification of the infinite loop above: ```c= while(1) { if (pressed) { TIM2->EGR |= (1<<0); // Reset timer value TIM2->CR1 |= (1<<0); // Enable timer while (TIM2->CNT < 1000) { // While CNT is below 1000 if (TIM2->CNT % 100 > 50) { GPIOA->ODR |= (1<<5); // LED ON } else { GPIOA->ODR &= ~(1<<5); // LED OFF } } GPIOA->ODR &= ~(1<<5); // LED ON pressed = 0; // Clear Semaphore } } ``` What this does is left as an exercise to the reader :) ## Example: Timers as Interrupts Perhaps more importantly, timers can be used as interrupt sources. By default, general purpose timers generate an interrupt when the `CNT` and `ARR` registers become equal. In addition to the usual interrupt registers and timer registers above, the following bits need to be taken note of: 1. **Interrupt Generation Enable Bit** (`TIM2->DIER[0]`): Setting this bit to `1` enables the timer to generate interrupts. 2. **Interrupt Pending Flag** (`TIM2->SR[0]`): MCU hardware sets this bit to `1` if an interrupt has been triggered. We have to set this bit to `0` in order to receive new timer interrupts. There are several others that configure the behavior of the timer interrupt but these are the only ones needed for our example. Including NVIC configuration, our `Tim2_Init()` will now look like this: ```c= void Tim2_Init(void){ RCC->APB1ENR |= (1<<0); // Enable clock for TIM2 TIM2->PSC = 16000-1; // Set PSC+1 = 160000 TIM2->ARR = 100; // Set timer to reset after CNT = 100 TIM2->DIER |= (1<<0); // Enable timer interrupt generation NVIC->IP[TIM2_IRQn] = (2 << 4); // Set priority to 2 NVIC->ISER[TIM2_IRQn >> 5] |= (1 << (TIM2_IRQn % 32)); // Enable interrupt TIM2->SR &= ~(1<<0); TIM2->EGR |= (1<<0); TIM2->CR1 &= ~(1<<0); // Disable timer, for now } ``` We can also use another semaphore so that our main code and interrupt handlers look like this: ```c= volatile unsigned int pressed; volatile unsigned int waiting; int main(void){ pressed = 0; waiting = 0; Interrupt_Init(); Tim2_Init(); LD_Init(); /* Loop forever */ while(1) { if (pressed) { TIM2->EGR |= (1<<0); // Reset timer TIM2->CR1 |= (1<<0); // Enable timer waiting = 1; while (waiting) { GPIOA->ODR |= (1<<5); // LED ON } GPIOA->ODR &= ~(1<<5); // LED OFF pressed = 0; } } } void TIM2_IRQHandler(void){ waiting = 0; TIM2->SR &= ~(1<<0); // Clear UIF update interrupt flag } void EXTI15_10_IRQHandler(void){ pressed = 1; EXTI->PR |= (1<<13); // Clear PR to re-enable EXTI interrupt } ``` This should have the same result with the [previous example](#Example-External-Interrupt). It would be important to note that at line`5` of `Tim2_Config` we set `ARR` to `1000` which was the `CNT` value we were using for the delay loop earlier. ## Example: Periodic Interrupts Alternatively, we can use interrupts generated by timers to run a periodic subroutine through the timer interrupt handler. The usual usage for this is to generate a square wave with a fixed frequency as follows: ```c= int main(void){ LD_Init(); Tim2_Init(); TIM2->CR1 |= (1<<0); // Enable timer /* Loop forever */ while(1) { } } void TIM2_IRQHandler(void){ GPIOA->ODR ^= (1<<5); // LED ON TIM2->SR &= ~(1<<0); // Clear UIF update interrupt flag } ``` Note that `Tim2_Init` is the same as the one used in the [previous example](#Example-Timers-as-Interrupts). Our development board or TINA simulation should look like something similar to our example code in the [last module](https://hackmd.io/@hrbenitez/158_2s2223_GPIO#Register-Level-Programming). # Exercise 2: Pushy Blinky (7 points) Either modify the example code given or start from scratch, accomplish the following functionality: * The on-board LED is `OFF` at system reset and the system clock is set to $16MHz$. * When the on-board switch is pressed, the LED will toggle between `ON` and `OFF` states. * The LED will continue to toggle as long as the switch remains pressed. * The toggling of the LED should form a square wave when viewed on TINA, the frequency of the square wave is $(2+X) Hz$ where $X$ is the last digit of your student number. * When the on-board switch is released, the LED will retain its last state and remain in that state until the switch is pressed again. At the minimum square wave frequency of $2 Hz$ it will look like this on the development board: <center> <img src=\"https://drive.google.com/uc?export=view&id=1eiXmibmKsRP5VsBF9p1gxQ0gVhyPTGeN\"/> <br /> </center> <br /> At the maximum square wave frequency of $11 Hz$ the output waveforms will look like this: <center> <img src=\"https://drive.google.com/uc?export=view&id=18faAgnUzHDYmJF8hEAxlSdXyud9SvzET\"/> <br /> </center> <br /> Some things that may or may not help: * You need to use interrupts to handle inputs because of the limitations of TINA. * You are not required to use interrupts for the timers but it is recommended. * Both `ARR` and `PSC` are 16-bit registers so make sure the values written on these can be represented by 16 bits. * Semaphores become more useful if more interrupts are involved. * A $5Hz$ square wave means that the LED blinks 5 times in 1 second. # Submission Requirements Submit one `.zip` file containing the following: 1. The main `.c` file for [Exercise 1](Exercise-1-Pushy-Pushy). Name this file `<section>_<surname>_Week4_Ex1.c`. 2. The main `.c` file for [Exercise 2](Exercise-2-Pushy-Blinky-Pushy). Name this file `<section>_<surname>_Week4_Ex2.c`. Include your name, section, and student number as a comment in your code. [Link to submission bin](https://uvle.upd.edu.ph/mod/assign/view.php?id=350306)"
    },
    {
        "link": "https://st.com/resource/en/user_manual/um1725-description-of-stm32f4-hal-and-lowlayer-drivers-stmicroelectronics.pdf",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/71626597/what-are-the-various-ways-to-disable-and-re-enable-interrupts-in-stm32-microcont",
        "document": "Update 10 May 2023: one of my primary motivating factors in learning this stuff was related to my first ever ring buffer implementation I wrote 7 years ago in 2016, leading to this debugging problem where I lost 25 hours of debugging work in 2 days. I finally wrote a really good ring buffer implementation that is lock-free when used on any system which supports C11 or C++11 atomic types. It is the best implementation I've ever written, and also the best I've ever seen. It solves a lot of the problems of other implementations. Full details are in the top of the file. It runs in both C and C++. You can see the full implementation here: containers_ring_buffer_FIFO_GREAT.c in my eRCaGuy_hello_world repo.\n\nFor the definition of these functions, see:\n‚Ä¢ https://github.com/ARM-software/CMSIS/blob/master/CMSIS/Include/cmsis_gcc.h\n‚Ä¢ Contains at least:\n\nTo save and restore the interrupt state, use , like this:\n\nWhen dealing with global interrupts, this is the best way for bare-metal, non-FreeRTOS code!\n\nI think this technique is also cross-compatible with ALL ARM-core mcus, not just STM32.\n\nI first learned this technique from Tilen Majerle, here: https://stm32f4-discovery.net/2015/06/how-to-properly-enabledisable-interrupts-in-arm-cortex-m/. His work and contributions to clear up this super-obfuscated stuff are infinitely valuable and appreciated!\n\nIt is best to avoid disabling global interrupts, if possible, and disable only the fewest number of specific interrupts possible to achieve atomicity for your specific code. So, using these functions allows you to enable or disable only the specific interrupts you need to!\n\nNVIC stands for \"Nested Vector Interrupt Controller\". Nested interrupts (meaning: a higher-priority interrupt can still fire within an ISR) are enabled by default on STM32 microcontrollers. Each interrupt type has a priority assigned to it, with lower numbers being higher priority, and higher-priority interrupts are able to fire while an ISR is being processed for a lower-priority interrupt. See here for a little more information on the STM32 NVIC: https://stm32f4-discovery.net/2014/05/stm32f4-stm32f429-nvic-or-nested-vector-interrupt-controller/.\n\nContrast this to AVR microcontrollers (ex: ATMega328 / Arduino Uno), which do not have priority-based interrupts, so by default, when any ISR is being processed, all interrupts (ie: global interrupts) are automatically disabled as the program enters the ISR. Note that even on AVR mcus, however, you can still manually enable nested interrupts / ISRs if you like by manually re-enabling global interrupts inside your ISR, via a call to on Arduino or (set interrupts) on raw AVR.\n\nEach ARM-core microcontroller manufacturer, I believe, including STM32 types, must define and create its own list of interrupt request types, so see below for the STM32 details on their specific interrupt types defined for each mcu.\n\nSee, for example: \"stm/stm32f2xx/st_hal_v1.1.3/STM32F2xx_HAL_Driver/Src/stm32f2xx_hal_cortex.c/.h\" - definitions for those functions above are in those files. See them online:\n\nHere are the definitions of and . Notice that they just check to ensure your is valid, then they pass the input argument on to the ARM-core CMSIS and functions above!:\n\nFor s: see the appropriate definition file for your specific board! These are board-specific definitions, for your board from your manufacturer. Here are all of the boards in the STM32 F2xx line, for instance: https://github.com/STMicroelectronics/STM32CubeF2/tree/master/Drivers/CMSIS/Device/ST/STM32F2xx/Include. Let's look at the file specifically:\n‚Ä¢ Raw view (since file is too big to view on GitHub otherwise): https://raw.githubusercontent.com/STMicroelectronics/STM32CubeF2/master/Drivers/CMSIS/Device/ST/STM32F2xx/Include/stm32f217xx.h\n\nFrom this file, we can see the definition for the , which is the \"STM32F2XX Interrupt Number Definition\". Here is what it looks like:\n\nTo get exclusive access (to ensure strings are atomically printed, for instance) to the for printing debug chars via a HAL-based blocking (polled) mode (ie: via ), you need to disable all interrupts for by doing the following. (This guarantees you get atomic access to this device):\n\nThe FreeRTOS atomic-access-guard / interrupt-related functions are listed under the \"Modules\" section of the Kernel Control API here: Kernel Control:\n\nSee also my README here, with a potential list of which calls are and are not allowed within FreeRTOS critical sections: https://github.com/ElectricRCAircraftGuy/eRCaGuy_Engineering/tree/main/FreeRTOS#freertos-critical-section-calls\n‚Ä¢ None These are the preferred macros to use, and are the freertos-recommended ones!\n‚Ä¢ None These all support nested calls, and end up calling anyway, which is the port implementation of the lower-level , shown below. Calls to and are designed to nest. Therefore, a critical section will only be exited when one call to has been executed for every preceding call to . Critical sections must be kept very short, otherwise they will adversely affect interrupt response times. Every call to must be closely paired with a call to . FreeRTOS API functions must not be called from within a critical section.\n‚Ä¢ None These do NOT support nested calls!\n‚Ä¢ None Official documentation on them is on the main \"Kernel Control\" page:\n‚Ä¢ \n‚Ä¢ at the link above states: Normally this macro would not be called directly and and should be used in its place.\n‚Ä¢ at the link above states: Normally this macro would not be called directly and and should be used in its place.\n‚Ä¢ Note also that the use of is demonstrated as the technique used to panic inside an example macro definition for .\n‚Ä¢ From here: https://www.freertos.org/a00110.html#configASSERT, when used with a debugger, it is defined as: /* Define configASSERT() to disable interrupts and sit in a loop. */ #define configASSERT( ( x ) ) if( ( x ) == 0 ) { taskDISABLE_INTERRUPTS(); for( ;; ); }\n‚Ä¢ My thoughts: perhaps in this one case (ie: hard asserting, or panicking), might be preferred over because no amount of calling from another thread will re-enable interrupts once has been called [I think!?]--rather, one would have to explicitly (and accidentally) call (ex: from another thread) to re-enable interrupts once has been called. In other words, using the low-level call is appropriate here because it will truly cause the system to sit in a loop, as desired, whereas would not.\n\nBeyond the examples above, you can also use FreeRTOS queues (which are thread-safe, unlike all containers in the C++ std library), mutexes, semaphores, task notifications, and other synchronization primitives, where able and where appropriate, to protect certain data which is shared between FreeRTOS tasks (threads), assuming you are running FreeRTOS.\n\nSee the list of these tools here: https://www.freertos.org/a00106.html, and in the left-hand navigation menus once you click on that link.\n‚Ä¢ None Add an atomic ( or really makes more sense as a function name for this, I think) demo using ARM-core CMSIS functions, or assembly, or whatever means necessary, to demonstrate writing a spin lock in STM32. I don't know how to do this yet so it will require finding the right function or operation to use. See here: https://en.wikipedia.org/wiki/Test-and-set#Pseudo-C_implementation_of_a_spin_lock: volatile int lock = 0; void critical() { // Spin lock: loop forever until we get the lock; we know the lock was // successfully obtained after exiting this while loop because the // test_and_set() function locks the lock and returns the previous lock // value. If the previous lock value was 1 then the lock was **already** // locked by another thread or process. Once the previous lock value // was 0, however, then it indicates the lock was **not** locked before we // locked it, but now it **is** locked because we locked it, indicating // we own the lock. while (test_and_set(&lock) == 1); critical section // only one process can be in this section at a time lock = 0; // release lock when finished with the critical section } Here is a spin lock implementation I did in C11 using types. It should work just fine for STM32 as well, and probably compiles to use the underlying exclusive / operations to store (write) and read (load), but I'd have to check that by looking at the assembly. Additionally, this implementation would need to be modified to add safety anti-deadlock mechanisms such as automatic deferral, timeout, and retry, to prevent deadlock. See my notes here: Add basic mutex (lock) and spin lock implementations in C11, C++11, AVR, and STM32\n‚Ä¢ My answer on this for AVR mcus/Arduino\n‚Ä¢ My answer on the general practice and demo of using atomic access guards, and my func which ensures atomic access withOUT turning interrupts off\n‚Ä¢ [my Q&A] Which variable types/sizes are atomic on STM32 microcontrollers?\n\nSee the References section of my question here: How to properly count timer overflows to convert a 32-bit high-resolution timer into a 64-bit high-resolution timer:"
    },
    {
        "link": "https://vivonomicon.com/2018/04/28/bare-metal-stm32-programming-part-4-intro-to-hardware-interrupts",
        "document": "In a previous entry in this tutorial series, I tried to walk through some basic steps for writing an example STM32 program which toggled an LED on and off when a button is pressed. But that program only checked the button‚Äôs status once every cycle of the ‚Äòmain‚Äô loop, and in a complex application each loop iteration could take a fairly long time. If a button press were very short and our application was busy for a long time, the program could miss the input.\n\nWhen you want to respond to input very quickly and consistently on a microcontroller, it is usually a good idea to use a ‚Äòhardware interrupt‚Äô to run some code when certain hardware events are detected. In this tutorial, we will look at the STM32‚Äôs ‚ÄòEXTI‚Äô interrupt lines, which can be set to trigger when the state of a GPIO pin changes.\n\nAnd once we have a simple ‚Äòbutton press‚Äô interrupt triggering, we can easily demonstrate a real-world use by extending it to listen for faster inputs such as ‚Äúrotary encoder‚Äù dials:\n\nThis type of dial ‚Äòclicks‚Äô in small steps when turned in either direction; they are nice tactile inputs, but it can be difficult to read them without hardware interrupts because of the large number of rapid pulses that they can generate when you twist them. So let‚Äôs get started!\n\nWhat Do ‚ÄòEXTI‚Äô and ‚ÄòNVIC‚Äô Mean?\n\nFirst, some background. We will use the ‚ÄòEXTI‚Äô peripheral to trigger a hardware interrupt from a GPIO input pin. ‚ÄòEXTI‚Äô stands for ‚ÄòEXTended Interrupt controller‚Äô, and its purpose is to extend the number of hardware interrupts available to us programmers. Basically, the chip‚Äôs ‚ÄúARM Cortex-M0‚Äù core is where these interrupts originate from, and the people designing the chips cannot control how those ARM interrupts are structured. I think that ST buys the ‚Äòcore‚Äô designs and builds around them ‚Äì as do other manufacturers like TI, NXP, Cypress, etc ‚Äì which would make sense considering the insane complexity of these systems.\n\nThe ARM ‚Äòhardware interrupts‚Äô peripheral included in the line of chips is described in Chapter 5 of the ARM Cortex-M0 technical reference manual, titled ‚ÄúNested Vector Interrupt Controller‚Äù, but you don‚Äôt need to read all of that. I just linked to it as a reference, and to explain why this internal ARM peripheral‚Äôs acronym is ‚ÄòNVIC‚Äô. The C methods that we will use later for enabling an NVIC interrupt are included in the CMSIS device header files that we included in the last post.\n\nSo, the STM32 EXTI peripherals take a small number of NVIC interrupts and assign several different ‚Äòextended interrupt events‚Äô to each one. Remember the ‚ÄòVector Table‚Äô that we wrote earlier? As I understand it, that defines which code should be run for each interrupt. And since the interrupts represent only one of several possible events, our NVIC ‚Äòinterrupt handler‚Äô function will need to check which EXTI event actually triggered the interrupt and act accordingly.\n\nThere are 32 EXTI lines on the line. The first 16 of them can be used to trigger hardware interrupts when changes are detected on any of the 16 GPIO pins associated with each GPIO bank. refers to pin #0, refers to pin #1, and so on. But the STM32 also has several different banks of GPIO pins ( , , , etc.), so there is a limitation that we can only use an interrupt for ‚ÄòPin #X‚Äô on one of those banks at a time. For example, we can have an interrupt on and at the same time, but not and since they have the same pin number.\n\nYou can see that in our vector table, there are only three NVIC interrupts dedicated to those 16 EXTI lines. can listen to pins 0 and 1, can listen to pins 2 and 3, and can listen to pins 4 through 15, inclusive.\n\nOkay, that was a lot of text. To review, these chips have core ‚ÄúNVIC‚Äù interrupts which need to be enabled in addition to the actual STM32 peripheral interrupts that we want to use. Our code will configure the STM32‚Äôs ‚ÄúEXTI‚Äù line to listen on a specific GPIO pin, and then we will enable the NVIC interrupt. I‚Äôll also go over writing a C method for the appropriate vector table entry.\n\nAnd while I primarily discuss the chip in this post, all of the C code for enabling and using these EXTI interrupts should also work on an if the appropriate device headers and compiler options are used. This tutorial code will build on the previous examples in this series without describing each file in full, so here is a Github repository with a full example project if you want to review the basic structure, or if I do a poor job of explaining where different lines of code should go.\n\nIt‚Äôs a good idea to set up the EXTI line to point to the correct GPIO pin (or signal) before actually turning the interrupt on. This is done with the ‚ÄòSYSCFG‚Äô (System Configuration) peripheral, which we need to turn on using an RCC register, just like the GPIOB peripheral:\n\nThe SYSCFG peripheral is in the ‚ÄòAPB2‚Äô clock domain, so we use the register to turn it on. To assign an EXTI line to a GPIO bank, we need to set four bits in one of four registers. They are described in Section 9.1 of the reference manual. maps a line to , maps a line to , and so on. Each pin uses four bits, so there are four contiguous registers for the 16 possible pins. The struct defined in the device header files treats them as a 4-element array of registers called instead of using , , etc. We can set the correct values using the macro that we defined last time in :\n\nOr if you prefer, you can be a bit more clear by using the macros defined in the device header files if you know what pin you want and don‚Äôt expect that to change ‚Äì this would be for pin :\n\nWith EXTI line 1 mapped to GPIO port B, we can set what type of inputs we want to listen for. This only requires three registers. Setting a bit in enables the interrupt for that EXTI line, setting a bit in configures an interrupt to trigger on a ‚Äòrising edge‚Äô transition from to , and setting a bit in configures an interrupt to trigger on a ‚Äòfalling edge‚Äô transition from to . These registers are described in section 11.3 of the reference manual.\n\nWith the button/dial/etc. connected to ground on one side and the pin configured with a pull-up resistor, we want to listen for a ‚Äòfalling edge‚Äô to detect button presses. A ‚Äòrising edge‚Äô would indicate that the button was just released from a pressed state:\n\nTo listen for a button on pin like in our previous example, we‚Äôll want to use the NVIC interrupt. Turning it on is simple ‚Äì we call one command to define the interrupt‚Äôs priority, and one to actually enable it. In more advanced ARM cores, the NVIC interrupts have more complicated priority and sub-priority settings, but the ARM Cortex-M0 only has four basic levels. ‚ÄòLevel 0‚Äô is the highest priority, and ‚ÄòLevel 3‚Äô is the lowest. With only one interrupt active, it doesn‚Äôt really matter what priority we use, so I‚Äôll go with 3:\n\nNote that if you change your value to something other than 0 or 1, you will also need to use a different NVIC interrupt. As I mentioned earlier, the interrupt only works for pins 0 and 1. For pins 2-3 you can use , and for pins 4-15 you can use .\n\nWith the NVIC interrupt enabled and the EXTI line configured to listen on pin , the chip will now jump to whatever memory address is specified under the vector table‚Äôs entry when our button is pressed. Earlier in this series of tutorials, we pointed all of our vector table‚Äôs entries to a ‚Äòdefault handler‚Äô which was nothing but an infinite loop. Jumping to that ‚Äòdefault handler‚Äô is practically an error, because it means that we have enabled an interrupt without defining an interrupt handler for it to use.\n\nTo run a C function when the interrupt triggers, we just need to define one with the same name as the vector table entry. That will override the ‚Äòdefault interrupt handler‚Äô link, because we used the keyword when defining those defaults in the vector table. I used separate interrupts files for this method ( / ), and added a simple function definition to the header file. Double-check your vector file and change the name if necessary:\n\nWhen the interrupt triggers, the microcontroller will set a status bit in the register to tell us which EXTI line was triggered. We can check that register to make sure that it was the button pin attached to which caused the interrupt, and then we need to clear the bit to allow new interrupts to trigger. Somewhat confusingly, we need to set the status bit to (not ) to clear it. So this is our mildly strange interrupt handler for a push-button input; the variable will be discussed in the next section:\n\nAs a final step, we should update our ‚Äòmain‚Äô files. I created a new file for defining includes and values which every file should have access to. It is included by every other header file in the project (in this case, and ). I moved the device header file includes and the macro definitions like from to , and added an variable:\n\nThe qualifier tells the compiler that the variable can change at any time. Sometimes the compiler will look at a block of code, decide that it will not change a variable‚Äôs value, and cut some corners using the assumption that the value will never change. But hardware interrupts can happen at more or less any time, so you should use the keyword to tell the compiler not to assume anything about variables which hardware interrupts can modify.\n\nAlso, if you use this project structure of ‚Äúglobal variables defined in a global header file‚Äù, you won‚Äôt be able to pre-initialize those variables unless they‚Äôre declared ‚Äì the compiler might complain about ‚Äòmultiple definitions‚Äô. But you can get around that by setting starting values at the beginning of your method. If that annoys you, a cleaner option is to use the keyword to access variables across files, but I want to keep things simple for now.\n\nNo matter how you decide to define global variables in your project, the entire main loop can be nothing but setting the LED pin according to the value:\n\nYou can also set the register directly in the interrupt handler, in which case the main loop could be completely empty. I just didn‚Äôt want to talk about hardware interrupts without mentioning the keyword, because ignoring that can lead to some frustrating bugs as you start to write more complex applications.\n\nAt this point, you should be able to upload your program and see the same thing as the last tutorial; the on-board LED toggles on and off when the external button is pressed:\n\nDon‚Äôt forget to in , and add to your Makefile. I did forget those steps initially, and the compiler didn‚Äôt raise any warnings or errors because the label was already weakly linked to the ‚Äòdefault interrupt handler‚Äô in our vector table. So the program compiled and uploaded, but nothing happened when I pressed the button because the chip jumped to the ‚Äòdefault handler‚Äô and stayed there. Compiling the project with the interrupt files fixed the problem, because the definition in was associated with the vector table label of the same name. In GDB, you can use the or command to view the chip‚Äôs current function stack and check where it is in your program.\n\nWith a single push-button working, let‚Äôs move on to a ‚Äúreal world‚Äù use of GPIO hardware interrupts: a ‚Äúrotary encoder‚Äù dial.\n\nThe term ‚ÄúRotary Encoder‚Äù can refer to a lot of different things, as Wikipedia will tell you. I am specifically talking about the sort described as ‚ÄòIncremental Rotary Encoders‚Äô on that page. They are simple devices which ‚Äòclick‚Äô both clockwise and counter-clockwise in small steps, and they usually have two data pins labeled and . When they are ‚Äòclicked‚Äô in one direction, the pin pulses just before the pin. In the other direction, the pin pulses just before the pin.\n\nIt is difficult to listen for this sort of input in a simple loop, because the pulses happen extremely quickly. It‚Äôs easy to miss a ‚Äòclick‚Äô in either direction, and you can also read the wrong direction if you miss the first pulse of a ‚Äòclick‚Äô but catch the second one. With a hardware interrupt, however, the chip can reliably run our interrupt code on every pulse and listen very accurately.\n\nThe concept behind the interrupt code is simple: with our microcontroller running at a speed in the range of megahertz, an interrupt on the first pulse should be able to finish running its interrupt handler code before the second pulse is triggered by the rotary encoder. So even if we only set an interrupt on one of the rotary encoder‚Äôs data pins, we can still determine the direction of the ‚Äòclick‚Äô by checking the state of the other data pin at the very beginning of the interrupt handler. If the other pin is already high, then the interrupt pin got the second pulse. If it is still low, then the interrupt pin got the first pulse. Since the direction of a ‚Äòclick‚Äô is indicated by which pin pulses first, that gives us our answer:\n\nThat interrupt handler code simple turns the LED on/off depending on the last direction that the dial was spun in, but you could also count a number up/down as an example.\n\nNote that it is good practice to do as little work as possible in hardware interrupt handlers; they should finish as quickly as possible so the chip can get back to what it was doing, and so that other interrupts can be processed quickly. If you want an interrupt to trigger complicated or long-running logic, one way to do that is to simply mark a variable (like ) inside of the interrupt, and then check that variable‚Äôs status in your main loop to decide whether or not to run the lengthy task.\n\nThe only remaining step is to define a macro for in the file, and set it up as a GPIO input pin with the pull-up enabled. (I continued using instead of defining a new so that I wouldn‚Äôt need to change the code much for these examples).\n\nOn the ‚ÄòNucleo‚Äô board, is marked . We can use the same GPIO register settings as before, and we don‚Äôt have to set up another interrupt:\n\nIt would have been nice to have a display count up and down as the dial is spun, but there is only one LED available on these ‚ÄòNucleo-32‚Äô boards and I want to keep things simple. So after uploading and running the project with this new interrupt handler, the onboard LED should turn on when the rotary encoder is spun in one direction, and off when it is spun in the other:\n\nAs you can see, hardware interrupts are a good way to respond to external inputs very quickly. And beyond inputs like buttons and dials, many interrupts can also be configured to trigger on internal events, such as ‚Äòtimer‚Äô peripherals which can have the chip perform actions on a schedule.\n\nAnd again, here is a Github repository with an example project for the code described here.\n\nI‚Äôm not sure what the next post will be about yet. I was thinking of looking at the hardware peripheral for a common communication protocol like I2C or SPI, but I might also look into using a ‚ÄòPWM‚Äô peripheral to adjust the brightness of the onboard LED. Or, I might go over the single-wire interface used by individually-addressable colored LEDs such as the ever-popular WS2812B. Those are lots of fun in all kinds of random projects."
    }
]