[
    {
        "link": "https://medium.com/@joao_vaz/template-meta-programming-in-c-17-primer-1b493a22d51",
        "document": "Note: This article is not for C++ novices but you can try anyway!\n\nAs C++ programmers, we know that templates are a powerful tool for creating generic code. They allow us to write functions and classes that can work with any type, as long as that type meets certain requirements.\n\nBut templates are not just a tool for creating generic code. They are also a powerful tool for creating highly optimized code that computes results at compile-time and can be tailored to specific use cases. In this article, we‚Äôll explore the power of templates in modern C++ (C++17), using basic TMP(template meta-programming) and see how they can be used to create highly performant and flexible code.\n\nThis article will use the facility std::type_traits , structure binding, variadic templates, constexpr and std::static_assert to show a complete use case of operations on a very basic implementation of a type list i.e. really just a dumb placeholder, which holds a list of arithmetic types with its corresponding values and that we will use its elements to compute the sum of all its containing values and count the number of even numbers in it.\n\nBefore we dive into the more advanced uses of templates, let‚Äôs review the basics. In C++, a template is a mechanism for creating code that works with multiple types. For example, consider the following template function:\n\nThis function takes a single argument of type , and returns the square of that value. The keyword specifies that is a type parameter while the says the function should be evaluated at compile time. Note that is stricly not necessary here but improves code readability and in some cases compiler overhead so it‚Äôs a good habit.\n\nWe can use this function with any type that supports the operator. For example, we can call to get the square of an integer, or to get the square of a floating-point value.\n\nNow in the spirit of TMP, as per the paragraph above, you should contrain your type so we can use the standard template meta-programming facility std::type_traits present in the header to check if the type is an arithmetic one i.e. integer or floating point. Here‚Äôs the improved version:\n\nNote the usage of here as one of your best friends when using TMP (concepts in C++20 go a step further). It enforces at compile type that the type corresponds logically to one‚Äôs expectations.\n\nIf we tried to pass a string to the function it would trigger something like static_assert failed due to requirement ‚Äòstd::is_arithmetic_v<const char *>‚Äô ‚ÄúT must be an arithmetic type‚Äù\n\n static_assert(std::is_arithmetic_v<T>, ‚ÄúT must be an arithmetic type‚Äù);\n\nHere‚Äôs a complete listing of the square example program:\n\nOk, we shall go to the use case now , let‚Äôs declare a type list that uses variadic template arguments:\n\nThe is just a dumb placeholder of our types and associated values. We will use the std::integral_constant type from the <type_traits> header in the instead of normal integers or floats since we‚Äôre counting on types that have a ‚Äúvalue‚Äù attribute associated with it. wraps a static constant of specified type, something akin to the listing below:\n\nHere‚Äôs our type_list with with our values:\n\nWe aliased it to to make it easier to use in our sample code.\n\nShortly we will see a basic implementation without type-checking of a function that will sum-up all the arguments in a typelist but before that we will see the example used in cppreference.com in which we can visualize an expansion of the parameter pack using folding (C++17 feature) with a simple function that does a logical bolean evaluation of its types and returns true if all values are true, false otherwise:\n\nThis example uses unary left folding, but it‚Äôs also supported unary right folding, binary left and right folding. Please see link above for a proper explanation.\n\nWe can now try to visualize how a basic sum function that sums its arguments would look like:\n\nNow we can see the implementation of our sum for our type_list which is very similar:\n\nThis uses binary folding of the parameter pack in which the compiler does the typing for us. Another great thing with folding is that it works with the operator so we make sure the type_list is not empty, although in our case the code would work just fine with an empty list and the sum would return 0.\n\nRight the implementation of the function is just slightly more involved as we just want to count the even numbers:\n\nWe have a function that returns if the value of its type it‚Äôs even and within our function we call it on each argument taking advantage of folding.\n\nWe will also need a function that will return the arguments of the typelist as a tuple which is a fixed-size collection of heterogeneous values for us to extract the values later on.\n\nWe will implement the final two functions that will operate on our type_list, one will return the front of the typelist , the other the back!\n\nThe function will only get the first type . The trick is to take advantage how variadic templates work , so that we have 2 typename parameters, first a ‚Äúnormal‚Äù with will get the first type of the type_list and then we use a parameter pack that will be used to ‚Äúpack‚Äù the remaining types of the type_list. The function uses the same two typenames and then works recursively until there‚Äôs no type present in the Args parameter pack so we will only have the {} corresponding to the first template argument . For a step by step analysis of the call see below\n\nThere‚Äôs a lot of recursion in TMP so please take your time to understand how does it work as in the link above or here.\n\nNow we just need the full listing of what we discussed, the only thing to add is that we take advantage of structure binding and std::tuples in the sample code to extract the types from our type_list, which is a C++17 feature in which we can assign to several variables at the same time extracting the values of arrays, data members, tuples, etc. See the link to see what is allowed or not. Note: no optional values, all values need to be binded and they need to be unique identifiers too.\n\nThis calls our function that will return a tuple with the types of our typelist, which in turn will bind to the correspoding variables.\n\nTo better understand this here‚Äôs a verbatim copy of the example of structure binding from cppreference.com with a tuple with their explanation\n\nFull listing of the working source code we discussed in the article\n\nI hope you enjoyed the article! Any criticism good or bad is welcome! I should publish some primers on low-level concurrency and C++ 20 concepts as my next articles! Stay tuned!\n\nNote 2: For really understanding typelists see Modern C++ Design book by Alexandrescu or check his old Loki library https://github.com/snaewe/loki-lib\n\nC++ logo from <a href=‚Äùhttps://www.flaticon.com/free-icons/programmer\" title=‚Äùprogrammer icons‚Äù>Programmer icons created by Freepik ‚Äî Flaticon</a>"
    },
    {
        "link": "https://stackoverflow.com/questions/112277/best-introduction-to-c-template-metaprogramming",
        "document": "The best introductions I've found so far are chapter 10, \"Static Metaprogramming in C++\" from Generative Programming, Methods, Tools, and Applications by Krzysztof Czarnecki and Ulrich W. Eisenecker, ISBN-13: 9780201309775; and chapter 17, \"Metaprograms\" of C++ Templates: The Complete Guide by David Vandevoorder and Nicolai M. Josuttis, ISBN-13: 9780201734843.\n\nTodd Veldhuizen has an excellent tutorial here.\n\nA good resource for C++ programming in general is Modern C++ Design by Andrei Alexandrescu, ISBN-13: 9780201704310. This book mixes a bit of metaprogramming with other template techniques. For metaprogramming in particular, see sections 2.1 \"Compile-Time Assertions\", 2.4 \"Mapping Integral Constants to Types\", 2.6 \"Type Selection\", 2.7 \"Detecting Convertibility and Inheritance at Compile Time\", 2.9 \" and \" and 2.10 \"Type Traits\".\n\nThe best intermediate/advanced resource I've found is C++ Template Metaprogramming by David Abrahams and Aleksey Gurtovoy, ISBN-13: 9780321227256\n\nIf you'd prefer just one book, get C++ Templates: The Complete Guide since it is also the definitive reference for templates in general."
    },
    {
        "link": "https://geeksforgeeks.org/template-metaprogramming-in-c",
        "document": "Predict the output of following C++ program.\n\n\n\nThe program calculates ‚Äú2 raise to the power 8 (or 2^8)‚Äù. In fact, the structure funStruct can be used to calculate 2^n for any known n (or constant n). The special thing about above program is: calculation is done at compile time. So, it is compiler that calculates 2^8. To understand how compiler does this, let us consider the following facts about templates and enums:\n\n1) We can pass nontype parameters (parameters that are not data types) to class/function templates. \n\n2) Like other const expressions, values of enumeration constants are evaluated at compile time. \n\n3) When compiler sees a new argument to a template, compiler creates a new instance of the template.\n\nLet us take a closer look at the original program. When compiler sees funStruct<8>::val, it tries to create an instance of funStruct with parameter as 8, it turns out that funStruct<7> must also be created as enumeration constant val must be evaluated at compile time. For funStruct<7>, compiler need funStruct<6> and so on. Finally, compiler uses funStruct<1>::val and compile time recursion terminates. So, using templates, we can write programs that do computation at compile time, such programs are called template metaprograms. Template metaprogramming is in fact Turing-complete, meaning that any computation expressible by a computer program can be computed, in some form, by a template metaprogram. Template Metaprogramming is generally not used in practical programs, it is an interesting concept though."
    },
    {
        "link": "https://reddit.com/r/cpp/comments/v2h7zw/when_to_use_template_meta_programming",
        "document": "I have 10 years of professionnal C++ experience and I just never use templates. In a way it's probably due to the fact that I don't know template programmin very well, which kind of create a loop. The main reason is that I never feel the need to use templates hence my question, when should it be used ?\n\nI know that if I were to develop a kind of container I would use them, but I pretty much never write librairies, I'm always on the \"higher level\" side of applications, so not developping game engine, or reimplementing algorithm or data structures...\n\nAre there more legitimate use of templates than containers and data stuctures ?"
    },
    {
        "link": "https://blog.nelhage.com/post/advent-of-templates",
        "document": "This December, the imp of the perverse struck me, and I decided to see how many days of Advent of Code I could do purely in compile-time C++ metaprogramming.\n\nAs of this writing, I‚Äôve done two days, and I‚Äôm not sure I‚Äôll make it any further. However, that‚Äôs one more day than I planned to do as of yesterday, which is in turn further than I thought I‚Äôd make it after my first attempt. So we‚Äôll see how it goes.\n\nThat said, Day 1 was interesting enough to post a short writeup. You can find the code on GitHub, but I‚Äôll also do an annotated walkthrough of day 1!\n\nWe‚Äôll start by defining a basic compile-time type, and we‚Äôll also use a in order to lift values into the type system I decided that we‚Äôd eschew , since that makes things too easy, but permit ourselves to use basic arithmetic and compile-time integers and booleans.\n\nIdeally, I would read input using the new C++23 directive, for maximum purity; but as of this writing it seems hard to find a compiler that supports one. Thus, I fell back to a polyfill using . We can run , and then include our input using and a variadic template. We‚Äôll also use a bit of preprocessor trickery to pass the input file in using a compiler flag.\n\nC++ template metaprogramming is very much a functional language, and so it‚Äôs natural that the main operation we‚Äôll define over lists will be . This is a relatively standard construction:\n\nWe‚Äôll introduce a few more helpers, and then we‚Äôre almost ready for Part 1. We‚Äôll add a sentinel, a basic conditional, and an function that takes the first non-nil of its arguments:\n\nIf you‚Äôre not doing Advent of Code, a quick refresher for the problem statement: For each line in the input file, we need to find the first and last digit in that line, and then concatenate them into a two-digit number (the ‚Äúcalibration number‚Äù), and output the sum of every calibration number in the file.\n\nWe‚Äôll implement this using a single over the input for efficiency. As we go, we‚Äôll track state consistent of a tuple of :\n\nThe fold function advances the state using some simple rules:\n‚Ä¢ If the character is a newline, we compute this line‚Äôs calibration value, add it in to the accumulator, and reset the per-line state.\n‚Ä¢ If the character is a digit, we update the ‚Äúlast digit‚Äù to this digit unconditionally\n‚Ä¢ And also update the first digit, if we haven‚Äôt already seen a digit this line.\n\nThese are all fairly straightforward applications of existing helpers:\n\nOne bit of trickiness is that, in order to make the outer lazy, we evaluate on its result, instead of on its arguments. This results in the compiler evaluating whichever of the consequent or the alternate is actually selected.\n\nTrying it out üîóÔ∏é\n\nFor convenience, we‚Äôll allow a tiny bit of runtime behavior to print the result:\n\nArmed with that, we can now verify the initial test case included in the problem body:\n\nBut if we try the real input, we run into issues:\n\nThe basic problem here is that our needs to recurse for each character in the input, and the provided test case is over 20,000 characters long! We can try increasing , per the provided suggestion; On my machine we can make the program compile with a large-enough value, but clang gives scary warnings about stack capacity and is very slow ‚Äì compiling takes 90s or more.\n\nThe problem here is fairly fundamental; recursive template expansion is basically the game in town for template metaprogramming. However, it turns out that there is one option we have up our sleeve.\n\nis a variadic template, which means we can manipulate its entire contents as a C++ parameter pack. As long as we can keep the arguments as a parameter pack, we can use relatively fast paths inside the compiler, and work much more efficiently.\n\nPoring over the above cppreference page, we notice that C++17 added ‚Äúfold expressions‚Äù ‚Äî a way of turning a parameter pack into an expression that folds a user-chosen operator over the pack! This is suspiciously similar to what we‚Äôre trying to do, but it operates on the value level, using value-level operators.\n\nHowever, it turns out that with some judicious use of , , and a wrapper struct, this poses no problem ‚Äî we can construct types that perform our type-level computation in the process of typechecking the fold expression.\n\nThe compiler will still have to deal with a massively nested expression, but in my testing that‚Äôs much more efficient than a 20,000-deep template:\n\nThe struct translates our type-level function into one that can be evaluated via an expression-level operator. The expression will evaluate to a value of type . Once we have that, we expand the list elements into a fold expression using that translation, and use to access the type of the output. At no point will any code actually be emitted or ‚Äî horrors! ‚Äî evaluated.\n\nAnd this works! With this implementation, the part 1 solution above compiles iin about a second on my M1 Air, and gives the correct answer!\n\nFor part 2, digits may now be spelled out ‚Äì has a calibration value of ‚Äú73.‚Äù\n\nWe‚Äôll start by introducing a short abstraction. Handling newlines in our fold worked, but was a bit annoying. We can write a helper that abstracts the splitting on newlines and lets us worry about individual lines.\n\nThe interface will take the form of a over lines, instead of, say, materializing a list-of-lists; keeping our processing streaming in this fashion is very important for performance. The helper is, itself, a fairly straightforward application of :\n\nNow that we have that, we need to compute calibration values within a single line‚Ä¶\n\nWe‚Äôre going to once again implement calibration using a single over each line.\n\nIn order to match each of the possible digits, we‚Äôll maintain a finite-state-machine matcher, and write transition rules for each <state, character> pair ‚Äî this is essentially the DFA that some regular expression implementations would produce under the hood. We‚Äôll name states by the ‚Äúrelevant‚Äù substring we‚Äôve seen so far; so, for instance, means we just saw ‚Äúseve‚Äù; in this case, if we encounter an then we‚Äôve found the digit .\n\nNote that many digits contain letters which can start another digit, and we‚Äôll need to handle these in our transitions; for instance, if we‚Äôre in state and we see an , we need to move into because we might be looking at the string ‚Äúseveight‚Äù and need to handle the . Fortunately, no two digits have more-complex overlaps, so the state machine remains fairly simple.\n\nWe‚Äôll start with state definitions, using to mean ‚Äúno relevant prefix‚Äù:\n\nAnd we can define the transition rules. We‚Äôll make liberal use of wildcards, and rely on relative specificity of the partial specializations to pick the correct rule.\n\nIf no other rule matches, we go back to :\n\nAnd if we see the first letter for any digit ‚Äî and no more-specific rule matched ‚Äî we can move directly into that state.\n\nThen we define the transitions within and between rules. Most of these are straightforward ‚Äî e.g. , but we have to be careful of the ones where we might jump ‚Äúmidway‚Äù into matching another digit.\n\nWe haven‚Äôt yet defined when we ‚Äúmatch‚Äù a rule, or what to do when we do; It turns out, for this problem, that defining ‚Äúsuccessful match‚Äù as a separate function from our state transition makes both functions much simpler. If you like to be technical, we‚Äôre essentially implementing what EEs would call a Mealy state machine for this matcher.\n\nThe function will will have a similar signature to ‚Äî ‚Äì and tells us which digit (if any) matched at any particular position:\n\n(We could replace the last 10 specializations with a conditional inside the primary definition, but I find this version somewhat more straightforward, if a bit verbose).\n\nWith these types in place, we can now do a very similar fold as in part 1 to compute the calibration value for a single line. Compared to that one, we no longer need to track the overall accumulator ‚Äî we‚Äôll use to push that to an outer loop ‚Äî but we do need to keep the matcher state, and so our state class looks very similar:\n\nTo advance one element, we compute the output state, and the matched digit (if any). We‚Äôll also use some of our helpers to simplify the ‚Äúfirst / last seen digit‚Äù computation:\n\nWith the fold function in place, computing calibration values is easy:\n\nWe can even write some quick test cases ‚Äî C++ template metaprogramming has excellent support for in-line tests.\n\nPutting it all together üîóÔ∏é\n\nThe fold over lines is a simple sum of calibration values ‚Äî almost trivial, at this point.\n\nIt works! And, on my laptop, it‚Äôs ‚Äúonly‚Äù ~1.5s to compile!\n\nI‚Äôve done a bit of C++ template metaprogramming here and there in the past ‚Äî for instance, I wrote a simple x86 assembler for C++, once ‚Äî but this was my first really encounter with C++17 TMP and with truly going down the deep end.\n\nAnd, I‚Äôve heard this sentiment before, but after working through this problem ‚Ä¶ honestly I have to admit that modern C++ templates are a pretty passable functional programming language, even with some nice features! And I was pleasantly surprised to discover the fold-expression trick, which even allows for relatively-efficient list processing.\n\nI‚Äôm ‚Ä¶ still not sure how many more days I will do, or how much more C++ I will have cause to write, but I ended up quite enjoying the exercise!"
    },
    {
        "link": "https://en.cppreference.com/w/cpp/types/is_pointer",
        "document": "Checks whether is a pointer to object or function (including pointer to void, but excluding pointer to member) or a cv-qualified version thereof. Provides the member constant which is equal to true, if is an object/function pointer type. Otherwise, is equal to false.\n\nIf the program adds specializations for or , the behavior is undefined.\n\nmain A m f A mem_data_ptr A A mem_fun_ptr A static_assert std A std A // same thing as above, but in C++17! std A // same as above, using inherited operator bool std A std A // same as above, using inherited operator() std A std A std A std A std decltype mem_data_ptr std decltype mem_fun_ptr std std std std std std std"
    },
    {
        "link": "https://stackoverflow.com/questions/49878757/c17-how-to-write-is-pointer-pointer-generic-lambda",
        "document": "How would one approach implementing this generic lambda?\n\nThanks to @luk32. His solution (aka \"Answer\") I have taken to the wandbox, and made it a bit more resilient. Code is here.\n\nThe solution is this lambda:\n\nFor the thirsty of knowledge here is the article explaining the c++17 generic lambda issue with auto args. Hint: that is why I use std::decay above."
    },
    {
        "link": "https://sppcontests.org/lang_docs/cppdocs/en/cpp/types/is_pointer.html",
        "document": "Checks whether is a pointer to object or a pointer to function (but not a pointer to member/member function). Provides the member constant which is equal to true, if is a object/function pointer type. Otherwise, is equal to false.\n\nchecks if a type is a pointer to an non-static member function or object \n\n checks if a type is a pointer to a non-static member object \n\n checks if a type is a pointer to a non-static member function \n\n checks if a type is an array type"
    },
    {
        "link": "https://stackoverflow.com/questions/40845500/c-curious-case-where-template-is-pointer-seems-to-fails",
        "document": "I am trying to make the project for BinaryTree Operations, the following are the class prototype with the code in which I am having the problem.\n\nBinaryTreeOperations Class inherit BinaryTree Class and its prototype is defined in BinaryTreeOperations.h\n\nWhile the constructors are defined in BinaryTreeOperations.cpp class\n\nAnd now the error which g++ is throwing is\n\nHere comes the issue. I have already defined isPointer structure to check whether the given template is pointer or not. But it seems, in spite of T being std::string g++ is going in condition.\n\nI don't understand what am I doing wrong? Any sort of guidance will be deeply appreciated."
    },
    {
        "link": "https://saco-evaluator.org.za/docs/cppreference/en/cpp/types/is_pointer.html",
        "document": "Checks whether is a pointer to object or a pointer to function (but not a pointer to member/member function). Provides the member constant which is equal to true, if is a object/function pointer type. Otherwise, is equal to false.\n\nchecks if a type is a pointer to a non-static member function or object \n\n checks if a type is a pointer to a non-static member object \n\n checks if a type is a pointer to a non-static member function \n\n checks if a type is an array type"
    }
]