[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.openfiledialog?view=windowsdesktop-9.0",
        "document": "The following code example creates an OpenFileDialog, sets several properties to define the file extension filter and dialog behavior, and displays the dialog box using the CommonDialog.ShowDialog method. The example requires a form with a Button placed on it and a reference to the System.IO namespace added to it.\n\nThis class allows you to check whether a file exists and to open it. The ShowReadOnly property determines whether a read-only check box appears in the dialog box. The ReadOnlyChecked property indicates whether the read-only check box is checked.\n\nMost of the core functionality for this class is found in the FileDialog class.\n\nOn a right-to-left operating system, setting the containing form's RightToLeft property to RightToLeft.Yes localizes the dialog's File Name, Open, and Cancel buttons. If the property is not set to RightToLeft.Yes, English text is used instead.\n\nIf you want to give the user the ability to select a folder instead of a file, use FolderBrowserDialog instead.\n\nInitializes an instance of the OpenFileDialog class. Gets or sets a value indicating whether the dialog box automatically adds an extension to a file name if the user omits the extension. (Inherited from FileDialog) Gets or sets a value indicating whether the dialog box adds the file being opened or saved to the recent list. (Inherited from FileDialog) Gets or sets a value indicating whether this FileDialog instance should automatically upgrade appearance and behavior when running on Windows Vista. (Inherited from FileDialog) Gets a value indicating whether the component can raise an event. (Inherited from Component) Gets or sets a value indicating whether the dialog box displays a warning if the user specifies a file name that does not exist. Gets or sets a value indicating whether the dialog box displays a warning if the user specifies a path that does not exist. (Inherited from FileDialog) Gets or sets the GUID to associate with this dialog state. Typically, state such as the last visited folder and the position and size of the dialog is persisted based on the name of the executable file. By specifying a GUID, an application can have different persisted states for different versions of the dialog within the same application (for example, an import dialog and an open dialog). This functionality is not available if an application is not using visual styles or if AutoUpgradeEnabled is set to . (Inherited from FileDialog) Gets the IContainer that contains the Component. (Inherited from Component) Gets the custom places collection for this FileDialog instance. (Inherited from FileDialog) Gets or sets the default file name extension. (Inherited from FileDialog) Gets or sets a value indicating whether the dialog box returns the location of the file referenced by the shortcut or whether it returns the location of the shortcut (.lnk). (Inherited from FileDialog) Gets a value that indicates whether the Component is currently in design mode. (Inherited from Component) Gets the list of event handlers that are attached to this Component. (Inherited from Component) Gets or sets a string containing the file name selected in the file dialog box. (Inherited from FileDialog) Gets the file names of all selected files in the dialog box. (Inherited from FileDialog) Gets or sets the current file name filter string, which determines the choices that appear in the \"Save as file type\" or \"Files of type\" box in the dialog box. (Inherited from FileDialog) Gets or sets the index of the filter currently selected in the file dialog box. (Inherited from FileDialog) Gets or sets the initial directory displayed by the file dialog box. (Inherited from FileDialog) Gets the Win32 instance handle for the application. (Inherited from FileDialog) Gets or sets a value indicating whether the dialog box allows multiple files to be selected. Gets or sets a value indicating whether the OK button of the dialog box is disabled until the user navigates the view or edits the filename (if applicable). (Inherited from FileDialog) Gets values to initialize the FileDialog. (Inherited from FileDialog) Gets or sets a value indicating whether the read-only check box is selected. Gets or sets a value indicating whether the dialog box restores the directory to the previously selected directory before closing. (Inherited from FileDialog) Gets the file name and extension for the file selected in the dialog box. The file name does not include the path. Gets an array of file names and extensions for all the selected files in the dialog box. The file names do not include the path. Gets or sets a value indicating whether the dialog box allows selection of read-only files. Gets or sets a value indicating whether the Help button is displayed in the file dialog box. (Inherited from FileDialog) Gets or sets a value indicating whether the dialog box displays hidden and system files. (Inherited from FileDialog) Gets or sets a value indicating whether the items shown by default in the view's navigation pane are shown. (Inherited from FileDialog) Gets or sets a value indicating whether the dialog box shows a preview for selected files. Gets or sets a value indicating whether the dialog box contains a read-only check box. Gets or sets the ISite of the Component. (Inherited from Component) Gets or sets whether the dialog box supports displaying and saving files that have multiple file name extensions. (Inherited from FileDialog) Gets or sets an object that contains data about the control. (Inherited from CommonDialog) Gets or sets the file dialog box title. (Inherited from FileDialog) Gets or sets a value indicating whether the dialog box accepts only valid Win32 file names. (Inherited from FileDialog) Creates an object that contains all the relevant information required to generate a proxy used to communicate with a remote object. (Inherited from MarshalByRefObject) Releases all resources used by the Component. (Inherited from Component) Releases the unmanaged resources used by the Component and optionally releases the managed resources. (Inherited from Component) Determines whether the specified object is equal to the current object. (Inherited from Object) Retrieves the current lifetime service object that controls the lifetime policy for this instance. (Inherited from MarshalByRefObject) Returns an object that represents a service provided by the Component or by its Container. (Inherited from Component) Gets the Type of the current instance. (Inherited from Object) Defines the common dialog box hook procedure that is overridden to add specific functionality to the file dialog box. (Inherited from FileDialog) Obtains a lifetime service object to control the lifetime policy for this instance. (Inherited from MarshalByRefObject) Opens the file selected by the user, with read-only permission. The file is specified by the FileName property. Defines the owner window procedure that is overridden to add specific functionality to a common dialog box. (Inherited from CommonDialog) Resets all properties to their default values. Runs a common dialog box with the specified owner. (Inherited from CommonDialog) Provides a string version of this object. (Inherited from FileDialog) Occurs when the component is disposed by a call to the Dispose() method. (Inherited from Component) Occurs when the user clicks on the Open or Save button on a file dialog box. (Inherited from FileDialog) Occurs when the user clicks the Help button on a common dialog box. (Inherited from CommonDialog)\n• How to: Read Text from a File"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.filedialog?view=windowsdesktop-9.0",
        "document": "The following code example uses the OpenFileDialog implementation of FileDialog and illustrates creating, setting of properties, and showing the dialog box. The example uses the ShowDialog method to display the dialog box and return the DialogResult. The example requires a form with a Button placed on it and the System.IO namespace added to it.\n\nFileDialog is an abstract class that contains common behavior for the OpenFileDialog and SaveFileDialog classes. It is not intended to be used directly but contains common behavior for those two classes. You cannot create an instance of FileDialog. Although the class is declared public, you cannot inherit from it, as it contains internal abstract methods. To create a dialog box to select or save a file, use OpenFileDialog or SaveFileDialog.\n\nFileDialog is a modal dialog box; therefore, when shown, it blocks the rest of the application until the user has chosen a file. When a dialog box is displayed modally, no input (keyboard or mouse click) can occur except to objects on the dialog box. The program must hide or close the dialog box (usually in response to some user action) before input to the calling program can occur.\n\nIf you want to enable users to select a folder instead of a file, use the FolderBrowserDialog.\n\nDepending upon the type of application, how data associated with the application is stored, and the reason for accessing the file system, there are many possible ways in which you can create a directory path. The following table shows the techniques for creating paths dynamically.\n\nNotice that a full path may be built up using one or more of the described techniques. For example, the GetFolderPath method might be used to obtain the path to the MyDocuments folder, then an application setting may be used to add a relative subdirectory portion.\n\nThe System.IO.Path class contains static members to assist in manipulating absolute and relative path strings, whereas the System.IO.File and System.IO.Directory classes have static members that actually manipulate files and directories, respectively.\n\nGets or sets a value indicating whether the dialog box automatically adds an extension to a file name if the user omits the extension. Gets or sets a value indicating whether the dialog box adds the file being opened or saved to the recent list. Gets or sets a value indicating whether this FileDialog instance should automatically upgrade appearance and behavior when running on Windows Vista. Gets a value indicating whether the component can raise an event. (Inherited from Component) Gets or sets a value indicating whether the dialog box displays a warning if the user specifies a file name that does not exist. Gets or sets a value indicating whether the dialog box displays a warning if the user specifies a path that does not exist. Gets or sets the GUID to associate with this dialog state. Typically, state such as the last visited folder and the position and size of the dialog is persisted based on the name of the executable file. By specifying a GUID, an application can have different persisted states for different versions of the dialog within the same application (for example, an import dialog and an open dialog). This functionality is not available if an application is not using visual styles or if AutoUpgradeEnabled is set to . Gets the IContainer that contains the Component. (Inherited from Component) Gets the custom places collection for this FileDialog instance. Gets or sets the default file name extension. Gets or sets a value indicating whether the dialog box returns the location of the file referenced by the shortcut or whether it returns the location of the shortcut (.lnk). Gets a value that indicates whether the Component is currently in design mode. (Inherited from Component) Gets the list of event handlers that are attached to this Component. (Inherited from Component) Gets or sets a string containing the file name selected in the file dialog box. Gets the file names of all selected files in the dialog box. Gets or sets the current file name filter string, which determines the choices that appear in the \"Save as file type\" or \"Files of type\" box in the dialog box. Gets or sets the index of the filter currently selected in the file dialog box. Gets or sets the initial directory displayed by the file dialog box. Gets the Win32 instance handle for the application. Gets or sets a value indicating whether the OK button of the dialog box is disabled until the user navigates the view or edits the filename (if applicable). Gets values to initialize the FileDialog. Gets or sets a value indicating whether the dialog box restores the directory to the previously selected directory before closing. Gets or sets a value indicating whether the Help button is displayed in the file dialog box. Gets or sets a value indicating whether the dialog box displays hidden and system files. Gets or sets a value indicating whether the items shown by default in the view's navigation pane are shown. Gets or sets the ISite of the Component. (Inherited from Component) Gets or sets whether the dialog box supports displaying and saving files that have multiple file name extensions. Gets or sets an object that contains data about the control. (Inherited from CommonDialog) Gets or sets the file dialog box title. Gets or sets a value indicating whether the dialog box accepts only valid Win32 file names. Creates an object that contains all the relevant information required to generate a proxy used to communicate with a remote object. (Inherited from MarshalByRefObject) Releases all resources used by the Component. (Inherited from Component) Releases the unmanaged resources used by the Component and optionally releases the managed resources. (Inherited from Component) Determines whether the specified object is equal to the current object. (Inherited from Object) Retrieves the current lifetime service object that controls the lifetime policy for this instance. (Inherited from MarshalByRefObject) Returns an object that represents a service provided by the Component or by its Container. (Inherited from Component) Gets the Type of the current instance. (Inherited from Object) Defines the common dialog box hook procedure that is overridden to add specific functionality to the file dialog box. Obtains a lifetime service object to control the lifetime policy for this instance. (Inherited from MarshalByRefObject) Defines the owner window procedure that is overridden to add specific functionality to a common dialog box. (Inherited from CommonDialog) Resets all properties to their default values. Runs a common dialog box with the specified owner. (Inherited from CommonDialog) Provides a string version of this object. Occurs when the component is disposed by a call to the Dispose() method. (Inherited from Component) Occurs when the user clicks on the Open or Save button on a file dialog box. Occurs when the user clicks the Help button on a common dialog box. (Inherited from CommonDialog)"
    },
    {
        "link": "https://stackoverflow.com/questions/63393939/how-to-get-save-file-dialog-as-a-control-in-windows-forms",
        "document": "I don't think you can get SaveFileDialog as a control, but there is a way you can access the \"Save As\" window and access the informations you want.\n\nUsing hwnd - window handle. OR handle to a window.\n\nHere is how you can get the window, if your save file dialog is at the front, you can use:\n\nFurther, you can go inside child windows and access the information like FileName, Save button and so on...\n\nFor ex, if you want to access Save button, add following in existing\n\nThe Class name of Save button would be \"Button\"\n\nAnd you can get the handle to this button using following:\n\nHope this will help!!"
    },
    {
        "link": "https://stackoverflow.com/questions/50555219/how-to-use-openfiledialog-to-open-any-file-as-text-in-c",
        "document": "What you are doing at the moment is starting a with the argument , calling on the process and setting this as text in the TextBox. If the path was valid, the result would probably be something like \"System.Diagnostics.Process\". But since you use as a path, your application probably crashes with a file not found error.\n\nTo get the selected file of an , use . (See the docs here)\n\nWhat I think you actually want to do, is read from the file and write its contents as text to the TextBox. To do this, you need a , like so:\n\nThis way, you open the file with the StreamReader, read its contents and then assign them to the text box.\n\nThe statement is there because a needs to be disposed of after you're done with it so that the file is no longer in use and all resources are released. The using statement does this for you automatically."
    },
    {
        "link": "https://docs.telerik.com/devtools/winforms/controls/file-dialogs/overview",
        "document": "Telerik UI for WinForms features the three most commonly used file and folder manipulation dialogs — Open File Dialog, Save File Dialog and Open Folder Dialog, all of which are fully themable delivering consistent look and feel across the application. They can come really handy if you are looking for a more appealing UI and want to replace the standard MS file dialogs with a modern design and user experience.\n\nThe FileDialogs is part of Telerik UI for WinForms, a professional grade UI library with 160+ components for building modern and feature-rich applications. To try it out sign up for a free 30-day trial.\n\nHere are a few of the controls' main features:\n• None Easy Navigation: The dialogs allow you to easily browse through your file system either through the tree-view-like navigation pane or the breadcrumb/path pane. A history of the visited folders is kept so that you can seamlessly jump back and forth between folders.\n• None Search: The out-of-the-box search functionality allows you to quickly find just the files and folders you're looking for by using the Windows Search index when available. It is supported with .NET 4.0 target framework or higher.\n• None Customizable Layouts: The controls also provide you with an API to set an initial directory, specify custom folders to be displayed top-most in the navigation pane and switch between different view modes (tiles, small icons, large icons, etc.).\n• None Variety of Themes: You can persist the appearance throughout your application by applying any of the predefined themes provided by the UI for WinForms suite to your dialogs.\n• None Keyboard Navigation Support: You can easily navigate through the tree-view-like navigation pane, the breadcrumb/path pane and the files in all layouts by just pressing the arrow keys on your keyboard.\n• None Windows File System Synchronization: The dialogs provide seemless synchronization with the Windows File System. Adding, renaming or deleting operations on files are reflected in the dialogs instantly.\n• None New Folder Functionality: You can add a new folder in all dialogs with the New Folder button.\n• None Context Menu: The dialogs use the well-known Windows context menu.\n• None Editing: The controls provide file and folder names editing via the F2 key or mouse click.\n• None Drive/Directory Filtering: You can filter all drives and directories with the DirectoryRequesting event.\n• None Environment variables: The dialogs support the usage of all system and user-defined environment variables.\n• None Network Locations: The controls allow you to display network locations by setting the ShowNetworkLocations property.\n\nThe file dialogs also support many other features of the native Windows file dialogs.\n• Get Started with the Telerik UI for WinForms FileDialogs\n• Getting Started with Telerik UI for WinForms Components\n• What’s New in Telerik UI for WinForms"
    },
    {
        "link": "https://stackoverflow.com/questions/217902/reading-writing-an-ini-file",
        "document": "Delphi has the TIniFile component and I want to know if there is anything similar for C#?\n\nIs there any class in the .NET framework that can read/write standard .ini files:\n\nFirstly, read this MSDN blog post on the limitations of INI files. If it suits your needs, read on. This is a concise implementation I wrote, utilising the original Windows P/Invoke, so it is supported by all versions of Windows with .NET installed, (i.e. Windows 98 - Windows 11). I hereby release it into the public domain - you're free to use it commercially without attribution. Add a new class called to your project: using System.IO; using System.Reflection; using System.Runtime.InteropServices; using System.Text; // Change this to match your program's normal namespace namespace MyProg { class IniFile // revision 11 { string Path; string EXE = Assembly.GetExecutingAssembly().GetName().Name; [DllImport(\"kernel32\", CharSet = CharSet.Unicode)] static extern long WritePrivateProfileString(string Section, string Key, string Value, string FilePath); [DllImport(\"kernel32\", CharSet = CharSet.Unicode)] static extern int GetPrivateProfileString(string Section, string Key, string Default, StringBuilder RetVal, int Size, string FilePath); public IniFile(string IniPath = null) { Path = new FileInfo(IniPath ?? EXE + \".ini\").FullName; } public string Read(string Key, string Section = null) { var RetVal = new StringBuilder(255); GetPrivateProfileString(Section ?? EXE, Key, \"\", RetVal, 255, Path); return RetVal.ToString(); } public void Write(string Key, string Value, string Section = null) { WritePrivateProfileString(Section ?? EXE, Key, Value, Path); } public void DeleteKey(string Key, string Section = null) { Write(Key, null, Section ?? EXE); } public void DeleteSection(string Section = null) { Write(null, null, Section ?? EXE); } public bool KeyExists(string Key, string Section = null) { return Read(Key, Section).Length > 0; } } } How to use it Open the INI file in one of the 3 following ways: // Creates or loads an INI file in the same directory as your executable // named EXE.ini (where EXE is the name of your executable) var MyIni = new IniFile(); // Or specify a specific name in the current dir var MyIni = new IniFile(\"Settings.ini\"); // Or specify a specific name in a specific dir var MyIni = new IniFile(@\"C:\\Settings.ini\"); You can write some values like so: To create a file like this: To read the values out of the INI file: To create a file like this: You can also check for the existence of a key like so: You can delete a key like so: You can also delete a whole section (including all keys) like so: Please feel free to comment with any improvements!\n\nWorks well for what I need. public class TestParser { public static void Main() { IniParser parser = new IniParser(@\"C:\\test.ini\"); String newMessage; newMessage = parser.GetSetting(\"appsettings\", \"msgpart1\"); newMessage += parser.GetSetting(\"appsettings\", \"msgpart2\"); newMessage += parser.GetSetting(\"punctuation\", \"ex\"); //Returns \"Hello World!\" Console.WriteLine(newMessage); Console.ReadLine(); } } using System; using System.IO; using System.Collections; public class IniParser { private Hashtable keyPairs = new Hashtable(); private String iniFilePath; private struct SectionPair { public String Section; public String Key; } /// <summary> /// Opens the INI file at the given path and enumerates the values in the IniParser. /// </summary> /// <param name=\"iniPath\">Full path to INI file.</param> public IniParser(String iniPath) { TextReader iniFile = null; String strLine = null; String currentRoot = null; String[] keyPair = null; iniFilePath = iniPath; if (File.Exists(iniPath)) { try { iniFile = new StreamReader(iniPath); strLine = iniFile.ReadLine(); while (strLine != null) { strLine = strLine.Trim().ToUpper(); if (strLine != \"\") { if (strLine.StartsWith(\"[\") && strLine.EndsWith(\"]\")) { currentRoot = strLine.Substring(1, strLine.Length - 2); } else { keyPair = strLine.Split(new char[] { '=' }, 2); SectionPair sectionPair; String value = null; if (currentRoot == null) currentRoot = \"ROOT\"; sectionPair.Section = currentRoot; sectionPair.Key = keyPair[0]; if (keyPair.Length > 1) value = keyPair[1]; keyPairs.Add(sectionPair, value); } } strLine = iniFile.ReadLine(); } } catch (Exception ex) { throw ex; } finally { if (iniFile != null) iniFile.Close(); } } else throw new FileNotFoundException(\"Unable to locate \" + iniPath); } /// <summary> /// Returns the value for the given section, key pair. /// </summary> /// <param name=\"sectionName\">Section name.</param> /// <param name=\"settingName\">Key name.</param> public String GetSetting(String sectionName, String settingName) { SectionPair sectionPair; sectionPair.Section = sectionName.ToUpper(); sectionPair.Key = settingName.ToUpper(); return (String)keyPairs[sectionPair]; } /// <summary> /// Enumerates all lines for given section. /// </summary> /// <param name=\"sectionName\">Section to enum.</param> public String[] EnumSection(String sectionName) { ArrayList tmpArray = new ArrayList(); foreach (SectionPair pair in keyPairs.Keys) { if (pair.Section == sectionName.ToUpper()) tmpArray.Add(pair.Key); } return (String[])tmpArray.ToArray(typeof(String)); } /// <summary> /// Adds or replaces a setting to the table to be saved. /// </summary> /// <param name=\"sectionName\">Section to add under.</param> /// <param name=\"settingName\">Key name to add.</param> /// <param name=\"settingValue\">Value of key.</param> public void AddSetting(String sectionName, String settingName, String settingValue) { SectionPair sectionPair; sectionPair.Section = sectionName.ToUpper(); sectionPair.Key = settingName.ToUpper(); if (keyPairs.ContainsKey(sectionPair)) keyPairs.Remove(sectionPair); keyPairs.Add(sectionPair, settingValue); } /// <summary> /// Adds or replaces a setting to the table to be saved with a null value. /// </summary> /// <param name=\"sectionName\">Section to add under.</param> /// <param name=\"settingName\">Key name to add.</param> public void AddSetting(String sectionName, String settingName) { AddSetting(sectionName, settingName, null); } /// <summary> /// Remove a setting. /// </summary> /// <param name=\"sectionName\">Section to add under.</param> /// <param name=\"settingName\">Key name to add.</param> public void DeleteSetting(String sectionName, String settingName) { SectionPair sectionPair; sectionPair.Section = sectionName.ToUpper(); sectionPair.Key = settingName.ToUpper(); if (keyPairs.ContainsKey(sectionPair)) keyPairs.Remove(sectionPair); } /// <summary> /// Save settings to new file. /// </summary> /// <param name=\"newFilePath\">New file path.</param> public void SaveSettings(String newFilePath) { ArrayList sections = new ArrayList(); String tmpValue = \"\"; String strToSave = \"\"; foreach (SectionPair sectionPair in keyPairs.Keys) { if (!sections.Contains(sectionPair.Section)) sections.Add(sectionPair.Section); } foreach (String section in sections) { strToSave += (\"[\" + section + \"]\\r\n\n\"); foreach (SectionPair sectionPair in keyPairs.Keys) { if (sectionPair.Section == section) { tmpValue = (String)keyPairs[sectionPair]; if (tmpValue != null) tmpValue = \"=\" + tmpValue; strToSave += (sectionPair.Key + tmpValue + \"\\r\n\n\"); } } strToSave += \"\\r\n\n\"; } try { TextWriter tw = new StreamWriter(newFilePath); tw.Write(strToSave); tw.Close(); } catch (Exception ex) { throw ex; } } /// <summary> /// Save settings back to ini file. /// </summary> public void SaveSettings() { SaveSettings(iniFilePath); } }\n\nCheck my github, I think it will be help you: using System; using System.Collections.Generic; using System.IO; using System.Runtime.InteropServices; using System.Text; namespace yourNamespace { public class Ini { /// <summary> /// Initializes a new instance of the <see cref=\"IniFile\"/> class. /// </summary> /// <param name=\"file\">The initialization file path.</param> /// <param name=\"commentDelimiter\">The comment delimiter string (default value is \";\"). /// </param> public Ini(string file) { TheFile = file; } /// <summary> /// Initializes a new instance of the <see cref=\"IniFile\"/> class. /// </summary> //public Ini() //{ // CommentDelimiter = \";\"; //} /// <summary> /// The comment delimiter string (default value is \";\"). /// </summary> //public string CommentDelimiter { get; set; } private string theFile = null; /// <summary> /// The initialization file path. /// </summary> public string TheFile { get { return theFile; } set { theFile = null; dictionary.Clear(); if (File.Exists(value)) { theFile = value; using StreamReader sr = new StreamReader(theFile); string line, section = \"\"; while ((line = sr.ReadLine()) != null) { line = line.Trim(); if (line.Length == 0) continue; // empty line //if (line.StartsWith(CommentDelimiter)) // continue; // comment if (line.StartsWith(\"[\") && line.Contains(\"]\")) // [section] { int index = line.IndexOf(']'); section = line[1..index].Trim(); continue; } if (line.Contains(\"=\")) // key=value { int index = line.IndexOf('='); string key = line.Substring(0, index).Trim(); string val = line[(index + 1)..].Trim(); string key2 = String.Format(\"[{0}]{1}\", section, key).ToLower(); if (val.StartsWith(\"\\\"\") && val.EndsWith(\"\\\"\")) // strip quotes val = val[1..(val.Length - 2)]; if (dictionary.ContainsKey(key2)) // multiple values can share the same key { index = 1; string key3; while (true) { key3 = String.Format(\"{0}~{1}\", key2, ++index); if (!dictionary.ContainsKey(key3)) { dictionary.Add(key3, val); break; } } } else { dictionary.Add(key2, val); } } } } } } // \"[section]key\" -> \"value1\" // \"[section]key~2\" -> \"value2\" // \"[section]key~3\" -> \"value3\" private readonly Dictionary<string, string> dictionary = new Dictionary<string, string>(); private bool TryGetValue(string section, string key, out string value) { string key2; if (section.StartsWith(\"[\")) key2 = String.Format(\"{0}{1}\", section, key); else key2 = String.Format(\"[{0}]{1}\", section, key); return dictionary.TryGetValue(key2.ToLower(), out value); } /// <summary> /// Gets a string value by section and key. /// </summary> /// <param name=\"section\">The section.</param> /// <param name=\"key\">The key.</param> /// <param name=\"defaultValue\">The default value.</param> /// <returns>The value.</returns> /// <seealso cref=\"GetAllValues\"/> public string GetValue(string section, string key, string defaultValue = \"\") { if (!TryGetValue(section, key, out string value)) return defaultValue; return value; } /// <summary> /// Gets a string value by section and key. /// </summary> /// <param name=\"section\">The section.</param> /// <param name=\"key\">The key.</param> /// <returns>The value.</returns> /// <seealso cref=\"GetValue\"/> public string this[string section, string key] { get { return GetValue(section, key); } } /// <summary> /// Gets an integer value by section and key. /// </summary> /// <param name=\"section\">The section.</param> /// <param name=\"key\">The key.</param> /// <param name=\"defaultValue\">The default value.</param> /// <param name=\"minValue\">Optional minimum value to be enforced.</param> /// <param name=\"maxValue\">Optional maximum value to be enforced.</param> /// <returns>The value.</returns> public int GetInteger(string section, string key, int defaultValue = 0, int minValue = int.MinValue, int maxValue = int.MaxValue) { if (!TryGetValue(section, key, out string stringValue)) return defaultValue; if (!int.TryParse(stringValue, out int value)) { if (!double.TryParse(stringValue, out double dvalue)) return defaultValue; value = (int)dvalue; } if (value < minValue) value = minValue; if (value > maxValue) value = maxValue; return value; } /// <summary> /// Gets a double floating-point value by section and key. /// </summary> /// <param name=\"section\">The section.</param> /// <param name=\"key\">The key.</param> /// <param name=\"defaultValue\">The default value.</param> /// <param name=\"minValue\">Optional minimum value to be enforced.</param> /// <param name=\"maxValue\">Optional maximum value to be enforced.</param> /// <returns>The value.</returns> //public double GetDouble(string section, string key, double defaultValue = 0, // double minValue = double.MinValue, double maxValue = double.MaxValue) //{ // string stringValue; // if (!TryGetValue(section, key, out stringValue)) // return defaultValue; // double value; // if (!double.TryParse(stringValue, out value)) // return defaultValue; // if (value < minValue) // value = minValue; // if (value > maxValue) // value = maxValue; // return value; //} /// <summary> /// Gets a boolean value by section and key. /// </summary> /// <param name=\"section\">The section.</param> /// <param name=\"key\">The key.</param> /// <param name=\"defaultValue\">The default value.</param> /// <returns>The value.</returns> public bool GetBoolean(string section, string key, bool defaultValue = false) { if (!TryGetValue(section, key, out string stringValue)) return defaultValue; return (stringValue != \"0\" && !stringValue.StartsWith(\"f\", true, null)); } /// <summary> /// Gets an array of string values by section and key. /// </summary> /// <param name=\"section\">The section.</param> /// <param name=\"key\">The key.</param> /// <returns>The array of values, or null if none found.</returns> /// <seealso cref=\"GetValue\"/> //public string[] GetAllValues(string section, string key) //{ // string key2, key3, value; // if (section.StartsWith(\"[\")) // key2 = String.Format(\"{0}{1}\", section, key).ToLower(); // else // key2 = String.Format(\"[{0}]{1}\", section, key).ToLower(); // if (!dictionary.TryGetValue(key2, out value)) // return null; // List<string> values = new List<string>(); // values.Add(value); // int index = 1; // while (true) // { // key3 = String.Format(\"{0}~{1}\", key2, ++index); // if (!dictionary.TryGetValue(key3, out value)) // break; // values.Add(value); // } // return values.ToArray(); //} } }\n\nI needed a way to simply read values from an ini file that is cross-platform (Linux, Mac, Windows) too (something that doesn't depend upon & ). I ended up using some code from this article but I dumbed it down quite a bit and made it run from a .NET Core (8.x) console app. I also added a file so you can download it and run it and see the results quickly. You can grab the one source file and include it in any project so you can easily read the values out of your ini files. Here's a quick look at the source which you can get at my github repo: Just pass in the ini file (full path or relative) and new up an IniFileReader and it'll parse the entire file so you can grab any value or iterate over them. class IniFileReader { private string FileName {get;set;} private Dictionary<string, Dictionary<string, string>> m_Sections = new Dictionary<string, Dictionary<string, string>>(); public IniFileReader(string fileName) { FileName = fileName; ParseFile(); } public void DisplayAllSections(){ foreach (string sectionKey in m_Sections.Keys){ Console.WriteLine($\"[{sectionKey}]\"); Dictionary<string,string> keyValuePairs = null; m_Sections.TryGetValue(sectionKey, out keyValuePairs); Console.WriteLine($\"Values in section: {keyValuePairs.Count}\"); foreach (string k in keyValuePairs.Keys){ string value = null; keyValuePairs.TryGetValue(k,out value); Console.WriteLine($\"{k} : {value}\"); } Console.WriteLine(); } } private string ParseSectionName(string Line) { if (!Line.StartsWith(\"[\")) return null; if (!Line.EndsWith(\"]\")) return null; if (Line.Length < 3) return null; return Line.Substring(1, Line.Length - 2); } private bool ParseKeyValuePair(string Line, ref string Key, ref string Value) { int i; if ((i = Line.IndexOf('=')) <= 0) return false; int j = Line.Length - i - 1; Key = Line.Substring(0, i).Trim(); if (Key.Length <= 0) return false; Value = (j > 0) ? (Line.Substring(i + 1, j).Trim()) : (\"\"); return true; } public string GetValue(string SectionName, string Key, string DefaultValue=\"\") { // *** Check if the section exists *** Dictionary<string, string> Section; if (!m_Sections.TryGetValue(SectionName, out Section)) return DefaultValue; // *** Check if the key exists *** string Value; if (!Section.TryGetValue(Key, out Value)) return DefaultValue; // *** Return the found value *** return Value; } public void ParseFile(){ StreamReader sr = null; try { // *** Clear local cache *** m_Sections.Clear(); // *** Open the INI file *** try { sr = new StreamReader(FileName); } catch (FileNotFoundException) { return; } Dictionary<string, string> CurrentSection = null; string s; string SectionName; string Key = null; string Value = null; while ((s = sr.ReadLine()) != null) { s = s.Trim(); SectionName = ParseSectionName(s); if (SectionName != null) { // *** Only first occurrence of a section is loaded - duplicates ignored*** if (m_Sections.ContainsKey(SectionName)) { CurrentSection = null; } else { CurrentSection = new Dictionary<string, string>(); m_Sections.Add(SectionName, CurrentSection); } } else if (CurrentSection != null) { // *** Check for key+value pair *** if (ParseKeyValuePair(s, ref Key, ref Value)) { // *** Only first occurrence of a key is loaded - duplicates ignored *** if (!CurrentSection.ContainsKey(Key)) { CurrentSection.Add(Key, Value); } } } } } finally { if (sr != null) sr.Close(); sr = null; } } }"
    },
    {
        "link": "https://learn.microsoft.com/en-us/troubleshoot/developer/visualstudio/csharp/language-compilers/file-io-operation",
        "document": "Use Visual C# to do basic file I/O\n\nThis article describes how to do basic file I/O in Visual C#, and provides a code sample to illustrate how to perform this task.\n\nThis step-by-step article shows you how to do six basic file input/output (I/O) operations in Visual C#. If you are new to the .NET Framework, you will find that the object model for file operations in .NET is similar to the (FSO) that is popular with many Visual Studio 6.0 developers. To make the transition easier, the functionality that is demonstrated in How To Use FileSystemObject with Visual Basic.\n\nYou can still use the in .NET. Because the is a Component Object Model (COM) component, .NET requires that access to the object be through the Interop layer. Microsoft .NET generates a wrapper for the component for you if you want to use it. However, the , , , classes, and other related classes in the .NET Framework, offer functionality that is not available with the FSO, without the overhead of the Interop layer.\n\nThe examples in this article describe basic file I/O operations. The Step-by-step example section describes how to create a sample program that demonstrates the following file I/O operations:\n\nIf you want to use the following code samples directly, be aware of the following:\n• None Include the namespace, as follows:\n• None Declare the variable as follows:\n• None The function is declared as follows: Instead of declaring and using the function, you can use the following statement directly:\n\nThe following sample code uses a class to read the System.ini file. The contents of the file are added to a ListBox control. The block is used to alert the program if the file is empty. There are many ways to determine when the end of the file is reached; this sample uses the method to examine the next line before reading it.\n\nThis sample code uses a class to create and write to a file. If you have an existing file, you can open it in the same way.\n\nThis sample code uses a object to access a file's properties. Notepad.exe is used in this sample. The properties appear in a ListBox control.\n\nThis sample code uses the and classes to list the logical drives on a system. For this sample, the results appear in a ListBox control.\n\nThis sample code uses the method of the class to get a list of folders.\n\nThis sample code uses the method of the class to get a listing of files.\n\nMany things can go wrong when a user gains access to files. The files may not exist, the files may be in use, or users may not have rights on the files or folders that they are trying to access. It is important to consider these possibilities when you write code and to handle the exceptions that may be generated.\n• None In Visual C#, create a new Windows Forms Application. By default, Form1 is created.\n• None Delete all of the code in the Form1.cs.\n• None Paste the following code in the Code-Behind Editor window. using System.Windows.Forms; using System.IO; namespace fso_cs { public partial class Form1 : Form { string winDir = System.Environment.GetEnvironmentVariable(\"windir\"); public Form1() { InitializeComponent(); } private void button1_Click(object sender, System.EventArgs e) { //How to read a text file. //try...catch is to deal with a 0 byte file. this.listBox1.Items.Clear(); StreamReader reader = new StreamReader(winDir + \"\\\\system.ini\"); try { do { addListItem(reader.ReadLine()); } while (reader.Peek()!= -1); } catch { addListItem(\"File is empty\"); } finally { reader.Close(); } } private void button2_Click(object sender, System.EventArgs e) { //Demonstrates how to create and write to a text file. StreamWriter writer = new StreamWriter(\"c:\\\\KBTest.txt\"); writer.WriteLine(\"File created using StreamWriter class.\"); writer.Close(); this.listBox1.Items.Clear(); addListItem(\"File Written to C:\\\\KBTest.txt\"); } private void button3_Click(object sender, System.EventArgs e) { //How to retrieve file properties (example uses Notepad.exe). this.listBox1.Items.Clear(); FileInfo FileProps = new FileInfo(winDir + \"\\\n\notepad.exe\"); addListItem(\"File Name = \" + FileProps.FullName); addListItem(\"Creation Time = \" + FileProps.CreationTime); addListItem(\"Last Access Time = \" + FileProps.LastAccessTime); addListItem(\"Last Write TIme = \" + FileProps.LastWriteTime); addListItem(\"Size = \" + FileProps.Length); FileProps = null; } private void button4_Click(object sender, System.EventArgs e) { //Demonstrates how to obtain a list of disk drives. this.listBox1.Items.Clear(); string[] drives = Directory.GetLogicalDrives(); foreach (string drive in drives) { addListItem(drive); } } private void button5_Click(object sender, System.EventArgs e) { //How to get a list of folders (example uses Windows folder). this.listBox1.Items.Clear(); string[] dirs = Directory.GetDirectories(winDir); foreach (string dir in dirs) { addListItem(dir); } } private void button6_Click(object sender, System.EventArgs e) { //How to obtain list of files (example uses Windows folder). this.listBox1.Items.Clear(); string[] files = Directory.GetFiles(winDir); foreach (string i in files) { addListItem(i); } } private void Form1_Load(object sender, System.EventArgs e) { this.button1.Text = \"Read Text File\"; this.button2.Text = \"Write Text File\"; this.button3.Text = \"View File Information\"; this.button4.Text = \"List Drives\"; this.button5.Text = \"List Subfolders\"; this.button6.Text = \"List Files\"; } private void addListItem(string value) { this.listBox1.Items.Add(value); } } }\n• None Delete all of the code in Form1.Designer.cs.\n• None Paste the following code in Form1.Designer.cs. namespace fso_cs { partial class Form1 { /// <summary> /// Required designer variable. /// </summary> private System.ComponentModel.IContainer components = null; /// <summary> /// Clean up any resources being used. /// </summary> /// <param name=\"disposing\">true if managed resources should be disposed; otherwise, false.</param> protected override void Dispose(bool disposing) { if (disposing && (components != null)) { components.Dispose(); } base.Dispose(disposing); } #region Windows Form Designer generated code /// <summary> /// Required method for Designer support - do not modify /// the contents of this method with the code editor. /// </summary> private void InitializeComponent() { this.button1 = new System.Windows.Forms.Button(); this.button2 = new System.Windows.Forms.Button(); this.button3 = new System.Windows.Forms.Button(); this.button4 = new System.Windows.Forms.Button(); this.button5 = new System.Windows.Forms.Button(); this.button6 = new System.Windows.Forms.Button(); this.listBox1 = new System.Windows.Forms.ListBox(); this.SuspendLayout(); // button1 this.button1.Location = new System.Drawing.Point(53, 30); this.button1.Name = \"button1\"; this.button1.Size = new System.Drawing.Size(112, 23); this.button1.TabIndex = 1; this.button1.Text = \"button1\"; this.button1.Click += new System.EventHandler(this.button1_Click); // button2 this.button2.Location = new System.Drawing.Point(53, 62); this.button2.Name = \"button2\"; this.button2.Size = new System.Drawing.Size(112, 23); this.button2.TabIndex = 2; this.button2.Text = \"button2\"; this.button2.Click += new System.EventHandler(this.button2_Click); // button3 this.button3.Location = new System.Drawing.Point(53, 94); this.button3.Name = \"button3\"; this.button3.Size = new System.Drawing.Size(112, 23); this.button3.TabIndex = 3; this.button3.Text = \"button3\"; this.button3.Click += new System.EventHandler(this.button3_Click); // button4 this.button4.Location = new System.Drawing.Point(53, 126); this.button4.Name = \"button4\"; this.button4.Size = new System.Drawing.Size(112, 23); this.button4.TabIndex = 4; this.button4.Text = \"button4\"; this.button4.Click += new System.EventHandler(this.button4_Click); // button5 this.button5.Location = new System.Drawing.Point(53, 158); this.button5.Name = \"button5\"; this.button5.Size = new System.Drawing.Size(112, 23); this.button5.TabIndex = 5; this.button5.Text = \"button5\"; this.button5.Click += new System.EventHandler(this.button5_Click); // button6 this.button6.Location = new System.Drawing.Point(53, 190); this.button6.Name = \"button6\"; this.button6.Size = new System.Drawing.Size(112, 23); this.button6.TabIndex = 6; this.button6.Text = \"button6\"; this.button6.Click += new System.EventHandler(this.button6_Click); // listBox1 this.listBox1.FormattingEnabled = true; this.listBox1.Location = new System.Drawing.Point(204, 30); this.listBox1.Name = \"listBox1\"; this.listBox1.Size = new System.Drawing.Size(270, 199); this.listBox1.TabIndex = 7; // Form1 this.AutoScaleBaseSize = new System.Drawing.Size(5, 13); this.ClientSize = new System.Drawing.Size(525, 273); this.Controls.Add(this.button6); this.Controls.Add(this.button5); this.Controls.Add(this.button4); this.Controls.Add(this.button3); this.Controls.Add(this.button2); this.Controls.Add(this.button1); this.Controls.Add(this.listBox1); this.Name = \"Form1\"; this.Text = \"Form1\"; this.Load += new System.EventHandler(this.Form1_Load); this.ResumeLayout(false); } #endregion private System.Windows.Forms.Button button1; private System.Windows.Forms.Button button2; private System.Windows.Forms.Button button3; private System.Windows.Forms.Button button4; private System.Windows.Forms.Button button5; private System.Windows.Forms.Button button6; private System.Windows.Forms.ListBox listBox1; } }\n• None By default, Visual C# adds one form to the project when you create a Windows Forms project. This form is named Form1. The two source code files that represent the form are named Form1.cs and Form1.Designer.cs. You write your code in the Form1.cs file. The Windows Forms Designer writes designer-generated code in the Form1.Designer.cs file. The code in the preceding steps reflects that organization.\n• None Press F5 to build and then run the program. Click the buttons to view the different actions. When you view the sample code, you may want to collapse the area named Windows Form Designer Generated Code to hide this code."
    },
    {
        "link": "https://learn.microsoft.com/en-us/troubleshoot/developer/visualstudio/csharp/language-compilers/read-write-text-file",
        "document": "Use Visual C# to read from and write to a text file\n\nThis article helps you read from and write to a text file by using Visual C#.\n\nThe Read a text file section of this article describes how to use the class to read a text file. The Write a text file (example 1) and the Write a text file (example 2) sections describe how to use the class to write text to a file.\n\nThe following code uses the class to open, to read, and to close the text file. You can pass the path of a text file to the constructor to open the file automatically. The method reads each line of text, and increments the file pointer to the next line as it reads. When the method reaches the end of the file, it returns a null reference. For more information, see StreamReader Class.\n• \n• Paste the hello world text in Notepad.\n• None On the File menu, point to New, and then select Project.\n• None Select Visual C# Projects under Project Types, and then select Console Application under Templates.\n• None Add the following code at the beginning of the Class1.cs file:\n• None Add the following code to the method: String line; try { //Pass the file path and file name to the StreamReader constructor StreamReader sr = new StreamReader(\"C:\\\\Sample.txt\"); //Read the first line of text line = sr.ReadLine(); //Continue to read until you reach end of file while (line != null) { //write the line to console window Console.WriteLine(line); //Read the next line line = sr.ReadLine(); } //close the file sr.Close(); Console.ReadLine(); } catch(Exception e) { Console.WriteLine(\"Exception: \" + e.Message); } finally { Console.WriteLine(\"Executing finally block.\"); }\n• None On the Debug menu, select Start to compile and to run the application. Press ENTER to close the Console window. The Console window displays the contents of the Sample.txt file：\n\nThe following code uses the class to open, to write, and to close the text file. In a similar way to the class, you can pass the path of a text file to the constructor to open the file automatically. The method writes a complete line of text to the text file.\n• None On the File menu, point to New, and then select Project.\n• None Select Visual C# Projects under Project Types, and then select Console Application under Templates.\n• None Add the following code at the beginning of the Class1.cs file:\n• None Add the following code to the method: try { //Pass the filepath and filename to the StreamWriter Constructor StreamWriter sw = new StreamWriter(\"C:\\\\Test.txt\"); //Write a line of text sw.WriteLine(\"Hello World!!\"); //Write a second line of text sw.WriteLine(\"From the StreamWriter class\"); //Close the file sw.Close(); } catch(Exception e) { Console.WriteLine(\"Exception: \" + e.Message); } finally { Console.WriteLine(\"Executing finally block.\"); }\n• None On the Debug menu, select Start to compile and to run the application. This code creates a file that is named Test.txt on drive C. Open Test.txt in a text editor such as Notepad. Test.txt contains two lines of text: Hello World!! From the StreamWriter class\n\nThe following code uses the class to open, to write, and to close the text file. Unlike the previous example, this code passes two additional parameters to the constructor. The first parameter is the file path and the file name of the file. The second parameter, , specifies that the file is opened in append mode. If you specify for the second parameter, the contents of the file are overwritten each time you run the code. The third parameter specifies , so that encodes the file in Unicode format. You can also specify the following encoding methods for the third parameter:\n\nThe method is similar to the method, except that the method doesn't automatically embed a carriage return or line feed (CR/LF) character combination. It's useful when you want to write one character at a time.\n• None On the File menu, point to New, and then click Project.\n• None Click Visual C# Projects under Project Types, and then click Console Application under Templates.\n• None Add the following code at the beginning of the Class1.cs file:\n• None Add the following code to the method: Int64 x; try { //Open the File StreamWriter sw = new StreamWriter(\"C:\\\\Test1.txt\", true, Encoding.ASCII); //Write out the numbers 1 to 10 on the same line. for(x=0; x < 10; x++) { sw.Write(x); } //close the file sw.Close(); } catch(Exception e) { Console.WriteLine(\"Exception: \" + e.Message); } finally { Console.WriteLine(\"Executing finally block.\"); }\n• None On the Debug menu, select Start to compile and to run the application. This code creates a file that is named Test1.txt on drive C. Open Test1.txt in a text editor such as Notepad. Test1.txt contains a single line of text: 0123456789.\n\nComplete code listing for how to read a text file\n\nComplete code listing for how to write a text file (version 1)\n\nComplete code listing for how to write a text file (version 2)\n\nFor all file manipulations, it's good programming practice to wrap the code inside a block to handle errors and exceptions. Specifically, you may want to release handles to the file in the final block so that the file isn't locked indefinitely. Some possible errors include a file that doesn't exist, or a file that is already in use."
    },
    {
        "link": "https://learn-tech-tips.blogspot.com/2015/06/how-to-read-write-ini-file-in-C-Sharp.html",
        "document": "How to Read and Write INI Files in C#INI files are a simple and widely used format for storing configuration settings. They consist of sections, keys, and values, separated by brackets, equal signs, and newlines. For example, an INI file might look like this:\n\n\n\n[General] \n\nName=John \n\nAge=25 \n\n[Preferences] \n\nColor=Blue \n\nFont=Arial \n\n \n\nIn this article, we will show you how to read and write INI files in C# using the Windows API functions WritePrivateProfileString and GetPrivateProfileString. These functions are defined in the kernel32.dll library, which we can access using the Platform Invoke (P/Invoke) feature of .NET.\n\n\n\nTo use these functions, we need to declare them in our code using the DllImport attribute. We also need to specify the character set, the entry point, and the parameters of each function. For example:\n• None INI files can be used to save basic user settings easily.\n\nIni File Manipulation with C# , please share them in the comments below. I would love to hear from you and discuss this topic further \n\n Thank you for reading this post. I hope you found it helpful and easy to follow. If you have any feedback or questions about, please share them in the comments below. I would love to hear from you and discuss this topic further idane, See you next time soon ✋✋✋✋ ✋✋✋✋ Webzone Tech Tips, all things Tech Tips for web development - I amidane, See you next time soon ✋✋✋✋\n\nThe WritePrivateProfileString function writes a value to a specified key in a specified section of an INI file. The parameters are:\n• section: The name of the section to write to.\n• key: The name of the key to write to.\n• value: The value to write.\n• filePath: The path of the INI file.The GetPrivateProfileString function reads a value from a specified key in a specified section of an INI file. The parameters are:\n• section: The name of the section to read from.\n• key: The name of the key to read from.\n• defaultValue: The default value to return if the key is not found.\n• retVal: A StringBuilder object that receives the value.\n• size: The maximum number of characters to copy to the retVal object.\n• filePath: The path of the INI file.To use these functions in our code, we can create a helper class that wraps them in more convenient methods. For example:With this class, we can easily read and write INI files in C#. For example:We can also check if the INI file exists using the Exists method. For example:This is how we can read and write INI files in C# using the Windows API functions. For more information and examples on these functions, you can refer to these sources\n• #CSharp\n• #INIFiles\n• #WindowsAPI\n• #PInvoke\n• #Configuration\n• #Settings\n• #Programming\n• #Coding\n• #Tutorial\n• #HowTo\n• #DotNet\n• #Kernel32\n• #WritePrivateProfileString\n• #GetPrivateProfileString\n• #CodeExample style=\"color: red;\">What's INI file?This topic will be focus to how to read, writein CSharp.Read function:- Using GetPrivateProfileStringAPI for get key values in INI files- Using StringBuilder to stored value from file.Write function:Using WritePrivateProfileString API for write key values in INI filesLeave your comment for How to read Write Ini File In CSharp If you have anywith above code!"
    },
    {
        "link": "https://stackoverflow.com/questions/74000169/read-and-write-ini-file-without-sections",
        "document": "An INI file has a well defined structure composed by one or many [Sections] and zero or many pairs of [Key]=[Value] under each section. A file without at least a section is not a proper INI file and the standard windows API GetPrivateProfileString and WritePrivateProfileString are not able to read a file with that format.\n\nHowever, your file is a lot simpler than a standard INI file. It is just composed by pairs of [Key]=[Value] so it is a naturally perfect fit for a Dictionary<string, string>\n\nReading it coud be simple as\n\nand writing back that dictionary is even simpler\n\nNow if you want to change some value you could have\n\nWarning: In the examples above there is no error checking. A robust solution should check if the file passed to the read method exists and if the split operation produces an array of two elements. Consider also that checking for binary files is also an unhandled problem and with complex solutions. So we could also consider to let exceptions bubble up to the client caller."
    }
]