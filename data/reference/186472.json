[
    {
        "link": "https://vuejs.org/guide/components/v-model.html",
        "document": "can be used on a component to implement a two-way binding.\n\nStarting in Vue 3.4, the recommended approach to achieve this is using the macro: The parent can then bind a value with : The value returned by is a ref. It can be accessed and mutated like any other ref, except that it acts as a two-way binding between a parent value and a local one:\nâ€¢ Its is synced with the value bound by the parent ;\nâ€¢ When it is mutated by the child, it causes the parent bound value to be updated as well. This means you can also bind this ref to a native input element with , making it straightforward to wrap native input elements while providing the same usage: is a convenience macro. The compiler expands it to the following:\nâ€¢ A prop named , which the local ref's value is synced with;\nâ€¢ An event named , which is emitted when the local ref's value is mutated. This is how you would implement the same child component shown above prior to 3.4: Then, in the parent component will be compiled to: As you can see, it is quite a bit more verbose. However, it is helpful to understand what is happening under the hood. Because declares a prop, you can therefore declare the underlying prop's options by passing it to : If you have a value for prop and you don't provide any value for this prop from the parent component, it can cause a de-synchronization between parent and child components. In the example below, the parent's is undefined, but the child's is 1:\n\nFirst let's revisit how is used on a native element: Under the hood, the template compiler expands to the more verbose equivalent for us. So the above code does the same as the following: When used on a component, instead expands to this: For this to actually work though, the component must do two things:\nâ€¢ Bind the attribute of a native element to the prop\nâ€¢ When a native event is triggered, emit an custom event with the new value Now should work perfectly with this component: Another way of implementing within this component is to use a writable property with both a getter and a setter. The method should return the property and the method should emit the corresponding event:\n\non a component can also accept an argument:\n\nBy leveraging the ability to target a particular prop and event as we learned before with arguments, we can now create multiple bindings on a single component instance.\n\nEach will sync to a different prop, without the need for extra options in the component:\n\nWhen we were learning about form input bindings, we saw that has built-in modifiers - , and . In some cases, you might also want the on your custom input component to support custom modifiers.\n\nLet's create an example custom modifier, , that capitalizes the first letter of the string provided by the binding:\n\nModifiers added to a component can be accessed in the child component by destructuring the return value like this: To conditionally adjust how the value should be read / written based on modifiers, we can pass and options to . These two options receive the value on get / set of the model ref and should return a transformed value. This is how we can use the option to implement the modifier:\n\nModifiers added to a component will be provided to the component via the prop. In the below example, we have created a component that contains a prop that defaults to an empty object: Notice the component's prop contains and its value is - due to it being set on the binding . Now that we have our prop set up, we can check the object keys and write a handler to change the emitted value. In the code below we will capitalize the string whenever the element fires an event.\n\nHere's another example of using modifiers with multiple with different arguments:"
    },
    {
        "link": "https://vuejs.org/guide/essentials/reactivity-fundamentals.html",
        "document": "With the Options API, we use the option to declare reactive state of a component. The option value should be a function that returns an object. Vue will call the function when creating a new component instance, and wrap the returned object in its reactivity system. Any top-level properties of this object are proxied on the component instance ( in methods and lifecycle hooks): // `mounted` is a lifecycle hook which we will explain later // `this` refers to the component instance. // data can be mutated as well These instance properties are only added when the instance is first created, so you need to ensure they are all present in the object returned by the function. Where necessary, use , or some other placeholder value for properties where the desired value isn't yet available. It is possible to add a new property directly to without including it in . However, properties added this way will not be able to trigger reactive updates. Vue uses a prefix when exposing its own built-in APIs via the component instance. It also reserves the prefix for internal properties. You should avoid using names for top-level properties that start with either of these characters. In Vue 3, data is made reactive by leveraging JavaScript Proxies. Users coming from Vue 2 should be aware of the following edge case: When you access after assigning it, the value is a reactive proxy of the original . Unlike in Vue 2, the original is left intact and will not be made reactive: make sure to always access reactive state as a property of .\n\nIn Composition API, the recommended way to declare reactive state is using the function: takes the argument and returns it wrapped within a ref object with a property: To access refs in a component's template, declare and return them from a component's function: // `setup` is a special hook dedicated for the Composition API. // expose the ref to the template Notice that we did not need to append when using the ref in the template. For convenience, refs are automatically unwrapped when used inside templates (with a few caveats). You can also mutate a ref directly in event handlers: For more complex logic, we can declare functions that mutate refs in the same scope and expose them as methods alongside the state: // .value is needed in JavaScript // don't forget to expose the function as well. Exposed methods can then be used as event handlers: Here's the example live on Codepen, without using any build tools. Manually exposing state and methods via can be verbose. Luckily, it can be avoided when using Single-File Components (SFCs). We can simplify the usage with : Top-level imports, variables and functions declared in are automatically usable in the template of the same component. Think of the template as a JavaScript function declared in the same scope - it naturally has access to everything declared alongside it. For the rest of the guide, we will be primarily using SFC + syntax for the Composition API code examples, as that is the most common usage for Vue developers. If you are not using SFC, you can still use Composition API with the option. You might be wondering why we need refs with the instead of plain variables. To explain that, we will need to briefly discuss how Vue's reactivity system works. When you use a ref in a template, and change the ref's value later, Vue automatically detects the change and updates the DOM accordingly. This is made possible with a dependency-tracking based reactivity system. When a component is rendered for the first time, Vue tracks every ref that was used during the render. Later on, when a ref is mutated, it will trigger a re-render for components that are tracking it. In standard JavaScript, there is no way to detect the access or mutation of plain variables. However, we can intercept the get and set operations of an object's properties using getter and setter methods. The property gives Vue the opportunity to detect when a ref has been accessed or mutated. Under the hood, Vue performs the tracking in its getter, and performs triggering in its setter. Conceptually, you can think of a ref as an object that looks like this: Another nice trait of refs is that unlike plain variables, you can pass refs into functions while retaining access to the latest value and the reactivity connection. This is particularly useful when refactoring complex logic into reusable code. The reactivity system is discussed in more details in the Reactivity in Depth section.\n\nTo add methods to a component instance we use the option. This should be an object containing the desired methods: // methods can be called in lifecycle hooks, or other methods! Vue automatically binds the value for so that it always refers to the component instance. This ensures that a method retains the correct value if it's used as an event listener or callback. You should avoid using arrow functions when defining , as that prevents Vue from binding the appropriate value: // BAD: no `this` access here! Just like all other properties of the component instance, the are accessible from within the component's template. Inside a template they are most commonly used as event listeners: In the example above, the method will be called when the is clicked.\n\nRefs can hold any value type, including deeply nested objects, arrays, or JavaScript built-in data structures like . A ref will make its value deeply reactive. This means you can expect changes to be detected even when you mutate nested objects or arrays: // these will work as expected. Non-primitive values are turned into reactive proxies via , which is discussed below. It is also possible to opt-out of deep reactivity with shallow refs. For shallow refs, only access is tracked for reactivity. Shallow refs can be used for optimizing performance by avoiding the observation cost of large objects, or in cases where the inner state is managed by an external library.\n\nWhen you mutate reactive state, the DOM is updated automatically. However, it should be noted that the DOM updates are not applied synchronously. Instead, Vue buffers them until the \"next tick\" in the update cycle to ensure that each component updates only once no matter how many state changes you have made.\n\nTo wait for the DOM update to complete after a state change, you can use the nextTick() global API:\n\nThere is another way to declare reactive state, with the API. Unlike a ref which wraps the inner value in a special object, makes an object itself reactive: Reactive objects are JavaScript Proxies and behave just like normal objects. The difference is that Vue is able to intercept the access and mutation of all properties of a reactive object for reactivity tracking and triggering. converts the object deeply: nested objects are also wrapped with when accessed. It is also called by internally when the ref value is an object. Similar to shallow refs, there is also the API for opting-out of deep reactivity. It is important to note that the returned value from is a Proxy of the original object, which is not equal to the original object: // proxy is NOT equal to the original. Only the proxy is reactive - mutating the original object will not trigger updates. Therefore, the best practice when working with Vue's reactivity system is to exclusively use the proxied versions of your state. To ensure consistent access to the proxy, calling on the same object always returns the same proxy, and calling on an existing proxy also returns that same proxy: // calling reactive() on the same object returns the same proxy This rule applies to nested objects as well. Due to deep reactivity, nested objects inside a reactive object are also proxies: The API has a few limitations:\nâ€¢ None Limited value types: it only works for object types (objects, arrays, and collection types such as and ). It cannot hold primitive types such as , or .\nâ€¢ None Cannot replace entire object: since Vue's reactivity tracking works over property access, we must always keep the same reference to the reactive object. This means we can't easily \"replace\" a reactive object because the reactivity connection to the first reference is lost: // the above reference ({ count: 0 }) is no longer being tracked\nâ€¢ None Not destructure-friendly: when we destructure a reactive object's primitive type property into local variables, or when we pass that property into a function, we will lose the reactivity connection: // count is disconnected from state.count when destructured. // won't be able to track changes to state.count // we have to pass the entire object in to retain reactivity Due to these limitations, we recommend using as the primary API for declaring reactive state. A ref is automatically unwrapped when accessed or mutated as a property of a reactive object. In other words, it behaves like a normal property: If a new ref is assigned to a property linked to an existing ref, it will replace the old ref: // original ref is now disconnected from state.count Ref unwrapping only happens when nested inside a deep reactive object. It does not apply when it is accessed as a property of a shallow reactive object. Unlike reactive objects, there is no unwrapping performed when the ref is accessed as an element of a reactive array or a native collection type like : Ref unwrapping in templates only applies if the ref is a top-level property in the template render context. In the example below, and are top-level properties, but is not: Therefore, this expression works as expected: ...while this one does NOT: The rendered result will be because is not unwrapped when evaluating the expression and remains a ref object. To fix this, we can destructure into a top-level property: Now the render result will be . Another thing to note is that a ref does get unwrapped if it is the final evaluated value of a text interpolation (i.e. a tag), so the following will render : This is just a convenience feature of text interpolation and is equivalent to ."
    },
    {
        "link": "https://vuejs.org/guide/extras/reactivity-in-depth.html",
        "document": "One of Vueâ€™s most distinctive features is the unobtrusive reactivity system. Component state consists of reactive JavaScript objects. When you modify them, the view updates. It makes state management simple and intuitive, but itâ€™s also important to understand how it works to avoid some common gotchas. In this section, we are going to dig into some of the lower-level details of Vueâ€™s reactivity system.\n\nThis term comes up in programming quite a bit these days, but what do people mean when they say it? Reactivity is a programming paradigm that allows us to adjust to changes in a declarative manner. The canonical example that people usually show, because itâ€™s a great one, is an Excel spreadsheet:\n\nHere cell A2 is defined via a formula of (you can click on A2 to view or edit the formula), so the spreadsheet gives us 3. No surprises there. But if you update A0 or A1, you'll notice that A2 automagically updates too.\n\nJavaScript doesnâ€™t usually work like this. If we were to write something comparable in JavaScript:\n\nWhen we mutate , does not change automatically.\n\nSo how would we do this in JavaScript? First, in order to re-run the code that updates , let's wrap it in a function:\n\nThen, we need to define a few terms:\nâ€¢ None The function produces a side effect, or effect for short, because it modifies the state of the program.\nâ€¢ None and are considered dependencies of the effect, as their values are used to perform the effect. The effect is said to be a subscriber to its dependencies.\n\nWhat we need is a magic function that can invoke (the effect) whenever or (the dependencies) change:\n\nThis function has the following tasks:\nâ€¢ None Track when a variable is read. E.g. when evaluating the expression , both and are read.\nâ€¢ None If a variable is read when there is a currently running effect, make that effect a subscriber to that variable. E.g. because and are read when is being executed, becomes a subscriber to both and after the first call.\nâ€¢ None Detect when a variable is mutated. E.g. when is assigned a new value, notify all its subscriber effects to re-run.\n\nWe can't really track the reading and writing of local variables like in the example. There's just no mechanism for doing that in vanilla JavaScript. What we can do though, is intercept the reading and writing of object properties.\n\nThere are two ways of intercepting property access in JavaScript: getter / setters and Proxies. Vue 2 used getter / setters exclusively due to browser support limitations. In Vue 3, Proxies are used for reactive objects and getter / setters are used for refs. Here's some pseudo-code that illustrates how they work:\n\nThis explains a few limitations of reactive objects that we have discussed in the fundamentals section:\nâ€¢ None When you assign or destructure a reactive object's property to a local variable, accessing or assigning to that variable is non-reactive because it no longer triggers the get / set proxy traps on the source object. Note this \"disconnect\" only affects the variable binding - if the variable points to a non-primitive value such as an object, mutating the object would still be reactive.\nâ€¢ None The returned proxy from , although behaving just like the original, has a different identity if we compare it to the original using the operator.\n\nInside , we check whether there is a currently running effect. If there is one, we lookup the subscriber effects (stored in a Set) for the property being tracked, and add the effect to the Set:\n\nEffect subscriptions are stored in a global data structure. If no subscribing effects Set was found for a property (tracked for the first time), it will be created. This is what the function does, in short. For simplicity, we will skip its details.\n\nInside , we again lookup the subscriber effects for the property. But this time we invoke them instead:\n\nNow let's circle back to the function:\n\nIt wraps the raw function in an effect that sets itself as the current active effect before running the actual update. This enables calls during the update to locate the current active effect.\n\nAt this point, we have created an effect that automatically tracks its dependencies, and re-runs whenever a dependency changes. We call this a Reactive Effect.\n\nVue provides an API that allows you to create reactive effects: . In fact, you may have noticed that it works pretty similarly to the magical in the example. We can now rework the original example using actual Vue APIs:\n\nUsing a reactive effect to mutate a ref isn't the most interesting use case - in fact, using a computed property makes it more declarative:\n\nInternally, manages its invalidation and re-computation using a reactive effect.\n\nSo what's an example of a common and useful reactive effect? Well, updating the DOM! We can implement simple \"reactive rendering\" like this:\n\nIn fact, this is pretty close to how a Vue component keeps the state and the DOM in sync - each component instance creates a reactive effect to render and update the DOM. Of course, Vue components use much more efficient ways to update the DOM than . This is discussed in Rendering Mechanism.\n\nVue's reactivity system is primarily runtime-based: the tracking and triggering are all performed while the code is running directly in the browser. The pros of runtime reactivity are that it can work without a build step, and there are fewer edge cases. On the other hand, this makes it constrained by the syntax limitations of JavaScript, leading to the need of value containers like Vue refs.\n\nSome frameworks, such as Svelte, choose to overcome such limitations by implementing reactivity during compilation. It analyzes and transforms the code in order to simulate reactivity. The compilation step allows the framework to alter the semantics of JavaScript itself - for example, implicitly injecting code that performs dependency analysis and effect triggering around access to locally defined variables. The downside is that such transforms require a build step, and altering JavaScript semantics is essentially creating a language that looks like JavaScript but compiles into something else.\n\nThe Vue team did explore this direction via an experimental feature called Reactivity Transform, but in the end we have decided that it would not be a good fit for the project due to the reasoning here.\n\nIt's great that Vue's reactivity system automatically tracks dependencies, but in some cases we may want to figure out exactly what is being tracked, or what is causing a component to re-render.\n\nWe can debug what dependencies are used during a component's render and which dependency is triggering an update using the and lifecycle hooks. Both hooks will receive a debugger event which contains information on the dependency in question. It is recommended to place a statement in the callbacks to interactively inspect the dependency:\n\nThe debug event objects have the following type:\n\nWe can debug computed properties by passing a second options object with and callbacks:\nâ€¢ will be called when a reactive property or ref is tracked as a dependency.\nâ€¢ will be called when the watcher callback is triggered by the mutation of a dependency.\n\nBoth callbacks will receive debugger events in the same format as component debug hooks:\n\nSimilar to , watchers also support the and options:\n\nVue's reactivity system works by deeply converting plain JavaScript objects into reactive proxies. The deep conversion can be unnecessary or sometimes unwanted when integrating with external state management systems (e.g. if an external solution also uses Proxies).\n\nThe general idea of integrating Vue's reactivity system with an external state management solution is to hold the external state in a . A shallow ref is only reactive when its property is accessed - the inner value is left intact. When the external state changes, replace the ref value to trigger updates.\n\nIf you are implementing an undo / redo feature, you likely want to take a snapshot of the application's state on every user edit. However, Vue's mutable reactivity system isn't best suited for this if the state tree is large, because serializing the entire state object on every update can be expensive in terms of both CPU and memory costs.\n\nImmutable data structures solve this by never mutating the state objects - instead, it creates new objects that share the same, unchanged parts with old ones. There are different ways of using immutable data in JavaScript, but we recommend using Immer with Vue because it allows you to use immutable data while keeping the more ergonomic, mutable syntax.\n\nWe can integrate Immer with Vue via a simple composable:\n\nTry it in the Playground\n\nState Machine is a model for describing all the possible states an application can be in, and all the possible ways it can transition from one state to another. While it may be overkill for simple components, it can help make complex state flows more robust and manageable.\n\nOne of the most popular state machine implementations in JavaScript is XState. Here's a composable that integrates with it:\n\nTry it in the Playground\n\nRxJS is a library for working with asynchronous event streams. The VueUse library provides the add-on for connecting RxJS streams with Vue's reactivity system.\n\nQuite a few other frameworks have introduced reactivity primitives similar to refs from Vue's Composition API, under the term \"signals\":\n\nFundamentally, signals are the same kind of reactivity primitive as Vue refs. It's a value container that provides dependency tracking on access, and side-effect triggering on mutation. This reactivity-primitive-based paradigm isn't a particularly new concept in the frontend world: it dates back to implementations like Knockout observables and Meteor Tracker from more than a decade ago. Vue Options API and the React state management library MobX are also based on the same principles, but hide the primitives behind object properties.\n\nAlthough not a necessary trait for something to qualify as signals, today the concept is often discussed alongside the rendering model where updates are performed through fine-grained subscriptions. Due to the use of Virtual DOM, Vue currently relies on compilers to achieve similar optimizations. However, we are also exploring a new Solid-inspired compilation strategy, called Vapor Mode, that does not rely on Virtual DOM and takes more advantage of Vue's built-in reactivity system.\n\nThe design of Preact and Qwik's signals are very similar to Vue's shallowRef: all three provide a mutable interface via the property. We will focus the discussion on Solid and Angular signals.\n\nSolid's API design emphasizes read / write segregation. Signals are exposed as a read-only getter and a separate setter:\n\nNotice how the signal can be passed down without the setter. This ensures that the state can never be mutated unless the setter is also explicitly exposed. Whether this safety guarantee justifies the more verbose syntax could be subject to the requirement of the project and personal taste - but in case you prefer this API style, you can easily replicate it in Vue:\n\nTry it in the Playground\n\nAngular is undergoing some fundamental changes by foregoing dirty-checking and introducing its own implementation of a reactivity primitive. The Angular Signal API looks like this:\n\nAgain, we can easily replicate the API in Vue:\n\nTry it in the Playground\n\nCompared to Vue refs, Solid and Angular's getter-based API style provide some interesting trade-offs when used in Vue components:\nâ€¢ is slightly less verbose than , but updating the value is more verbose.\nâ€¢ There is no ref-unwrapping: accessing values always require . This makes value access consistent everywhere. This also means you can pass raw signals down as component props.\n\nWhether these API styles suit you is to some extent subjective. Our goal here is to demonstrate the underlying similarity and trade-offs between these different API designs. We also want to show that Vue is flexible: you are not really locked into the existing APIs. Should it be necessary, you can create your own reactivity primitive API to suit more specific needs."
    },
    {
        "link": "https://dev.to/blindkai/objects-and-v-model-in-vue3-1l9h",
        "document": "When I was using Vue2 along with and it was easy to synchronize between components simply using . When Vue 3 came out with its Composition API another way was needed to achieve the same result as if Class Component was used.\n\nIf you're already familiar with the capabilities of Composition API, then simply use within to update the whenever it changes.\n\n1) In child component define a model property with the default value\n\n\n\nIn the case of using TypeScript, there is one minor addition to the code above. is used it order to annotate the model type.\n\n\n\nAnd it's all you need to know to pass reactive objects into your custom components as ."
    },
    {
        "link": "https://stackoverflow.com/questions/64775876/vue-3-pass-reactive-object-to-component-with-two-way-binding",
        "document": "Your initial problem is quite simple. In Vue 3 defaults to to a prop called and emits come from . Other answers here have assumed that in their solutions but not directly addressed it.\n\nYou can either rename your prop to use the default prop OR use the multi-model features in Vue 3:\n\nAll (current) answers will work but aren't quite correct. They all fail the idiomatic \"One-way Data Flow\" rule.\n\nConsider this JSFiddle, modified from this answer.\n\nIn this example, the child component never 'emits' - yet the data is still updating in the parent component. This violates the \"One-way\" rule. Data must be propagated from child components using only emits and not via prop proxies.\n\nThe problem in here is that is reactive when arrives in the child component. One can verify this with the helper. When it's passed through the it retains that reactiveness and will continue to proxy updates through itself into the parent component.\n\nThe solution is three parts:\nâ€¢ None The computed getter must not return the proxy object from the parent component. Once this happens you're in danger of violating the \"one-way\" rule [note 1]. In this example is a string so we're safe.\nâ€¢ None The computed setter must emit the whole object, but again it must not be a reactive type. So we clone the using spread and include in the updated field. This can also be achieved with [note 2].\nâ€¢ None The variable in the parent component cannot be a and must be a . When the receives the newly emitted object the variable is clobbered and no longer reactive [note 3]. Even with refs the will still fully reactive when it arrives in the child component, so the cloning steps are still important.\n\nI should also mention that values from are not deeply reactive. As in, setting values on a computed object will not trigger the computed setter.\n\nAn alternate solution for passing the whole object through to your template:\n\nIn this, the whole object will emit whenever the field is updated. E.g. . This still obeys the \"one-way\" data rule because emits are the only way data is given to parent component.\n\n\"One-way\" data flow is important [4]. Consider this:\n\nOn a first (and a sensible) glance, this appears to pass data into 'child' but not out of 'child'. But, given a reactive object that is not handled by the child correctly, this will emit changes into my own component.\n\nObserving this code I don't expect this behaviour so it's very important that the child component gets it right.\n\n[1]: Testing violations of the \"one-way\" rule are surprisingly simple. Remove any and if the parent receives updates - you've broken it. Or replacing with also works.\n\n[2]: and spread are indeed different. But shouldn't affect our uses here.\n\n[3]: I haven't found any clear documentation about this behaviour regarding and . If anyone wants to chime in, that'd be great.\n\n[4]: The Vue docs stress the importance of one-way bind. Evan himself (creator of Vue) even provides examples about how to use with objects (in Vue 2, but the principles still apply).\n\nI feel it's also important to note later in the same thread Evan suggests objects that are nested more than 1-level are considered misuse of ."
    },
    {
        "link": "https://stackoverflow.com/questions/54564943/vuejs-conditional-component-mouse-events",
        "document": "New to Vue and frameworks in general, and may have my thinking not very \"Vue-like\".\n\nTrying to make a \"super\" button component that takes a prop, which dictates the buttons behavior so I only have to maintain one button component. The ideal form when implementing would like something like this...\n\nWhere prop could be or .\n\nI have a basic set of event emitters/methods and listeners that work regardless of the and simply makes the buttons state high or low / on or off using another prop .\n\nThe problem is trying to conditionally setup the mouse events depending on the . While figuring out the logic, I used the syntax to setup the mouse events etc. and everything worked great by itself. For example, the events for a button during testing looked like this...\n\nHowever, a simple toggle button looked more like this...\n\nObviously there is a bit of conflict there.\n\nMy attempted work around was to use a switch statement in that would take as the expression and conditionally register the appropriate mouse events...\n\nWhile switch itself is working, I can't figure out how to attach the mouse events in this context. I can attach a custom event no problem using...\n\nbut trying do something like...\n\nDoes not work, nor can I figure out any way to write it out that creates the same functionality as let alone or other built-in events.\n\nHow do you write out the syntax or syntax, for built-in events (click, mousedown, mouseup, etc.), using syntax, so the events actually fire?"
    },
    {
        "link": "https://katesmithyeah.medium.com/the-simplest-drag-and-drop-component-on-vue-js-3205d9f8791a",
        "document": "Sometimes it is more reasonable to do something from scratch instead of researching someoneâ€™s component API. For me, the theme of drag and drop mechanics wasnâ€™t quite clear so I decided to make my own for digging it out.\n\nLetâ€™s assume I have some array with items and the item is an object with title property.\n\nThe drag and drop mechanics lie on few browser events: mousedown, mousemove and mouseover. First of all, we need to connect these three events with corresponding drag and drop behavior stages: you click on element to drag it, dragging itself, dropping.\n\nOn the dragStart we should define which element is dragging on, make it absolute and slightly â€œmagnetâ€ to the cursor. At this moment we should have three methods:\n\nThe magical number 12 marks in my example the center of â€œdrag and dropâ€ icon. You should correct it for your styles and markdown. Now how do we handle draggableIndex, dragTop and dragLeft in a template?\n\nAt this step, we see how the selected item is â€œmagnetizedâ€ to the cursor and following it until we drop it. After dropping the item should go to its initial position, as we havenâ€™t calculated and saved the rearrange.\n\nFor this purpose, we need to create reorderedList variable, where we will store the changed data until the dragStop. On the dragStop, we will assign reorderedList to our initial items.\n\n// get all rendered list items\n\n // and their coordinates\n\n this.$refs.li.forEach((elem, i) => {\n\n // ignore dragging element \n\n if (i !== this.draggableIndex) {\n\n if (elem.offsetTop < event.pageY \n\n && i > this.draggableIndex) { // if we are here, that means\n\n // that element moved up \n\n reorderedList[i - 1] = this.items[i];\n\n if (lastI === -1 || lastI < i) {\n\n lastI = i;\n\n }\n\n } else if (elem.offsetTop > event.pageY \n\n && i < this.draggableIndex) { // if we are here, that means\n\n // that element moved down\n\n reorderedList[i + 1] = this.items[i];\n\n if (lastI === -1 || lastI > i) {\n\n lastI = i;\n\n }\n\n } else {\n\n // otherwise position doesn't change\n\n reorderedList[i] = this.items[i];\n\n }\n\n }\n\n }); // if positions changed - we should reassign items\n\n if (lastI !== -1) {\n\n reorderedList[lastI] = this.items[this.draggableIndex];\n\n this.reorderedList = Object.assign([], reorderedList, reorderedList);\n\n }\n\n this.dragLeft = event.pageX - 16;\n\n this.dragTop = event.pageY - 16;\n\n }\n\n },\n\n myDragStop() {\n\n this.draggableIndex = -1;\n\n this.dragLeft = 0;\n\n this.dragTop = 0;\n\n \n\n this.items = Object.assign([], this.reorderedList, this.reorderedList);\n\n }\n\n ...\n\nAnd voilÃ ! Youâ€™ve got the shortest and simplest drag and drop ever! ðŸ¤—"
    },
    {
        "link": "https://stackoverflow.com/questions/66788019/vuejs-dragging-an-element-on-occasion-causes-it-to-stick-to-the-mouse-pointer",
        "document": "I have a div (which holds a Zoom iFrame) which I would like to move around the screen. However... on occasion if the user is being jerky with the mouse, it sticks to the pointer and the only way you can fix that is by refreshing the page.\n\nIs that something anyone else has experienced and how did you solve it?\n\nI would imagine its something to do with my Javascript portion and how I am listening for some events.\n\nEDIT: Wanted to add that the below code was basically adjusted for Vue from this article: https://javascript.info/mouse-drag-and-drop"
    },
    {
        "link": "https://vuejs.org/guide/essentials/event-handling",
        "document": "We can use the directive, which we typically shorten to the symbol, to listen to DOM events and run some JavaScript when they're triggered. The usage would be or with the shortcut, .\n\nThe handler value can be one of the following:\nâ€¢ None Inline handlers: Inline JavaScript to be executed when the event is triggered (similar to the native attribute).\nâ€¢ None Method handlers: A property name or path that points to a method defined on the component.\n\nInline handlers are typically used in simple cases, for example:\n\nThe logic for many event handlers will be more complex though, and likely isn't feasible with inline handlers. That's why can also accept the name or path of a component method you'd like to call.\n\nA method handler automatically receives the native DOM Event object that triggers it - in the example above, we are able to access the element dispatching the event via .\n\nThe template compiler detects method handlers by checking whether the value string is a valid JavaScript identifier or property access path. For example, , and are treated as method handlers, while and are treated as inline handlers.\n\nInstead of binding directly to a method name, we can also call methods in an inline handler. This allows us to pass the method custom arguments instead of the native event:\n\nSometimes we also need to access the original DOM event in an inline handler. You can pass it into a method using the special variable, or use an inline arrow function:\n\nIt is a very common need to call or inside event handlers. Although we can do this easily inside methods, it would be better if the methods can be purely about data logic rather than having to deal with DOM event details.\n\nTo address this problem, Vue provides event modifiers for . Recall that modifiers are directive postfixes denoted by a dot.\n\nThe , , and modifiers mirror the options of the native method:\n\nThe modifier is typically used with touch event listeners for improving performance on mobile devices.\n\nWhen listening for keyboard events, we often need to check for specific keys. Vue allows adding key modifiers for or when listening for key events:\n\nYou can directly use any valid key names exposed via as modifiers by converting them to kebab-case.\n\nIn the above example, the handler will only be called if is equal to .\n\nVue provides aliases for the most commonly used keys:\n\nYou can use the following modifiers to trigger mouse or keyboard event listeners only when the corresponding modifier key is pressed:\n\nThe modifier allows control of the exact combination of system modifiers needed to trigger an event.\n\nThese modifiers restrict the handler to events triggered by a specific mouse button.\n\nNote, however, that , , and modifier names are based on the typical right-handed mouse layout, but in fact represent \"main\", \"secondary\", and \"auxiliary\" pointing device event triggers, respectively, and not the actual physical buttons. So that for a left-handed mouse layout the \"main\" button might physically be the right one but would trigger the modifier handler. Or a trackpad might trigger the handler with a one-finger tap, the handler with a two-finger tap, and the handler with a three-finger tap. Similarly, other devices and event sources generating \"mouse\" events might have trigger modes that are not related to \"left\" and \"right\" whatsoever."
    },
    {
        "link": "https://github.com/rhwilr/vue-nestable",
        "document": "\nâ€¢ Reorder items by dragging them above another item\nâ€¢ Everything is configurable: item identifier, max nesting level, threshold for nesting\n\nUse the plugin in your app:\n\nYou can also import the components on-demand, if you wish to do so:\n\nYou only need two components: which renders the list and which indicates the area the user can drag the item by.\n\nImportant Note: Each item must have a unique property and it must be a valid css class name. It can not contain a , , , or other special characters that are invalid in a css class name.\n\nBy default, vue-nestable comes without any styling. Which means you can customize the appearance completely to your needs. However, if you want you can take a look at the style used in the demo: example/assets/vue-nestable.css\n\nThe following props can be passed to the Component:\n\nThe Component has two slots that can be used to render items and a placeholder. See Example for an example on how to use them.\n\nEvents are triggered when an item was moved or when a drag operation was completed. When you use to bind your data, the event will automatically be handled.\n\nHooks allow you to get finer controll over which items can be moved or take action when a specific item is moved.\n\nHooks are passed as an Object to the prop. The object defines a key with the hook name and a function that will be called when the hook fires.\n\nLook here of an example on how to prevent one item from being moved."
    },
    {
        "link": "https://vuejs.org/guide/extras/animation",
        "document": "Vue provides the and components for handling enter / leave and list transitions. However, there are many other ways of using animations on the web, even in a Vue application. Here we will discuss a few additional techniques.\n\nFor elements that are not entering / leaving the DOM, we can trigger animations by dynamically adding a CSS class:\n\nSome transition effects can be applied by interpolating values, for instance by binding a style to an element while an interaction occurs. Take this example for instance:\n\nIn addition to color, you can also use style bindings to animate transform, width, or height. You can even animate SVG paths using spring physics - after all, they are all attribute data bindings:\n\nWith some creativity, we can use watchers to animate anything based on some numerical state. For example, we can animate the number itself:"
    },
    {
        "link": "https://stackoverflow.com/questions/67670235/how-can-i-animate-an-element-added-dynamically-to-a-list-in-vue-js-3",
        "document": "I am working on a small Todo App with Vue 3. I want the appending of a new to-do item to be smooth, not instantaneous.\n\nFor this purpose, I have added the class active to the latest to-do item:\n\nIn the CSS I have:\n\nIt does not work as I hoped. It might be because the CSS is loaded late, it might be for another reason I was unable to figure out.\n\nWhat is the easiest solution to this problem?"
    },
    {
        "link": "https://vuejs.org/guide/built-ins/transition",
        "document": "Vue offers two built-in components that can help work with transitions and animations in response to changing state:\nâ€¢ None for applying animations when an element or component is entering and leaving the DOM. This is covered on this page.\nâ€¢ None for applying animations when an element or component is inserted into, removed from, or moved within a list. This is covered in the next chapter.\n\nAside from these two components, we can also apply animations in Vue using other techniques such as toggling CSS classes or state-driven animations via style bindings. These additional techniques are covered in the Animation Techniques chapter.\n\nis a built-in component: this means it is available in any component's template without having to register it. It can be used to apply enter and leave animations on elements or components passed to it via its default slot. The enter or leave can be triggered by one of the following:\n\nThis is an example of the most basic usage:\n\nWhen an element in a component is inserted or removed, this is what happens:\nâ€¢ None Vue will automatically sniff whether the target element has CSS transitions or animations applied. If it does, a number of CSS transition classes will be added / removed at appropriate timings.\nâ€¢ None If there are listeners for JavaScript hooks, these hooks will be called at appropriate timings.\nâ€¢ None If no CSS transitions / animations are detected and no JavaScript hooks are provided, the DOM operations for insertion and/or removal will be executed on the browser's next animation frame.\n\nThere are six classes applied for enter / leave transitions.\nâ€¢ None : Starting state for enter. Added before the element is inserted, removed one frame after the element is inserted.\nâ€¢ None : Active state for enter. Applied during the entire entering phase. Added before the element is inserted, removed when the transition/animation finishes. This class can be used to define the duration, delay and easing curve for the entering transition.\nâ€¢ None : Ending state for enter. Added one frame after the element is inserted (at the same time is removed), removed when the transition/animation finishes.\nâ€¢ None : Starting state for leave. Added immediately when a leaving transition is triggered, removed after one frame.\nâ€¢ None : Active state for leave. Applied during the entire leaving phase. Added immediately when a leaving transition is triggered, removed when the transition/animation finishes. This class can be used to define the duration, delay and easing curve for the leaving transition.\nâ€¢ None : Ending state for leave. Added one frame after a leaving transition is triggered (at the same time is removed), removed when the transition/animation finishes.\n\nand give us the ability to specify different easing curves for enter / leave transitions, which we'll see an example of in the following sections.\n\nA transition can be named via the prop:\n\nFor a named transition, its transition classes will be prefixed with its name instead of . For example, the applied class for the above transition will be instead of . The CSS for the fade transition should look like this:\n\nis most commonly used in combination with native CSS transitions, as seen in the basic example above. The CSS property is a shorthand that allows us to specify multiple aspects of a transition, including properties that should be animated, duration of the transition, and easing curves.\n\nHere is a more advanced example that transitions multiple properties, with different durations and easing curves for enter and leave:\n\nNative CSS animations are applied in the same way as CSS transitions, with the difference being that is not removed immediately after the element is inserted, but on an event.\n\nFor most CSS animations, we can simply declare them under the and classes. Here's an example:\n\nYou can also specify custom transition classes by passing the following props to :\n\nThese will override the conventional class names. This is especially useful when you want to combine Vue's transition system with an existing CSS animation library, such as Animate.css:\n\nUsing Transitions and Animations Together â€‹\n\nVue needs to attach event listeners in order to know when a transition has ended. It can either be or , depending on the type of CSS rules applied. If you are only using one or the other, Vue can automatically detect the correct type.\n\nHowever, in some cases you may want to have both on the same element, for example having a CSS animation triggered by Vue, along with a CSS transition effect on hover. In these cases, you will have to explicitly declare the type you want Vue to care about by passing the prop, with a value of either or :\n\nAlthough the transition classes are only applied to the direct child element in , we can transition nested elements using nested CSS selectors:\n\nWe can even add a transition delay to the nested element on enter, which creates a staggered enter animation sequence:\n\nHowever, this creates a small issue. By default, the component attempts to automatically figure out when the transition has finished by listening to the first or event on the root transition element. With a nested transition, the desired behavior should be waiting until the transitions of all inner elements have finished.\n\nIn such cases you can specify an explicit transition duration (in milliseconds) using the prop on the component. The total duration should match the delay plus transition duration of the inner element:\n\nTry it in the Playground\n\nIf necessary, you can also specify separate values for enter and leave durations using an object:\n\nYou may notice that the animations shown above are mostly using properties like and . These properties are efficient to animate because:\nâ€¢ None They do not affect the document layout during the animation, so they do not trigger expensive CSS layout calculation on every animation frame.\nâ€¢ None Most modern browsers can leverage GPU hardware acceleration when animating .\n\nIn comparison, properties like or will trigger CSS layout, so they are much more expensive to animate, and should be used with caution.\n\nYou can hook into the transition process with JavaScript by listening to events on the component:\n\nThese hooks can be used in combination with CSS transitions / animations or on their own.\n\nWhen using JavaScript-only transitions, it is usually a good idea to add the prop. This explicitly tells Vue to skip auto CSS transition detection. Aside from being slightly more performant, this also prevents CSS rules from accidentally interfering with the transition:\n\nWith , we are also fully responsible for controlling when the transition ends. In this case, the callbacks are required for the and hooks. Otherwise, the hooks will be called synchronously and the transition will finish immediately.\n\nHere's a demo using the GSAP library to perform the animations. You can, of course, use any other animation library you want, for example Anime.js or Motion One:\n\nTransitions can be reused through Vue's component system. To create a reusable transition, we can create a component that wraps the component and passes down the slot content:\n\nNow can be imported and used just like the built-in version:\n\nIf you also want to apply a transition on the initial render of a node, you can add the prop:\n\nIn addition to toggling an element with / , we can also transition between two elements using / / , as long as we make sure that there is only one element being shown at any given moment:\n\nTry it in the Playground\n\nIn the previous example, the entering and leaving elements are animated at the same time, and we had to make them to avoid the layout issue when both elements are present in the DOM.\n\nHowever, in some cases this isn't an option, or simply isn't the desired behavior. We may want the leaving element to be animated out first, and for the entering element to only be inserted after the leaving animation has finished. Orchestrating such animations manually would be very complicated - luckily, we can enable this behavior by passing a prop:\n\nalso supports , although it's much less frequently used.\n\ncan also be used around dynamic components:\n\nprops like can also be dynamic! It allows us to dynamically apply different transitions based on state change:\n\nThis can be useful when you've defined CSS transitions / animations using Vue's transition class conventions and want to switch between them.\n\nYou can also apply different behavior in JavaScript transition hooks based on the current state of your component. Finally, the ultimate way of creating dynamic transitions is through reusable transition components that accept props to change the nature of the transition(s) to be used. It may sound cheesy, but the only limit really is your imagination.\n\nSometimes you need to force the re-render of a DOM element in order for a transition to occur.\n\nTake this counter component for example:\n\nIf we had excluded the attribute, only the text node would be updated and thus no transition would occur. However, with the attribute in place, Vue knows to create a new element whenever changes and thus the component has 2 different elements to transition between."
    },
    {
        "link": "https://keefdrive.medium.com/tips-and-tricks-to-create-smooth-animation-in-vue-3-71b8b20e6400",
        "document": "Animations can give a wow factor to your web application if done right. Smoother the animation, the more likely the user will stay on your site longer. But if the animation is inappropriate or choppy in its motion then users get frustrated and leave very quickly.\n\nWhen it comes to web application frameworks and animation, One thing that developers like about Vue.js is the fact that Vuejs has support for animations built-in, thatâ€™s right no need to fiddle around and research 3rd party libraries. You just need to install Vue.js and youâ€™re off!.\n\nIn this article, we will be looking at some tips and tricks you can use in Vue3 to create a smooth animation. There is also a video tutorial that gives a step by step guide in using these tips and tricks to create a friend list UI.\n\nVideo tutorial â€” How to create a smooth animated friend list in Vue 3\n\nHow does Vue.js make it easy to add animations?\n\nVuejs supports transitions as a standard feature. It does this by providing some animation hooks, which dynamically add css classes at the appropriate times, ie when you add or remove items. Transitions are based on two-state animation, where you have a start animation state and an end animation state and you apply some sort of motion algorithm to make a transition from the start state to end state.\n\nYou dont have to worry about the motion algorithm, that's all taken care off in the browser.\n\nUsually states change when something is added or removed from the dom or when a property of an element is changed like color or position. Vue 3 provides Hooks for components when such changes take place in the DOM. This is achieved by using the built-in <transition> and <transition-group> component wrappers, as shown in the example below:\n\nIn the above example, the <p> tag with the message â€œThis will added and removed from the DOMâ€ is wrapped around a <transition> tag. Also note that we have the V-If=â€showâ€ as an attribute. This is the mechanism that allows us to decide if this tag is to be rendered or not, changing the value of show to false will remove it from the display.\n\nIf you look closer at the wrapper transition tag you will see that we also gave a name attribute which is set to fade, as shown here: <transition name=â€fadeâ€>. Under the hood, the transition component provides some hooks that do some magic to make the animation possible. These hooks will add enter-leave css classes, these are prefixed with the name attribute that you specified in the transition tag. In this example these dynamically generated classes are : .fade-enter-active, .fade-leave-active,.fade-enter-from, .fade-leave-to.\n\nNow let us apply this to lists by using <transition-group>\n\nYou can take this further by animating a group of items like a list. Please see the example below:\n\nHere we have some methods associated with the buttons to add and remove items. The key part in the template is the block of code for rendering the list when items are added and deleted :\n\nWe are using <transition-group>.We are replacing a normal <ul> with <transition-group name=â€listâ€ tag=â€ulâ€>. In the transition tag we have a tag attribute which we set to â€œulâ€. This makes sure that we are rendering a ul. And we also specify the name attribute as â€œlistâ€. Knowing this we can add the animation style properties for the dynamically generated classes as shown below:\n\nThe property \"transition: all 1s ease;\" will apply a transition to all properties to the active state classes, but we only animate the opacity and y position. We are also applying the built in ease function to define the type of smooth animation we want. The class .\"list-enter-from\" is the class for the start position when we add an item, and the class \".list-leave-to\" is the end position when we remove an item.\n\nNow for more advanced animation, we use key frames.\n\nWe can use keyframes to apply intermediate states between our start state and end state to achieve advanced animation. In the example below, we add an effect of the item bouncing in and out.\n\nSo our styling for the Vue generated animation state classes becomes:\n\nTo bounce out we use the same animation in reverse. That is why we have the keyword reverse in the .list-leave-active class :\n\nAnimation is a tricky area to understand because you are dealing with states and states changes over a timeline. You can read more about how VueJs implements the transition classes here https://v3.vuejs.org/guide/transitions-enterleave.html#transitioning-single-elements-components"
    },
    {
        "link": "https://blog.openreplay.com/dynamic-list-transitions-in-vue",
        "document": "Vue.js is a powerful JavaScript framework that enables developers to easily create dynamic list transitions. This article will review the various types of Vue.js list transitions and how to use them in your applications. Weâ€™ll also go over some best practices for creating smooth and efficient list transitions. By the end of this article, youâ€™ll better understand how to use Vue.js to create dynamic list transitions.\n\nIn Vue.js, displaying a dynamic list entails creating a data object containing a list of items and then rendering the list with the v-for directive. The data object can be written as an array of objects, each containing data for a single item. This could be a list of names and ages, for example:\n\nThe v-for directive is then used to render the list. This directive enables developers to iterate over a data set and dynamically render a list of items. This can be used to generate an array of items or to display data from an API. The directive can be applied to a template element and requires a specific syntax like this:\n\nImage Credit For example, if we have an array of names, we can iterate over the array and generate a list of names and corresponding ages using the directive:\n\nThis would then generate a list of three items, each containing the name and age of a data object item. The attribute is used to set a unique key for each item, which Vue needs to keep track of each item. Hereâ€™s the result:\n\nThe dynamic list can be further customized by adding items to the data object.\n\nWhen building a dynamic list in Vue.js, it is often desirable to add some visual transition effects when elements are added, updated, or removed. This not only enhances the overall user experience but also provides visual cues that help the user understand the changes that are happening on the screen. Vue.js makes creating dynamic list transitions simple, allowing you to add and remove elements from a list without manually updating the page. It also includes several built-in list transitions, such as the component, which makes it simple to create transitions like , , and . Here are the steps you need to add transition effects to a dynamic list in Vue.js.\n\nIn Vue.js, You can use the component to wrap the list elements that need to be animated. A special Vue component provides a simple way to apply CSS transitions and animations to elements. Import the component into your projectâ€™s directory like this:\n\nThen, create a new component that wraps the list items with a element:\n\nAdd this to your components object so it can be referenced later in your app like this:\n\nNow, when adding an item to the list, we can wrap each list item within our newly created Component like this:\n\nAfter wrapping the list in the transition component, you can then add CSS transition or animation stylings to the transition component. You can achieve this by adding the appropriate CSS classes to the transition component. The CSS classes can be created to control the animation properties such as duration, easing, and delay. For example, if you want to animate the list elements using a fade-in effect, you can create a CSS class like this:\n\nThen, in the transition component, you can specify the CSS classes to be used like this:\n\nDynamic list transitions in Vue.js is a powerful feature that provides a visual and smooth way of rendering data. This can improve the overall user experience and provide a more interactive feel to your application. Here are some examples of dynamic list transitions in Vue.js:\nâ€¢ Fade in/out transition: This type of transition causes newly added list items to gradually appear (fade in) or disappear (fade out) from view rather than simply appearing or disappearing abruptly. This creates a smooth, visually appealing effect.\n\nHereâ€™s a sample code on how to apply a fade in/out transition to a dynamic list in Vue.js:\n\nIn the code above, we created a transition-group component with the name attribute set to fade. This will apply the fade transition to all elements inside the . Weâ€™ve also set the tag attribute to so that the will be rendered as an unordered list. Next, we used the v-for directive to loop through the items array and display each item as a element. We also set the key attribute to index so Vue can track each item in the array. The fade transition is defined in the CSS section of the code. The and classes are applied during the transition, while the and classes are applied when the element enters or leaves the list.\nâ€¢ Slide up/down transition: This type of transition involves list items sliding up or down on the screen when added or removed. This gives the appearance of items being pushed out of the way to make room for new items or vice versa.\n\nHere is an example of a slide up/down transition in Vue.js for dynamic list transitions:\n\nIn the above example, we use the component with the name to wrap a list of items. The and classes define the transition duration and easing for entering and leaving items. The and classes set the initial state of entering and leaving items with a vertical translate and zero opacity. Hereâ€™s the result:\nâ€¢ Rotate in/out transition: This type of transition involves list items rotating in or out of view when added or removed. This can add a playful, dynamic touch to your interface and can be especially effective when used in conjunction with other animations.\n\nIn this example, a transition component is used to wrap the element that needs to be animated. The name attribute is set to rotate, corresponding to the CSS class names. The v-if directive is used to toggle the visibility of the element. The and classes define the transition properties in the CSS. The and classes specify the styles for the entering and leaving elements, respectively. In this case, the element will rotate 180 degrees and fade out. Hereâ€™s the result:\n\nIn the following example, we will translate a list of programming languages and include a shuffle button that, when clicked, activates a shuffle action in the list. Hereâ€™s the code\n\nCreating dynamic list transitions in Vue.js involves several steps, including setting up the component, defining the transition, and applying the animation. Itâ€™s important to remember tips for customizing and optimizing the transition effects, such as using CSS transitions or animations and creating reusable transitions. For those wanting to learn more about Vue.js and dynamic transitions, numerous resources are available, including the official Vue.js documentation, online tutorials, and forums. In conclusion, adding transition effects to the dynamic list in Vue.js is a simple process that involves wrapping the list in the transition component and adding CSS transitions or animations to the transition component. This will enhance the overall user experience and provide visual cues that help the user understand the changes happening on the screen. I hope this article becomes valuable to you Happy coding!"
    }
]