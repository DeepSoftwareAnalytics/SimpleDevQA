[
    {
        "link": "https://coin-or.github.io/pulp",
        "document": "PuLP is an linear and mixed integer programming modeler written in Python.\n\nWith PuLP, it is simple to create MILP optimisation problems and solve them with the latest open-source (or proprietary) solvers. PuLP can generate MPS or LP files and call solvers such as GLPK, COIN-OR CLP/CBC, CPLEX, GUROBI, MOSEK, XPRESS, CHOCO, MIPCL, HiGHS, SCIP/FSCIP.\n\nHere are some ways to get started using PuLP:\n‚Ä¢ None for instructions about installing PuLP see Installing PuLP at Home.\n‚Ä¢ None If you‚Äôre new to Python and optimisation we recommend that you read Optimisation Concepts, The Optimisation Process, and the Basic Python Coding.\n‚Ä¢ None If you want to jump right in then start reading the case studies starting with A Blending Problem.\n\nThe full PuLP API documentation is available, and useful functions are also explained in the case studies. The case studies are in order, so the later case studies will assume you have (at least) read the earlier case studies. However, we will provide links to any relevant information you will need."
    },
    {
        "link": "https://pypi.org/project/PuLP",
        "document": "A required part of this site couldn‚Äôt load. This may be due to a browser extension, network issues, or browser settings. Please check your connection, disable any ad blockers, or try using a different browser."
    },
    {
        "link": "https://coin-or.github.io/pulp/main/includeme.html",
        "document": "PuLP is an linear and mixed integer programming modeler written in Python. With PuLP, it is simple to create MILP optimisation problems and solve them with the latest open-source (or proprietary) solvers. PuLP can generate MPS or LP files and call solvers such as GLPK, COIN-OR CLP/CBC, CPLEX, GUROBI, MOSEK, XPRESS, CHOCO, MIPCL, HiGHS, SCIP/FSCIP.\n\nThe documentation for PuLP can be found here.\n\nPuLP is part of the COIN-OR project.\n\nThe easiest way to install PuLP is with . If is available on your system, type: Otherwise follow the download instructions on the PyPi page.\n\nUse to create new variables. To create a variable x with 0 ‚â§ x ‚â§ 3: To create a binary variable, y, with values either 0 or 1: Use to create new problems. Create a problem called ‚ÄúmyProblem‚Äù like so: Combine variables in order to create expressions and constraints, and then add them to the problem.: An expression is a constraint without a right-hand side (RHS) sense (one of , or ). If you add an expression to a problem, it will become the objective: To solve the problem with the default included solver: If you want to try another solver to solve the problem: Display the status of the solution: You can get the value of the variables using . ex:\n‚Ä¢ None ‚Äì Variables that are added into constraints in the LP problem\n‚Ä¢ None ‚Äì A special type of constraint for constructing column of the model in column-wise modelling\n‚Ä¢ None ‚Äì Finds the value of a variable or expression\n‚Ä¢ None ‚Äì Given a list of the form [a1*x1, a2*x2, ‚Ä¶, an*xn] will construct a linear expression to be used as a constraint or variable\n‚Ä¢ None ‚Äì Given two lists of the form [a1, a2, ‚Ä¶, an] and [x1, x2, ‚Ä¶, xn] will construct a linear expression to be used as a constraint or variable\n\nSeveral tutorial are given in documentation and pure code examples are available in examples/ directory . The examples use the default solver (CBC). To use other solvers they must be available (installed and accessible). For more information on how to do that, see the guide on configuring solvers."
    },
    {
        "link": "https://optimization-online.org/wp-content/uploads/2011/09/3178.pdf",
        "document": ""
    },
    {
        "link": "https://techgoggler.com/computer-engineering/linear-programming-with-python-and-pulp",
        "document": "From the official page:\n\nWe want to give a short example of how to solve a linear programming problem with Python. Among the options we chose the PuLP module developed by Stuart Mitchell.\n\nA mechanics company can produce 2 different products using 4 departments. The maximum annual production capacity of the 4 departments in relation to the two types of product is the following:\n\nThis means, for example, that the moulding department has a maximum production capacity of 25,000 Product_A units if it operates exclusively on this product. The same department has a maximum capacity of 35,000 units if it only works for Product_B.\n\nWhat is the annual production (production mix) that maximizes the total net profit?\n\nPulp is a Python module that allows users to describe and solve linear programming problems. We found it very interesting because Pulp works entirely within the syntax and idioms of Python and provides Python objects that represent problems of optimization and decision variables also allowing constraints to be expressed in a way that is very similar to the original mathematical model.\n\nPlease refer to the documentation and examples on the use of PuLP."
    },
    {
        "link": "https://avinashnavlani.medium.com/solving-linear-programming-using-python-pulp-e3b658b60fa9",
        "document": "Learn how to use Python PuLP to solve linear programming problems.\n\nAs a Senior operation manager, your job is to optimize scarce resources, improve productivity, reduce cost, and maximize profit. For example, you want to maximize the profit of the manufacturing unit with constraints like labor working hours, machine capacity, and available raw material. Another example is that a marketing manager wants to allocate the optimum budget among alternative advertising media channels such as radio, television, newspapers, and magazines. Such problems can be considered optimization problems.\n\nOptimization problems can be represented as a mathematical function that captures the tradeoff between the decisions that need to be made. The feasible solutions to such problems depend upon constraints specified in mathematical form.\n\nLinear programming is the core of any optimization problem. It is used to solve a wide variety of planning and supply chain optimization. Linear programming was introduced by George Dantzig in 1947. It uses linear algebra to determine the optimal allocation of scarce resources."
    },
    {
        "link": "https://realpython.com/linear-programming-python",
        "document": "Linear programming is a set of techniques used in mathematical programming, sometimes called mathematical optimization, to solve systems of linear equations and inequalities while maximizing or minimizing some linear function. It‚Äôs important in fields like scientific computing, economics, technical sciences, manufacturing, transportation, military, management, energy, and so on.\n\nThe Python ecosystem offers several comprehensive and powerful tools for linear programming. You can choose between simple and complex tools as well as between free and commercial ones. It all depends on your needs.\n‚Ä¢ What linear programming is and why it‚Äôs important\n‚Ä¢ Which Python tools are suitable for linear programming\n‚Ä¢ How to build a linear programming model in Python\n‚Ä¢ How to solve a linear programming problem with Python\n\nYou‚Äôll first learn about the fundamentals of linear programming. Then you‚Äôll explore how to implement linear programming techniques in Python. Finally, you‚Äôll look at resources and libraries to help further your linear programming journey.\n\nIn this section, you‚Äôll see two examples of linear programming problems:\n‚Ä¢ A small problem that illustrates what linear programming is\n‚Ä¢ A practical problem related to resource allocation that illustrates linear programming concepts in a real-world scenario You‚Äôll use Python to solve these two problems in the next section. Consider the following linear programming problem: You need to find x and y such that the red, blue, and yellow inequalities, as well as the inequalities x ‚â• 0 and y ‚â• 0, are satisfied. At the same time, your solution must correspond to the largest possible value of z. The independent variables you need to find‚Äîin this case x and y‚Äîare called the decision variables. The function of the decision variables to be maximized or minimized‚Äîin this case z‚Äîis called the objective function, the cost function, or just the goal. The inequalities you need to satisfy are called the inequality constraints. You can also have equations among the constraints called equality constraints. This is how you can visualize the problem: The red line represents the function 2x + y = 20, and the red area above it shows where the red inequality is not satisfied. Similarly, the blue line is the function ‚àí4x + 5y = 10, and the blue area is forbidden because it violates the blue inequality. The yellow line is ‚àíx + 2y = ‚àí2, and the yellow area below it is where the yellow inequality isn‚Äôt valid. If you disregard the red, blue, and yellow areas, only the gray area remains. Each point of the gray area satisfies all constraints and is a potential solution to the problem. This area is called the feasible region, and its points are feasible solutions. In this case, there‚Äôs an infinite number of feasible solutions. You want to maximize z. The feasible solution that corresponds to maximal z is the optimal solution. If you were trying to minimize the objective function instead, then the optimal solution would correspond to its feasible minimum. Note that z is linear. You can imagine it as a plane in three-dimensional space. This is why the optimal solution must be on a vertex, or corner, of the feasible region. In this case, the optimal solution is the point where the red and blue lines intersect, as you‚Äôll see later. Sometimes a whole edge of the feasible region, or even the entire region, can correspond to the same value of z. In that case, you have many optimal solutions. You‚Äôre now ready to expand the problem with the additional equality constraint shown in green: The equation ‚àíx + 5y = 15, written in green, is new. It‚Äôs an equality constraint. You can visualize it by adding a corresponding green line to the previous image: The solution now must satisfy the green equality, so the feasible region isn‚Äôt the entire gray area anymore. It‚Äôs the part of the green line passing through the gray area from the intersection point with the blue line to the intersection point with the red line. The latter point is the solution. If you insert the demand that all values of x must be integers, then you‚Äôll get a mixed-integer linear programming problem, and the set of feasible solutions will change once again: You no longer have the green line, only the points along the line where the value of x is an integer. The feasible solutions are the green points on the gray background, and the optimal one in this case is nearest to the red line. These three examples illustrate feasible linear programming problems because they have bounded feasible regions and finite solutions. A linear programming problem is infeasible if it doesn‚Äôt have a solution. This usually happens when no solution can satisfy all constraints at once. For example, consider what would happen if you added the constraint x + y ‚â§ ‚àí1. Then at least one of the decision variables (x or y) would have to be negative. This is in conflict with the given constraints x ‚â• 0 and y ‚â• 0. Such a system doesn‚Äôt have a feasible solution, so it‚Äôs called infeasible. Another example would be adding a second equality constraint parallel to the green line. These two lines wouldn‚Äôt have a point in common, so there wouldn‚Äôt be a solution that satisfies both constraints. A linear programming problem is unbounded if its feasible region isn‚Äôt bounded and the solution is not finite. This means that at least one of your variables isn‚Äôt constrained and can reach to positive or negative infinity, making the objective infinite as well. For example, say you take the initial problem above and drop the red and yellow constraints. Dropping constraints out of a problem is called relaxing the problem. In such a case, x and y wouldn‚Äôt be bounded on the positive side. You‚Äôd be able to increase them toward positive infinity, yielding an infinitely large z value. In the previous sections, you looked at an abstract linear programming problem that wasn‚Äôt tied to any real-world application. In this subsection, you‚Äôll find a more concrete and practical optimization problem related to resource allocation in manufacturing. Say that a factory produces four different products, and that the daily produced amount of the first product is x‚ÇÅ, the amount produced of the second product is x‚ÇÇ, and so on. The goal is to determine the profit-maximizing daily production amount for each product, bearing in mind the following conditions:\n‚Ä¢ The profit per unit of product is $20, $12, $40, and $25 for the first, second, third, and fourth product, respectively.\n‚Ä¢ Due to manpower constraints, the total number of units produced per day can‚Äôt exceed fifty.\n‚Ä¢ For each unit of the first product, three units of the raw material A are consumed. Each unit of the second product requires two units of the raw material A and one unit of the raw material B. Each unit of the third product needs one unit of A and two units of B. Finally, each unit of the fourth product requires three units of B.\n‚Ä¢ Due to the transportation and storage constraints, the factory can consume up to one hundred units of the raw material A and ninety units of B per day. The mathematical model can be defined like this: The objective function (profit) is defined in condition 1. The manpower constraint follows from condition 2. The constraints on the raw materials A and B can be derived from conditions 3 and 4 by summing the raw material requirements for each product. Finally, the product amounts can‚Äôt be negative, so all decision variables must be greater than or equal to zero. Unlike the previous example, you can‚Äôt conveniently visualize this one because it has four decision variables. However, the principles remain the same regardless of the dimensionality of the problem.\n\nIn this tutorial, you‚Äôll use two Python packages to solve the linear programming problem described above:\n‚Ä¢ SciPy is a general-purpose package for scientific computing with Python.\n‚Ä¢ PuLP is a Python linear programming API for defining problems and invoking external solvers. SciPy is straightforward to set up. Once you install it, you‚Äôll have everything you need to start. Its subpackage can be used for both linear and nonlinear optimization. PuLP allows you to choose solvers and formulate problems in a more natural way. The default solver used by PuLP is the COIN-OR Branch and Cut Solver (CBC). It‚Äôs connected to the COIN-OR Linear Programming Solver (CLP) for linear relaxations and the COIN-OR Cut Generator Library (CGL) for cuts generation. Another great open source solver is the GNU Linear Programming Kit (GLPK). Some well-known and very powerful commercial and proprietary solutions are Gurobi, CPLEX, and XPRESS. Besides offering flexibility when defining problems and the ability to run various solvers, PuLP is less complicated to use than alternatives like Pyomo or CVXOPT, which require more time and effort to master. To follow this tutorial, you‚Äôll need to install SciPy and PuLP. The examples below use version 1.4.1 of SciPy and version 2.1 of PuLP. You can install both using : You might need to run or to enable the default solvers for PuLP, especially if you‚Äôre using Linux or Mac: Optionally, you can download, install, and use GLPK. It‚Äôs free and open source and works on Windows, MacOS, and Linux. You‚Äôll see how to use GLPK (in addition to CBC) with PuLP later in this tutorial. On Windows, you can download the archives and run the installation files. On MacOS, you can use Homebrew: On Debian and Ubuntu, use to install and : On Fedora, use with : You might also find conda useful for installing GLPK: After completing the installation, you can check the version of GLPK: See GLPK‚Äôs tutorials on installing with Windows executables and Linux packages for more information. In this section, you‚Äôll learn how to use the SciPy optimization and root-finding library for linear programming. To define and solve optimization problems with SciPy, you need to import : Now that you have imported, you can start optimizing. Let‚Äôs first solve the linear programming problem from above: solves only minimization (not maximization) problems and doesn‚Äôt allow inequality constraints with the greater than or equal to sign (‚â•). To work around these issues, you need to modify your problem before starting optimization:\n‚Ä¢ Instead of maximizing z = x + 2y, you can minimize its negative(‚àíz = ‚àíx ‚àí 2y).\n‚Ä¢ Instead of having the greater than or equal to sign, you can multiply the yellow inequality by ‚àí1 and get the opposite less than or equal to sign (‚â§). After introducing these changes, you get a new system: This system is equivalent to the original and will have the same solution. The only reason to apply these changes is to overcome the limitations of SciPy related to the problem formulation. The next step is to define the input values: You put the values from the system above into the appropriate lists, tuples, or NumPy arrays:\n‚Ä¢ holds the coefficients from the objective function.\n‚Ä¢ holds the left-side coefficients from the inequality (red, blue, and yellow) constraints.\n‚Ä¢ holds the right-side coefficients from the inequality (red, blue, and yellow) constraints.\n‚Ä¢ holds the left-side coefficients from the equality (green) constraint.\n‚Ä¢ holds the right-side coefficients from the equality (green) constraint. Note: Please, be careful with the order of rows and columns! The order of the rows for the left and right sides of the constraints must be the same. Each row represents one constraint. The order of the coefficients from the objective function and left sides of the constraints must match. Each column corresponds to a single decision variable. The next step is to define the bounds for each variable in the same order as the coefficients. In this case, they‚Äôre both between zero and positive infinity: This statement is redundant because takes these bounds (zero to positive infinity) by default. Note: Instead of , you can use , , or . Finally, it‚Äôs time to optimize and solve your problem of interest. You can do that with : The parameter refers to the coefficients from the objective function. and are related to the coefficients from the left and right sides of the inequality constraints, respectively. Similarly, and refer to equality constraints. You can use to provide the lower and upper bounds on the decision variables. You can use the parameter to define the linear programming method that you want to use. There are three options:\n‚Ä¢ selects the interior-point method. This option is set by default.\n‚Ä¢ is the objective function value at the optimum (if found).\n‚Ä¢ is the status of the solution.\n‚Ä¢ is the number of iterations needed to finish the calculation.\n‚Ä¢ is the values of the slack variables, or the differences between the values of the left and right sides of the constraints.\n‚Ä¢ is an integer between and that shows the status of the solution, such as for when the optimal solution has been found.\n‚Ä¢ is a Boolean that shows whether the optimal solution has been found.\n‚Ä¢ is a NumPy array holding the optimal values of the decision variables. You can access these values separately: That‚Äôs how you get the results of optimization. You can also show them graphically: As discussed earlier, the optimal solutions to linear programming problems lie at the vertices of the feasible regions. In this case, the feasible region is just the portion of the green line between the blue and red lines. The optimal solution is the green square that represents the point of intersection between the green and red lines. If you want to exclude the equality (green) constraint, just drop the parameters and from the call: The solution is different from the previous case. You can see it on the chart: In this example, the optimal solution is the purple vertex of the feasible (gray) region where the red and blue constraints intersect. Other vertices, like the yellow one, have higher values for the objective function. You can use SciPy to solve the resource allocation problem stated in the earlier section: As in the previous example, you need to extract the necessary vectors and matrix from the problem above, pass them as the arguments to , and get the results: The result tells you that the maximal profit is and corresponds to x‚ÇÅ = 5 and x‚ÇÉ = 45. It‚Äôs not profitable to produce the second and fourth products under the given conditions. You can draw several interesting conclusions here:\n‚Ä¢ The third product brings the largest profit per unit, so the factory will produce it the most.\n‚Ä¢ The first slack is , which means that the values of the left and right sides of the manpower (first) constraint are the same. The factory produces units per day, and that‚Äôs its full capacity.\n‚Ä¢ The second slack is because the factory consumes 60 units of raw material A (15 units for the first product plus 45 for the third) out of a potential units.\n‚Ä¢ The third slack is , which means that the factory consumes all units of the raw material B. This entire amount is consumed for the third product. That‚Äôs why the factory can‚Äôt produce the second or fourth product at all and can‚Äôt produce more than units of the third product. It lacks the raw material B. is and is , indicating that the optimization problem was successfully solved with the optimal feasible solution. SciPy‚Äôs linear programming capabilities are useful mainly for smaller problems. For larger and more complex problems, you might find other libraries more suitable for the following reasons:\n‚Ä¢ SciPy doesn‚Äôt provide classes or functions that facilitate model building. You have to define arrays and matrices, which might be a tedious and error-prone task for large problems.\n‚Ä¢ SciPy doesn‚Äôt allow you to define maximization problems directly. You must convert them to minimization problems.\n‚Ä¢ SciPy doesn‚Äôt allow you to define constraints using the greater-than-or-equal-to sign directly. You must use the less-than-or-equal-to instead. Fortunately, the Python ecosystem offers several alternative solutions for linear programming that are very useful for larger problems. One of them is PuLP, which you‚Äôll see in action in the next section. PuLP has a more convenient linear programming API than SciPy. You don‚Äôt have to mathematically modify your problem or use vectors and matrices. Everything is cleaner and less prone to errors. As usual, you start by importing what you need: Now that you have PuLP imported, you can solve your problems. You‚Äôll now solve this system with PuLP: The first step is to initialize an instance of to represent your model: You use the parameter to choose whether to perform minimization ( or , which is the default) or maximization ( or ). This choice will affect the result of your problem. Once that you have the model, you can define the decision variables as instances of the class: You need to provide a lower bound with because the default value is negative infinity. The parameter defines the upper bound, but you can omit it here because it defaults to positive infinity. The optional parameter defines the category of a decision variable. If you‚Äôre working with continuous variables, then you can use the default value . You can use the variables and to create other PuLP objects that represent linear expressions and constraints: When you multiply a decision variable with a scalar or build a linear combination of multiple decision variables, you get an instance of that represents a linear expression. Note: You can add or subtract variables or expressions, and you can multiply them with constants because PuLP classes implement some of the Python special methods that emulate numeric types like , , and . These methods are used to customize the behavior of operators like , , and . Similarly, you can combine linear expressions, variables, and scalars with the operators , , or to get instances of pulp.LpConstraint that represent the linear constraints of your model. Note: It‚Äôs also possible to build constraints with the rich comparison methods , , and that define the behavior of the operators , , and . Having this in mind, the next step is to create the constraints and objective function as well as to assign them to your model. You don‚Äôt need to create lists or matrices. Just write Python expressions and use the operator to append them to the model: # Add the constraints to the model In the above code, you define tuples that hold the constraints and their names. allows you to add constraints to a model by specifying them as tuples. The first element is a instance. The second element is a human-readable name for that constraint. Setting the objective function is very similar: # Add the objective function to the model Alternatively, you can use a shorter notation: # Add the objective function to the model Now you have the objective function added and the model defined. Note: You can append a constraint or objective to the model with the operator because its class, , implements the special method , which is used to specify the behavior of . For larger problems, it‚Äôs often more convenient to use with a list or other sequence than to repeat the operator. For example, you could add the objective function to the model with this statement: # Add the objective function to the model It produces the same result as the previous statement. You can now see the full definition of this model: The string representation of the model contains all relevant data: the variables, constraints, objective, and their names. Note: String representations are built by defining the special method . For more details about , check out Pythonic OOP String Conversion: vs or When Should You Use vs in Python?. Finally, you‚Äôre ready to solve the problem. You can do that by calling on your model object. If you want to use the default solver (CBC), then you don‚Äôt need to pass any arguments: calls the underlying solver, modifies the object, and returns the integer status of the solution, which will be if the optimum is found. For the rest of the status codes, see . You can get the optimization results as the attributes of . The function and the corresponding method return the actual values of the attributes: holds the value of the objective function, contains the values of the slack variables, and the objects and have the optimal values of the decision variables. returns a list with the decision variables: As you can see, this list contains the exact objects that are created with the constructor of . The results are approximately the same as the ones you got with SciPy. Note: Be careful with the method ‚Äîit changes the state of the objects and ! You can see which solver was used by calling : The output informs you that the solver is CBC. You didn‚Äôt specify a solver, so PuLP called the default one. If you want to run a different solver, then you can specify it as an argument of . For example, if you want to use GLPK and already have it installed, then you can use in the last line. Keep in mind that you‚Äôll also need to import it: Now that you have GLPK imported, you can use it inside : # Add the constraints to the model # Add the objective function to the model The parameter is used to display information from the solver. disables showing this information. If you want to include the information, then just omit or set . Your model is defined and solved, so you can inspect the results the same way you did in the previous case: You got practically the same result with GLPK as you did with SciPy and CBC. Let‚Äôs peek and see which solver was used this time: As you defined above with the highlighted statement , the solver is GLPK. You can also use PuLP to solve mixed-integer linear programming problems. To define an integer or binary variable, just pass or to . Everything else remains the same: # Initialize the decision variables: x is integer, y is continuous # Add the constraints to the model # Add the objective function to the model In this example, you have one integer variable and get different results from before: Now is an integer, as specified in the model. (Technically it holds a float value with zero after the decimal point.) This fact changes the whole solution. Let‚Äôs show this on the graph: As you can see, the optimal solution is the rightmost green point on the gray background. This is the feasible solution with the largest values of both and , giving it the maximal objective function value. GLPK is capable of solving such problems as well. Now you can use PuLP to solve the resource allocation problem from above: The approach for defining and solving the problem is the same as in the previous example: In this case, you use the dictionary to store all decision variables. This approach is convenient because dictionaries can store the names or indices of decision variables as keys and the corresponding objects as values. Lists or tuples of instances can be useful as well. The code above produces the following result: As you can see, the solution is consistent with the one obtained using SciPy. The most profitable solution is to produce units of the first product and units of the third product per day. Let‚Äôs make this problem more complicated and interesting. Say the factory can‚Äôt produce the first and third products in parallel due to a machinery issue. What‚Äôs the most profitable solution in this case? Now you have another logical constraint: if x‚ÇÅ is positive, then x‚ÇÉ must be zero and vice versa. This is where binary decision variables are very useful. You‚Äôll use two binary decision variables, y‚ÇÅ and y‚ÇÉ, that‚Äôll denote if the first or third products are generated at all: The code is very similar to the previous example except for the highlighted lines. Here are the differences:\n‚Ä¢ Line 5 defines the binary decision variables and held in the dictionary .\n‚Ä¢ Line 12 defines an arbitrarily large number . The value is large enough in this case because you can‚Äôt have more than units per day.\n‚Ä¢ Line 13 says that if is zero, then must be zero, else it can be any non-negative number.\n‚Ä¢ Line 14 says that if is zero, then must be zero, else it can be any non-negative number.\n‚Ä¢ Line 15 says that either or is zero (or both are), so either or must be zero as well. It turns out that the optimal approach is to exclude the first product and to produce only the third one."
    },
    {
        "link": "https://medium.com/operations-research-bit/diving-into-pulp-a-pythonic-approach-to-linear-programming-7b20ca15aa88",
        "document": "Python PuLP is a popular optimization modeling package that enables users to solve linear and integer programming problems. The PuLP library provides a high-level interface to optimization solvers and allows users to formulate and solve optimization problems easily. Examples in this guide:\n\nPuLP (Python Universal Linear Programming) is an open-source Python library that simplifies constructing and solving linear optimization models. It provides a user-friendly syntax for defining variables, objective functions, and constraints, making LP accessible to users with varying programming backgrounds. It is widely used in various industries such as Finance and Supply Chain.\n\nPuLP is a powerful tool for formulating and solving LP problems in Python. Its user-friendly interface and versatility make it a valuable resource for operations research practitioners and anyone looking to optimize their decision-making processes. With further exploration, you can leverage its features to tackle more complex LP problems and gain valuable insights for real-world applications."
    },
    {
        "link": "https://thegeeksdiary.com/2023/02/24/linear-programming-in-python-using-pulp-part-1",
        "document": "Linear programming is an optimization technique used to find the best outcomes for a given problem. This technique relies on a set of constructs which are all expressed using a system of linear equations. It is important to understand that you should be able to express your objective as a linear equation dependent on an arbitrary number of variables. If your objective is non linear (example: quadratic equations ‚Äì then you can use Quadratic Programming aka QP) then you cannot use linear programming techniques to optimize the outcomes (objectives).\n\nLet‚Äôs Understand the linear programming technique with an easy example, let‚Äôs say you are a nutritionist who would like to find the best meal plan for a patient based on a few factors, the patient is suffering from Anemia and you would like to design a meal plan for the patient to find the best meals for the patient from the hospital dialy menu such that they get the maximum possible content of Vitamin B12 subject to a few contraints.\n\nFrom the above table we can see that there are a few abstractions/constructs that need to be well defined in relation to an objective and now let‚Äôs understand what each of these are.\n\nMost readers visit my blog for easy to follow guides around complicated topics and this one is no exception, so we will start with a very simple and intuitive example problem.\n\nThe above is a simple problem with a goal that can be expressed as a linear equation between 2 variables. So let‚Äôs breakdown the variables and understand the constraints as well.\n\nIn our example we have 2 variables, quantity of steak and peanut butter. we can denote them with whatever name we want but for this guide we will be denoting them with S and P respectively.\n\nOur goal is to minimize the cost of meals per day while meeting the requirements of serving atleast 4 units of proteins per day. The cost of both inputs (steak and peanut butter) can fluctuate per day and our goal is to create a model that can determine the best combination of steak and peanut butter with minimum cost to meet the constraints (discussed in next section). Let‚Äôs assume that for a given day price per pound of steak is 3 currency units (it could be dollars or euros or any other currency for that matter) and price per pound of peanut butter is 2 currency units. So our goal is to:\n\nThe above goal formulation might look a bit terse on mathematical notation `but we will break it down below.\n‚Ä¢ Cost: Cost of daily meals is given by the price per pound of inputs (steak and peanut butter) times the pounds of inputs (steak and peanut butter)\n‚Ä¢ Objective: Our objective is to minimize the cost per day by finding the total daily cost such that we serving atleast 4 units of proteins per day (constraint 1) and the quantity of any input (steak and peanut butter) cannot go below 0 (constraint 2) because you cannot feed negative amounts of steak to anyone üòä\n\nWhile meeting our objective we have to make sure that we don‚Äôt voilate a couple of constraints.\n\nWe will be implementing the model using Python and PuLP. This is a minimalistic example so we will not be needing any more libraries.\n\nAll the code for this article is present on the Machine Learning Guides github repository, so let‚Äôs start.\n\nI am using miniconda to create an isolated environment ‚Äì you can use any environment manager available for python like venv or full anaconda. In the code directory on github you will find the environment.yml file, after installing anaconda simply run the following commands on your terminal.\n\nYou can now checkout the repository on you machine by running the following commands.\n\nThese commands simply checkout the code on your computer and create an anaconda environment with the correct python version (3.10), pip (>=22.0) and packages defined in file. We are using the following pacakges:\n\nWe will start by importing the classes and functions defined in PuLP library, we will be needing the following:\n\nTo define out problem I have created a simple function that takes in the following parameters:\n‚Ä¢ steak_price (float): price per pound of steak in dollars ($)\n‚Ä¢ peanut_butter_price (float): price per pund of peanut butter in dollars ($)\n\nThe function returns a tuple of problem, and 2 variables (S & P) ‚Äì these variables denote the quantity of steak and peanut butter respectively. The code is something like:\n‚Ä¢ We create a problem instance (LpProblem) and define it‚Äôs name ‚ÄúDietProblem‚Äù and indicate that we are trying to minimize the objective (cost) using .\n‚Ä¢ We create variable S to hold the quantity of Steak and give it a name ‚ÄúSteak_In_Pounds‚Äù and define the lowBound = 0 and indicate that this is continous variable using .\n‚Ä¢ We create variable P to hold the quantity of Peanut Butter and give it a name ‚ÄúPeanut_Butter_In_Pounds‚Äù and define the lowBound = 0 and indicate that this is continous variable using .\n‚Ä¢ We set the objective for the problem by defining how the our variables affect the cost i.e. the total cost = (price of steak X quantity of steak) + (price of peanut butter X quantity of peanut butter)\n‚Ä¢ We return the newly created problem and the variables for the problem.\n\nNow that we have the problem and objective, we need to define the constraints.\n‚Ä¢ Our first constraint is the the intake of proteins, each unit (pound) of steak contains 2 units of proteins and each unit of peanut butter contains 1 unit of protein.\n‚Ä¢ The quantities of steak or proteins cannot be less than 0.\n\nWe create a function and pass the problem and the variables to set these constaints as shown below:\n\nWe can now solve the problem at different price points as shown below.\n\nIn our code we are evaluating the problem at following price points.\n\nAs can be seen above the optimal choices affecting the cost change as the price per unit of steak and peanut butter changes.\n\nThis is the first in the series of articles that I would be publishing to cover the Linear programming concepts, in today article we saw a basic example of solving an optimization probelm, in coming weeks we would be diving deeper into more advanced problems with large number of variables and conclude this with Multi-Objective Optimization using Linear Programming wherein we would be optimizing multiple objective subject to various constraints.\n\nIf you have any questions or idea please post them in the comments and I would be happy to answer them or cover the new topics in the upcoming articles."
    },
    {
        "link": "https://or.stackexchange.com/questions/10279/what-are-my-options-for-exact-linear-programming-solvers-in-python3-that-work-as",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    }
]