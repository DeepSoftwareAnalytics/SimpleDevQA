[
    {
        "link": "https://libwebsockets.org",
        "document": "(LWS) is a flexible, lightweight pure C library for implementing modern network protocols easily with a tiny footprint, using a nonblocking event loop. It has been developed continuously since 2010 and is used in tens of millions of devices and by thousands of developers around the world.\n\nLWS is Free Software using the MIT license."
    },
    {
        "link": "https://github.com/warmcat/libwebsockets",
        "document": "Libwebsockets is a simple-to-use, MIT-license, pure C library providing client and server for http/1, http/2, websockets, MQTT and other protocols in a security-minded, lightweight, configurable, scalable and flexible way. It's easy to build and cross-build via cmake and is suitable for tasks from embedded RTOS through mass cloud serving.\n\nIt supports a lot of lightweight ancilliary implementations for things like JSON, CBOR, JOSE, COSE, and supports OpenSSL and MbedTLS v2 and v3 out of the box for everything. It's very gregarious when it comes to event loop sharing, supporting libuv, libevent, libev, sdevent, glib and uloop, as well as custom event libs.\n\n100+ independent minimal examples for various scenarios, CC0-licensed (public domain) for cut-and-paste, allow you to get started quickly.\n\nThere are a lot of READMEs on a variety of topics.\n\nWe do a huge amount of CI testing per push, currently 582 builds on 30 platforms. You can see the lws CI rack and read about how lws-based Sai is used to coordinate all the testing.\n\nWant to drive your EPD or TFT / OLED display using HTML + CSS? Only got an ESP32?\n\nRealtime render into a line buffer because you don't have enough heap for a framebuffer?\n\nTake a look here...\n\nThanks to Felipe Gasper, there's now a perl binding for lws available at metacpan, this uses the recent generic event loop support in lws to have lws as a guest on an existing perl event loop.\n\nSecure Streams support in lws was introduced a couple of years ago, it's a higher-level interface to lws -level apis that simplifies connectivity by segregating connection policy like protocol and endpoint information into a separate JSON policy file, and just having the code deal with payloads; as many details of the wire protocol as possible are hidden or moved to the policy, so user code is almost identical even if the wire protocol changes.\n\nThe user code just asks to create a SS by \"streamtype name\", it is created according to the details (protocol, endpoint, etc) under the same name in the policy.\n\nKey policy entries like endpoint can contain string substitutions to handle runtime adaptations via metadata. h1, h2, ws and mqtt are supported.\n\nAs a layer on top of the apis, SS provides a higher-level way to access the existing wsi-level capabilities, both kinds of API will remain supported. Secure Streams are longer-lived than a single wsi, so an SS can coordinate retries by itself. SS-based user code is typically significantly smaller and more maintainable than wsi layer.\n\nIn main branch I have moved the older examples into and am starting to port more cases from there into SS-based examples.\n\nSecure Streams APIs are also serializable, the exact same client code can fulfil the connection directly in the same process as you would expect, or forward the actions, metadata and payloads to an SS Proxy that owns the policy over a Unix Domain or TCP socket connection to be fulfilled centrally. This allows, eg, h2 streams from different processes sharing a single connection.\n\nThe serialized SS can also travel over generic transports like UART, an example is provided implementing the Binance example on an RPi Pico with a UART transport to a UART transport SS proxy, where the pico itself has no network stack, tls, compression or wss stack, but can send and receive to and from the endpoint as if it did.\n\nThe optional is used to interpose between the UART transport and the SSPC layer, allowing a single pipe to carry many separate SS connections.\n\nThe user SS code is identical however it is transported, muxed and fulfilled.\n\nThe initial commit for lws will have been 11 years ago come Oct 28 2021, it's been a lot of work. There are a total of 4.3K patches, touching 800KLOC cumulatively (this is not the size in the repo, but over the years, how many source lines were changed by patches).\n\nGratifyingly, it turns out over the years, ~15% of that was contributed by 404 contributors: that's not so bad. Thanks a lot to everyone who has provided patches.\n\nToday at least tens of millions of devices and product features rely on lws to handle their communications including several from FAANG; Google now include lws as part of Android sources.\n\nThis is the libwebsockets C library for lightweight websocket clients and servers. For support, visit\n\nand consider joining the project mailing list at\n\nYou can get the latest version of the library from git:"
    },
    {
        "link": "https://libwebsockets.org/lws-api-doc-main/html/index.html",
        "document": "Libwebsockets covers a lot of interesting features for people making embedded servers or clients\n• support for linux, bsd, windows etc... and very small nonlinux targets like ESP32\n\nPlease note you just need in include libwebsockets.h. It includes all the individual includes in /usr/include/libwebsockets/ itself.\n\nA collection of READMEs for build, coding, lwsws etc are here"
    },
    {
        "link": "https://github.com/woodsts/libwebsockets",
        "document": "Libwebsockets is a simple-to-use, MIT-license, pure C library providing client and server for http/1, http/2, websockets, MQTT and other protocols in a security-minded, lightweight, configurable, scalable and flexible way. It's easy to build and cross-build via cmake and is suitable for tasks from embedded RTOS through mass cloud serving.\n\n80+ independent minimal examples for various scenarios, CC0-licensed (public domain) for cut-and-paste, allow you to get started quickly.\n\nThere are a lot of READMEs on a variety of topics.\n\nWe do a huge amount of CI testing per push, currently 495 builds on 27 platforms.\n\nIf you're interested in ws + h.264, there's a 80-90% complete minimal example that needs help with the mp4 container part, the lws v4l2 integration, MPJPG->h.264 transcoding and ws transport to MediaSource parts already work.\n\nTake a look at the top two patches on branch and post on the mailing list or github to discuss if you can help.\n\nThe master->main branch transition happened several months ago, currently master is still around as a mirror of main. master branch will go away some time before the next release.\n\nThis is the libwebsockets C library for lightweight websocket clients and servers. For support, visit\n\nand consider joining the project mailing list at\n\nYou can get the latest version of the library from git:"
    },
    {
        "link": "https://news.ycombinator.com/item?id=28439447",
        "document": ""
    },
    {
        "link": "https://libwebsockets.org",
        "document": "(LWS) is a flexible, lightweight pure C library for implementing modern network protocols easily with a tiny footprint, using a nonblocking event loop. It has been developed continuously since 2010 and is used in tens of millions of devices and by thousands of developers around the world.\n\nLWS is Free Software using the MIT license."
    },
    {
        "link": "https://github.com/warmcat/libwebsockets/issues/411",
        "document": "I took a nap and then I implemented a quick test with libuv. It just started working but seems pretty stable. I need to add more functionalities (signals) and clean things up.\n\nWould you be interested in working with me to add this new backend? It shares a lot with libev in terms of concepts so maybe it would be easiest to merge libev/libuv backends into one (with some differences, ofc). But this is completely up to you.\n\nThis is my (really ugly) first patch version:\n\n/ / . / / . .. / / . / / . @@ , , @@ ( ) } } ( , . ); ( ) ( , . ); ( . ); ( ; ; ) { / / . / / . .. / / . / / . @@ , , @@ ( ) } ( , , ) ( , , ) { ( , , ); ; ; ( ) ; ( ) ; . ; . . ; . ; . ; ( ) { . ; ( ) { . |= ; . |= ; } ( ) { ( ) { . |= ; . |= ; } @@ , , @@ ( , , ) } ( , , ) ( , , ) { ( , ); } @@ , , @@ ( , , } ( , ) ( , ) { . ; . ; ; . ; ; ; ; ; (! ) ( ); (); ; @@ , , @@ ( , ) / ( , , [ ]. , ) ; ( , ); ( , , [ ]. ); ( , , ); /* Register the signal watcher unless the user says not to */ ( ) { ( , , ) ; ( , ); } ( ); ; } @@ , , @@ ( , ) { ( ); . ; . ; . ; (! ( )) ; . ; . ; ( , , , ); ( , , , ); ( , , ); } ( , ) { ( ); . . . ( | ); (! ( )) ; @@ , , @@ ( , ) ( ( | ))); ( ) { ( ) ( , . ); ( ) ( , . ); ( ) |= ; ( ) |= ; ( . , , ); } { ( ) ( , . ); ( ) ( , . ); ( ) &= ~ ; ( ) &= ~ ; (!( ( | ))) ( . ); ( . , , ); } } @@ , , @@ ( ) { ( ( )) ( , ); ( , ); } / / . / / . . / / . / / . @@ , , @@ ; @@ , , @@ ( ); ( )( , ); ( )( , , ); ( , , ); ( , ); ( , ); ( , , ); ( , , ); / / . / / . . / / . / / . @@ , , @@ / . . . . / . @@ , , @@ ; { ; ; ; }; { ; ; ; }; @@ , , @@ { ; ; ; ; ; ;"
    },
    {
        "link": "https://stackoverflow.com/questions/46436610/compiling-libuv-with-libwebsockets",
        "document": "I am trying to run the \"libwebsockets-test-server\" that is installed with the LWS library, but it will not run because \"lwsts[31616]: libuv support not compiled in\".\n\nI have checked that libuv is installed (1.8.0). I also changed the setting for LIBUV in cmake and recompiled the library.\n\nHow do I get the project compiled with libuv?\n\nI am on Ubuntu 16.04, cross-compiling using arm-linux-gcc. I have successfully compiled programs, loaded them to the embedded board (TS-7800), and run the executable, but not yet with LWS. I am relatively new to Linux and cross-compilers."
    },
    {
        "link": "https://libwebsockets.org/lws-api-doc-main/html/md_READMEs_README_coding.html",
        "document": "Originally lws only supported the \"manual\" method of handling everything in the user callback found in test-server.c / test-server-http.c.\n\nSince v2.0, the need for most or all of this manual boilerplate has been eliminated: the protocols[0] http stuff is provided by a generic lib export . You can serve parts of your filesystem at part of the URL space using mounts, the dummy http callback will do the right thing.\n\nIt's much preferred to use the \"automated\" v2.0 type scheme, because it's less code and it's easier to support.\n\nThe minimal examples all use the modern, recommended way.\n\nIf you just need generic serving capability, without the need to integrate lws to some other app, consider not writing any server code at all, and instead use the generic server , and writing your special user code in a standalone \"plugin\". The server is configured for mounts etc using JSON, see ./READMEs/README.lwsws.md.\n\nAlthough the \"plugins\" are dynamically loaded if you use lwsws or lws built with libuv, actually they may perfectly well be statically included if that suits your situation better, eg, ESP32 test server, where the platform does not support processes or dynamic loading, just #includes the plugins one after the other and gets the same benefit from the same code.\n\nIsolating and collating the protocol code in one place also makes it very easy to maintain and understand.\n\nSo it if highly recommended you put your protocol-specific code into the form of a \"plugin\" at the source level, even if you have no immediate plan to use it dynamically-loaded.\n\nYou should only send data on a websocket connection from the user callback (or for clients).\n\nIf you want to send something, do NOT just send it but request a callback when the socket is writeable using\n• for all connections using that protocol to get a callback when next writeable.\n\nUsually you will get called back immediately next time around the service loop, but if your peer is slow or temporarily inactive the callback will be delayed accordingly. Generating what to write and sending it should be done in the ...WRITEABLE callback.\n\nSee the test server code for an example of how to do this.\n\nOtherwise evolved libs like libuv get this wrong, they will allow you to \"send\" anything you want but it only uses up your local memory (and costs you memcpys) until the socket can actually accept it. It is much better to regulate your send action by the downstream peer readiness to take new data in the first place, avoiding all the wasted buffering.\n\nLibwebsockets' concept is that the downstream peer is truly the boss, if he, or our connection to him, cannot handle anything new, we should not generate anything new for him. This is how unix shell piping works, you may have `cat a.txt | grep xyz > remote\", but actually that does not cat anything from a.txt while remote cannot accept anything new.\n\nOnly one lws_write per WRITEABLE callback\n\nFrom v2.5, lws strictly enforces only one lws_write() per WRITEABLE callback.\n\nYou will receive a message about \"Illegal back-to-back write of ... detected\" if there is a second lws_write() before returning to the event loop.\n\nThis is because with http/2, the state of the network connection carrying a wsi is unrelated to any state of the wsi. The situation on http/1 where a new request implied a new tcp connection and new SSL buffer, so you could assume some window for writes is no longer true. Any lws_write() can fail and be buffered for completion by lws; it will be auto-completed by the event loop.\n\nNote that if you are handling your own http responses, writing the headers needs to be done with a separate lws_write() from writing any payload. That means after writing the headers you must call and send any payload from the writable callback.\n\nDo not rely on only your own WRITEABLE requests appearing\n\nLibwebsockets may generate additional events if it met network conditions where it had to buffer your send data internally.\n\nSo your code for needs to own the decision about what to send, it can't assume that just because the writeable callback came something is ready to send.\n\nIt's quite possible you get an 'extra' writeable callback at any time and just need to and wait for the expected callback later.\n\nThere's a helper api built by default that does everything you need to daemonize well, including creating a lock file. If you're making what's basically a daemon, just call this early in your init to fork to a headless background process and exit the starting process.\n\nNotice stdout, stderr, stdin are all redirected to /dev/null to enforce your daemon is headless, so you'll need to sort out alternative logging, by, eg, syslog via .\n\nThe maximum number of connections the library can deal with is decided when it starts by querying the OS to find out how many file descriptors it is allowed to open (1024 on Fedora for example). It then allocates arrays that allow up to that many connections, minus whatever other file descriptors are in use by the user code.\n\nIf you want to restrict that allocation, or increase it, you can use ulimit or similar to change the available number of file descriptors, and when restarted libwebsockets will adapt accordingly.\n\nIf you select at cmake, then lws will track peer IPs and monitor how many connections and ah resources they are trying to use at one time. You can choose to limit these at context creation time, using and .\n\nNote that although the ah limit is 'soft', ie, the connection will just wait until the IP is under the ah limit again before attaching a new ah, the wsi limit is 'hard', lws will drop any additional connections from the IP until it's under the limit again.\n\nIf you use these limits, you should consider multiple clients may simultaneously try to access the site through NAT, etc. So the limits should err on the side of being generous, while still making it impossible for one IP to exhaust all the server resources.\n\nLibwebsockets works in a serialized event loop, in a single thread. It supports the default poll() backend, and libuv, libev, and libevent event loop libraries that also take this locking-free, nonblocking event loop approach that is not threadsafe. There are several advantages to this technique, but one disadvantage, it doesn't integrate easily if there are multiple threads that want to use libwebsockets.\n\nHowever integration to multithreaded apps is possible if you follow some guidelines.\n\n1) Aside from two APIs, directly calling lws apis from other threads is not allowed.\n\n2) If you want to keep a list of live wsi, you need to use lifecycle callbacks on the protocol in the service thread to manage the list, with your own locking. Typically you use an ESTABLISHED callback to add ws wsi to your list and a CLOSED callback to remove them.\n\n3) LWS regulates your write activity by being able to let you know when you may write more on a connection. That reflects the reality that you cannot succeed to send data to a peer that has no room for it, so you should not generate or buffer write data until you know the peer connection can take more.\n\nOther libraries pretend that the guy doing the writing is the boss who decides what happens, and absorb as much as you want to write to local buffering. That does not scale to a lot of connections, because it will exhaust your memory and waste time copying data around in memory needlessly.\n\nThe truth is the receiver, along with the network between you, is the boss who decides what will happen. If he stops accepting data, no data will move. LWS is designed to reflect that.\n\nIf you have something to send, you call on the connection, and when it is writeable, you will get a callback, where you should generate the data to send and send it with .\n\nYou cannot send data using outside of the WRITEABLE callback.\n\n4) For multithreaded apps, this corresponds to a need to be able to provoke the action and to wake the service thread from its event loop wait (sleeping in or or whatever). The rules above mean directly sending data on the connection from another thread is out of the question.\n\nThe only lws api that's safe to call from other thread contexts is . This will take a platform-specific action to wake the lws event loop thread wait, either put a byte into a pipe2() the event loop is waiting on, or send a packet on a UDP socket pair that the event loop waits on. When the wake is handled by the lws event loop thread, it will broadcast a message to every vhost-protocol instantiation, so you can handle this callback, usually lock a shared data region, and if you see you need to write, call for the wsi(s) that need to write.\n\nThere's no restriction on multiple threads calling , it's unconditionally safe due to how it is implemented underneath.\n\n5) The obverse of this truism about the receiver being the boss is the case where we are receiving. If we get into a situation we actually can't usefully receive any more, perhaps because we are passing the data on and the guy we want to send to can't receive any more, then we should \"turn off RX\" by using the RX flow control API, . When something happens where we can accept more RX, (eg, we learn our onward connection is writeable) we can call it again to re-enable it on the incoming wsi.\n\nLWS stops calling back about RX immediately you use flow control to disable RX, it buffers the data internally if necessary. So you will only see RX when you can handle it. When flow control is disabled, LWS stops taking new data in... this makes the situation known to the sender by TCP \"backpressure\", the tx window fills and the sender finds he cannot write any more to the connection.\n\nSee the mirror protocol implementations for example code.\n\nIf you need to service other socket or file descriptors as well as the websocket ones, you can combine them together with the websocket ones in one poll loop, see \"External Polling Loop support\" below, and still do it all in one thread / process context. If the need is less architectural, you can also create RAW mode client and serving sockets; this is how the lws plugin for the ssh server works.\n\nWebsockets allows connections to negotiate without a protocol name... in that case by default it will bind to the first protocol in your vhost protocols[] array.\n\nYou can tell the vhost to use a different protocol by attaching a pvo (per-vhost option) to the\n\nWill select \"my-protocol\" from your protocol list (even if it came in by plugin) as being the target of client connections that don't specify a protocol.\n\nWhen you want to close a connection, you do it by returning from a callback for that connection.\n\nYou can provoke a callback by calling on the wsi, then notice in the callback you want to close it and just return -1. But usually, the decision to close is made in a callback already and returning -1 is simple.\n\nIf the socket knows the connection is dead, because the peer closed or there was an affirmitive network error like a FIN coming, then libwebsockets will take care of closing the connection automatically.\n\nIf you have a silently dead connection, it's possible to enter a state where the send pipe on the connection is choked but no ack will ever come, so the dead connection will never become writeable. To cover that, you can use TCP keepalives (see later in this document) or pings.\n\nLws now supports serving gzipped files from inside a zip container. Thanks to Per Bothner for contributing the code.\n\nThis has the advtantage that if the client can accept GZIP encoding, lws can simply send the gzip-compressed file from inside the zip file with no further processing, saving time and bandwidth.\n\nIn the case the client can't understand gzip compression, lws automatically decompressed the file and sends it normally.\n\nClients with limited storage and RAM will find this useful; the memory needed for the inflate case is constrained so that only one input buffer at a time is ever in memory.\n\nTo use this feature, ensure LWS_WITH_ZIP_FOPS is enabled at CMake.\n\nincludes a mount using this technology already, run that test server and navigate to http://localhost:7681/ziptest/candide.html\n\nThis will serve the book Candide in html, together with two jpgs, all from inside a .zip file in /usr/[local/]share-libwebsockets-test-server/candide.zip\n\nUsage is otherwise automatic, if you arrange a mount that points to the zipfile, eg, \"/ziptest\" -> \"mypath/test.zip\", then URLs like will be servied from inside\n\nTo support fragmented messages you need to check for the final frame of a message with . This check can be combined with to gather the whole contents of a message, eg:\n\nThe test app libwebsockets-test-fraggle sources also show how to deal with fragmented messages.\n\nUnder GCC you can select for the build to be instrumented with the Address Sanitizer, using . LWS is routinely run during development with valgrind, but ASAN is capable of finding different issues at runtime, like operations which are not strictly defined in the C standard and depend on platform behaviours.\n\nRun your application like this\n\nand attach gdb to catch the place it halts.\n\nlibwebsockets maintains an internal array for all of its sockets, but you can instead integrate the sockets into an external polling array. That's needed if libwebsockets will cooperate with an existing poll array maintained by another server.\n\nThree callbacks , and appear in the callback for protocol 0 and allow interface code to manage socket descriptors in other poll loops.\n\nYou can pass all pollfds that need service to , even if the socket or file does not belong to libwebsockets it is safe.\n\nIf libwebsocket handled it, it zeros the pollfd field before returning. So you can let libwebsockets try and if is nonzero on return, you know it needs handling by your code.\n\nAlso note that when integrating a foreign event loop like libev or libuv where it doesn't natively use poll() semantics, and you must return a fake pollfd reflecting the real event:\n• be sure you set .events to .revents value as well in the synthesized pollfd\n• check the built-in support for the event loop if possible (eg, ./lib/libuv.c) to see how it interfaces to lws\n• use LWS_POLLHUP / LWS_POLLIN / LWS_POLLOUT from libwebsockets.h to avoid losing windows compatibility\n\nYou also need to take care about \"forced service\" somehow... these are cases where the network event was consumed, incoming data was all read, for example, but the work arising from it was not completed. There will not be any more network event to trigger the remaining work, Eg, we read compressed data, but we did not use up all the decompressed data before returning to the event loop because we had to write some of it.\n\nLws provides an API to determine if anyone is waiting for forced service, , normally tsi is 0. If it returns 0, then at least one connection has pending work you can get done by calling , again normally tsi is 0.\n\nFor eg, the default poll() event loop, or libuv/ev/event, lws does this checking for you and handles it automatically. But in the external polling loop case, you must do it explicitly. Handling it after every normal service triggered by the external poll fd should be enough, since the situations needing it are initially triggered by actual network events.\n\nAn example of handling it is shown in the test-server code specific to external polling.\n\nUsing with in c++ apps\n\nThe library is ready for use by C++ apps. You can get started quickly by copying the test server\n\nand building it in C++ like this\n\nis only needed because the test server uses it as shipped, if you remove the references to it in your app you don't need to define it on the g++ line either.\n\nHTTP Header information is managed by a pool of \"ah\" structs. These are a limited resource so there is pressure to free the headers and return the ah to the pool for reuse.\n\nFor that reason header information on HTTP connections that get upgraded to websockets is lost after the ESTABLISHED callback. Anything important that isn't processed by user code before then should be copied out for later.\n\nFor HTTP connections that don't upgrade, header info remains available the whole time.\n\nWebsocket connections only work over http/1, so there is nothing special to do when you want to enable -DLWS_WITH_HTTP2=1.\n\nThe internal http apis already follow these requirements and are compatible with http/2 already. So if you use stuff like mounts and serve stuff out of the filesystem, there's also nothing special to do.\n\nHowever if you are getting your hands dirty with writing response headers, or writing bulk data over http/2, you need to observe these rules so that it will work over both http/1.x and http/2 the same.\n\n1) LWS_PRE requirement applies on ALL lws_write(). For http/1, you don't have to take care of LWS_PRE for http data, since it is just sent straight out. For http/2, it will write up to LWS_PRE bytes behind the buffer start to create the http/2 frame header.\n\nThis has implications if you treated the input buffer to lws_write() as const... it isn't any more with http/2, up to 9 bytes behind the buffer will be trashed.\n\n2) Headers are encoded using a sophisticated scheme in http/2. The existing header access apis are already made compatible for incoming headers, for outgoing headers you must:\n• Use to add the transaction status (200 etc)\n• use lws apis and to put the headers into the buffer (these will translate what is actually written to the buffer depending on if the connection is in http/2 mode or not)\n• use the api after adding the last response header\n\n3) http/2 introduces per-stream transmit credit... how much more you can send on a stream is decided by the peer. You start off with some amount, as the stream sends stuff lws will reduce your credit accordingly, when it reaches zero, you must not send anything further until lws receives \"more credit\" for that stream the peer. Lws will suppress writable callbacks if you hit 0 until more credit for the stream appears, and lws built-in file serving (via mounts etc) already takes care of observing the tx credit restrictions. However if you write your own code that wants to send http data, you must consult the api to find out the state of your tx credit. For http/1, it will always return (size_t)-1, ie, no limit.\n\nThis is orthogonal to the question of how much space your local side's kernel will make to buffer your send data on that connection. So although the result from is \"how much you can send\" logically, and may be megabytes if the peer allows it, you should restrict what you send at one time to whatever your machine will generally accept in one go, and further reduce that amount if returns something smaller. If it returns 0, you should not consume or send anything and return having asked for callback on writable, it will only come back when more tx credit has arrived for your stream.\n\n4) Header names with captital letters are illegal in http/2. Header names in http/1 are case insensitive. So if you generate headers by name, change all your header name strings to lower-case to be compatible both ways.\n\n5) Chunked Transfer-encoding is illegal in http/2, http/2 peers will actively reject it. Lws takes care of removing the header and converting CGIs that emit chunked into unchunked automatically for http/2 connections.\n\nIf you follow these rules, your code will automatically work with both http/1.x and http/2.\n\nIt is possible for a connection which is not being used to send to die silently somewhere between the peer and the side not sending. In this case by default TCP will just not report anything and you will never get any more incoming data or sign the link is dead until you try to send.\n\nTo deal with getting a notification of that situation, you can choose to enable TCP keepalives on all libwebsockets sockets, when you create the context.\n\nTo enable keepalive, set the ka_time member of the context creation parameter struct to a nonzero value (in seconds) at context creation time. You should also fill ka_probes and ka_interval in that case.\n\nWith keepalive enabled, the TCP layer will send control packets that should stimulate a response from the peer without affecting link traffic. If the response is not coming, the socket will announce an error at forcing a close.\n\nNote that BSDs don't support keepalive time / probes / interval per-socket like Linux does. On those systems you can enable keepalive by a nonzero value in , but the systemwide kernel settings for the time / probes/ interval are used, regardless of what nonzero value is in .\n\nThere's a member in the struct which allows the user code to restrict the possible cipher selection at context-creation time.\n\nYou might want to look into that to stop the ssl peers selecting a cipher which is too computationally expensive. To use it, point it to a string like\n\nif left , then the \"DEFAULT\" set of ciphers are all possible to select.\n\nYou can also set it to to allow everything (including insecure ciphers).\n\nPassing your own cert information direct to SSL_CTX\n\nFor most users it's enough to pass the SSL certificate and key information by giving filepaths to the info.ssl_cert_filepath and info.ssl_private_key_filepath members when creating the vhost.\n\nIf you want to control that from your own code instead, you can do so by leaving the related info members NULL, and setting the info.options flag LWS_SERVER_OPTION_CREATE_VHOST_SSL_CTX at vhost creation time. That will create the vhost SSL_CTX without any certificate, and allow you to use the callback LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS to add your certificate to the SSL_CTX directly. The vhost SSL_CTX * is in the user parameter in that callback.\n\nWhen you call and get a back, it does not mean your connection is active. It just means it started trying to connect.\n\nYour client connection is actually active only when you receive for it.\n\nThere's a 5 second timeout for the connection, and it may give up or die for other reasons, if any of that happens you'll get a callback on protocol 0 instead for the .\n\nAfter attempting the connection and getting back a non- you should loop calling until one of the above callbacks occurs.\n\nAs usual, see test-client.c for example code.\n\nNotice that the client connection api tries to progress the connection somewhat before returning. That means it's possible to get callbacks like CONNECTION_ERROR on the new connection before your user code had a chance to get the wsi returned to identify it (in fact if the connection did fail early, NULL will be returned instead of the wsi anyway).\n\nTo avoid that problem, you can fill in in the client connection info struct to point to a struct lws that get filled in early by the client connection api with the related wsi. You can then check for that in the callback to confirm the identity of the failing client connection.\n\nlws now exposes his internal platform file abstraction in a way that can be both used by user code to make it platform-agnostic, and be overridden or subclassed by user code. This allows things like handling the URI \"directory space\" as a virtual filesystem that may or may not be backed by a regular filesystem. One example use is serving files from inside large compressed archive storage without having to unpack anything except the file being requested.\n\nThe test server shows how to use it, basically the platform-specific part of lws prepares a file operations structure that lives in the lws context.\n\nThe user code can get a pointer to the file operations struct\n\nand then can use helpers to also leverage these platform-independent file handling apis\n\nGeneric helpers are provided which provide access to generic fops information or call through to the above fops\n\nThe user code can also override or subclass the file operations, to either wrap or replace them. An example is shown in test server.\n\nChanges from v2.1 and before fops\n\nThere are several changes:\n\n1) Pre-2.2 fops directly used platform file descriptors. Current fops returns and accepts a wrapper type lws_fop_fd_t which is a pointer to a malloc'd struct containing information specific to the filesystem implementation.\n\n2) Pre-2.2 fops bound the fops to a wsi. This is completely removed, you just give a pointer to the fops struct that applies to this file when you open it. Afterwards, the operations in the fops just need the lws_fop_fd_t returned from the open.\n\n3) Everything is wrapped in typedefs. See lws-plat-unix.c for examples of how to implement.\n\n4) Position in the file, File Length, and a copy of Flags left after open are now generically held in the fop_fd. VFS implementation must set and manage this generic information now. See the implementations in lws-plat-unix.c for examples.\n\n5) The file length is no longer set at a pointer provided by the open() fop. The api is provided to get the file length after open.\n\n6) If your file namespace is virtual, ie, is not reachable by platform fops directly, you must set LWS_FOP_FLAG_VIRTUAL on the flags during open.\n\n7) There is an optional uint32_t member in the generic fop_fd. If you are able to set it during open, you should indicate it by setting on the flags.\n\nLWS allows you to include generic platform file descriptors in the lws service / poll / event loop.\n\nOpen your fd normally and then\n\nA wsi is created for the file fd that acts like other wsi, you will get these callbacks on the named protocol\n\nThe minimal example demonstrates how to use it.\n\nplugin also provides a method for testing this with :\n\nThe plugin creates a FIFO on your system called \"/tmp/lws-test-raw\"\n\nYou can feed it data through the FIFO like this\n\nThis plugin simply prints the data. But it does it through the lws event loop / service poll.\n\nYou can also enable your vhost to accept RAW socket connections, in addition to HTTP[s] and WS[s]. If the first bytes written on the connection are not a valid HTTP method, then the connection switches to RAW mode.\n\nThis is disabled by default, you enable it by setting the flag LWS_SERVER_OPTION_FALLBACK_TO_APPLY_LISTEN_ACCEPT_CONFIG, and setting to when creating the vhost.\n\nYou can control which protocol on your vhost handles these RAW mode incoming connections by setting the vhost info struct's to the vhost protocol name to use.\n\nplugin provides a method for testing this with :\n\nRun libwebsockets-test-server-v2.0 and connect to it by telnet, eg\n\ntype something that isn't a valid HTTP method and enter, before the connection times out. The connection will switch to RAW mode using this protocol, and pass the unused rx as a raw RX callback.\n\nThe test protocol echos back what was typed on telnet to telnet.\n\nYou can now also open RAW socket connections in client mode.\n\nFollow the usual method for creating a client connection, but set the to \"RAW\". When the connection is made, the wsi will be converted to RAW mode and operate using the same callbacks as the server RAW sockets described above.\n\nThe libwebsockets-test-client supports this using raw:// URLS. To test, open a netcat listener in one window\n\nand in another window, connect to it using the test client\n\nThe connection should succeed, and text typed in the netcat window (including a CRLF) will be received in the client.\n\nLws provides an api to create, optionally bind, and adopt a RAW UDP socket (RAW here means an uninterpreted normal UDP socket, not a \"raw socket\").\n\nshould be if the socket will receive packets.\n\nThe callbacks , , and apply to the wsi. But UDP is different than TCP in some fundamental ways.\n\nFor receiving on a UDP connection, data becomes available at as usual, but because there is no specific connection with UDP, it is necessary to also get the source address of the data separately, using . You should take a copy of the itself (not the pointer) and save it for when you want to write back to that peer.\n\nWriting is also a bit different for UDP. By default, the system has no idea about the receiver state and so asking for a always believes that the socket is writeable... the callback will happen next time around the event loop.\n\nWith UDP, there is no single \"connection\". You need to write with sendto() and direct the packets to a specific destination. To return packets to a peer who sent something earlier and you copied his , you use the .sa and .salen members as the last two parameters of the sendto().\n\nThe kernel may not accept to buffer / write everything you wanted to send. So you are responsible to watch the result of sendto() and resend the unsent part next time (which may involve adding new protocol headers to the remainder depending on what you are doing).\n\nECDH Certs are now supported. Enable the CMake option\n\nto build in support and select it at runtime.\n\nOpenSSL allows you to receive callbacks for various events defined in a bitmask in openssl/ssl.h. The events include stuff like TLS Alerts.\n\nBy default, lws doesn't register for these callbacks.\n\nHowever if you set the info.ssl_info_event_mask to nonzero (ie, set some of the bits in it like at vhost creation time, then connections to that vhost will call back using LWS_CALLBACK_SSL_INFO for the wsi, and the parameter will be pointing to a struct of related args:\n\nThe default callback handler in lws has a handler for LWS_CALLBACK_SSL_INFO which prints the related information, You can test it using the switch -S -s on .\n\nReturning nonzero from the callback will close the wsi.\n\nSMP support is integrated into LWS without any internal threading. It's very simple to use, libwebsockets-test-server-pthread shows how to do it, use -j n argument there to control the number of service threads up to 32.\n\nTwo new members are added to the info struct\n\nleave them at the default 0 to get the normal singlethreaded service loop.\n\nSet count_threads to n to tell lws you will have n simultaneous service threads operating on the context.\n\nThere is still a single listen socket on one port, no matter how many service threads.\n\nWhen a connection is made, it is accepted by the service thread with the least connections active to perform load balancing.\n\nThe user code is responsible for spawning n threads running the service loop associated to a specific tsi (Thread Service Index, 0 .. n - 1). See the libwebsockets-test-server-pthread for how to do.\n\nIf you leave fd_limit_per_thread at 0, then the process limit of fds is shared between the service threads; if you process was allowed 1024 fds overall then each thread is limited to 1024 / n.\n\nYou can set fd_limit_per_thread to a nonzero number to control this manually, eg the overall supported fd limit is less than the process allowance.\n\nYou can control the context basic data allocation for multithreading from Cmake using -DLWS_MAX_SMP=, if not given it's set to 1. The serv_buf allocation for the threads (currently 4096) is made at runtime only for active threads.\n\nBecause lws will limit the requested number of actual threads supported according to LWS_MAX_SMP, there is an api lws_get_count_threads(context) to discover how many threads were actually allowed when the context was created.\n\nSee the test-server-pthreads.c sample for how to use.\n\nLws provide a set of pthread mutex helpers that reduce to no code or variable footprint in the case that LWS_MAX_SMP == 1.\n\nDefine your user mutex like this\n\nIf LWS_MAX_SMP > 1, this produces . In the case LWS_MAX_SMP == 1, it produces nothing.\n\nLikewise these helpers for init, destroy, lock and unlock\n\nresolve to nothing if LWS_MAX_SMP == 1, otherwise produce the equivalent pthread api.\n\npthreads is required in lws only if LWS_MAX_SMP > 1.\n\nYou can select either or both\n\nat cmake configure-time. The user application may use one of the context init options flags\n\nto indicate it will use one of the event libraries at runtime.\n\nlibev and libevent headers conflict, they both define critical constants like EV_READ to different values. Attempts to discuss clearing that up with both libevent and libev did not get anywhere useful. Therefore CMakeLists.txt will error out if you enable both LWS_WITH_LIBEV and LWS_WITH_LIBEVENT.\n\nIn addition depending on libev / compiler version, building anything with libev apis using gcc may blow strict alias warnings (which are elevated to errors in lws). I did some googling at found these threads related to it, the issue goes back at least to 2010 on and off\n\nWe worked around this problem by disabling -Werror on the parts of lws that use libev. FWIW as of Dec 2019 using Fedora 31 libev 4.27.1 and its gcc 9.2.1 doesn't seem to trigger the problem even without the workaround.\n\nFor these reasons and the response I got trying to raise these issues with them, if you have a choice about event loop, I would gently encourage you to avoid libev. Where lws uses an event loop itself, eg in lwsws, we use libuv.\n\nUser code may set per-connection extension options now, using a new api .\n\nThis should be called from the ESTABLISHED callback like this\n\nIf the extension is not active (missing or not negotiated for the connection, or extensions are disabled on the library) the call is just returns -1. Otherwise the connection's extension has its named option changed.\n\nThe extension may decide to alter or disallow the change, in the example above permessage-deflate restricts the size of his rx output buffer also considering the protocol's rx_buf_size member.\n\nClient connections as HTTP[S] rather than WS[S]\n\nYou may open a generic http client connection using the same struct lws_client_connect_info used to create client ws[s] connections.\n\nTo stay in http[s], set the optional info member \"method\" to point to the string \"GET\" instead of the default NULL.\n\nAfter the server headers are processed, when payload from the server is available the callback LWS_CALLBACK_RECEIVE_CLIENT_HTTP will be made.\n\nYou can choose whether to process the data immediately, or queue a callback when an outgoing socket is writeable to provide flow control, and process the data in the writable callback.\n\nEither way you use the api to access the data, eg\n\nNotice that if you will use SSL client connections on a vhost, you must prepare the client SSL context for the vhost after creating the vhost, since this is not normally done if the vhost was set up to listen / serve. Call the api lws_init_vhost_client_ssl() to also allow client SSL on the vhost.\n\nIf you are opening more client requests to the same host and port, you can give the flag LCCSCF_PIPELINE on to indicate you wish to pipeline them.\n\nWithout the flag, the client connections will occur concurrently using a socket and tls wrapper if requested for each connection individually. That is fast, but resource-intensive.\n\nWith the flag, lws will queue subsequent client connections on the first connection to the same host and port. When it has confirmed from the first connection that pipelining / keep-alive is supported by the server, it lets the queued client pipeline connections send their headers ahead of time to create a pipeline of requests on the server side.\n\nIn this way only one tcp connection and tls wrapper is required to transfer all the transactions sequentially. It takes a little longer but it can make a significant difference to resources on both sides.\n\nIf lws learns from the first response header that keepalive is not possible, then it marks itself with that information and detaches any queued clients to make their own individual connections as a fallback.\n\nLws can also intelligently combine multiple ongoing client connections to the same host and port into a single http/2 connection with multiple streams if the server supports it.\n\nUnlike http/1 pipelining, with http/2 the client connections all occur simultaneously using h2 stream multiplexing inside the one tcp + tls connection.\n\nYou can turn off the h2 client support either by not building lws with or giving the flag in the client connection info struct member.\n\nIf you set LWS_SERVER_OPTION_EXPLICIT_VHOSTS options flag when you create your context, it won't create a default vhost using the info struct members for compatibility. Instead you can call lws_create_vhost() afterwards to attach one or more vhosts manually.\n\nlws_create_vhost() uses the same info struct as lws_create_context(), it ignores members related to context and uses the ones meaningful for vhost (marked with VH in libwebsockets.h).\n\nWhen you attach the vhost, if the vhost's port already has a listen socket then both vhosts share it and use SNI (is SSL in use) or the Host: header from the client to select the right one. Or if no other vhost already listening the a new listen socket is created.\n\nThere are some new members but mainly it's stuff you used to set at context creation time.\n\nHow lws matches hostname or SNI to a vhost\n\nThen it tries to find an exact name match for a vhost listening on the correct port, ie, if SNI or the Host: header provided abc.com:1234, it will match on a vhost named abc.com that is listening on port 1234.\n\nIf there is no exact match, lws will consider wildcard matches, for example if cats.abc.com:1234 is provided by the client by SNI or Host: header, it will accept a vhost \"abc.com\" listening on port 1234. If there was a better, exact, match, it will have been chosen in preference to this.\n\nConnections with SSL will still have the client go on to check the certificate allows wildcards and error out if not.\n\nThe last argument to lws_create_vhost() lets you associate a linked list of lws_http_mount structures with that vhost's URL 'namespace', in a similar way that unix lets you mount filesystems into areas of your / filesystem how you like and deal with the contents transparently.\n\nThe last mount structure should have a NULL mount_next, otherwise it should point to the 'next' mount structure in your list.\n\nBoth the mount structures and the strings must persist until the context is destroyed, since they are not copied but used in place.\n\nshould be one of\n• LWSMPRO_FILE is used for mapping url namespace to a filesystem directory and serve it automatically.\n• LWSMPRO_CGI associates the url namespace with the given CGI executable, which runs when the URL is accessed and the output provided to the client.\n• LWSMPRO_REDIR_HTTP and LWSMPRO_REDIR_HTTPS auto-redirect clients to the given origin URL.\n• LWSMPRO_CALLBACK causes the http connection to attach to the callback associated with the named protocol (which may be a plugin).\n\nThe feature provided by CALLBACK type mounts is binding a part of the URL namespace to a named protocol callback handler.\n\nThis allows protocol plugins to handle areas of the URL namespace. For example in test-server-v2.0.c, the URL area \"/formtest\" is associated with the plugin providing \"protocol-post-demo\" like this\n\nClient access to /formtest[anything] will be passed to the callback registered with the named protocol, which in this case is provided by a protocol plugin.\n\nAccess by all methods, eg, GET and POST are handled by the callback.\n\nprotocol-post-demo deals with accepting and responding to the html form that is in the test server HTML.\n\nWhen a connection accesses a URL related to a CALLBACK type mount, the connection protocol is changed until the next access on the connection to a URL outside the same CALLBACK mount area. User space on the connection is arranged to be the size of the new protocol user space allocation as given in the protocol struct.\n\nThis allocation is only deleted / replaced when the connection accesses a URL region with a different protocol (or the default protocols[0] if no CALLBACK area matches it).\n\nThis \"binding connection to a protocol\" lifecycle in managed by and . Because of HTTP/1.1 connection pipelining, one connection may perform many transactions, each of which may map to different URLs and need binding to different protocols. So these messages are used to create the binding of the wsi to your protocol including any allocations, and to destroy the binding, at which point you should destroy any related allocations.\n\nThe .bind_iface flag in the context / vhost creation struct lets you declare that you want all traffic for listen and transport on that vhost to be strictly bound to the network interface named in .iface.\n\nThis Linux-only feature requires SO_BIND_TO_DEVICE, which in turn requires CAP_NET_RAW capability... root has this capability.\n\nHowever this feature needs to apply the binding also to accepted sockets during normal operation, which implies the server must run the whole time as root.\n\nYou can avoid this by using the Linux capabilities feature to have the unprivileged user inherit just the CAP_NET_RAW capability.\n\nYou can confirm this with the test server\n\nThe part that ensures the capability is inherited by the unprivileged user is\n\nThe lws test plugins' html provides useful feedback on the webpage about if it is still connected to the server, by greying out the page if not. You can also add this to your own html easily\n• None dim the page during initialization, in a script section on your page\n• None in your ws onOpen(), remove the dimming\n• None in your ws onClose(), reapply the dimming\n\nIn the code, http errors should be handled by .\n\nThere are basically two ways... the vhost can be told to redirect to an \"error page\" URL in response to specifically a 404... this is controlled by the context / vhost info struct ( ) member ... if non-null the client is redirected to this string.\n\nIf it wasn't redirected, then the response code html is synthesized containing the user-selected text message and attempts to pull in for styling.\n\nIf this file exists, it can be used to style the error page. See https://libwebsockets.org/git/badrepo for an example of what can be done ( and https://libwebsockets.org/error.css for the corresponding css)."
    },
    {
        "link": "https://github.com/warmcat/libwebsockets/issues/2464",
        "document": "I understand that there are 2 ways to integrate libwebsockets into an existed project (said project A).\n• register the libuv event loop (B) into libwebsockets (through 'info.foreign_loops' & 'lws_create_context')\n• start the event loop (B), then the libwebsockets callback function (said C) (i.e., protocols.callback) would be called, and we could put our original logic into this callback C to complete the integration.\n\nMethod 2 (low level integration, project A could use any async-like eventing architecture):\n• project A creates a customized 'lws_plugin_evlib' structure and its 'ops' field, fill suitable function pointers, and register it into 'info' and then creates 'context'.\n• project A waits and see if something is happened in some file descriptor, and use 'lws_service_fd' to service that fd.\n• libwebsockets callback (i.e., protocols.callback) would be called afterwards.\n\nAccording to my understanding, there are only these two integrated architectures, and nothing else. Is this understanding correct?\n\nIt seems libwebsockets needs to 'own' that file descriptor, and intercept 'all' data/messages from that file descriptor. And I wonder is there any other method I don't know that can achieve the following integration. (assume project A uses libuv)\n• project A waits and see if something is happened in some fd, and receives data from that fd first to see if it can handle that data, if yes, project A itself would handle that data by itself. And if project A discovers that it can not handle that data, it will call libwebsockets to parse that data and finally the libwebsockets callback would be called.\n\nThat is to say, the 'fd' is actually owned by the original codes of project A, and libwebsockets merely acts as a parser, perform some incremental parsing (the data will be continuously feed by the original codes of project A), and finally the libwebsockets callback would be called based on the parsing result.\n\nI currently use llhttp as the HTTP content parser, and have found another websocket library wslay seems to be able to do that. However, in my previous experience, I like libwebsockets, and wonder if libwebsockets could be the websocket content parser."
    }
]