[
    {
        "link": "https://typescriptlang.org/docs/handbook/2/objects.html",
        "document": "In JavaScript, the fundamental way that we group and pass around data is through objects. In TypeScript, we represent those through object types.\n\nAs we‚Äôve seen, they can be anonymous:\n\nor they can be named by using either an interface:\n\nIn all three examples above, we‚Äôve written functions that take objects that contain the property (which must be a ) and (which must be a ).\n\nWe have cheat-sheets available for both and , if you want a quick look at the important every-day syntax at a glance.\n\nEach property in an object type can specify a couple of things: the type, whether the property is optional, and whether the property can be written to.\n\nMuch of the time, we‚Äôll find ourselves dealing with objects that might have a property set. In those cases, we can mark those properties as optional by adding a question mark ( ) to the end of their names.\n\nIn this example, both and are considered optional. We can choose to provide either of them, so every call above to is valid. All optionality really says is that if the property is set, it better have a specific type.\n\nWe can also read from those properties - but when we do under , TypeScript will tell us they‚Äôre potentially .\n\nIn JavaScript, even if the property has never been set, we can still access it - it‚Äôs just going to give us the value . We can just handle specially by checking for it.\n\nNote that this pattern of setting defaults for unspecified values is so common that JavaScript has syntax to support it.\n\nHere we used a destructuring pattern for ‚Äôs parameter, and provided default values for and . Now and are both definitely present within the body of , but optional for any callers to .\n\nProperties can also be marked as for TypeScript. While it won‚Äôt change any behavior at runtime, a property marked as can‚Äôt be written to during type-checking.\n\nUsing the modifier doesn‚Äôt necessarily imply that a value is totally immutable - or in other words, that its internal contents can‚Äôt be changed. It just means the property itself can‚Äôt be re-written to.\n\nIt‚Äôs important to manage expectations of what implies. It‚Äôs useful to signal intent during development time for TypeScript on how an object should be used. TypeScript doesn‚Äôt factor in whether properties on two types are when checking whether those types are compatible, so properties can also change via aliasing.\n\nUsing mapping modifiers, you can remove attributes.\n\nSometimes you don‚Äôt know all the names of a type‚Äôs properties ahead of time, but you do know the shape of the values.\n\nIn those cases you can use an index signature to describe the types of possible values, for example:\n\nAbove, we have a interface which has an index signature. This index signature states that when a is indexed with a , it will return a .\n\nOnly some types are allowed for index signature properties: , , , template string patterns, and union types consisting only of these.\n\nWhile string index signatures are a powerful way to describe the ‚Äúdictionary‚Äù pattern, they also enforce that all properties match their return type. This is because a string index declares that is also available as . In the following example, ‚Äôs type does not match the string index‚Äôs type, and the type checker gives an error:\n\nHowever, properties of different types are acceptable if the index signature is a union of the property types:\n\nFinally, you can make index signatures in order to prevent assignment to their indices:\n\nYou can‚Äôt set because the index signature is .\n\nWhere and how an object is assigned a type can make a difference in the type system. One of the key examples of this is in excess property checking, which validates the object more thoroughly when it is created and assigned to an object type during creation.\n\nNotice the given argument to is spelled instead of . In plain JavaScript, this sort of thing fails silently.\n\nYou could argue that this program is correctly typed, since the properties are compatible, there‚Äôs no property present, and the extra property is insignificant.\n\nHowever, TypeScript takes the stance that there‚Äôs probably a bug in this code. Object literals get special treatment and undergo excess property checking when assigning them to other variables, or passing them as arguments. If an object literal has any properties that the ‚Äútarget type‚Äù doesn‚Äôt have, you‚Äôll get an error:\n\nGetting around these checks is actually really simple. The easiest method is to just use a type assertion:\n\nHowever, a better approach might be to add a string index signature if you‚Äôre sure that the object can have some extra properties that are used in some special way. If can have and properties with the above types, but could also have any number of other properties, then we could define it like so:\n\nHere we‚Äôre saying that can have any number of properties, and as long as they aren‚Äôt or , their types don‚Äôt matter.\n\nOne final way to get around these checks, which might be a bit surprising, is to assign the object to another variable: Since assigning won‚Äôt undergo excess property checks, the compiler won‚Äôt give you an error:\n\nThe above workaround will work as long as you have a common property between and . In this example, it was the property . It will however, fail if the variable does not have any common object property. For example:\n\nKeep in mind that for simple code like above, you probably shouldn‚Äôt be trying to ‚Äúget around‚Äù these checks. For more complex object literals that have methods and hold state, you might need to keep these techniques in mind, but a majority of excess property errors are actually bugs.\n\nThat means if you‚Äôre running into excess property checking problems for something like option bags, you might need to revise some of your type declarations. In this instance, if it‚Äôs okay to pass an object with both a or property to , you should fix up the definition of to reflect that.\n\nIt‚Äôs pretty common to have types that might be more specific versions of other types. For example, we might have a type that describes the fields necessary for sending letters and packages in the U.S.\n\nIn some situations that‚Äôs enough, but addresses often have a unit number associated with them if the building at an address has multiple units. We can then describe an .\n\nThis does the job, but the downside here is that we had to repeat all the other fields from when our changes were purely additive. Instead, we can extend the original type and just add the new fields that are unique to .\n\nThe keyword on an allows us to effectively copy members from other named types, and add whatever new members we want. This can be useful for cutting down the amount of type declaration boilerplate we have to write, and for signaling intent that several different declarations of the same property might be related. For example, didn‚Äôt need to repeat the property, and because originates from , a reader will know that those two types are related in some way.\n\ns can also extend from multiple types.\n\ns allowed us to build up new types from other types by extending them. TypeScript provides another construct called intersection types that is mainly used to combine existing object types.\n\nAn intersection type is defined using the operator.\n\nHere, we‚Äôve intersected and to produce a new type that has all the members of and .\n\nWe just looked at two ways to combine types which are similar, but are actually subtly different. With interfaces, we could use an clause to extend from other types, and we were able to do something similar with intersections and name the result with a type alias. The principal difference between the two is how conflicts are handled, and that difference is typically one of the main reasons why you‚Äôd pick one over the other between an interface and a type alias of an intersection type.\n\nIf interfaces are defined with the same name, TypeScript will attempt to merge them if the properties are compatible. If the properties are not compatible (i.e., they have the same property name but different types), TypeScript will raise an error.\n\nIn the case of intersection types, properties with different types will be merged automatically. When the type is used later, TypeScript will expect the property to satisfy both types simultaneously, which may produce unexpected results.\n\nFor example, the following code will throw an error because the properties are incompatible:\n\nIn contrast, the following code will compile, but it results in a type:\n\nIn this case, Staff would require the name property to be both a string and a number, which results in property being of type .\n\nLet‚Äôs imagine a type that can contain any value - s, s, s, whatever.\n\nRight now, the property is typed as , which works, but can lead to accidents down the line.\n\nWe could instead use , but that would mean that in cases where we already know the type of , we‚Äôd need to do precautionary checks, or use error-prone type assertions.\n\nOne type safe approach would be to instead scaffold out different types for every type of .\n\nBut that means we‚Äôll have to create different functions, or overloads of functions, to operate on these types.\n\nThat‚Äôs a lot of boilerplate. Moreover, we might later need to introduce new types and overloads. This is frustrating, since our box types and overloads are all effectively the same.\n\nInstead, we can make a generic type which declares a type parameter.\n\nYou might read this as ‚ÄúA of is something whose have type ‚Äù. Later on, when we refer to , we have to give a type argument in place of .\n\nThink of as a template for a real type, where is a placeholder that will get replaced with some other type. When TypeScript sees , it will replace every instance of in with , and end up working with something like . In other words, and our earlier work identically.\n\nis reusable in that can be substituted with anything. That means that when we need a box for a new type, we don‚Äôt need to declare a new type at all (though we certainly could if we wanted to).\n\nThis also means that we can avoid overloads entirely by instead using generic functions.\n\nIt is worth noting that type aliases can also be generic. We could have defined our new interface, which was:\n\nby using a type alias instead:\n\nSince type aliases, unlike interfaces, can describe more than just object types, we can also use them to write other kinds of generic helper types.\n\nWe‚Äôll circle back to type aliases in just a little bit.\n\nGeneric object types are often some sort of container type that work independently of the type of elements they contain. It‚Äôs ideal for data structures to work this way so that they‚Äôre re-usable across different data types.\n\nIt turns out we‚Äôve been working with a type just like that throughout this handbook: the type. Whenever we write out types like or , that‚Äôs really just a shorthand for and .\n\nMuch like the type above, itself is a generic type.\n\nModern JavaScript also provides other data structures which are generic, like , , and . All this really means is that because of how , , and behave, they can work with any sets of types.\n\nThe is a special type that describes arrays that shouldn‚Äôt be changed.\n\nMuch like the modifier for properties, it‚Äôs mainly a tool we can use for intent. When we see a function that returns s, it tells us we‚Äôre not meant to change the contents at all, and when we see a function that consumes s, it tells us that we can pass any array into that function without worrying that it will change its contents.\n\nUnlike , there isn‚Äôt a constructor that we can use.\n\nInstead, we can assign regular s to s.\n\nJust as TypeScript provides a shorthand syntax for with , it also provides a shorthand syntax for with .\n\nOne last thing to note is that unlike the property modifier, assignability isn‚Äôt bidirectional between regular s and s.\n\nA tuple type is another sort of type that knows exactly how many elements it contains, and exactly which types it contains at specific positions.\n\nHere, is a tuple type of and . Like , it has no representation at runtime, but is significant to TypeScript. To the type system, describes arrays whose index contains a and whose index contains a .\n\nIf we try to index past the number of elements, we‚Äôll get an error.\n\nWe can also destructure tuples using JavaScript‚Äôs array destructuring.\n\nOther than those length checks, simple tuple types like these are equivalent to types which are versions of s that declare properties for specific indexes, and that declare with a numeric literal type.\n\nAnother thing you may be interested in is that tuples can have optional properties by writing out a question mark ( after an element‚Äôs type). Optional tuple elements can only come at the end, and also affect the type of .\n\nTuples can also have rest elements, which have to be an array/tuple type.\n‚Ä¢ describes a tuple whose first two elements are and respectively, but which may have any number of s following.\n‚Ä¢ describes a tuple whose first element is and then any number of s and ending with a .\n‚Ä¢ describes a tuple whose starting elements are any number of s and ending with a then a .\n\nA tuple with a rest element has no set ‚Äúlength‚Äù - it only has a set of well-known elements in different positions.\n\nWhy might optional and rest elements be useful? Well, it allows TypeScript to correspond tuples with parameter lists. Tuples types can be used in rest parameters and arguments, so that the following:\n\nThis is handy when you want to take a variable number of arguments with a rest parameter, and you need a minimum number of elements, but you don‚Äôt want to introduce intermediate variables.\n\nOne final note about tuple types - tuple types have variants, and can be specified by sticking a modifier in front of them - just like with array shorthand syntax.\n\nAs you might expect, writing to any property of a tuple isn‚Äôt allowed in TypeScript.\n\nTuples tend to be created and left un-modified in most code, so annotating types as tuples when possible is a good default. This is also important given that array literals with assertions will be inferred with tuple types.\n\nHere, never modifies its elements, but expects a mutable tuple. Since ‚Äôs type was inferred as , it won‚Äôt be compatible with since that type can‚Äôt guarantee ‚Äôs elements won‚Äôt be mutated."
    },
    {
        "link": "https://reddit.com/r/typescript/comments/qc6u5d/whats_the_best_practice_for_when_to_use_interface",
        "document": "So I'm just getting into TypeScript, and it seems like there are multiple ways to handle types. You've got interfaces:\n\nIs there a good rule of thumb for when you would want to use one of these vs. another?"
    },
    {
        "link": "https://typescriptlang.org/docs/handbook/interfaces.html",
        "document": ""
    },
    {
        "link": "https://blog.logrocket.com/types-vs-interfaces-typescript",
        "document": "Editor‚Äôs note: This article was last updated on 5 September 2024 by Vijit Ail to reflect the latest updates on primitive types, union types, and advanced function types in TypeScript .\n\nWe have two options for defining types in TypeScript: types and interfaces. One of the most frequently asked questions about TypeScript is whether we should use interfaces or types.\n\nThe answer to this question, like many programming questions, is that it depends. In some cases, one has a clear advantage over the other, but in many cases, they are interchangeable.\n\nIn this article, I will discuss the key differences and similarities between types and interfaces and explore when it is appropriate to use each one.\n\nLet‚Äôs start with the basics of types and interfaces.\n\nis a keyword in TypeScript that we can use to define the shape of data. The basic types in TypeScript include:\n\nEach has unique features and purposes, allowing developers to choose the appropriate one for their particular use case.\n\nType aliases in TypeScript mean ‚Äúa name for any type.‚Äù They provide a way of creating new names for existing types. Type aliases don‚Äôt define new types; instead, they provide an alternative name for an existing type.\n\n Type aliases can be created using the keyword, referring to any valid TypeScript type, including primitive types.\n\nIn the above example, we create two type aliases: and . We can use as shorthand for a number type and use to represent the type definition of a user.\n\nWhen we say ‚Äútypes versus interfaces,‚Äù we refer to ‚Äútype versus interfaces.‚Äù For example, you can create the following aliases:\n\nThe two type aliases above represent alternative names for the same union type: . While the underlying type is the same, the different names express different intents, which makes the code more readable.\n\nIn TypeScript, an interface defines a contract that an object must adhere to. Below is an example:\n\nWe can express the same contract definition using type annotations:\n\nFor the above case, we can use either or . But there are some scenarios in which using instead of makes a difference.\n\nPrimitive types are inbuilt types in TypeScripts. They include , , , , and types.\n\n We can use define a type alias for a primitive type as below:\n\nWe often combine primitive type with union type to define a type alias, to make the code more readable:\n\nBut, we can‚Äôt use an interface to alias a primitive type. The interface can only be used for an object type.\n\n Therefore, when we need to define a primitive type alias, we use .\n\nUnion types allow us to describe values that can be one of several types and create unions of various primitive, literal, or complex types:\n\nUnion type can only be defined using type. There is no equivalent to a union type in an interface. But, it is possible to create a new union type from two interfaces, like so:\n\nIn TypeScript, a function type represents a function‚Äôs type signature. Using the type alias, we need to specify the parameters and the return type to define a function type:\n\nWe can also use an interface to represent the function type:\n\nBoth type and interface similarly define function types, except for a subtle syntax difference of interface using vs. when using type. Type is preferred in this case because it‚Äôs shorter and thus easier to read.\n\nAnother reason to use type for defining a function type is its capabilities that the interface lacks. When the function becomes more complex, we can take advantage of the advanced type features such as conditional types, mapped types, etc. Here‚Äôs an example:\n\nHere, we define a type with conditional type and union type. It provides a unified function signature for and handlers in a type-safe manner. We can‚Äôt achieve the same with the interface as it doesn‚Äôt have the equivalent of conditional and union types.\n\nDeclaration merging is a feature that is exclusive to interfaces. With declaration merging, we can define an interface multiple times, and the TypeScript compiler will automatically merge these definitions into a single interface definition.\n\nIn the following example, the two interface definitions are merged into one by the TypeScript compiler, and we have two properties when using the interface:\n\nType aliases can‚Äôt be merged in the same way. If you try to define the type more than once, as in the above example, an error will be thrown:\n\nWhen used in the right places, declaration merging can be very useful. One common use case for declaration merging is to extend a third-party library‚Äôs type definition to fit the needs of a particular project.\n\nIf you need to merge declarations, interfaces are the way to go.\n\nAn interface can extend one or multiple interfaces. Using the keyword, a new interface can inherit all the properties and methods of an existing interface while also adding new properties.\n\nFor example, we can create a interface by extending the interface:\n\nTo achieve a similar result for types, we need to use an intersection operator:\n\nYou can also extend an interface from a type alias with statically known members:\n\nThe exception is union types. If you try to extend an interface from a union type, you‚Äôll receive the following error:\n\nThis error occurs because the union type is not statically known. The interface definition needs to be statically known at compile time.\n\nType aliases can extend interfaces using the intersection, as below:\n\nIn a nutshell, both interfaces and type aliases can be extended. An interface can extend a statically known type alias, while a type alias can extend an interface using an intersection operator.\n\nAnother difference between types and interfaces is how conflicts are handled when you try to extend from one with the same property name.\n\nWhen extending interfaces, the same property key isn‚Äôt allowed, as in the example below:\n\nAn error is thrown because a conflict is detected.\n\nType aliases handle conflicts differently. In the case of a type alias extending another type with the same property key, it will automatically merge all properties instead of throwing errors.\n\nIn the following example, the intersection operator merges the method signature of the two declarations, and a operator is used to narrow down the union type parameter so that we can get the return value in a type-safe way:\n\nIt is important to note that the type intersection of two properties may produce unexpected results. In the example below, the property for the extended type becomes , since it can‚Äôt be both and at the same time:\n\nIn summary, interfaces will detect property or method name conflicts at compile time and generate an error, whereas type intersections will merge the properties or methods without throwing errors. Therefore, if we need to overload functions, type aliases should be used.\n\nOften, when using an interface, Typescript will generally do a better job displaying the shape of the interface in error messages, tooltips and IDEs. It is also much easier to read, no matter how many types you combine or extend.\n\nCompare that to the type alias that uses the intersection of two or more types like , and you then type to use that alias in another intersection like , TypeScript can struggle to display the structure of the combined type, making it harder to understand the shape of the type from the error messages.\n\nTypescript caches the results of the evaluated relationship between interfaces, like whether one interface extends another or if two interfaces are compatible. This approach improves the overall performance when the same relationship is referenced in the future.\n\nIn contrast, when working with intersections, TypeScript does not cache these relationships. Every time a type intersection is used, TypeScript has to re-evaluate the entire intersection which can lead to efficiency concerns.\n\nFor these reasons, it is advisable to use interface extends instead of relying on type intersections.\n\nIn TypeScript, we can implement a class using either an interface or a type alias:\n\nAs shown above, both interfaces and type aliases can be used to implement a class similarly; the only difference is that we can‚Äôt implement a union type.\n\nIn the above example, the TypeScript compiler throws an error because a class represents a specific data shape, but a union type can be one of several data types.\n\nIn TypeScript, the tuple type allows us to express an array with a fixed number of elements, where each element has its data type. It can be useful when you need to work with arrays of data with a fixed structure:\n\nInterfaces don‚Äôt have direct support for tuple types. Although we can create some workarounds like in the example below, it is not as concise or readable as using the tuple type:\n\nUnlike tuples, this interface extends the generic type, which enables it to have any number of elements beyond the first three. This is because arrays in TypeScript are dynamic, and you can access or assign values to indices beyond the ones explicitly defined in the interface:\n\nTypeScript provides a wide range of advanced type features that can‚Äôt be found in interfaces. Some of the unique features in TypeScript include:\n‚Ä¢ Type inferences: Can infer the type of variables and functions based on their usage. This reduces the amount of code and improves readability\n‚Ä¢ Conditional types: Allow us to create complex type expressions with conditional behaviors that depend on other types\n‚Ä¢ Type guards: Used to write sophisticated control flow based on the type of a variable\n‚Ä¢ Mapped types: Transforms an existing object type into a new type\n‚Ä¢ Utility types: A set of out-of-the-box utilities that help to manipulate types\n\nTypeScript‚Äôs typing system constantly evolves with every new release, making it a complex and powerful toolbox. The impressive typing system is one of the main reasons many developers prefer to use TypeScript.\n\nWhen to use types vs. interfaces\n\nType aliases and interfaces are similar but have subtle differences, as shown in the previous section.\n\nWhile almost all interface features are available in types or have equivalents, one exception is declaration merging. Interfaces should generally be used when declaration merging is necessary, such as extending an existing library or authoring a new one. Additionally, if you prefer the object-oriented inheritance style, using the keyword with an interface is often more readable than using the intersection with type aliases.\n\nInterfaces with enables the compiler to be more performant, compared to type aliases with intersections.\n\nHowever, many of the features in types are difficult or impossible to achieve with interfaces. For example, TypeScript provides rich features like conditional types, generic types, type guards, advanced types, and more. You can use them to build a well-constrained type system to make your app strongly typed. The interface can‚Äôt achieve this.\n\nIn many cases, they can be used interchangeably depending on personal preference. But, we should use type aliases in the following use cases:\n‚Ä¢ To create a new name for a primitive type\n‚Ä¢ To define a union type, tuple type, function type, or another more complex type\n‚Ä¢ To use mapped types, conditional types, type guards, or other advanced type features\n\nCompared with interfaces, types are more expressive. Many advanced type features are unavailable in interfaces, and those features continue to grow as TypeScript evolves.\n\n Below is an example of the advanced type feature that the interface can‚Äôt achieve.\n\nUsing mapped type, template literal types, and operator, we created a type that automatically generates getter methods for any object type.\n\nIn addition, many developers prefer to use types because they match the functional programming paradigm well. The rich type expression makes it easier to achieve functional composition, immutability, and other functional programming capabilities in a type-safe manner.\n\nIn this article, we discussed type aliases and interfaces and their differences. While there are some scenarios in which one is preferred over the other, in most cases, the choice between them boils down to personal preference.\n\n I lean towards using types simply because of the amazing type system. What are your preferences? You are welcome to share your opinions in the comments section below."
    },
    {
        "link": "https://prismic.io/blog/typescript-interfaces",
        "document": "When working with TypeScript, there are several core principles you‚Äôll use a lot. One of those is interfaces, so it pays to have a solid understanding and grasp of them. In this post, we‚Äôre going to do a deep dive into interfaces, their benefits as well as their various use cases. If you‚Äôd like to follow along with this and experiment with using interfaces yourself, you can use the TypeScript Playground here.\n\nLet‚Äôs start by looking at what exactly interfaces are. Interfaces are a feature of TypeScript that allows us to define the structure or shape of an object and specify the properties and methods that an object has or should have. Their primary function is type checking and aiding developers in catching type-related errors during development. Here, you can see a small example of how we can define an interface and apply it to an object.\n\nAs you can see in the above code block, we access a property that is defined in the interface with no issues by running . We also can see an example of us trying to access a property that doesn‚Äôt exist in the interface by running , therefore throwing a type error.\n\nNow that we understand a bit more about interfaces, what they look like, and how to use them, let‚Äôs take a closer look at their benefits to us. The first benefit of interfaces is the most obvious one: they highlight any possible type errors and issues in our code to prevent us from accessing any properties that might not exist. This, in turn, helps us reduce runtime errors and prevent bugs from being created. Another benefit of interfaces is that they define and create clear contracts for the functions and code that consume them. They prevent us from consuming methods and properties that don‚Äôt exist and help ensure we stay within the established structure defined for the object that the interface is describing. Because interfaces define the properties and methods that exist on an object as well as their types, they act as a form of documentation that enhances the code readability and helps developers reading the code understand how it works and how the code fits together. Since interfaces can always be extended and reused in various places, they promote code reusability and help reduce duplication. By defining central, common interfaces that can be reused and extended throughout an application, you can ensure consistency in your code and logic. IDEs that integrate with TypeScript can read the interfaces you define and offer autocompletion suggestions from them, as well as help with code navigation to make you a more productive and efficient developer. Finally, interfaces help make refactoring easier because you‚Äôre able to update the implementation of a piece of code or logic, and as long as it adheres to the same interface, other code that depends on the changed logic shouldn‚Äôt be impacted.\n\nI hope, at this point, you‚Äôre convinced of the benefits of interfaces and why we should be using them. So, now, let‚Äôs look at how we can use them in our TypeScript code. In addition to defining the types of objects, we can also use interfaces to type functions, their return values, and their arguments. For example, we can do something like this.\n\nIn this example, we have an interface called and use the keyword to say the class will have all of the types defined in . Because this isn‚Äôt true and the field is missing in the class, an error is thrown. When working with objects in TypeScript, it‚Äôs quite common to have properties that might only be defined some of the time. In these instances, we can define optional properties like so.\n\nWhat this interface says is if we index an object that is typed using the interface with a , we‚Äôll have a returned to us. You‚Äôre not limited to just types, either. It could also be another type or interface if you wish, which is great for times when you don‚Äôt know all of the properties but know their shape. Also, if you want to combine index signatures and normal interface definitions, you can do so. However, if you do this, the index signature needs to be updated to contain all of the potential return types.\n\nIt‚Äôs worth noting that while index signatures can make your life easier, where possible and feasible, you should always reach for actually typing properties on an object as that‚Äôll give you better type safety. Sometimes, you want to extend an existing interface and add new fields to it without changing the original one. This can be achieved by using the keyword. This allows you to take an existing interface and create a copy of it while also adding new fields to it. For example, we could do something like this.\n\nIn this example, we took the original interface and extended it with the property to create a new interface called . So, at this point, we have two interfaces, and , with them being identical apart from the latter having the property added to it. If you want to, you can also combine multiple existing interfaces to create a new one without adding any new properties to it, which can be done like so.\n\nDiscriminating unions are a way we can define a new type from multiple interfaces and use a common property present on all of the interfaces (the ‚Äúdiscriminator‚Äù) to distinguish between the types in our logic. For example, we can define two interfaces for two different shapes ( and ), and we can then use a property present on both of them ( ) to dictate which interface we are dealing with at that moment."
    },
    {
        "link": "https://typescriptlang.org/docs/handbook/dom-manipulation.html",
        "document": ""
    },
    {
        "link": "https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/tutorials/DOM%20Manipulation.md",
        "document": "In the 20+ years since its standardization, JavaScript has come a very long way. While in 2020, JavaScript can be used on servers, in data science, and even on IoT devices, it is important to remember its most popular use case: web browsers.\n\nWebsites are made up of HTML and/or XML documents. These documents are static, they do not change. The Document Object Model (DOM) is a programming interface implemented by browsers to make static websites functional. The DOM API can be used to change the document structure, style, and content. The API is so powerful that countless frontend frameworks (jQuery, React, Angular, etc.) have been developed around it to make dynamic websites even easier to develop.\n\nTypeScript is a typed superset of JavaScript, and it ships type definitions for the DOM API. These definitions are readily available in any default TypeScript project. Of the 20,000+ lines of definitions in lib.dom.d.ts, one stands out among the rest: . This type is the backbone for DOM manipulation with TypeScript.\n\nLet's explore a TypeScript script that adds a element to the element.\n\nAfter compiling and running the index.html page, the resulting HTML will be:\n\nThe first line of the TypeScript code uses a global variable . Inspecting the variable shows it is defined by the interface from the lib.dom.d.ts file. The code snippet contains calls to two methods, and .\n\nThe definition for this method is as follows:\n\nPass it an element id string and it will return either or . This method introduces one of the most important types, . It serves as the base interface for every other element interface. For example, the variable in the code example is of type . Also, take note that this method can return . This is because the method can't be certain pre-runtime if it will be able to actually find the specified element or not. In the last line of the code snippet, the new optional chaining operator is used to call .\n\nThe definition for this method is (I have omitted the deprecated definition):\n\nThis is an overloaded function definition. The second overload is simplest and works a lot like the method does. Pass it any and it will return a standard HTMLElement. This definition is what enables developers to create unique HTML element tags.\n\nFor example returns a element, clearly not an element that is specified by the HTML specification.\n\nFor the first definition of , it is using some advanced generic patterns. It is best understood broken down into chunks, starting with the generic expression: . This expression defines a generic parameter that is constrained to the keys of the interface . The map interface contains every specified HTML tag name and its corresponding type interface. For example here are the first 5 mapped values:\n\nSome elements do not exhibit unique properties and so they just return , but other types do have unique properties and methods so they return their specific interface (which will extend from or implement ).\n\nNow, for the remainder of the definition: . The first argument is defined as the generic parameter . The TypeScript interpreter is smart enough to infer the generic parameter from this argument. This means that the developer does not have to specify the generic parameter when using the method; whatever value is passed to the argument will be inferred as and thus can be used throughout the remainder of the definition. This is exactly what happens; the return value takes the argument and uses it to return the corresponding type. This definition is how the variable from the code snippet gets a type of . And if the code was , then it would be an element of type .\n\nThe function returns an . interface extends the interface which extends the interface. This prototypal extension allows for all to utilize a subset of standard methods. In the code snippet, we use a property defined on the interface to append the new element to the website.\n\nThe last line of the code snippet is . The previous, , section detailed that the optional chaining operator is used here because can potentially be null at runtime. The method is defined by:\n\nThis method works similarly to the method as the generic parameter is inferred from the argument. is constrained to another base interface .\n\nPreviously, this document details the interface extends from which extends from . In the DOM API there is a concept of children elements. For example in the following HTML, the tags are children of the element\n\nAfter capturing the element, the prop will return an list containing the . The property will return a similar list of nodes. Each tag will still be of type , but the can contain additional HTML nodes that the list cannot.\n\nModify the HTML by removing one of the tags, but keep the text.\n\nSee how both lists change. now only contains the element, and the contains a node rather than two nodes. The part of the is the literal containing the text . The list does not contain this because it is not considered an .\n\nBoth of these methods are great tools for getting lists of dom elements that fit a more unique set of constraints. They are defined in lib.dom.d.ts as:\n\nThe definition is similar to , except it returns a new type: . This return type is essentially a custom implementation of the standard JavaScript list element. Arguably, replacing with would result in a very similar user experience. only implements the following properties and methods: , , , and numeric indexing. Additionally, this method returns a list of elements, not nodes, which is what was returning from the method. While this may appear as a discrepancy, take note that interface extends from .\n\nTo see these methods in action modify the existing code to:\n\nThe best part about the lib.dom.d.ts type definitions is that they are reflective of the types annotated in the Mozilla Developer Network (MDN) documentation site. For example, the interface is documented by this HTMLElement page on MDN. These pages list all available properties, methods, and sometimes even examples. Another great aspect of the pages is that they provide links to the corresponding standard documents. Here is the link to the W3C Recommendation for HTMLElement."
    },
    {
        "link": "https://svijaykoushik.github.io/blog/2019/09/27/typescript-dom-manipulation",
        "document": "Every TypeScript example and tutorial I have found thus far is about language features, Static typing, Visual Studio, etc. I cannot find anything to tell me how I should be using it with reference to JavaScript and the DOM. My understanding it you can use TypeScript for the DOM. But, I never see anyone using it for that.\n\nSaid johnny in a question on stackoverflow.com. A while back I had the same question. Can We Use Typescript to manipulate the DOM?\n\nHello world! I‚Äôve been learning Typescript for a week now. I got into typescript when I wanted to learn the new Angular. Since it is based on Typescript, I decided to learn Typescript. During learning, I found it odd that none of the learning aids I used included examples of using the language with HTML. Every example I saw in those learning aids and some other tutorials I then looked up involved only node.js. More googling landed me on StackOverflow where johnny, as I mentioned before, had the same question. using this as an opportunity to make a post after almost a year, I‚Äôve made this post, the missing piece of the puzzle, in hopes that it would land first instead of johnny‚Äôs question on StackOverflow.\n\nUsing the DOM or Dom manipulation in typescript is simple. All I needed to do was to use the types defined specifically for DOM access that is available in Typescript. The rest was the same as in JavaScript. But‚Ä¶ these ‚ÄúDOM types‚Äù are not available out of the box with Typescript. I needed to explicitly configure the typescript compiler to include the ‚Äúdom‚Äù library in the section in the configuration file[2] to access the DOM types in my project. ‚ÄúWhy didn‚Äôt they include by default?. Maybe the creators didn‚Äôt intend to use it primarily for front end development‚Äù I thought to myself.\n\nSome other configuration changes I made were: I enabled mode for strict type checking and I changed the from ‚Äúcommon JS‚Äù to ‚Äúes5‚Äù, so the compiler can output JS for browsers and not for node.js. I also added the ‚Äúes2015‚Äù library so that I could use functionalities like arrays and Math functions for my example.\n\nIn this article, I‚Äôm going to write a hello world program to demonstrate the use of DOM in typescript. Because it‚Äôs my first post on typescript. I‚Äôll be covering the basics of using the DOM types and a problem a beginner like me would face while doing this the first time. I‚Äôm not covering DOM events here. I‚Äôll be covering them in another article coming soon.\n\nI‚Äôll begin with the basics where I change the inner text value of an existing element. I started by creating an HTML file with a simple html5 boilerplate with a element with id greeter saying ‚Äúhello‚Äù inside the body.\n\nThen, I opened a new typescript file and added the following code\n\nIn the code, I created a variable greeter and I assigned the type to it. The type which is defined in the ‚Äúdom‚Äù library we added to the configuration, tells the compiler that the greeter variable expects an Html heading element and nothing else. And, I assigned the greeter to the value returned by the function which returns the element with the ID provided. Then I assigned the string ‚Äúhello world‚Äù to the property of the greeter element.\n\nWhen I compiled the code with the command\n\nIt threw the following error\n\nBummer! My first attempt failed. On the bright side, Typescript is doing its job and the configurations I set up works. The error means that, I tried to assign greeter which is of type with an object of type that the method returned. in the error message means that the method‚Äôs return value can be either of type or . The special operator is called the union operator. I won‚Äôt be explaining ‚Äúunion types‚Äù in this article. You can learn about them here.\n\ntype is just a common interface for all the html elements[1] but the compiler expects a . I thought of changing the greeter variable‚Äôs type to but I didn‚Äôt. Because, it‚Äôs not right. If I had changed it to , it means greeter could accept any HTML element from the DOM. I wanted it to accept only a heading element. So, I used type assertion feature of typescript (Learn about type assertion here) to tell the compiler that the element returned from the getElementById is indeed a heading element and it doesn‚Äôt have to worry about it. Here‚Äôs the fixed code:\n\nNow, the compilation was a success. I included the script.js file generated by the compiler in the Html document and opened it on a browser. It looked like this:\n\nNow that I‚Äôve made sure that everything works as intended, It was time to decorate the page. I wanted a font style that is not formal looking. After browsing through google fonts, I chose Rock Salt. I imported it in my stylesheet along with Dancing Script as a secondary font using CSS imports. I then proceeded by adding a few more elements to the Html document. I centered all the text using CSS flexbox, added a nice background from UI gradients, and adjusted positions of some elements to arrange them properly. The page now looked beautiful.\n\nNext, to place the cherry on top, I wanted to add a pretty background animation of orbs rising to the top like bubbles to the page. To make the orbs I decided to use elements. Since I wanted several of these orbs with different sizes, I split the task into two so the work could be simplified. One, I created a common style for all the orbs and created a custom animation for the orbs in CSS. And two, I created the orbs dynamically with the help of typescript by creating a set number of elements, assigning them the style created beforehand and randomizing their sizes, positions, and animation-delay to make them look more natural.\n\nFinally, I added the orbs to the dom like this and thereby kickstarting the animation\n\nAnd the link to the repo containing the complete code\n\nDuring writing this article and the example, I realized the involvement of advanced concepts like type assertion and union types. I now understand why the authors of those tutorials didn‚Äôt include them. If included, it would have confused beginners outright. I think it‚Äôs best to learn typescript well before starting to use DOM in your projects.\n\nIn my example, I skipped the null checking when I fixed the type mismatch error as it seemed unnecessary for the example but you should check for nulls when necessary to avoid breaking your app at runtime. I also skipped the part where I added animations using the animate.css plugin for the text as it felt trivial explaining it.\n\nFinally, I need to thank Ivan Petrov for suggesting me to read a book when learning a new tech in a comment on my previous post on https://dev.to. Thanks, Ivan üëçüèΩ. The exercises in the book helped me.\n\nThanks for your time. :)\n‚Ä¢ Stop tracking and start ignoring: A tip to delete files from a repository and stop tracking them while keeping them locally - https://svijaykoushik.github.io/blog/2019/02/17/start-ignoring/"
    },
    {
        "link": "https://stackoverflow.com/questions/66718083/how-to-manipulate-dom-elements-in-typescript",
        "document": "Whenever you use or you are not guaranteed to find a matching element. That's why the Typescript return type is .\n\nWhen you use the type assertion you are insisting that you will always have an and not . You aren't checking if you have an element, you are asserting that you do.\n\nIt turns out that your assertion was incorrect. You actually had and not an . So you get a runtime error when trying to set on .\n\nAs for why you can't find a matching element when one seems to exist in your app -- that I cannot answer from just what you've posted here.\n\nBut I can help with properly handling the possibility of in your Typescript code."
    },
    {
        "link": "https://stackoverflow.com/questions/35801420/angular2typescript-how-to-manipulate-dom-element",
        "document": "Update in 2017: ViewChild will be the best way to access Dom element.\n\nI have tried the following two methods, only method 2 works. But I don't want the repeated code: document.getElementById() in each method. I prefer method 1, but why method 1 doesn't work?\n\nAre there any better ways to manipulate DOM in Angular2?"
    }
]