[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce",
        "document": "The method of instances executes a user-supplied \"reducer\" callback function on each element of the array, in order, passing in the return value from the calculation on the preceding element. The final result of running the reducer across all elements of the array is a single value. The first time that the callback is run there is no \"return value of the previous calculation\". If supplied, an initial value may be used in its place. Otherwise the array element at index 0 is used as the initial value and iteration starts from the next element (index 1 instead of index 0).\n\nA function to execute for each element in the array. Its return value becomes the value of the parameter on the next invocation of . For the last invocation, the return value becomes the return value of . The function is called with the following arguments: The value resulting from the previous call to . On the first call, its value is if the latter is specified; otherwise its value is . The value of the current element. On the first call, its value is if is specified; otherwise its value is . The index position of in the array. On the first call, its value is if is specified, otherwise . The array was called upon. A value to which is initialized the first time the callback is called. If is specified, starts executing with the first value in the array as . If is not specified, is initialized to the first value in the array, and starts executing with the second value in the array as . In this case, if the array is empty (so that there's no first value to return as ), an error is thrown.\n\nThe method is an iterative method. It runs a \"reducer\" callback function over all elements in the array, in ascending-index order, and accumulates them into a single value. Every time, the return value of is passed into again on next invocation as . The final value of (which is the value returned from on the final iteration of the array) becomes the return value of . Read the iterative methods section for more information about how these methods work in general. is invoked only for array indexes which have assigned values. It is not invoked for empty slots in sparse arrays. Unlike other iterative methods, does not accept a argument. is always called with as , which gets substituted with if is non-strict. is a central concept in functional programming, where it's not possible to mutate any value, so in order to accumulate all values in an array, one must return a new accumulator value on every iteration. This convention propagates to JavaScript's : you should use spreading or other copying methods where possible to create new arrays and objects as the accumulator, rather than mutating the existing one. If you decided to mutate the accumulator instead of copying it, remember to still return the modified object in the callback, or the next iteration will receive undefined. However, note that copying the accumulator may in turn lead to increased memory usage and degraded performance â€” see When to not use reduce() for more details. In such cases, to avoid bad performance and unreadable code, it's better to use a loop instead. The method is generic. It only expects the value to have a property and integer-keyed properties.\n\nIf the array only has one element (regardless of position) and no is provided, or if is provided but the array is empty, the solo value will be returned without calling . If is provided and the array is not empty, then the reduce method will always invoke the callback function starting at index 0. If is not provided then the reduce method will act differently for arrays with length larger than 1, equal to 1 and 0, as shown in the following example: const getMax = (a, b) => Math.max(a, b); // callback is invoked for each element in the array starting at index 0 [1, 100].reduce(getMax, 50); // 100 [50].reduce(getMax, 10); // 50 // callback is invoked once for element at index 1 [1, 100].reduce(getMax); // 100 // callback is not invoked [50].reduce(getMax); // 50 [].reduce(getMax, 1); // 1 [].reduce(getMax); // TypeError\n\nWhen to not use reduce() Multipurpose higher-order functions like can be powerful but sometimes difficult to understand, especially for less-experienced JavaScript developers. If code becomes clearer when using other array methods, developers must weigh the readability tradeoff against the other benefits of using . Note that is always equivalent to a loop, except that instead of mutating a variable in the upper scope, we now return the new value for each iteration: const val = array.reduce((acc, cur) => update(acc, cur), initialValue); // Is equivalent to: let val = initialValue; for (const cur of array) { val = update(val, cur); } As previously stated, the reason why people may want to use is to mimic functional programming practices of immutable data. Therefore, developers who uphold the immutability of the accumulator often copy the entire accumulator for each iteration, like this: const names = [\"Alice\", \"Bob\", \"Tiff\", \"Bruce\", \"Alice\"]; const countedNames = names.reduce((allNames, name) => { const currCount = Object.hasOwn(allNames, name) ? allNames[name] : 0; return { ...allNames, [name]: currCount + 1, }; }, {}); This code is ill-performing, because each iteration has to copy the entire object, which could be big, depending how many unique names there are. This code has worst-case performance, where is the length of . A better alternative is to mutate the object on each iteration. However, if gets mutated anyway, you may want to convert the to a loop instead, which is much clearer: const names = [\"Alice\", \"Bob\", \"Tiff\", \"Bruce\", \"Alice\"]; const countedNames = names.reduce((allNames, name) => { const currCount = allNames[name] ?? 0; allNames[name] = currCount + 1; // return allNames, otherwise the next iteration receives undefined return allNames; }, Object.create(null)); const names = [\"Alice\", \"Bob\", \"Tiff\", \"Bruce\", \"Alice\"]; const countedNames = Object.create(null); for (const name of names) { const currCount = countedNames[name] ?? 0; countedNames[name] = currCount + 1; } Therefore, if your accumulator is an array or an object and you are copying the array or object on each iteration, you may accidentally introduce quadratic complexity into your code, causing performance to quickly degrade on large data. This has happened in real-world code â€” see for example Making Tanstack Table 1000x faster with a 1 line change. Some of the acceptable use cases of are given above (most notably, summing an array, promise sequencing, and function piping). There are other cases where better alternatives than exist.\nâ€¢ Flattening an array of arrays. Use instead.\nâ€¢ Grouping objects by a property. Use instead.\nâ€¢ Concatenating arrays contained in an array of objects. Use instead. const friends = [ { name: \"Anna\", books: [\"Bible\", \"Harry Potter\"] }, { name: \"Bob\", books: [\"War and peace\", \"Romeo and Juliet\"] }, { name: \"Alice\", books: [\"The Lord of the Rings\", \"The Shining\"] }, ]; const allBooks = friends.reduce((acc, cur) => [...acc, ...cur.books], []);\nâ€¢ Removing duplicate items in an array. Use and instead.\nâ€¢ Eliminating or adding elements in an array. Use instead. // Takes an array of numbers and splits perfect squares into its square roots const roots = array.reduce((acc, cur) => { if (cur < 0) return acc; const root = Math.sqrt(cur); if (Number.isInteger(root)) return [...acc, root, root]; return [...acc, cur]; }, []); If you are only eliminating elements from an array, you also can use .\nâ€¢ Searching for elements or testing if elements satisfy a condition. Use and , or and instead. These methods have the additional benefit that they return as soon as the result is certain, without iterating the entire array. In cases where is the best choice, documentation and semantic variable naming can help mitigate readability drawbacks."
    },
    {
        "link": "https://w3schools.com/jsref/jsref_reduce.asp",
        "document": "Round all the numbers and display the sum:\n\nSubtract all numbers in an array:\n\nThe method returns a single value: the function's accumulated result.\n\nThe method does not execute the function for empty array elements.\n\nThe method does not change the original array.\n\nAt the first callback, there is no return value from the previous callback.\n\nNormally, array element 0 is used as initial value, and the iteration starts from array element 1.\n\nIf an initial value is supplied, this is used, and the iteration starts from array element 0."
    },
    {
        "link": "https://geeksforgeeks.org/how-to-use-array-prototype-reduce-method-in-javascript",
        "document": "The Array.prototype.reduce() method is used in an array to return a single value from an array after executing the user-supplied callback function on each array element variety. It transverses from the left-most-element to the right-most-element of the given array.\n\nArray.prototype.reduce() can be called using two ways.\nâ€¢ Callback function : The function will be declared first and later called for execution on an array.\nâ€¢ Inline callback function: The parameters are passed inside the function inside reduce() method along with the array that is to be executed. It accepts four arguments:\nâ€¢ returnValue: It is the returning value resulting from the previous call of the callback function. On its first call, it takes the value of initialValue else takes the value of the first element of the array, i.e. array[0]\nâ€¢ currentValue: It is the present value of the element which is getting currently executed by the callback function. On the first call, it is the first element of the array if initialValue was specified else it is array[1], i.e. a second element of the array.\nâ€¢ currentIndex: It is the value of the index of the â€˜currentValueâ€™ element. It takes the value â€˜0â€™ if initialValue is specified else â€˜1â€™.\nâ€¢ array: It is the required array we need to transverse.\nâ€¢ initialValue: It is an optional parameter that will be initialized as returnValue if it is mentioned, after which execution will be performed on other elements of the array starting from index 0.\n\nExample 1: We will see the basic use of the Array.prototype.reduce() method using the callback function in Javascript.\n\nExample 2: We will see the use of the Array.prototype.reduce() method in Javascript."
    },
    {
        "link": "https://thecodebarbarian.com/javascript-reduce-in-5-examples.html",
        "document": "The method on JavaScript arrays executes a \"reducer\" function on every element of the array in order, passing the return value from the previous reducer call to the next reducer call. The function is a common cause of confusion, but it can also make your code much more readable when combined with other functional programming abstractions. Here are 4 common examples and 1 not-so-common example that demonstrate how to use .\n\nMost tutorials start with this example: given an array of numbers , calculate the sum. Here's how you might sum up an array with a plain old loop.\n\nHere's an equivalent example using :\n\nThe function's first 2 parameters are a function and an arbitrary . JavaScript then calls the on each element of the array with the accumulator value as the first parameter. The accumulator starts as , and then JavaScript uses the return value of each call as the new accumulator.\n\nTalk is cheap, show me the code. So here's a quick example of how you might implement a simplified function using loops.\n\nThe function by itself is often more confusing than helpful. If all you need to do is sum an array of numbers, you might be better off using a loop. But, when combined with other array methods like and , starts looking more appealing.\n\nFor example, suppose you have an array of line items, and you want to calculate the sum of each line item's property.\n\nHere's one way to add up the line items using :\n\nThis works, but is less composable. A better alternative is to first to get the .\n\nWhy is this second approach better? Because you can abstract out the reducer into a function , and reuse it wherever you need to sum up an array.\n\nThis is important because, while you think will never change, it will. For example, the above code doesn't account for the fact that in JavaScript. This is a common mistake when calculating prices in an interpretted language. Binary floating points are weird. So you actually need to round:\n\nmakes it easy to reuse logic like throughout your app using function chaining. So you can change your logic once rather than searching through every loop in your app.\n\nWhile is often used for summing, it doesn't have to be. The can be any value: number, , , array, POJO, even a promise.\n\nFor example, suppose you have an array of JavaScript dates, and you want to find the most recent date.\n\nOne approach is to sort the array and take the last element in the sorted array. That works, but isn't as efficient as it could be, and sorting an array of dates in JavaScript is non-trivial.\n\nInstead, you can use and make your reducer return the most recent date found so far.\n\nGiven an array of objects with an property:\n\nHow do you return a map that contains how many characters have a given ? For example, the correct output on the above array would be .\n\nHere's how you can do that with .\n\nSuppose you have an array of async functions that you want to execute in series. There is a non-standard function for this, but you can also do this with .\n\nThe function is a powerful tool. By abstracting out filters and reducers, you can consolidate common tasks like \"summing an array of numbers\" into a separate function for easier refactoring and DRY-er code."
    },
    {
        "link": "https://stackoverflow.com/questions/5732043/how-to-call-reduce-on-an-array-of-objects-to-sum-their-properties",
        "document": "What am I doing wrong in the first example?\n\nI have cause to believe that a.x is undefined at some point.\n\nSay I want to sum a.x for each element in arr .\n\nAfter the first iteration your're returning a number and then trying to get property of it to add to the next object which is and maths involving results in . try returning an object contain an property with the sum of the x properties of the parameters: The return value of each iteration of used as the variable in the next iteration. The problem with your example is that you're returning a number literal. Iteration 1: , , as in next iteration A number literal does not (typically) have a property called so it's and returns and is always Clarification: I prefer my method over the other top answer in this thread as I disagree with the idea that passing an optional parameter to reduce with a magic number to get out a number primitive is cleaner. It may result in fewer lines written but imo it is less readable.\n\nThe key to this is setting initial value. The return value becomes first parameter of the next iteration. Technique used in top answer is not idiomatic The accepted answer proposes NOT passing the \"optional\" value. This is wrong, as the idiomatic way is that the second parameter always be included. Why? Three reasons: 1. Dangerous -- Not passing in the initial value is dangerous and can create side-effects and mutations if the callback function is careless. const badCallback = (a,i) => Object.assign(a,i) const foo = [ { a: 1 }, { b: 2 }, { c: 3 } ] const bar = foo.reduce( badCallback ) // bad use of Object.assign // Look, we've tampered with the original array foo // [ { a: 1, b: 2, c: 3 }, { b: 2 }, { c: 3 } ] If however we had done it this way, with the initial value: const bar = foo.reduce( badCallback, {}) // foo is still OK foo // { a: 1, b: 2, c: 3 } For the record, unless you intend to mutate the original object, set the first parameter of to an empty object. Like this: . 2 - Better Type Inference --When using a tool like TypeScript or an editor like VS Code, you get the benefit of telling the compiler the initial and it can catch errors if you're doing it wrong. If you don't set the initial value, in many situations it might not be able to guess and you could end up with creepy runtime errors. 3 - Respect the Functors -- JavaScript shines best when its inner functional child is unleashed. In the functional world, there is a standard on how you \"fold\" or an array. When you fold or apply a catamorphism to the array, you take the values of that array to construct a new type. You need to communicate the resulting type--you should do this even if the final type is that of the values in the array, another array, or any other type. Let's think about it another way. In JavaScript, functions can be passed around like data, this is how callbacks work, what is the result of the following code? Will it return an number? An object? This makes it clearer Read more on the functional programming spec here: https://github.com/fantasyland/fantasy-land#foldable The function takes the following parameters\nâ€¢ None If is provided, the function passes the as the and the first item of the array as the .\nâ€¢ None If is not provided, the function passes the first item in the array as the and the second item in the array as which can be confusing behavior. I teach and recommend always setting the initial value of reduce. You can check out the documentation at:\n\nTo formalize what has been pointed out, a reducer is a catamorphism which takes two arguments which may be the same type by coincidence, and returns a type which matches the first argument. That means that the body of the reducer needs to be about converting and the current value of the to the value of the new . This works in a straightforward way, when adding, because the accumulator and the element values both happen to be the same type (but serve different purposes). This just works because they're all numbers. Now we're giving a starting value to the aggregator. The starting value should be the type that you expect the aggregator to be (the type you expect to come out as the final value), in the vast majority of cases. While you aren't forced to do this (and shouldn't be), it's important to keep in mind. Once you know that, you can write meaningful reductions for other n:1 relationship problems. Reducing an array of arrays, to a single flat array: Any time you're looking to go from an array of things, to a single value that doesn't match a 1:1, reduce is something you might consider. In fact, map and filter can both be implemented as reductions: I hope this provides some further context for how to use . The one addition to this, which I haven't broken into yet, is when there is an expectation that the input and output types are specifically meant to be dynamic, because the array elements are functions:\n\nIf you have a complex object with a lot of data, like an array of objects, you can take a step by step approach to solve this. First, you should map your array into a new array of your interest, it could be a new array of values in this example. This call back function will return a new array containing only values from the original array and store it on values const. Now your values const is an array like this: And now your are ready to perform your reduce: As you can see, the reduce method executes the call back function multiple times. For each time, it takes the current value of the item in the array and sum with the accumulator. So to properly sum it you need to set the initial value of your accumulator as the second argument of the reduce method. Now you have your new const sum with the value of 30."
    },
    {
        "link": "https://medium.com/@shore.jeremiah/recursion-vs-reduction-in-javascript-a2dec8ae5c21",
        "document": "My last post on JSâ€”one involving style choices to make it read like Englishâ€”was a bitâ€¦ lengthy. Iâ€™ll try to not over-explain or overthink this one. Iâ€™ll post some code, some quick thoughts for context, then a distinct observation. After that, you can draw your own conclusions. ðŸ˜Ž\n\nHere we have three functions that do the same thing. They take an array of numbers and return a sum. There are tradeoffs between using each. In a simple example like this, it might be difficult to see them. Iâ€™ll leave it to you (for now!) to do your own research on the style, readability, and performance implications between a choice like this.\n\nWhat I want to draw most attention to is how these solutions are connected. Sure, they have the same signature, but the manner by which they operate is also connected. All solutions are, in their own way, iterating over the array. Each has a linear or O(n) runtime. The functional and recursive operations are less declarative, and donâ€™t need to operate via side effect internally; they simply pass the accumulator forward during each iteration. The only real difference in the recursive solution is that it is narrowing the size of the input on each invocation. The array gets smaller until it reaches the base case, where it is empty. Herein lies a very intriguing observationâ€¦\n\nIâ€™ve been programming in some form or another for 15+ years, and professionally for 8+ years. It was only yesterday that I reached this surprisingly simple conclusion! I sincerely hope anyone reading benefits from this perspective to get a deeper understanding of recursive style. ðŸ™Œâœ¨ As a final note: For many operations like thisâ€”especially working with arrays in JavaScript or TypeScriptâ€”I prefer the functional approach. Writing reducer functions and applying them with is, very often, simple and concise! The only notable negative tradeoff I see is that reducers sometimes have a higher learning curve, which can challenge less experienced developers until they understand them generally.\n\nWhat do you prefer? What do you think about this assertion and these conclusions? Iâ€™d love to hear what you think. Feel free to let me know in the comments!"
    },
    {
        "link": "https://javascript.plainenglish.io/the-truth-about-javascript-performance-array-iterations-5864f7f24562",
        "document": "By efficiency, developers usually may mean a few different aspects of programming: readability, supportability and the hero of today's article performance.\n\nHave you asked yourself, what should I use, or ?\n\nAnd obviously, there could be other reasons to use cycle instead of , for example, readability. If you want to have the ability to an early exit from the cycle, then it probably will be better to use .\n\nThis article should help you with sorting out one thing from the expression â€” performance.\n\nHow are we going to do this?\n\nTo archive our goal, we are going to take every single iteration way in Javascript and compare it side by side, running in different environments, platforms, etc.\n\nBe prepared, this is going to be a long read with a lot of numbers, so prepare a tea, and letâ€™s get going.\nâ€¢ The exact numbers in testing will be different in your testing environment\nâ€¢ The ratio difference between iteration methods should be close to what you see in your testing environment\nâ€¢ It is not possible to cover every single device and software version, but the comparison that you will see will be wide enough to help you to see the full picture\nâ€¢ Do not trust my words, verify yourself\n\nIn purpose to make our testing easy, we are going to take the go-to tool for benchmarking in JavaScript â€” a library called benchmark.js.\n\nThe next step for us â€” will be a creation of an array with a fixed number of items. Originally, when I started to write this article, I wanted the array to have 1M items, but recursion in Javascript has some limitations, so our array will have 1k items.\n\nThen we are going iterate through an array with different approaches and libraries.\n\nNext, complete a simple operation, for example, read array value.\n\nAnd everything mentioned above weâ€™re going to repeat at least 200 times to avoid faults.\n\nWhat are we going to test?\nâ€¢ Web on mobile (Chrome on Android and Safari on iOS)\n\nFirstly, letâ€™s take a look at the implementation of every single way to iterate through an array.\n\nThe most common way to iterate is through an array. I think this is one of the first lines of code, that JavaScript developers write when they learn.\n\nA good way to iterate, one major pro is that you can early exist your loop.\n\nNothing fancy here, take a look:\n\n`for` with `in` cycle\n\nOne variation of loop is to avoid writing this long, annoying line . And each time ask yourself if here should be or â€¦\n\nSo developers come out with keyword, which is basically an idea to take keys from the array and iterate through them.\n\n`for` with `of` cycle\n\nReally close to the previous cycle, but with a small difference â€” iteration allows you to iterate through values.\n\nThis is how it looks:\n\nYup, we cannot go on without cycle. Words are redundant here.\n\nA more simple way to iterate through an array. This method is simple and straightforward.\n\nAs a downside, we can say, that there is no easy way to exit the loop, but you still can exit it if you want.\n\nThe method that checks if every element in an array pass truthy conditions, is close to , because it accepts a function as an argument, but in the case of it should return or .\n\nThe benefit of it, in comparison with , here you can exit the loop easily if you return ."
    },
    {
        "link": "https://softwareengineering.stackexchange.com/questions/179863/performance-recursion-vs-iteration-in-javascript",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://stackoverflow.com/questions/39007637/javascript-set-vs-array-performance",
        "document": "Ok, I have tested adding, iterating and removing elements from both an array and a set. I ran a \"small\" test, using 10 000 elements and a \"big\" test, using 100 000 elements. Here are the results.\n\nIt would seem that the array method is about 4 times faster than the set method, no matter the number of elements being added.\n\nIterating over and modifying elements in a collection\n\nFor this part of the test I used a loop to iterate over the array and a loop to iterate over the set. Again, iterating over the array was faster. This time it would seem that it is exponentially so as it took twice as long during the \"small\" tests and almost four times longer during the \"big\" tests.\n\nNow this is where it gets interesting. I used a combination of a loop and to remove some elements from the array and I used and to remove some elements from the set. For the \"small\" tests, it was about three times faster to remove items from the set (2.6 ms vs 7.1 ms) but things changed drastically for the \"big\" test where it took 1955.1 ms to remove items from the array while it only took 83.6 ms to remove them from the set, 23 times faster.\n\nAt 10k elements, both tests ran comparable times (array: 16.6 ms, set: 20.7 ms) but when dealing with 100k elements, the set was the clear winner (array: 1974.8 ms, set: 83.6 ms) but only because of the removing operation. Otherwise the array was faster. I couldn't say exactly why that is.\n\nI played around with some hybrid scenarios where an array was created and populated and then converted into a set where some elements would be removed, the set would then be reconverted into an array. Although doing this will give much better performance than removing elements in the array, the additional processing time needed to transfer to and from a set outweighs the gains of populating an array instead of a set. In the end, it is faster to only deal with a set. Still, it is an interesting idea, that if one chooses to use an array as a data collection for some big data that doesn't have duplicates, it could be advantageous performance wise, if there is ever a need to remove many elements in one operation, to convert the array to a set, perform the removal operation, and convert the set back to an array."
    },
    {
        "link": "https://stackoverflow.com/questions/31188981/array-prototype-reduce-vs-a-simple-for-loop-for-filtering-and-modifying-data",
        "document": "One objective benefit of array operations like or is the inherent variable scoping and reduction of boilerplate code. Compare:\n\nThe giant loop declaration has nothing inherently to do with what you're trying to do here, it's just boilerplate code. Further, your scope now has two additional variables and floating around which nobody asked for, which may or may not introduce some non-obvious bugs if you're not careful.\n\nThe code on the other hand just contains the minimum necessary parts to do what it needs to do. In something like CoffeeScript its syntax can even further be reduced to , which is pretty darn concise. And even if you'd need to create additional variables during the operation inside the loop/the callback, those won't clutter the outer scope.\n\nSecondarily, is a well known paradigm and serves as a good statement of intend for that code block. You don't need to parse useless auxiliary variables and figure out what they're for, you can simply break down the operation into what array is being operated on ( ) and what result the callback expression ( ) will produce, then extrapolate that over the entire array to know what the result will be.\n\nPotentially such operations can also be better optimised by a compiler under certain circumstances, but this is mostly not seen in practice at this time I believe."
    }
]