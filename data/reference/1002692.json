[
    {
        "link": "https://auth0.com/blog/developing-restful-apis-with-python-and-flask",
        "document": "TL;DR: Throughout this article, we will use Flask and Python to develop a RESTful API. We will create an endpoint that returns static data (dictionaries). Afterward, we will create a class with two specializations and a few endpoints to insert and retrieve instances of these classes. Finally, we will look at how to run the API on a Docker container. The final code developed throughout this article is available in this GitHub repository. I hope you enjoy it!\n\nThis article is divided into the following sections:\n\nNowadays, choosing Python to develop applications is becoming a very popular choice. As StackOverflow recently analyzed, Python is one of the fastest-growing programming languages, having surpassed even Java in the number of questions asked on the platform. On GitHub, the language also shows signs of mass adoption, occupying the second position among the top programming languages in 2021.\n\nThe huge community forming around Python is improving every aspect of the language. More and more open source libraries are being released to address many different subjects, like Artificial Intelligence, Machine Learning, and web development. Besides the tremendous support provided by the overall community, the Python Software Foundation also provides excellent documentation, where new adopters can learn its essence fast.\n\nWhen it comes to web development on Python, there are three predominant frameworks: Django, Flask, and a relatively new player FastAPI. Django is older, more mature, and a little bit more popular. On GitHub, this framework has around 66k stars, 2.2k contributors, ~350 releases, and more than 25k forks.\n\nFastAPI is growing at high speed, with 48k stars on Github, 370 contributors, and more than 3.9k forks. This elegant framework built for high-performance and fast-to-code APIs is not one to miss.\n\nFlask, although less popular, is not far behind. On GitHub, Flask has almost 60k stars, ~650 contributors, ~23 releases, and nearly 15k forks.\n\nEven though Django is older and has a slightly more extensive community, Flask has its strengths. From the ground up, Flask was built with scalability and simplicity. Flask applications are known for being lightweight, mainly compared to their Django counterparts. Flask developers call it a microframework, where micro (as explained here) means that the goal is to keep the core simple but extensible. Flask won't make many decisions for us, such as what database to use or what template engine to choose. Lastly, Flask has extensive documentation that addresses everything developers need to start. FastAPI follows a similar \"micro\" approach to Flask, though it provides more tools like automatic Swagger UI and is an excellent choice for APIs. However, as it is a newer framework, many more resources and libraries are compatible with frameworks like Django and Flask but not with FastAPI.\n\nBeing lightweight, easy to adopt, well-documented, and popular, Flask is a good option for developing RESTful APIs.\n\nFirst and foremost, we will need to install some dependencies on our development machine. We will need to install Python 3, Pip (Python Package Index), and Flask.\n\nIf we are using some recent version of a popular Linux distribution (like Ubuntu) or macOS, we might already have Python 3 installed on our computer. If we are running Windows, we will probably need to install Python 3, as this operating system does not ship with any version.\n\nAfter installing Python 3 on our machine, we can check that we have everything set up as expected by running the following command:\n\nNote that the command above might produce a different output when we have a different Python version. What is important is that you are running at least\n\nor newer. If we get \"Python 2\" instead, we can try issuing. If this command produces the correct output, we must replace all commands throughout the article to useinstead of just\n\nPip is the recommended tool for installing Python packages. While the official installation page states that\n\ncomes installed if we're using Python 2 >=or Python 3 >=, installing Python throughon Ubuntu doesn't install. Therefore, let's check if we need to installseparately or already have it.\n\nIf the command above produces an output similar to\n\n, then we are good to go. If we get, we can try replacingwith. If we cannot find Pip for Python 3 on our machine, we can follow the instructions here to install Pip\n\nWe already know what Flask is and its capabilities. Therefore, let's focus on installing it on our machine and testing to see if we can get a basic Flask application running. The first step is to use\n\nAfter installing the package, we will create a file called\n\nand add five lines of code to it. As we will use this file to check if Flask was correctly installed, we don't need to nest it in a new directory.\n\nThese 5 lines of code are everything we need to handle HTTP requests and return a \"Hello, World!\" message. To run it, we execute the following command:\n\nAfter executing these commands, we can reach our application by opening a browser and navigating to\n‚Ä¢ installs packages globally, making it hard to manage multiple versions of the same package on the same machine.\n‚Ä¢ need all dependencies and sub-dependencies listed explicitly, a manual process that is tedious and error-prone.\n\nas the tool for installing Python packages, we will need to use another package to manage our project's dependencies. It's true thatsupports package management through the file , but the tool lacks some features required on serious projects running on different production and development machines. Among its issues, the ones that cause the most problems are:\n\nTo solve these issues, we are going to use Pipenv. Pipenv is a dependency manager that isolates projects in private environments, allowing packages to be installed per project. If you're familiar with NPM or Ruby's bundler, it's similar in spirit to those tools.\n\nNow, to start creating a serious Flask application, let's create a new directory that will hold our source code. In this article, we will create Cashman, a small RESTful API that allows users to manage incomes and expenses. Therefore, we will create a directory called\n\n. After that, we will useto start our project and manage our dependencies.\n\nThe second command creates our virtual environment, where all our dependencies get installed, and the third will add Flask as our first dependency. If we check our project's directory, we will see two new files:\n‚Ä¢ contains details about our project, such as the Python version and the packages needed.\n‚Ä¢ contains precisely what version of each package our project depends on and its transitive dependencies.\n\nLike other mainstream programming languages, Python also has the concept of packages to enable developers to organize source code according to subjects/functionalities. Similar to Java packages and C# namespaces, packages in Python are files organized in directories that other Python scripts can import. To create a package in a Python application, we need to create a folder and add an empty file called\n\nLet's create our first package in our application, the main package, with all our RESTful endpoints. Inside the application's directory, let's create another one with the same name,\n\n. The rootdirectory created before will hold metadata about our project, like what dependencies it has, while this new one will be our package with our Python scripts.\n\n. In this script, we will define the first endpoint of our application.\n\nAs in the previous example, our application returns a \"Hello, world!\" message. We will start improving it in a second, but first, let's create an executable file called\n\nin the root directory of our application.\n\nThe goal of this file is to facilitate the start-up of our application. Its source code will be the following:\n\nThe first command defines the main script to be executed by Flask. The second command runs our Flask application in the context of the virtual environment listening to all interfaces on the computer (\n\nTo check that this script is working correctly, we run\n\nto get similar results as when executing the \"Hello, world!\" application.\n\nNow that our application is structured, we can start coding some relevant endpoints. As mentioned before, the goal of our application is to help users to manage incomes and expenses. We will begin by defining two endpoints to handle incomes. Let's replace the contents of the\n\nfile with the following:\n\nSince improving our application, we have removed the endpoint that returned \"Hello, world!\" to users. In its place, we defined an endpoint to handle HTTP\n\nrequests to return incomes and another endpoint to handle HTTPrequests to add new ones. These endpoints are annotated withto define routes listening to requests on theendpoint. Flask provides great documentation on what exactly this does\n\nTo facilitate the process, we currently manipulate incomes as dictionaries. However, we will soon create classes to represent incomes and expenses.\n\nTo interact with both endpoints that we have created, we can start our application and issue some HTTP requests:\n\nUsing dictionaries in a simple use case like the one above is enough. However, for more complex applications that deal with different entities and have multiple business rules and validations, we might need to encapsulate our data into Python classes.\n\nWe will refactor our application to learn the process of mapping entities (like incomes) as classes. The first thing that we will do is create a subpackage to hold all our entities. Let's create a\n\ndirectory inside thepackage and add an empty file calledon it.\n\nWe will create three classes in this new directory:\n\n, and. The first class will be the base for the two others, and we will call it. Let's create a file calledin thedirectory with the following code:\n\nclass, we also defined a. We will use the latter to deserialize and serialize instances offrom and to JSON objects. This class inherits from another superclass calledthat belongs on a package not yet installed.\n\nMarshmallow is a popular Python package for converting complex datatypes, such as objects, to and from built-in Python datatypes. We can use this package to validate, serialize, and deserialize data. We won't dive into validation in this article, as it will be the subject of another one. Though, as mentioned, we will use\n\nto serialize and deserialize entities through our endpoints.\n\nTo keep things more organized and meaningful, we won't expose the\n\nclass on our endpoints. We will create two specializations to handle the requests:and. Let's make a module calledinside thepackage with the following code:\n\nThe only value that this class adds for our application is that it hardcodes the type of transaction. This type is a Python enumerator, which we still have to create, that will help us filter transactions in the future. Let's create another file, called\n\nThe code of the enumerator is quite simple. It just defines a class called\n\nthat inherits fromand that defines two types:and\n\nLastly, let's create the class that represents expenses. To do that, let's add a new file called\n\n, this class hardcodes the type of the transaction, but now it passesto the superclass. The difference is that it transforms the givento be negative. Therefore, no matter if the user sends a positive or a negative value, we will always store it as negative to facilitate calculations.\n\nsuperclass and its specializations adequately implemented, we can now enhance our endpoints to deal with these classes. Let's replacecontents to:\n\nThe new version that we just implemented starts by redefining the\n\nvariable into a list ofand, now called. Besides that, we have also changed the implementation of both methods that deal with incomes. For the endpoint used to retrieve incomes, we defined an instance ofto produce a JSON representation of incomes. We also used to extract incomes only from thelist. In the end we send the array of JSON incomes back to users.\n\nThe endpoint responsible for accepting new incomes was also refactored. The change on this endpoint was the addition of\n\nto load an instance ofbased on the JSON data sent by the user. As thelist deals with instances ofand its subclasses, we just added the newin that list.\n\nThe other two endpoints responsible for dealing with expenses,\n‚Ä¢ instead of dealing with instances of , we deal with instances of to accept new expenses,\n‚Ä¢ and instead of filtering by , we filter by to send expenses back to the user.\n\nand, are almost copies of theircounterparts. The differences are:\n\nThis finishes the implementation of our API. If we run our Flask application now, we will be able to interact with the endpoints, as shown here:\n\nAs we are planning to eventually release our API in the cloud, we are going to create a\n\nto describe what is needed to run the application on a Docker container. We need to install Docker on our development machine to test and run dockerized instances of our project. Defining a Docker recipe () will help us run the API in different environments. That is, in the future, we will also install Docker and run our program on environments like production and staging\n\nin the root directory of our project with the following code:\n\nThe first item in the recipe defines that we will create our Docker container based on the default Python 3 Docker image. After that, we update APK and install\n\n. Having, we define the working directory we will use in the image and copy the code needed to bootstrap and run the application. In the fourth step, we useto install all our Python dependencies. Lastly, we define that our image will communicate through portand that this image, when executed, needs to run thescript to start Flask.\n\nTo create and run a Docker container based on the\n\nthat we created, we can execute the following commands:\n\nis simple but effective, and using it is similarly easy. With these commands and this, we can run as many instances of our API as we need with no trouble. It's just a matter of defining another port on the host or even another host.\n\nIn this article, we learned about the basic components needed to develop a well-structured Flask application. We looked at how to use\n\nto manage the dependencies of our API. After that, we installed and used Flask and Marshmallow to create endpoints capable of receiving and sending JSON responses. In the end, we also looked at how to dockerize the API, which will facilitate the release of the application to the cloud.\n\nAlthough well structured, our API is not that useful yet. Among the things that we can improve, we are going to cover the following topics in the following article:\n‚Ä¢ How to handle JWTs in Python"
    },
    {
        "link": "https://geeksforgeeks.org/python-build-a-rest-api-using-flask",
        "document": "REST stands for REpresentational State Transfer and is an architectural style used in modern web development. It defines a set or rules/constraints for a web application to send and receive data.\n\nIn this article, we will build a REST API in Python using the Flask framework. Flask is a popular micro framework for building web applications. Since it is a micro-framework, it is very easy to use and lacks most of the advanced functionality which is found in a full-fledged framework. Therefore, building a REST API in Flask is very simple.\n\nThere are two ways of creating a REST API in Flask:\n‚Ä¢ Using Flask without any external libraries\n\ncan be installed via the pip command:\n\nHere, there are two functions: One function to just return or print the data sent through GET or POST and another function to calculate the square of a number sent through GET request and print it."
    },
    {
        "link": "https://flask-restful.readthedocs.io",
        "document": "Flask-RESTful is an extension for Flask that adds support for quickly building REST APIs. It is a lightweight abstraction that works with your existing ORM/libraries. Flask-RESTful encourages best practices with minimal setup. If you are familiar with Flask, Flask-RESTful should be easy to pick up.\n\nIf you are looking for information on a specific function, class or method, this part of the documentation is for you.\n\nSee Flask‚Äôs license for legal information governing this project."
    },
    {
        "link": "https://moesif.com/blog/technical/api-development/Building-RESTful-API-with-Flask",
        "document": "Python Flask is a popular framework for building web applications and APIs in Python. It provides developers with a quick and easy way to create RESTful APIs that can be used by other software applications. Flask is lightweight and requires minimal setup, making it a great choice for building small to medium-sized APIs. This makes Flask an ideal choice for developers looking to build robust and scalable APIs in Python. This example will review how to create a simple rest API Flask tutorial.\n\nBefore we start, we must ensure that a couple of prerequisites are completed. To follow along and run this tutorial, you will need to:\n‚Ä¢ Have an IDE to edit your code\n‚Ä¢ Install Postman so that you can test the endpoint\n\nAfter all 3 of these prerequisites are completed, we can begin!\n\nTo create the base project, the first thing we will do is create a folder named in your chosen directory.\n\nWith the new folder created, we will open a terminal in the root of the folder so that commands can be executed to build and run our Python project. Once your terminal is pointed to the root directory of your project, run the following commands so you can initialize the Python Rest API Flask project and manage the dependencies.\n\nFirst, we will use to install Flask in the project directory. To do this, run the command below.\n\nIn our first line of code in the file, we will import the modules for , , , and .\n\nNext, we will create a new Flask application by adding the following code just below our import statements.\n\nNext, to give our API a little bit of data to work with, we will define an array of employee objects with an ID and name.\n\nTo define our API endpoint, we will now add code to define a route for GET requests to the ‚Äò/employees‚Äô endpoint. This will return all employees (from our employees array defined above) in JSON format.\n\nOn top of our GET method, we will also define a route for POST, PUT, and DELETE methods as well. These functions can be used to create a new employee and update or delete the employee based on their given ID.\n\nOnce our code is complete, it should look like this:\n\nLastly, we will add a line of code to run our Flask app. As you can see, we call the method and get the Flask app running on port 5000.\n\nWith our code written and saved, we can start the app up. To run the app, in the terminal we will execute the follow command.\n\nNow, our API is up and running. You can send a test HTTP request through Postman. By sending a request to . After the request is sent. you should see a status code in the response along with an array of employees returned.\n\nFor this test, no request body is needed for the incoming request.\n\nWith that, we‚Äôve created a simple RESTful API Flask using Python. This code can then be expanded on as needed to build APIs for your applications. Moving forward, you may want to secure the API with an API key, integrate the API with an API gateway, check out how your API is being consumed and used, or build revenue through API monetization? For a solution to your API analytics and monetization needs, check out Moesiftoday to explore all of this and more!"
    },
    {
        "link": "https://imaginarycloud.com/blog/flask-python",
        "document": "How to make a REST API using Python Flask?\n\nThis article will guide you through the first steps to create a REST API using Flask(üå∂Ô∏è).\n\nBelow you can see the endpoints you‚Äôll have by the end of the tutorial. The documentation presented is also generated by the application you will create!\n\nYou must have Python installed on the current machine. The code presented will consider Python3. If you want to use Python2 and/or are following this procedure in a Windows machine, please follow the instructions presented in the Flask installation guide.\n\nLet‚Äôs start by creating a directory to store the project. In the directory you want to have your project, run the following commands on the shell:\n\nWe‚Äôve created the directory and moved it inside. Before starting to install dependencies, let‚Äôs create a virtual environment by running the following command:\n\nThis will create a folder into your project with the name . After that, we need to activate the respective environment by running:\n\nThis means we are now considering the venv virtual environment when running any Python code. It might be important to specify the environment you are considering when running it in your IDE.\n\nMake sure you have the environment active before following the next steps. You can check if you are inside the environment by looking to the left side of the console. If there‚Äôs the virtual environment name inside parentheses, you‚Äôre good to go.\n\nIf you want to deactivate the environment, just run the following command:\n\n‚Äç\n\nAt the point of writing, the Flask stable version is 1.1.2. If you want to have the project specifications updated and with the same version as me, you can use a file instead of installing Flask. You can copy the file below to the root directory.\n\nAfter that, you just need to run the following command:\n\nNow we are ready to start developing our REST API. The usage of the file is widespread and useful in Python projects since it easily allows you to share and have the project with the same packages installed.\n\nWhat?! Is it that simple? Yes, it is! The code is done to have an application with an implemented endpoint. Now we simply have to define the Flask environment variables and see your application ?. Note that you need to be in the folder with the file to run this commands.\n\nAccess the link to see the classic message we all love.\n\nNow that we have created our first endpoint, let‚Äôs get back to this application blog post's main purpose: Have the REST API with the basic CRUD structure. Import request from Flask and add the lines below to the main file to have the CRUD endpoints created for a specific entity:\n\nNow, for each of the routes created different methods are allowed. The following endpoints are available:\n\n‚Äç\n‚Ä¢ GET /entities - get list of entities\n\nWith this structure, you are ready to create an API with all the complexity you need. This is not the most scalable structure since you consider multiple validations for each route, and the structure is not rigid. In the next sections, we‚Äôll cover a more scalable solution that allows easy documentation creation as you develop your endpoints.\n\nTo test how these endpoints are working, you can use a curl request like the one presented below:\n\nThis is the result you should get if you run this command on your machine. Make sure the port your application is running on is the same:\n\nAnother tool that is very useful and common to use in the development of APIs is Postman. If you‚Äôve never used it, we recommend you try it and explore it! It is very powerful and will increase your development to the moon and beyond. üöÄ\n\nBefore we present other Flask strengths, let‚Äôs talk about blueprints. A blueprint is an object very similar to a flask application object, but instead of creating a new one, it allows the extension of the current application. This might be useful if you want to create multiple versions of an API or simply divide services within the same application.\n\nWe will use this class type to present different use case scenarios of a Flask application. Let‚Äôs convert the code above to be inserted into a blueprint and load into the main application.\n\nCreate a new folder to start inserting blueprints models as we progress in the blog post. Inside create a folder named and create a file in it named :\n\nNow the file just needs to load the created blueprint and register it to the application object:\n\nNow you should have exactly the same endpoints but with the usage of Blueprints.\n\nAs already stated, Flask is a very minimal framework; however, it relies on a handy tool: the Jinja template engine. This allows for rendering dynamic HTML templates. Although this is out of this blog post's scope, we will just give a small example to demonstrate the concept.\n\nThe first thing you have to do is create the folder and inside this folder, insert the file.\n\nNote there are two variables in use in the template inside {{ }}. This is a special format to include Python code inside the template, allowing for dynamic content to be rendered. In this case, we have the top and bottom of the variable, which will be converted to text inside the tag. Now that the template is created let‚Äôs load it using Flask. Let‚Äôs create a new blueprint in a different file to demonstrate this example:\n\nDo not forget to register this blueprint in the main.py file:\n\nHere we can see the definition of the top and bottom variables based on the query params sent in the URL. For example, if you go to you will get the following result:\n\nFor the giggles, let‚Äôs add some CSS to the page we just created. Create the folder with the file inside.\n\nAfter that, add the corresponding reference to the CSS file we just created by adding this head tag to the HTML file:\n\nGo to and you should see something like this:\n\nThere! You have your jinja crash course and a meme generator endpoint! Do not touch the Business Cat! You might be surprised with what you'll find..."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/processing-incoming-request-data-in-flask",
        "document": "Web applications frequently require processing incoming request data from users. This payload can be in the shape of query strings, form data, and JSON objects. Flask, like any other web framework, allows you to access the request data.\n\nIn this tutorial, you will build a Flask application with three routes that accept either query strings, form data, or JSON objects.\n\nTo complete this tutorial, you will need:\n‚Ä¢ This project will require Python installed in a local environment.\n‚Ä¢ This project will use Pipenv, a production-ready tool that aims to bring the best of all packaging worlds to the Python world. It harnesses Pipfile, pip, and virtualenv into one single command.\n‚Ä¢ Downloading and installing a tool like Postman will be required for testing API endpoints.\n\nThis tutorial was verified with Pipenv v2020.11.15, Python v3.9.0, and Flask v1.1.2.\n\nTo demonstrate the different ways of using requests, you will need to create a Flask app. Even though the example app uses a simplified structure for the view functions and routes, what you learn in this tutorial can be applied to any method of organizing your views like class-based views, blueprints, or an extension like Flask-Via.\n\nFirst, you will need to create a project directory. Open your terminal and run the following command:\n\nThen, navigate to the new directory:\n\nNext, install Flask. Open your terminal and run the following command:\n\nThe command will create a virtualenv for this project, a Pipfile, install , and a Pipfile.lock.\n\nTo activate the project‚Äôs virtualenv, run the following command:\n\nTo access the incoming data in Flask, you have to use the object. The object holds all incoming data from the request, which includes the mimetype, referrer, IP address, raw data, HTTP method, and headers, among other things.\n\nAlthough all the information the object holds can be useful, for the purposes of this article, you will focus on the data that is normally directly supplied by the caller of the endpoint.\n\nTo gain access to the request object in Flask, you will need to import it from the Flask library:\n\nYou then have the ability to use it in any of your view functions.\n\nUse your code editor to create an file. Import and the object. And also establish routes for , , and :\n\nNext, open your terminal and start the app with the following command:\n\nThe app will start on port 5000, so you can view each route in your browser with the following links:\n\nThe code establishes three routes and visiting each route will display the messages of , , and respectively.\n\nURL arguments that you add to a query string are a common way to pass data to a web app. While browsing the web, you will have likely encountered a query string before.\n\nThe query string begins after the question mark ( ) character:\n\nAnd has key-value pairs separated by an ampersand ( ) character:\n\nFor each pair, the key is followed by an equals sign ( ) character and then the value.\n\nQuery strings are useful for passing data that does not require the user to take action. You could generate a query string somewhere in your app and append it to a URL so when a user makes a request, the data is automatically passed for them. A query string can also be generated by forms that have GET as the method.\n\nLet‚Äôs add a query string to the route. In this hypothetical example, you will provide the name of a programming language that will be displayed on the screen. Create a key of and a value of :\n\nIf you run the app and navigate to that URL, you will see that it still displays a message of .\n\nYou will need to program the part that handles the query arguments. This code will read in the key by using either or .\n\nBy calling , the application will continue to run if the key doesn‚Äôt exist in the URL. In that case, the result of the method will be .\n\nBy calling , the app will return a 400 error if the key doesn‚Äôt exist in the URL.\n\nWhen dealing with query strings, it is recommended to use to prevent the app from failing.\n\nLet‚Äôs read the key and display it as output.\n\nModify the route in with the following code:\n\nThen, run the app and navigate to the URL:\n\nThe browser should display the following message:\n\nThe argument from the URL gets assigned to the variable and then gets returned to the browser.\n\nTo add more query string parameters, you can append ampersands and the new key-value pairs to the end of the URL. Create a key of and a value of :\n\nAnd if you want more, continue adding ampersands and key-value pairs. Create a key of and a value of :\n\nTo gain access to those values, you will still use either or . Let‚Äôs use both to demonstrate what happens when there is a missing key. Modify the route to assign the value of the results to variables and then display them:\n\nThen, run the app and navigate to the URL:\n\nThe browser should display the following message:\n\nRemove the key from the URL:\n\nThe browser should display the following message with when a value is not provided for :\n\nRemove the key from the URL:\n\nThe browser should encounter an error because it is expecting a value for :\n\nNow you understand handling query strings. Let‚Äôs continue to the next type of incoming data.\n\nForm data comes from a form that has been sent as a POST request to a route. So instead of seeing the data in the URL (except for cases when the form is submitted with a GET request), the form data will be passed to the app behind the scenes. Even though you cannot easily see the form data that gets passed, your app can still read it.\n\nTo demonstrate this, modify the route in to accept both GET and POST requests and returns a form:\n\nThen, run the app and navigate to the URL:\n\nThe browser should display a form with two input fields - one for and one for - and a submit button.\n\nThe most important thing to know about this form is that it performs a POST request to the same route that generated the form. The keys that will be read in the app all come from the attributes on our form inputs. In this case, and are the names of the inputs, so you will have access to those in the app.\n\nInside the view function, you will need to check if the request method is GET or POST. If it is a GET request, you can display the form. Otherwise, if it is a POST request, then you will want to process the incoming data.\n\nModify the route in with the following code:\n\nThen, run the app and navigate to the URL:\n\nFill out the field with value of and the field with the value of . Then, press Submit.\n\nThe browser should display the following message:\n\nNow you understand handling form data. Let‚Äôs continue to the next type of incoming data.\n\nJSON data is normally constructed by a process that calls the route.\n\nAn example JSON object looks like this:\n\nThis structure can allow for much more complicated data to be passed as opposed to query strings and form data. In the example, you see nested JSON objects and an array of items. Flask can handle this format of data.\n\nModify the route in to accept POST requests and ignore other requests like GET:\n\nUnlike the web browser used for query strings and form data, for the purposes of this article, to send a JSON object, you will use Postman to send custom requests to URLs.\n\nIn Postman, add the URL and change the type to POST. On the body tab, change to raw and select JSON from the drop-down.\n\nThese settings are required so Postman can send JSON data properly, and so your Flask app will understand that it is receiving JSON:\n\nNext, copy the earlier JSON example into the text input.\n\nSend the request, and you should get as the response. That is fairly anti-climatic but is to be expected because the code for handling the JSON data response has yet to be written.\n\nTo read the data, you must understand how Flask translates JSON data into Python data structures:\n‚Ä¢ Anything that is an object gets converted to a Python dict. in JSON corresponds to , which returns a value in Python.\n‚Ä¢ An array in JSON gets converted to a list in Python. Since the syntax is the same, here‚Äôs an example list:\n‚Ä¢ The values inside of quotes in the JSON object become strings in Python.\n‚Ä¢ Boolean and become and in Python.\n‚Ä¢ Finally, numbers without quotes around them become numbers in Python.\n\nNow let‚Äôs work on the code to read the incoming JSON data.\n\nFirst, let‚Äôs assign everything from the JSON object into a variable using .\n\nconverts the JSON object into Python data. Let‚Äôs assign the incoming request data to variables and return them by making the following changes to the route:\n\nNote how you access elements that aren‚Äôt at the top level. is used because you are entering a nested object. And is used to access the 0th index in the examples array.\n\nIf the JSON object sent with the request doesn‚Äôt have a key that is accessed in your view function, then the request will fail. If you don‚Äôt want it to fail when a key doesn‚Äôt exist, you‚Äôll have to check if the key exists before trying to access it.\n\nRun the app and submit the example JSON request using Postman. In the response, you will get the following output:\n\nIn this article, you built a Flask application with three routes that accept either query strings, form data, or JSON objects.\n\nAlso, recall that all approaches had to address the recurring consideration for gracefully failing when a key is missing.\n\nIf you‚Äôd like to learn more about Flask, check out our Flask topic page for exercises and programming projects."
    },
    {
        "link": "https://apidog.com/blog/flask-post-json",
        "document": "Flask is a popular Python web framework that is used to build web applications. One of the most common tasks when building a web application is to send data from the client to the server. This is typically done using the HTTP POST method. JSON (JavaScript Object Notation) is a lightweight data interchange format that is commonly used for sending data over the internet.\n\nIn this post, we will explore how to use Flask to handle JSON data sent via the HTTP method and discover how to use Apidog, an all-in-one platform that facilitates efficient API development, to design and test your Python REST API\n\nJSON (JavaScript Object Notation) is a lightweight data interchange format that is commonly used for sending data over the internet. It is based on a subset of the JavaScript programming language, but it can be used with any programming language.\n\nOne of the advantages of using JSON is that it is easy to read and write. JSON data is represented as key-value pairs, which makes it easy to understand and work with. JSON can represent six types of data natively: strings, numbers, booleans, null, arrays, and objects. For example, here is a JSON representation of a blog post:\n\nThis example demonstrates all the JSON data types. It also illustrates the concision of JSON-formatted data, one of the characteristics that‚Äôs made it so appealing for use in APIs.\n\nThe HTTP POST method is one of the most common HTTP methods used to send data from the client to the server. When a client sends an HTTP POST request, it includes a message body that contains the data that is being sent. This data can be in a variety of formats, including JSON.\n\nBy using JSON, developers can ensure that the data sent to the server is well-organized and easily understandable, thereby enhancing the efficiency of resource creation and updates.\n\nWhat is Flask and Why Should You Use It?\n\nFlask is a lightweight web framework that is written in Python. It is designed to be simple and easy to use, while still providing all of the features that you need to build a modern web application.\n\nFlask is built on top of the Werkzeug WSGI toolkit and the Jinja2 template engine. It provides a simple and intuitive API for handling HTTP requests and responses.\n\nOne of the key features of Flask is its support for handling JSON data. Flask provides a simple way to parse JSON data sent via the HTTP POST method. This makes it easy to build web applications that can accept JSON data from clients.\n\nFlask is a Python-based microframework, so you‚Äôll need to have Python installed on your computer. You can download the latest version of Python from the official website:\n\nCreate a virtual environment: It‚Äôs a good practice to create a virtual environment for your project to avoid conflicts with other Python projects. You can create a virtual environment using the module that comes with Python. Here‚Äôs how you can create a virtual environment:\n\nThis will create a new directory called in your current directory.\n\nActivate the virtual environment: Once you‚Äôve created the virtual environment, you need to activate it. Here‚Äôs how you can activate the virtual environment:\n\nInstall Flask: With the virtual environment activated, you can now install Flask using , the Python package manager. Here‚Äôs how you can install Flask:\n\nThis will install Flask and its dependencies.\n\nVerify the installation: To verify that Flask has been installed correctly, you can create a new file called with the following contents:\n\nSave the file and run it using the following command:\n\nThis will start a local development server at . Open your web browser and navigate to . You should see a message that says ‚ÄúHello, World!‚Äù.\n\nTo handle JSON data in Flask, you will need to use the object. The object is provided by Flask and contains all of the data that was sent in the HTTP request. To parse JSON data, you can use the attribute of the object.\n\nTo access the JSON data sent by the client, you can use the object‚Äôs attribute or the method. Both of them return a Python dictionary or list that represents the parsed JSON data.\n\nThe difference is that the attribute will raise an exception if the data is not valid JSON, while the method will return in that case. You can also pass a parameter to the method to force parsing the data as JSON, regardless of the content type.\n\nHere is an example of a simple route handler that receives a POST request with JSON data and prints it to the console:\n\nThe content type of the request is important because it tells Flask how to parse the data. If the content type is , Flask will automatically parse the data as JSON and make it available through the attribute or the method.\n\nIf the content type is not specified or is something else, Flask will not parse the data as JSON unless you use the parameter of the method. Therefore, it is recommended to set the content type to when sending JSON data to Flask, or to handle the cases where the content type is not correct or the data is not valid JSON.\n\nTo create and return JSON responses using the function from Flask, you need to import the function from the module and pass a Python dictionary or list as an argument. The function will convert the Python object into a JSON string and set the content type of the response to . This way, the client can easily parse the JSON data and use it for their purposes.\n\nHere is an example of a simple route handler that sends a JSON response with some data back to the client:\n\nThe function has some optional parameters that can affect the formatting and ordering of the JSON output. For example, you can use the parameter to sort the keys of the JSON object alphabetically, or the parameter to add indentation and newlines to the JSON string. These parameters can make the JSON output more readable and consistent, but they can also increase the size of the response.\n\nHow to POST JSON Data with Apidog\n\nApidog is a great tool for anyone who works with APIs, whether you are a developer, a tester, a designer, or a student. It helps you to:\n‚Ä¢ Learn how to use different APIs and explore their features\n‚Ä¢ Test and debug your own APIs and find errors and bugs\n‚Ä¢ Experiment with different parameters and options and see how they affect the response\n‚Ä¢ Document and demonstrate your API usage and results\n‚Ä¢ Collaborate and communicate with other API users and developers\n\nTo test your Flask API that can send and receive JSON data using Apidog, you need to follow these steps:\n‚Ä¢ Visit the Apidog website and create a free account. You can also use Apidog without an account, but you won‚Äôt be able to save and share your requests. Open Apidog and create a new request.\n‚Ä¢ Select the HTTP method that you want to use. For example, if you want to get the list of messages, you can select the GET method. If you want to create a new message, you can select the POST method.\n‚Ä¢ Enter the URL of your API endpoint in the URL input field. Add any headers, cookies, or parameters that you need for your request. For example, if you want to create a new message, you need to add the header with the value and write the data in JSON format in the body input field. For example, you can write the following data:\n‚Ä¢ Click on the Send button to send the request to your API. Apidog will then display the response from your API in the Response tab. You can also switch to the Headers, Cookies, or Raw tabs to see other details of the response.\n‚Ä¢ Analyze and manipulate the response data using Apidog‚Äôs features and tools. You can use the JSON Viewer, JSONPath, JavaScript, JSON Schema, and other features and tools to view, filter, modify, or validate the response data. You can also save your request and response and share them with others using a unique URL.\n\nYou have now tested your FlaskAPI that can send and receive JSON data using Apidog. You can also test other API endpoints and methods using the same steps. You can also use Apidog to test other APIs that you find online or create yourself. Apidog is a versatile and powerful tool that can help you with any API-related task. You can learn more about Apidog and its features and tools from the official website:\n\nIn this post, we have learned how to handle JSON requests in Flask, a popular micro-framework for web development in Python. We have seen how to:\n‚Ä¢ Get and parse JSON data from POST requests using the object‚Äôs attribute or the method.\n‚Ä¢ Create and return JSON responses using the function, which converts a Python dictionary or list into a JSON string and sets the appropriate content type for the response.\n‚Ä¢ Use some optional parameters of the function, such as and , to affect the formatting and ordering of the JSON output."
    },
    {
        "link": "https://medium.com/@obotnt/understanding-the-difference-between-get-json-and-request-json-in-flask-d612d1fbc895",
        "document": "Flask is a popular Python web framework that allows developers to create web applications quickly and efficiently. One of the most common tasks when building web applications is handling incoming data, especially in the form of JSON. In Flask, two methods are often used for handling JSON data from requests: and . While they might appear similar at first glance, they have key differences that make each useful in different scenarios.\n\nIn this article, we‚Äôll explore the differences between these two methods, why you might use one over the other, and how to use them effectively in your Flask applications.\n\nBefore we dive into the specifics, let‚Äôs quickly recap what JSON (JavaScript Object Notation) is. JSON is a lightweight data-interchange format that is easy for humans to read and write and easy for machines to parse and generate. It‚Äôs widely used in APIs to send data between a server and a client.\n\nIn Flask, JSON data is often sent in the body of HTTP POST requests, and you need to extract that data to process it in your server-side logic.\n\nTwo Common Approaches in Flask for Handling JSON\n\nIn Flask, when you receive a request that contains JSON data, you can retrieve and work with that data using either or . Let‚Äôs look at both in detail:"
    },
    {
        "link": "https://stackoverflow.com/questions/20001229/how-to-get-posted-json-in-flask",
        "document": "First of all, the attribute is a property that delegates to the method, which documents why you see here.\n\nYou need to set the request content type to for the property and method (with no arguments) to work as either will produce otherwise. See the Flask documentation:\n\nYou can tell to skip the content type requirement by passing it the keyword argument.\n\nNote that if an exception is raised at this point (possibly resulting in a 415 Unsupported Media Type response), your JSON data is invalid. It is in some way malformed; you may want to check it with a JSON validator."
    },
    {
        "link": "https://medium.com/@modimuskan397/how-to-parse-json-file-and-show-output-json-using-flask-c0b415f3f0a0",
        "document": "Hey there, welcome aboard! Ever wondered how to make your JSON data shine on the web? Welcome to our comprehensive guide on parsing JSON files and elegantly displaying their contents using Flask.\n\nJSON (JavaScript Object Notation) is a popular data interchange format, and Flask is a lightweight web framework for Python. In this tutorial, we‚Äôll walk you through the process of uploading a JSON file, parsing its data, and presenting it in a user-friendly format on a web page.\n\nInput : Uploaded JSON file as the Input File\n\nOutput: Values from the JSON file in the form of Table pair.\n\nFirstly, we will start by parsing our JSON File. Here is a code to parse the JSON File:\n\nNext, we will start accessing the Values of the JSON File using for loops. A JSON is essentially a nested dictionary with key and value pairs, which you can easily access using loops. You can write your own python code to access values from JSON by studying its structure, and iterating through the parsed JSON data.\n\nHere is a code snippet of my code for your understanding:\n\nOnce you are done with writing a working code to extract desired value from your JSON, make sure you convert it into a function for better usability.\n\nNow that we have completed basics steps of reading our JSON file and learning how to access values from it, we will start with developing our Flask App.\n\nTo get started with Flask, you first need to install it in your environment.\n\nOnce the installation is complete, you can verify that Flask is installed by typing\n\nWe will now add our function to this code.\n\nNow, we have to write the html code Index.html which will be displayed on the web page. We keep Index.html inside templates folder, which is on the same level as the main.py, where our rest of the python code is written. Here is the code for Index.html:\n‚Ä¢ We start with the standard HTML structure.\n‚Ä¢ Inside the tag, we have a heading that says \"Employee Data.\"\n‚Ä¢ We use a table to organize our employee data.\n‚Ä¢ Within the table, we have table headers ( ) for ID, Name, Position, and Salary.\n‚Ä¢ We use a Jinja for loop to iterate over each employee in the dictionary.\n‚Ä¢ For each employee, we display their ID, name, position, and salary within table cells\n\nThis part of the HTML code is a for loop, which is a Jinja template. A Jinja template is used in Flask to render dynamic HTML content.\n\nHere, employees is the dictionary that we got from python function from parsing the JSON file. We are iterating over our dictionary and are displaying the values in the form of a table.\n\nHere is the complete code:"
    }
]