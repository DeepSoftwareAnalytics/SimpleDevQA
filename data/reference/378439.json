[
    {
        "link": "https://stackoverflow.com/questions/27035308/add-a-rounding-method-to-number-prototype-in-javascript",
        "document": "How can I simplify rounding in JavaScript? I wish that I could do it in a more elegantly in an object-oriented manner. The method toFixed works well, but does not have backward rounding and it also returns a string and not a number.\n\nAs it is, rounding is a bit of a tangle because I have to use:\n\nIt would be much nicer instead just to stick a method to the end of a variable, such as:"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
        "document": "Numbers are most commonly expressed in literal forms like or . The lexical grammar contains a more detailed reference. A number literal like in JavaScript code is a floating-point value, not an integer. There is no separate integer type in common everyday use. (JavaScript also has a type, but it's not designed to replace Number for everyday uses. is still a number, not a BigInt.) When used as a function, converts a string or other value to the Number type. If the value can't be converted, it returns .\n\nThe JavaScript type is a double-precision 64-bit binary format IEEE 754 value, like in Java or C#. This means it can represent fractional values, but there are some limits to the stored number's magnitude and precision. Very briefly, an IEEE 754 double-precision number uses 64 bits to represent 3 parts:\nâ€¢ 1 bit for the sign (positive or negative)\nâ€¢ 11 bits for the exponent (-1022 to 1023)\nâ€¢ 52 bits for the mantissa (representing a number between 0 and 1) The mantissa (also called significand) is the part of the number representing the actual value (significant digits). The exponent is the power of 2 that the mantissa should be multiplied by. Thinking about it as scientific notation: The mantissa is stored with 52 bits, interpreted as digits after in a binary fractional number. Therefore, the mantissa's precision is 2-52 (obtainable via ), or about 15 to 17 decimal places; arithmetic above that level of precision is subject to rounding. The largest value a number can hold is 21023 Ã— (2 - 2-52) (with the exponent being 1023 and the mantissa being 0.1111â€¦ in base 2), which is obtainable via . Values higher than that are replaced with the special number constant . Integers can only be represented without loss of precision in the range -253 + 1 to 253 - 1, inclusive (obtainable via and ), because the mantissa can only hold 53 bits (including the leading 1). More details on this are described in the ECMAScript standard.\n\nMany built-in operations that expect numbers first coerce their arguments to numbers (which is largely why objects behave similarly to number primitives). The operation can be summarized as follows:\nâ€¢ Strings are converted by parsing them as if they contain a number literal. Parsing failure results in . There are some minor differences compared to an actual number literal:\nâ€¢ Leading and trailing whitespace/line terminators are ignored.\nâ€¢ A leading digit does not cause the number to become an octal literal (or get rejected in strict mode).\nâ€¢ and are allowed at the start of the string to indicate its sign. (In actual code, they \"look like\" part of the literal, but are actually separate unary operators.) However, the sign can only appear once, and must not be followed by whitespace.\nâ€¢ and are recognized as literals. In actual code, they are global variables.\nâ€¢ Empty or whitespace-only strings are converted to .\nâ€¢ Objects are first converted to a primitive by calling their (with as hint), , and methods, in that order. The resulting primitive is then converted to a number. There are two ways to achieve nearly the same effect in JavaScript.\nâ€¢ Unary plus: does exactly the number coercion steps explained above to convert .\nâ€¢ The function: uses the same algorithm to convert , except that BigInts don't throw a , but return their number value, with possible loss of precision. and are similar to but only convert strings, and have slightly different parsing rules. For example, doesn't recognize the decimal point, and doesn't recognize the prefix. Some operations expect integers, most notably those that work with array/string indices, date/time components, and number radixes. After performing the number coercion steps above, the result is truncated to an integer (by discarding the fractional part). If the number is Â±Infinity, it's returned as-is. If the number is or , it's returned as . The result is therefore always an integer (which is not ) or Â±Infinity. Notably, when converted to integers, both and become , because is converted to , which also becomes . JavaScript has some lower-level functions that deal with the binary encoding of integer numbers, most notably bitwise operators and objects. Bitwise operators always convert the operands to 32-bit integers. In these cases, after converting the value to a number, the number is then normalized to the given width by first truncating the fractional part and then taking the lowest bits in the integer's two's complement encoding. new Int32Array([1.1, 1.9, -1.1, -1.9]); // Int32Array(4) [ 1, 1, -1, -1 ] new Int8Array([257, -257]); // Int8Array(2) [ 1, -1 ] // 257 = 0001 0000 0001 // = 0000 0001 (mod 2^8) // = 1 // -257 = 1110 1111 1111 // = 1111 1111 (mod 2^8) // = -1 (as signed integer) new Uint8Array([257, -257]); // Uint8Array(2) [ 1, 255 ] // -257 = 1110 1111 1111 // = 1111 1111 (mod 2^8) // = 255 (as unsigned integer)"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed",
        "document": "The method returns a string representation of a number without using exponential notation and with exactly digits after the decimal point. The number is rounded if necessary, and the fractional part is padded with zeros if necessary so that it has the specified length.\n\nIf the absolute value of the number is greater or equal to 1021, this method uses the same algorithm as and returns a string in exponential notation. returns , , or if the value of the number is non-finite.\n\nThe output of may be more precise than for some values, because only prints enough significant digits to distinguish the number from adjacent number values. For example:\n\nHowever, choosing a precision that's too high can return unexpected results, because decimal fractional numbers cannot be represented precisely in floating point. For example:"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round",
        "document": "If the fractional portion of the argument is greater than 0.5, the argument is rounded to the integer with the next higher absolute value. If it is less than 0.5, the argument is rounded to the integer with the lower absolute value. If the fractional portion is exactly 0.5, the argument is rounded to the next integer in the direction of +âˆž.\n\nNote: This differs from many languages' functions, which often round half-increments away from zero, giving a different result in the case of negative numbers with a fractional part of exactly 0.5.\n\nis not exactly the same as . When is -0, or -0.5 â‰¤ x < 0, returns -0, while returns 0. However, neglecting that difference and potential precision errors, and are generally equivalent.\n\nBecause is a static method of , you always use it as , rather than as a method of a object you created ( has no constructor)."
    },
    {
        "link": "https://w3schools.com/jsref/jsref_prototype_num.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://dev.to/dvddpl/jest-testing-like-a-pro-tips-and-tricks-4o6f",
        "document": "We recently switch to Jest framework when writing Unit and Integration tests in our React and Node applications. We used Mocha many years ago and AVA for a few years.\n\nChanging framework is no big deal once you are used to write tests ( or even better used to TDD) extensively.\n\n The fundamentals are the same in every framework ( and every programming language) but there are some nuances.\n\n Jest documentation is very extensive and detailed, and I really suggest you reading it and going back to it every time you write a slightly more complex test or assertion, but what I'd like to share here is a recollection of tips and tricks that can hopefully save you some time and headaches.\n\nThis is actually one of the main reasons I loved AVA, tests are by default run concurrently, and for a good reason!\n\n Tests should not rely on external apis/services, they should not rely on globals or other objects that are persisted across different tests, so why should not be run - very slowly - one after another, when they could and should be run all the same time (workers and thread permitting).\n\n If, for some reason, and normally this happen only on integration tests, we need to preserve a certain order, then we can run them in a sequence / serially.\n\nIn Jest it is the opposite. You need to explicitly tell that a test should be run concurrently. see here\n\nIn some case you have some tests which are basically the same but with slight variations.\n\nYou could create individual tests or you could use each(table)\n\n which basically will run a loop / map over your table/array and run the test with that specific payload (eventually running the assertion on that specific expected result).\n\nThis is a very interesting feature but I would be careful because it is easy to be carried away by \"reusing and optimizing\" too much making tests more complicated than they need to be or simply ending up having many of unnecessary duplicated tests.\n\nImagine you want to test your sum method:\n\nImho, as good as this snippet is to explain how to use each(table), we should not write such a test.\n\nHaving multiple inputs for such thing would not add any value. Unless our method has some weird logic - like that over a certain sum the predefined maximum is always returned.\n\nStill in this case I would probably write 2 simple tests which make this specific behaviour stand more out.\n\nI'd rather be redundant here to raise attention to the specifics of this method. And also be clearer in case of a failing test.\n\nImagine that someone changes the value of the cap and your tests in your table start failing \n\n In the results you will find:\n\nwhich does not make much sense because 45+95 gives 140 and both the expected 10 or received 50 do not match, and you would stare at the error message wondering \"what the heck...!?\"\n\nclearly let you figure out that something is wrong with the cap, and in this specific case that just the assertion and title are not updated with the updated code.\n\nWhen you run Jest, tests are run by file, within that file you can have groups of related tests, which you put under a Describe block.\n\nAlthough seen in every example around, is not mandatory, so if you have a tiny file with just a bunch of tests, you don't need really it.\n\nIn many cases though it is beneficial to group tests which share the same method under test and differ by the input and assertion.\n\nGrouping and Naming properly is often underrated. You must remember that tests suites are supposed to succeed, and they can contain hundreds or thousands of tests.\n\n When something goes wrong, locally or on you CI Pipeline, you want to be able to immediately have a grasp of what went wrong: the more information you have in the test failure message, the better.\n\nThe concatenation of file name + describe + test name, together with the diff among expected and received values. (assuming you wrote specific enough assertions) will allow you to immediately spot the issue, and surgically intervene in seconds.\n\nImagine that your original implementation of create user returns a new user in this format :\n\nAnd your test will assert those 3 properties\n\nwill clearly let anyone understand that your method is now returning an object just containing the ID of the new user, not all its data.\n\nI know naming it's hard, but be precise and be disciplined in how you name and group your test files, test suits and individual tests. It will pay off whenever you have to debug a failing test.\n\nOn this topic I really suggest a very interesting article touching many aspects and pitfalls of writing Tests, and why writing a test is fundamentally different than coding for production:\n\n Why good developers write bad tests\n\nWhether you are using Jest or not, test structure should be clean and explicit.\n\nWrite your test in AAA Style, which means Arrange Act Assert\n\nSet up mock or db connection or service instance etc\n\n Define input\n\n Define expectation\n\nRun the code under test passing the input\n\nrun the assertion between the result and the expectation\n\nThe most important thing is keeping the reader within the test (following up a tip from the above article).\n\nRemember that people will go back to a test only when it starts failing, and at that point it is important that the purpose of the test, the set up and the error is understandable and debuggable quickly without having to click through many other variables or helper methods.\n\nIf the methods you want to test are asynchronous, be it callbacks, promises or async, it is not a problem with Jest. \n\n The biggest pitfall I'd like to warn you about is when you forget to await or to add a when you run your expectation.\n\n This would cause your test to pass even if the asynchronous method is failing ( simply because Jest is not waiting, and when the test fails, it is already to late to notify it)\n\nThis happens very often if you jump from one sync test to another; consider these examples:\n\nThey are similar and do the same thing.\n\n In the first we are telling jest the test is and we are for the method to return the loaded data, then we run the assertion.\n\n In the second example we just return the Expect.\n\nIf you forgot either the async / await or the return, the test will exit immediately, way before the data is loaded, and no assertion is done.\n\nThis is very dangerous because it could lead to false positives.\n\nIn some cases is useful to add a special Assertion in your test where you tell jest to count and make sure a certain number of expectations are run and passed.\n\nThis is extremely important in the case I mentioned above - if you forget to return expect or await your async method.\n\n But it is also useful if your test has assertions inside try/catches or then/catch.\n\n\n\n Having assertions within blocks is not an approach I would suggest, much better to use resolve/rejects or other ways, but sometimes I found it necessary like the example below:\n\nIf I need to make more assertions on the Error being thrown beside just checking it's type/class - like ie making sure the error contains some specific inner properties or by regexing its detailed message - and I don't want the method to be executed multiple times, we need to catch the error and run assertion directly on it:\n\nIf I don't put , and then for some reason the logic is the validation is changed ( so that the payload passes, or instead of an error a true|false is returned) the test would pass silently, just because jest did not know there were some assertions to run.\n\nJust to spice up a bit assertions on errors, just remember that when your method is asynchronous the syntax is a bit different.\n\nOf course you can still rely on the catch block - but still remember of and , but the preferred approach is using :\n\nMore info about testing Promises and Async code with resolve/rejects here\n\nMocking within Tests is a chapter per se, and I have mixed feelings about it. \n\n Too many times I have seen overly engineered abstractions with loads of classes and method with dependency injection were tested through super complicated tests where everything was mocked and stubbed. \n\n Very high code coverage and everything green in the CI pipeline, just to see production crash because, well the mocks were not really matching reality. \n\n This is also the reason why, expecially with serverless, I prefer when possible to have integration tests - which hit the real thing not some weird dockerized emulator of some aws service.\n\nThis does not mean we never used aws-sdk-mock - haven't tried yet this version for SDK v3 - check this article for more info - but in general I try to write very simple unit tests, and very simple integration tests, keeping mocks to a minimum.\n\nIf you are a 100% Mock Advocate, I really suggest reading Mocking is a code smell by Eric Elliot which few years ago, really blew my mind.\n\nGoing back to Mocks in Jest.\n\nIf you just started with Mocks you may look at the documentation and then stare at the code and ask yourself: \"Eh?!? Why? What's the point?!?\"\n\nHow are you supposed to use that? Asserting on the mocked method would make no sense...\n\nSo this bring us to a broader topic that can lead us to dependency injection and inversion of control.\n\nUsing mocks can be hard and tricky because often our methods are just too coupled together and you have no access on the internal methods being used.\n\nImagine a method that validates some data, creates a payload and passes it to an api to create a user, then maps the result or catches errors and returns it.\n\nIf you want to create a Test for this you don't want to invoke the real API and create the user for real ( for multiple reasons, the test could become flaky and depend on network issues or API availability, you don't want to unnecessarily creates users which you will have to tear down/ delete afterwards, you don't want to \"spam\" endpoint with invalid payloads to test all possible errors).\n\nThis is where mocking comes handy. BUT...\n\n how do you access that internal method that calls the api?\n\nSome may use Rewire to access internals of a module and overwrite them, or you can expose those specific methods in different modules and then mock their implementation, or you can rely on dependency injection and closures to decouple the behaviour and then easily mock it without too many headaches.\n\nTo use that you first partially apply your method injecting the api class\n\nthen use the real creator function which expects only the payload (that is your original method under test)\n\nSo how do you mock your api?\n\nFrom here you can easily mock the faulty responses, and make sure you handle everything properly, without relying on network nor bothering the real API at all.\n\nMocking can go deeper and further, you can assert that the mocked method is called and with which parameters ( imaging you have some conditionals in your method which might or might not call the api based on certain input) and so on.\n\nHonestly for the reasons above I am not a super fan of such mocking.\n\n Strike a balance and keep it simple.\n\n\n\n When you see it is getting too complicated, you are probably doing it wrong. And it is likely the case you should refactor your method in the first place.\n\nJust dropping here a mock example of Axios calls which might be useful if you don't want or can't refactor your code to inject your external dependencies doing network calls.\n\nIn this example, if your createUser method uses axios to invoke an api, you are mocking axios entirely so that the requests will not be made but your mocked response will be triggered .\n\nOften we want to assert that our method returns a specific object but we don't want to hardcode lots of values in our setup/assertion.\n\n Or we don't care to assert every single property in the object which is returned. \n\n Imagine some dynamic values like Ids, or dates/timestamps and so on.\n\nIn this case asserting for equality would cause the error to fail.\n\ntoMatchObject is here very handy.\n\nUsing toMatchObject in combination with other expect globals like ANY is very powerful to have tests that are generic enough but still validate the \"type\" of object being returned.\n\nMarking a test as TODO is very handy when you are jotting down ideas of possible test scenarios, or if you are preparing a list of tests for a junior dev or trainee you are mentoring, or simply to leave a trace of possible improvements/technical debt.\n\nOnly can be used when debugging a test.\n\n\n\n Be very careful when committing after you are done. You might screw the entire Build pipeline and even risk putting something broken in production, because the only tests you are actually running, are well, those that you marked as .only!\n\nTo avoid such problems you can use a git hook (check Husky \n\n and DotOnlyHunter) which scans your tests making sure you are not pushing any test where you forgot to remove .only.\n\nthis is actually a feature I am missing in jest (which was available in AVA\n\n Sometimes a test is failing but for some reason, you want to keep it without just skipping it. When/if the implementation is fixed, you are notified that the failing test, now is succeeding. \n\n I can't tell you when and why I used that, but I found it very useful, and apparently I am not the only one, since there is github issue about it. Until the issue is closed we have to use a simple skip.\n\nThis is valid basically for every step of your development process. Drop those _console.log_s and start to use the Debugger and Breakpoints, no matter what your IDE is (here an example for VisualStudioCode) this allows to interrupt the running code and expect props and methods, and move step by step in the execution. A very useful,fast and pratical way of understanding what is really going on.\n\nIt does not matter if you are doing TDD (Test Driven Development - meaning you write the tests before you wrote / while writing the implementation) or writing tests for code you just wrote or you are refactoring.\n\nIf you wrote a test and it passes, don't just move on, taking for granted / hoping everything is ok. Maybe your assertion is broken, maybe Jest is not awaiting your result, maybe the edge-case you thing you are testing is not really ending up in the code you implemented. \n\n Prove that your assertion is working - and your assumption is correct - by having the test failing first - ie by passing the wrong payload - and then adjust the Arrange part of the test to make it work again.\n\nKent C. Dodds has a very clear video explanation on how to do that.\n\nHope it helps. If you have other tips, feel free to comment below!"
    },
    {
        "link": "https://stackoverflow.com/questions/61285655/jest-unit-testing-a-function-throwing-error",
        "document": "I was trying to unit test a function in node which throws an error regardless of any condition. Here is my node function definition.\n\nAs you can see this function always throws an error whenever it has been called. I tried to execute unit testing to this function using jest .toThrow(error?) method. I was not able to unit test the function as expected.\n\nThe below mentioned are the test cases that I wrote and have attached the screenshot of the errors that I faced while executing the same.\n\nFrom this blog, it was mentioned that\n\nIf we want to expect a function to throw an exception for certain input parameters, the key point is that we must pass in a function definition and not call our function inside the expect.\n\nSo I updated my test case as\n\nBut it was throwing error like\n\nWhat is the issue with my implementation? What is the correct method to unit test a function which throws an error object back?"
    },
    {
        "link": "https://stackoverflow.com/questions/62466368/testing-a-js-function-with-jest-returns-a-bad-value-in-for-loop",
        "document": "It is my first use of Jest and I try to test a function with many many values like this :\n\nMy first test worked but for 2 days, Jest does not seem to execute my function for each round of the for loop, as if it kept value in memory (often that of the second round of the loop) and the toBe test is ultimately false. In some cases, the result of my functions is completely inconsistent (null or some kind of increment from the previous result). When I launch my function with the node with the same arguments it works well.\n\nI tried with it.each and the problem persists. Each mode is not good for me because I want to test my function for many many many values ðŸ˜….\n\nAfter your feedback, here are the two functions imported and the config constant. But these functions work well with the arguments sent in my loop. The problem does not seem to come from what returns the functions because when I launch them individually with node they work well with the same arguments as in the for loop of my Jest test.\n\nThis is the function imported in numToWordConstructor :\n\nThis is the function imported in wordToNumConstructor :\n\nAnd this is the result of const config = convertConfig['en'] :\n\nThank you in advance for your valuable feedback."
    },
    {
        "link": "https://projectai.in/projects/6442fcb7-d590-41c9-a973-343870c4a614/tasks/06b8330e-6503-409b-9163-1a69cf5bd26f",
        "document": "âš™ï¸ We are optimizing all the projects, removing redundant steps and task, and even more elaborated task details for you to follow. In a few weeks all the projects will be replaced with the new/better tasks. Stay tuned!"
    },
    {
        "link": "https://lambdatest.com/jest",
        "document": "Jest is one of the most popular JavaScript testing frameworks built by Meta (Facebook). As it works with Babel, TypeScript, Node, React, Angular, and Vue-based projects, it has been used on over 3,898,000 public repositories on GitHub.\n\nAccording to the official Jest website, Jest saw a mark of more than 50 million downloads in July 2022. It was initially designed to perform unit testing for React components and gained massive popularity within a blink of an eye. Its popularity led to its massive usage and uncountable updates.\n\nToday, Jest is used to perform testing for React components along with full-fledged front-end and back-end JavaScript applications. Many people misinterpret Jest as a library instead of a framework, which is not the case. Jest also comes with a CLI (Command Line Interface) that lets you run relevant commands from the terminal. Moreover, it also offers an assertion library, test runner, support for mocking techniques, and much more.\n\nIn this Jest tutorial, we will dive deep into every aspect of the Jest framework. We will kick-start the Jest tutorial with the basics of Jest (i.e., installation, configuration, etc.) and test execution using the Jest framework on local & cloud grids. The learnings of this Jest tutorial can be utilized in using Jest in an ideal manner in your project.\n\nBefore we look into the internals of Jest, letâ€™s do a quick recap of unit testing since Jest is majorly used for performing unit tests in web applications\n\nThe two most commonly used terms in Jest are: Mock and Spy. Mock captures objects from a constructor by erasing the actual implementation, while Spy is used for spying on every method call in Jest. Letâ€™s have a deeper look at Mock and Spy individually. As per Jestâ€™s official documentation, Mock functions erase the actual function implementation, capture the function calls with related parameters, capture instances of a constructor, and specify the test-time configuration of all the values returned. This whole process makes the testing of dependent codes easy. Jest Mocking is a technique we can use to remove any dependency between the test subjects and run the tests in isolation. A dependency is generally a module that our test subjects import. Moreover, Mock functions return whatever we want them to return. This feature makes testing all possible paths easy, as we have control over function parameters. This means we can make the function return whatever we want: true, false, and error. In Jest, you can mock both a function and a module. To create a mock for any function, you need to use jest.fn(); for a module, youâ€™ll use jest.mock. Letâ€™s take an example of mocking a function and understand it better: The first line in the above code initializes a simple mock called in the second line. The third line checks whether this mock is called. We can also check it by looking for a return value. Look at the following snippet: Every mock function has a .mock property that stores the data of how a function is called and what it returns. This property also tracks the value of this keyword in every call. console.log(myMock1.mock.instances); // > [ <a> ] // .mock.instances gives out the instance of myMock1 bound(); console.log(myMock2.mock.contexts); Spy is somewhat similar to mock, as it creates a mock function like jest.fn(), tracks every call to object[methodName], and returns a mock function. It is also known as a partial mock object. As the name suggests, Spy tracks all the calls to the function. It helps verify whether the function has been called under the right condition and with the right values and parameters. In short, Spy observes every call that is made to a method without changing the method itself. Spy can also be used for a class full of different functions and methods, and we want to mock them. To set a spy on any method, we use this syntax: In the end, we need to reset the spy so that the method returns to its original implementation. This can be done using the spy.mockRestore() method. Developers like freedom and Jest gives them just that. Below are some of the most basic Jest concepts that give developers the power to develop tests and testing conditions fast with lesser effort. Jest offers describe Blocks that organize Jest test cases in logical groups. It lets us create certain divisions into the test suite called blocks. These blocks are helpful in many cases, for example: when we need to group all the test cases of a specific method or class together. We can also create a nested describe block that contains a list of two or more describe blocks. The describe blocks are also responsible for cleaning up the JSDOM after every test execution. We can call the describe method to create a block by using the callback function. The â€˜itâ€™ keyword is used when we want to start a new individual test case definition. We can also use â€˜testâ€™ as an alias for â€˜it.â€™ The test case definition created by â€˜itâ€™ can be used in the â€˜describeâ€™ callback. If we are to combine the above two, we use â€˜describeâ€™ with a callback for creating a new test module, and then we use â€˜itâ€™ inside that describe block to create one or more individual tests. should be the best framework The beforeAll block is responsible for running a specific function before the test suite starts executing any of the tests in the file. If the function in beforeAll returns a JavaScript promise, it waits for it to resolve before running any tests. The most common use case of beforeAll is the setting up of any global state to be used by one or more tests in the suite. For example - Selenium, since the web drivers are initiated in a beforeAll() block. The afterAll block is used to run a specific function after all the tests in a suite have been executed successfully. If the functions result in a JavaScript promise, it stops the execution and waits until the promise has been resolved. The most common use case of afterAll is the clean-up, i.e., the afterAll block allows you to remove all the global setup states created or shared across the test suite. Both beforeAll and afterAll are used within the describe block. beforeAll runs at the beginning, while afterAll runs towards the end of the block. These are used in one-time setup and teardown hooks which we will discuss in the later sections of this Jest tutorial with examples. (Refer to the section Jest Hooks: Setup and Teardown). When working with a relatively large project and code database, there may be scenarios where you want to skip certain tests from the execution. Say 5 out of 1000 cases fail due to external dependencies, and you want to skip these specific tests. This can be done by using the skip tests functionality of Jest. This feature comes under the below aliases: Suppose youâ€™ve a test â€˜testWaterLevelâ€™â€™ and you want to skip its execution: This code block skips the execution of a given test and runs all the other tests in the suite. You also have the option to comment out the code related to such tests, but using skip tests methods is nicer, easier, and considered a best practice.\n\nIn this Jest tutorial, we will be walking through writing and performing tests with Jest. But before testing your JavaScript code, you must perform some prerequisite steps. Only after installing Jest and its associated software will you be able to exploit the features of Jest. Before installing Jest and running Jest scripts on your system, you need to have the below-mentioned libraries and packages installed: \n\n Java is one of the most popular languages for developing Selenium automation testing scripts. As the Jest framework incorporates the usage of Selenium, you also need to install the Java Development Kit (JDK 7.0 and above). You can download the JDK from its official website. \n\n NPM stands for Node Package Manager. You can install Node JS from the npm manager or the nodejs.org website. \n\n Browser drivers are used to implement Selenium WebDriverâ€™s protocols that convert given commands into a browserâ€™s native API. Or you can run the given command in your terminal to install the Chrome driver that instantiates Chrome and places executable files under the root directory. For the Safari browser, there is an in-built driver called safaridriver, which is already available in most Selenium client libraries. To configure your Safari browser for enabling WebDriver support, run the following command in your terminal: Jest needs the Selenium WebDriver installed in your system in case you are testing on a local Selenium Grid. It is recommended to have the WebDriver installed in the root directory. It is a non-negotiable dependency. Once youâ€™ve installed npm on your system, you can install the Selenium WebDriver using the below command. Now that youâ€™ve moved past the prerequisites, you need to install the Jest package module. Jest comes in the form of a node package. You can install it by using any node-based package manager like npm. To install Jest, open your command prompt or preferred terminal and type the following command: This command will initialize the npm. The second step is to write the below command to install Jest. The -g in the above command indicates that the module will be installed globally. Now press enter and wait for the process to complete. Once the installation is complete, type the next given command to get an executable file in the bin folder of its root directory. You can now verify if Jest has been installed by giving the following command: This command returns the current version of Jest installed on your system. Voila! Your system is ready to play with Jest: The JavaScript Testing Framework.\n\nOnce you are done with the initial setup and installation of Jest (and its prerequisites), itâ€™s time you write your first test using the Jest framework. In this section of this Jest tutorial, you will learn how to set up a test environment with the Jest framework. Let us start by installing Selenium dependencies and cloning the tutorials from LambdaTestâ€™s jest-selenium-webdriver-sample repository. Run the following Git command on your terminal: In the above command, we are cloning a sample repository by LambdaTest that helps us execute Jest tests with LambdaTest automation testing cloud. You can use cross browser testing tools like LambdaTest, which offers more than 3000 browsers and real device simulators & emulators to perform testing. Subscribe to the LambdaTest YouTube Channel to get more such tutorials around automated browser testing , App test automation, Cypress E2E testing, Mobile App Testing, and more. Now, install Jest by running the following command. - -save-dev saves the version and name of whichever package is being installed by the given command. This storing of version and name happens in the dev-dependency object. Dev-dependencies are the packages we only need while developing the project and not deploying. - -force is used to overwrite your local branch commit history forcefully. You need to set up your user name and access key from LambdaTest. You can get your credentials from the LambdaTest Profile or the LambdaTest Dashboard. The next step is to set your LambdaTest Username and Key in the environment variables. Let us now create a sample test with Jest on LambdaTest cloud grid. Copy the below code that hosts Jest test for a simple To-Do app. This is all you need to do to run your first test in Jest. You can also test your react AUT on the LambdaTest platform by following the given steps. Before going in, you need to set up LambdaTest authorizations. You can get your credentials from your LambdaTest Profile or through the LambdaTest Dashboard.\nâ€¢ Create a new file called capabilities.js and paste capabilities from LambdaTest Capabilities Generator.\nâ€¢ Add your username and access key to the index.test.js file and modify the beforeAll function to run the test on LambdaTest.\nâ€¢ Run the test using `npm run test` on a terminal and check your LambdaTest Dashboard. Running a test on LambdaTest in parallel across 5 different browsers LambdaTest supports parallel testing, which allows you to run the same test across different browsers simultaneously. To do this, create multiple instances of the WebDriver with different capabilities. \n\n // replace USERNAME and ACCESS_KEY with your LambdaTest credentials .withCapabilities({ }) .build(); }); }); \n\n Jest uses \"matchers\" to let you test values in different ways. For example, in the `toBe` matcher we used earlier, it checks for exact equality. There are numerous other matchers available in Jest like `toEqual` (for checking deep equality), `toBeNull `, `toBeDefined`, `toBeTruthy`, `toBeFalsy`, etc. \n\n \n\n After you run tests on LambdaTest, you can view the test results on LambdaTest dashboard. It will provide you with test status, test environment, and other details. You can also view the video of your Selenium test execution and share the test result link with your team. Now, in the upcoming sections of this Jest tutorial, we will dive deeper into the Jest framework.\n\nMatchers in Jest allow you to test data values in several ways. These, when combined with the expect keyword, are used in enforcing assertions, i.e., comparison of the output value with the expected value. For example: In the below code, we are checking whether the taken object is from the correct class. The expect keyword contains the test value together with the matcher function toBeInstanceOf(). Thatâ€™s not it! Matchers allow you to test value in more ways, letâ€™s discuss a few of them in brief: The most common way of comparing test data using matchers is with exact equality. In the above code, .toBe(4) is the matcher that expects the returned value to be equal to the expected value. This function is very similar to the Object.is function and hence enforces exact equality. In case you want to check the returned value rather than enforcing equality, you can use toEqual. Normally, you define the keywords undefined, false, and null differently. But there may be times when you want these to mean the same. This is possible with the truthiness helpers in Jest. Here are some of them:\nâ€¢ toBeNull matches if the value is null.\nâ€¢ toBeUndefined matches if the value is undefined.\nâ€¢ toBeDefined is the exact opposite of toBeUndefined.\nâ€¢ toBeTruthy returns true if the condition of an if condition is satisfied.\nâ€¢ toBeFalsy returns false if the condition of an if condition is not satisfied. Let us understand it with an example where we test these for a Null value: Let us understand it with an example where we test these for a Null value: Similar to truthiness and equality, we can also use matchers to match numbers in jest tests. There are several operations of matching numbers, be it equivalency or comparison. Below mentioned are a few of them: // toEqual and toBe are equivalent for numbers }); In case you are dealing with decimals, you need to ensure that matchers do not result in rounding errors. Hence, for floating point numbers, we use toBeCloseTo() number matcher. Matching strings in Jest is no different. You can match strings using toMatch(), hereâ€™s how:\n\nSetting up a few conditions and functions before a test runs and tearing them down right after the execution is an important step of testing. These may include the works that need to happen before and after tests are executed. Jest provides helper functions for that. Suppose you need to do some setup before each test, and you have several tests to be executed in line. For example - Say you have many test cases to be executed on Chrome and the same Chrome instance has to be used across all. Therefore, Chrome can be instantiated in the setup block. For setup, you can use beforeEach(). Each test follows a new setup and hence must end with a teardown. This teardown can be achieved by afterEach(). Look at the example below: //run this before every test execution }); //run this after every test execution }); In the above code, before every test, beforeEach() setups and initializes a database. The test is executed based on the values from the database. Now when the test is done, afterEach() clears the database. In many cases, you may need to set up and teardown only once. This is where beforeAll() and afterAll() are used. These two are called within the describe block and are helpful in synchronous tests. As we have already discussed in the above sections of this Jest tutorial, beforeAll() runs at the beginning while afterAll() runs towards the end of the block. //run this before every test execution }); //run this after every test execution }); In the above example, unlike beforeEach() and afterEach(), a one-time setup with beforeAll() and afterAll() initializes and clears the database only once. The before and after blocks are automatically applied to every test in a suite by default. As we have already discussed, all the tests are grouped within the describe block together. Moreover, the before and after blocks work only for the tests that are inside the describe block. Any test outside the â€˜describeâ€™ block wonâ€™t have any before or after operations. The setup and teardown are only effective and scoped for the tests within the block.\n\nIn this section of this Jest tutorial, we will learn to set up and perform snapshot tests in react applications using the Jest framework. Snapshot tests are a significant way of testing UI by comparing previous UI components to newer UI components. This testing ensures that your UI components do not change unexpectedly. Snapshot testing works by rendering a UI component, which takes a snapshot of the component, and then compares it to a reference snapshot file stored alongside. The test will fail if the two snapshots do not match, if there is an unexpected change, or if the reference snapshot needs to be updated to the new version of the UI component. Let us now see how snapshot testing for React front-end works with Jest. First, create a new React application by running an `npx create-react-app jest-snapshot-demo` command in your terminal. Now navigate to the React application using `cd jest-snapshot-demo` and run `npm start` to start the React app. Now, we will walk through the creation of a basic React frontend AUT. Open the react application in your favorite IDE and navigate to src/App.js.\nâ€¢ Modify the App.js file by importing and adding the â€˜Todosâ€™ component, which we will create in the next step.\nâ€¢ Create a new Todo component under the src folder as Todos.js and paste the code below for this component. This marks the creation of our basic React app. Now, if you visit `http://localhost:3000/` in your browser, your screen will display the list of todos youâ€™ve just created. In this subsection of this Jest tutorial, we will write snapshot tests for the React component weâ€™ve just created. Follow the given step-by-step process to write and execute a snapshot test.\nâ€¢ Open your terminal and install `react-test-renderer` by running `npm install react-test-renderer` on your project directory.\nâ€¢ Delete the App.test.js file and create a Todos.test.js file in the src folder. Now, write the first test case for the Todos component for the case if there are no todos. \"renders correctly when there are no todos\" expect(tree).toMatchSnapshot(); });\nâ€¢ Now you can run your test using the `npm test` command and check your test output on the terminal. Youâ€™ll get an output screen like the one below.\nâ€¢ Add another test case for the component when the todo list is empty and when there are three todos. \"renders correctly when there are empty todo\" expect(tree).toMatchSnapshot(); }); \"renders correctly when there are 3 todos\" expect(tree).toMatchSnapshot(); });\nâ€¢ Press the Enter key on the terminal to run all three test cases, and you can check if all the test cases are passed or not. Snapshot testing is excellent at finding any abrupt changes or mistakes in the UI. If there are any changes in the UI and the new snapshot doesnâ€™t match the previous one, it will throw an error. Here's how you can verify a snapshot test of the React component weâ€™ve created.\nâ€¢ Make changes to your Todos component by replacing the h1 tag with h2 and the div with span.\nâ€¢ Save the Todos component file and run the `npm test` on your terminal again.\nâ€¢ Your test case would fail because of the changes in the Todos component.\nâ€¢ To resolve this issue, you can either update the snapshot by either pressing the `u` key (if you are in Jest interactive mode) or by deleting the `__snapshots__` folder inside the src folder.\n\nThere are many JavaScript testing frameworks and tools available in the market: Mocha, Chai, Jasmine, Cypress, and whatnot. But why should you use Jest? We have already covered a few points of why Jest is one of the best automation testing frameworks for JavaScript testing. Let us now establish a concrete answer as to why you should test with the Jest framework. The best reasons to use Jest are its rich feature set. Letâ€™s look at a few more characteristics and features of Jest: As per the official Jest website, it has been used on more than 3,898,000 public repositories on GitHub. This number proves that Jest has become one of the best JavaScript testing frameworks in the market, and the credit goes to the features it lays out. Letâ€™s have a look at some of its best features. \n\n Jest requires minimal configuration and setup. It is one of the rarest test frameworks that do not require a complex setup before testing the applications. \n\n Jest framework supports almost every type of mocking. It supports everything from mocking individual API calls to functional and timer mocking. \n\n Jest provides a sandbox environment for every test to ensure that no two tests interfere and execute in an isolated environment. This feature supports the isolation property of unit testing. \n\n Jest comes with built-in support for code coverages. It offers out-of-the-box CLI-based commands to deliver precise code coverage and ensure the overall efficiency of an app or project. You can use the â€“coverage command or the â€“collectCoverage property in the Jest configuration file. \n\n As it runs tests parallely in isolated sandboxes, the speed of unit testing with Jest increases manifolds. Not only does it execute individual tests fast, but it also boosts the overall speed and performance of the testing suite. \n\n Jest supports a feature to take a snapshot of every react component that is tested. This snapshot can verify the output and the appâ€™s behavior. \n\n Jest claims to have a rich API. From it to expect, it has a range of helpful APIs that allow you to match and validate values, meet desired conditions, and whatnot. One such example is the Expect API, which offers various matcher functions. These matcher functions can be used to validate certain values and conditions. It also incorporates numerous assertion types explained well in the Jest official documentation. As it is open source, Jest community members can add their matchers to its API list. You can check them here: jest-extended. \n\n No matter what tool or framework youâ€™ve been using, you can always migrate to Jest without facing typical programmatic issues with your module. Thanks to the jest-codemods module, you can migrate from any testing framework to Jest without doing any dirty migration work. It doesnâ€™t matter if youâ€™re using Jasmine, Mocha, Chai, Tape, or any other framework. You can easily migrate to Jest with the help of jest-codemods. With the help of jscodeshift, this third-party runs a code transformation procedure on your existing codebase. jscodeshift is a toolkit that is responsible for running codemods for JavaScript. Coming back to jest-codemods: You can run the below command to migrate your existing test codebase to Jest. Refer to this link to know more about jest-codemods: https://github.com/skovhus/jest-codemods\n\nAs per the Stack Overflow Developer Survey of 2021, JavaScript is the most popular programming language. With such popularity and use-case, it is obvious that JavaScript gets flooded with various automation testing tools. As per the State of JS 2020, Jest, Mocha, and Jasmine are the top three most popular JavaScript testing frameworks. In this Jest tutorial on Jest vs Mocha vs Jasmine, we make a detailed comparison between these three frameworks. The main focus of Jest is the testing of front-end components and apps. As weâ€™ve already discussed, it is a zero-configuration framework achieved by being built on top of Jasmine. The core package of Jasmine does not depend on any external dependency. Hence, any framework built on top of it gets an easy low-dependence package. Jest pairs best with React apps. At Facebook, it is the primary framework for testing ReactJS components. Moreover, prominent organizations like Spotify, Airbnb, Travel Park, Instagram, etc., have adopted the Jest framework in their tech stack. Jest is becoming the most used automation framework in JavaScript testing. Below are some points that make Jest a better framework.\nâ€¢ Jest is a framework that runs unit testing for each unit in isolation, supporting parallel testing. This makes it faster than other JavaScript testing frameworks.\nâ€¢ The Jest documentation is very easy to understand, especially for developers new to the test-driven development approach.\nâ€¢ It supports Snapshot testing (i.e., Smart Visual Regression testing by taking screenshots). During front-end testing, this feature comes in handy to detect and debug any UI bugs. With all the advantages and features, Jest is undoubtedly one of the best JavaScript testing frameworks. However, it also has a few disadvantages.\nâ€¢ Compared to Jasmine and Mocha, it doesnâ€™t support many libraries or tools.\nâ€¢ The auto-mocking feature in Jest can slow the process as it increases the number of dependencies for mocking.\nâ€¢ Snapshot feature is not feasible for larger files with thousands of lines. Jasmine works well with front-end and back-end apps and is a fast-aiming testing framework. It is also one of the oldest and most stable JavaScript testing frameworks. However, its front-end suite works better with Angular components rather than React. This is where Jest stands out as a preferred testing framework for React-based projects. Jasmine has been in the market for long and has a very active community. Giant corporations that prominently adopt Jasmine in their tech stack are: Uniqlo, GitHub, Accenture, Typeform, etc. Jasmine and Selenium are among the most popular tools for JavaScript and Web UI respectively. Combining these two for your JavaScript automation testing can prove very beneficial. Here are some advantages of choosing Jasmine over Jest and Mocha.\nâ€¢ It is compatible with most frameworks and libraries, making it very flexible.\nâ€¢ Jasmine offers a set of built-in assertion and matcher methods that can easily match expectations and help improve the readability of Jasmine tests.\nâ€¢ It doesnâ€™t rely on DOM, browser, or any other framework. Though it is independent, flexible, and powerful, it also has disadvantages. Letâ€™s look at a few of them.\nâ€¢ Easy installation doesnâ€™t guarantee easy setup. Setting up Jasmine is very complex as users need to choose assertion or mocking libraries before even using them.\nâ€¢ It is challenging to perform asynchronous testing with Jasmine.\nâ€¢ Integration required for snapshot testing is not easy. Mocha can be stated as the most flexible JavaScript testing framework out of all three. With flexibility and simplicity as its main focus, Mocha works well with various projects and tech stacks. Unlike Jest, Mocha doesnâ€™t depend on the mocking, stubbing, and assertion libraries; hence the developers get the advantage of choosing any library. However, it has fairly more dependencies than the other two. Giant multinational corporations like Accenture, Netlify, Asana, Yahoo, Oyo Rooms, Coursera, Wix, etc., include Mocha in their tech stack. Below given points make Mocha one of the most preferred frameworks for JavaScript testing.\nâ€¢ The Mocha API is very simple and similar to Jasmine. It is more conductive than Jasmine as it covers many scenarios, including BDD.\nâ€¢ Tests run serially in Mocha. This results in flexible and accurate reports, mapping all the unhandled exceptions to their correct test cases.\nâ€¢ It supports both BDD (Behavior Driven Development) and TDD (Test Driven Development). Mocha proves itself to be a very powerful tool and competes well with Jest and Jasmine. However, it also has disadvantages.\nâ€¢ Mocha requires multiple configuration and setup efforts. This is where Jest proves itself better.\nâ€¢ Auto-mocking and snapshotting are not very feasible.\nâ€¢ The lack of developer tooling and onboarding features makes it a bit complex for first-time developers.\n\nIn this Jest tutorial, weâ€™ve learned everything about Jest in detail. We covered various Jest concepts, testing your JavaScript and React apps using the Jest framework, and also established a brief comparison between Jest, Mocha, and Jasmine. We also discussed various features, advantages, and capabilities of the Jest framework.\n\nHowever, we canâ€™t just claim the superiority of any framework over others. Different frameworks focus on different aspects and choosing one mostly depends on individual needs. Of course, choosing the best JavaScript testing framework for your project may prove to be more challenging, but it is something you canâ€™t run from.\n\nThe final deciding factor is your needs and expectations from the framework. Considering the tech stack youâ€™re working on, Angular, React, or NodeJS, you can choose the most suitable JavaScript testing framework. We hope this Jest tutorial turned out beneficial for you."
    }
]