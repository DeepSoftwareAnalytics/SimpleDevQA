[
    {
        "link": "https://stackoverflow.com/questions/19034199/properly-handling-httpclient-exceptions-within-async-await",
        "document": "I was hoping somebody could enlighten me a little bit on an issue I am facing in regards to async/await exception handling with HttpClient. I have written some code to illustrate, and it is being excecuted on both a Windows Phone 8 device and the emulator:\n\nTapping the button that invokes this function, produces the following output in the debugger console, the most interesting being the ones in bold:\n\nAn exception of type 'System.Net.WebException' occurred in System.Windows.ni.dll and wasn't handled before a managed/native boundary An exception of type 'System.Net.WebException' occurred in System.Windows.ni.dll and wasn't handled before a managed/native boundary A first chance exception of type 'System.Net.Http.HttpRequestException' occurred in mscorlib.ni.dll An exception of type 'System.Net.Http.HttpRequestException' occurred in mscorlib.ni.dll and wasn't handled before a managed/native boundary\n\nOf course I am expecting an error in this case since the URL I am calling is nonsense. What I am not understanding here, is why the debugger reports that the exceptions are not handled, when the output simultaneously reports that the exception is caught. Also, the UI side of the app becomes much less responsive while the output is being printed, indicating that something is probably amiss.\n\nIs this not the way to handle exceptions when working with async and await? I appreciate any input! Thanks."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions",
        "document": "Proper exception handling is essential for application reliability. You can intentionally handle expected exceptions to prevent your app from crashing. However, a crashed app is more reliable and diagnosable than an app with undefined behavior.\n\nThis article describes best practices for handling and creating exceptions.\n\nThe following best practices concern how you handle exceptions:\n‚Ä¢ Use try/catch/finally blocks to recover from errors or release resources\n‚Ä¢ Design classes so that exceptions can be avoided\n\nUse try/catch/finally blocks to recover from errors or release resources\n\nFor code that can potentially generate an exception, and when your app can recover from that exception, use / blocks around the code. In blocks, always order exceptions from the most derived to the least derived. (All exceptions derive from the Exception class. More derived exceptions aren't handled by a clause that's preceded by a clause for a base exception class.) When your code can't recover from an exception, don't catch that exception. Enable methods further up the call stack to recover if possible.\n\nClean up resources that are allocated with either statements or blocks. Prefer statements to automatically clean up resources when exceptions are thrown. Use blocks to clean up resources that don't implement IDisposable. Code in a clause is almost always executed even when exceptions are thrown.\n\nFor conditions that are likely to occur but might trigger an exception, consider handling them in a way that avoids the exception. For example, if you try to close a connection that's already closed, you'll get an . You can avoid that by using an statement to check the connection state before trying to close it.\n\nIf you don't check the connection state before closing, you can catch the exception.\n\nThe approach to choose depends on how often you expect the event to occur.\n‚Ä¢ None Use exception handling if the event doesn't occur often, that is, if the event is truly exceptional and indicates an error, such as an unexpected end-of-file. When you use exception handling, less code is executed in normal conditions.\n‚Ä¢ None Check for error conditions in code if the event happens routinely and could be considered part of normal execution. When you check for common error conditions, less code is executed because you avoid exceptions. Up-front checks eliminate exceptions most of the time. However, there can be race conditions where the guarded condition changes between the check and the operation, and in that case, you could still incur an exception.\n\nIf the performance cost of exceptions is prohibitive, some .NET library methods provide alternative forms of error handling. For example, Int32.Parse throws an OverflowException if the value to be parsed is too large to be represented by Int32. However, Int32.TryParse doesn't throw this exception. Instead, it returns a Boolean and has an parameter that contains the parsed valid integer upon success. Dictionary<TKey,TValue>.TryGetValue has similar behavior for attempting to get a value from a dictionary.\n\nIt's better to catch OperationCanceledException instead of TaskCanceledException, which derives from , when you call an asynchronous method. Many asynchronous methods throw an OperationCanceledException exception if cancellation is requested. These exceptions enable execution to be efficiently halted and the callstack to be unwound once a cancellation request is observed.\n\nAsynchronous methods store exceptions that are thrown during execution in the task they return. If an exception is stored into the returned task, that exception will be thrown when the task is awaited. Usage exceptions, such as ArgumentException, are still thrown synchronously. For more information, see Asynchronous exceptions.\n\nDesign classes so that exceptions can be avoided\n\nA class can provide methods or properties that enable you to avoid making a call that would trigger an exception. For example, the FileStream class provides methods that help determine whether the end of the file has been reached. You can call these methods to avoid the exception that's thrown if you read past the end of the file. The following example shows how to read to the end of a file without triggering an exception:\n\nAnother way to avoid exceptions is to return (or default) for most common error cases instead of throwing an exception. A common error case can be considered a normal flow of control. By returning (or default) in these cases, you minimize the performance impact to an app.\n\nFor value types, consider whether to use or as the error indicator for your app. By using , becomes instead of . Sometimes, adding can make it clearer when a value is present or absent. Other times, adding can create extra cases to check that aren't necessary and only serve to create potential sources of errors.\n\nCallers should be able to assume that there are no side effects when an exception is thrown from a method. For example, if you have code that transfers money by withdrawing from one account and depositing in another account, and an exception is thrown while executing the deposit, you don't want the withdrawal to remain in effect.\n\nThe preceding method doesn't directly throw any exceptions. However, you must write the method so that the withdrawal is reversed if the deposit operation fails.\n\nOne way to handle this situation is to catch any exceptions thrown by the deposit transaction and roll back the withdrawal.\n\nThis example illustrates the use of to rethrow the original exception, making it easier for callers to see the real cause of the problem without having to examine the InnerException property. An alternative is to throw a new exception and include the original exception as the inner exception.\n\nOnce an exception is thrown, part of the information it carries is the stack trace. The stack trace is a list of the method call hierarchy that starts with the method that throws the exception and ends with the method that catches the exception. If you rethrow an exception by specifying the exception in the statement, for example, , the stack trace is restarted at the current method and the list of method calls between the original method that threw the exception and the current method is lost. To keep the original stack trace information with the exception, there are two options that depend on where you're rethrowing the exception from:\n‚Ä¢ If you rethrow the exception from within the handler ( block) that's caught the exception instance, use the statement without specifying the exception. Code analysis rule CA2200 helps you find places in your code where you might inadvertently lose stack trace information.\n‚Ä¢ If you're rethrowing the exception from somewhere other than the handler ( block), use ExceptionDispatchInfo.Capture(Exception) to capture the exception in the handler and ExceptionDispatchInfo.Throw() when you want to rethrow it. You can use the ExceptionDispatchInfo.SourceException property to inspect the captured exception.\n\nThe following example shows how the ExceptionDispatchInfo class can be used, and what the output might look like.\n\nIf the file in the example code doesn't exist, the following output is produced:\n\nThe following best practices concern how you throw exceptions:\n\nIntroduce a new exception class only when a predefined one doesn't apply. For example:\n‚Ä¢ If a property set or method call isn't appropriate given the object's current state, throw an InvalidOperationException exception.\n‚Ä¢ If invalid parameters are passed, throw an ArgumentException exception or one of the predefined classes that derive from ArgumentException.\n\nIt's common for a class to throw the same exception from different places in its implementation. To avoid excessive code, create a helper method that creates the exception and returns it. For example:\n\nSome key .NET exception types have such static helper methods that allocate and throw the exception. You should call these methods instead of constructing and throwing the corresponding exception type:\n\nIf you're implementing an asynchronous method, call CancellationToken.ThrowIfCancellationRequested() instead of checking if cancellation was requested and then constructing and throwing OperationCanceledException. For more information, see CA2250.\n\nThe error message the user sees is derived from the Exception.Message property of the exception that was thrown, and not from the name of the exception class. Typically, you assign a value to the Exception.Message property by passing the message string to the argument of an Exception constructor.\n\nFor localized applications, you should provide a localized message string for every exception that your application can throw. You use resource files to provide localized error messages. For information on localizing applications and retrieving localized strings, see the following articles:\n‚Ä¢ How to: Create user-defined exceptions with localized exception messages\n\nWrite clear sentences and include ending punctuation. Each sentence in the string assigned to the Exception.Message property should end in a period. For example, \"The log table has overflowed.\" uses correct grammar and punctuation.\n\nPlace throw statements where the stack trace will be helpful. The stack trace begins at the statement where the exception is thrown and ends at the statement that catches the exception.\n\nDon't raise exceptions in clauses. For more information, see code analysis rule CA2219.\n\nSome methods, such as , , and methods, static constructors, and equality operators, shouldn't throw exceptions. For more information, see code analysis rule CA1065.\n\nIn task-returning methods, you should validate arguments and throw any corresponding exceptions, such as ArgumentException and ArgumentNullException, before entering the asynchronous part of the method. Exceptions that are thrown in the asynchronous part of the method are stored in the returned task and don't emerge until, for example, the task is awaited. For more information, see Exceptions in task-returning methods.\n\nThe following best practices concern custom exception types:\n\nWhen a custom exception is necessary, name it appropriately and derive it from the Exception class. For example:\n\nUse at least the three common constructors when creating your own exception classes: the parameterless constructor, a constructor that takes a string message, and a constructor that takes a string message and an inner exception.\n‚Ä¢ Exception(String, Exception), which accepts a string message and an inner exception.\n\nFor an example, see How to: Create user-defined exceptions.\n\nProvide additional properties for an exception (in addition to the custom message string) only when there's a programmatic scenario where the additional information is useful. For example, the FileNotFoundException provides the FileName property."
    },
    {
        "link": "https://stackoverflow.com/questions/22274924/good-pattern-for-exception-handling-when-using-async-calls",
        "document": "I want to consume an Web API and I see many people recommending .\n\nThat's fine... but I have only VS-2010, so I cannot use just yet. Instead, I guess I could use in combination to . So I tried this piece of code:\n\nMy first observation was to realize that it doesn't generate any error if URL is not available, but maybe there will be more errors like this...\n\nSo I am trying to find a way to handle exceptions for such async calls (particularly for HttpClient). I noticed that \"Task\" has property and an which maybe could be used, but I am not sure yet how.\n\nAnother observation was that returns , but returns . The latter could be maybe more useful, since it presents a .\n\nCould you share a pattern on how to use the async calls correctly and handle exceptions in a good way? Basic explanation would be appreciated as well."
    },
    {
        "link": "https://reddit.com/r/csharp/comments/o2lvp7/how_to_better_handle_exceptions_with_httpclient",
        "document": "What's the best way to handle exceptions when doing multiple web requests with ?\n\nFor example in this method I use in order to ensure the request goes through but in case it doesn't it throws an exception, as it should.\n\nSince I have these kind of web requests all over the place would it be worth for me to encapsulate the whole thing in a method and handle the eventual exceptions in there? Because doing to for every call seems to be burdensome and frankly inefficient.\n\nBonus question: what's the best way to handle said exceptions in a library and show them? I'm developing a .NET Core library and I don't know in which application it'll be used."
    },
    {
        "link": "https://medium.com/@iamprovidence/http-client-in-c-best-practices-for-experts-840b36d8f8c4",
        "document": "Did you think that learning how to create an is all you need to start using it? Oh silly you are üòå. Network communication is unreliable, therefore you need to make your resilient.\n\nWhen you have one service calling another, there are multiple issues you can encounter:\n‚Ä¢ the request may take too long\n‚Ä¢ the server may be slow or not available at all\n\nTherefore, you should learn about:\n\nThere is another popular NuGet, called , which allows you to write resilient code in a fluent manner:\n\nMicrosoft saw how good it is, and decided to use in their own NuGet ( that adds resiliency to .\n\nLet‚Äôs see it in practice.\n\nWhen a user clicks a button, he does not care whether you are performing complex computations or calling an external service. The user just expects to see a response right away.\n\nHowever, when an external service is overloaded and the request takes too long, it will cause slowness in your application.\n\nTherefore you should set a timeout of how long you can wait for the response:\n\nIf the request takes longer, it will be aborted and considered as a failed one.\n\nWe can face another issue. The response is returned in an acceptable interval, however, it failed with an error.\n\nIn that case, it is worth try sending the same request again.\n\nWith retries you need to consider the following factors:\n‚Ä¢ which status codes should be retried\n\nHTTP‚Äôs status code indicates the result of the request, whether it was successful or encountered an error. The codes are grouped into five categories based on their first digit:\n\nAnd only and groups indicate an error.\n\nIt is important to understand which codes should be retried.\n\nIf the request is returned with client error ( ), it means that it was poorly formed. Parameters are invalid, the authorization token is missing, the validation failed, and so on. Retrying such a request will likely result in the same error.\n\nTherefore you should not retry the group. But there are exceptions:\n‚Ä¢ . This status code indicates that the server did not complete the request within the expected time. Retrying after a reasonable delay might help\n‚Ä¢ . If you encounter this status code, it means you‚Äôre making too many requests in a given time frame. Retrying after some period can help avoid hitting rate limits\n\nOn the other hand, server errors ( ), typically means temporary issues that will be resolved on a retry (except üòÖ).\n\nIn practice, you don‚Äôt have to think about which status codes to retry, because Microsoft already implemented that üôè:\n\nIt‚Äôs often a good practice to set a limit on the number of retry attempts to prevent infinite retry loops in case of persistent failures.\n\nOf course, in case you are integrating with a third party, you should take into account the number of requests you send, the rate limits it imposes, and the potential impact on performance and costs.\n\nWe agreed on a number of retry attempts. It is also important to choose a delay between retries.\n\nEach retry can happen after a constant timeout, let‚Äôs say .\n\nThis can be easily set in our retry policy:\n\nIt is simple, but not very effective.\n\nIf the server returns an error, retrying after a short delay can help quickly obtain a response from the server.\n\nHowever, if you fail on a second attempt, on the third one, it usually means the server is overloaded, and spamming it with more requests just worsens the situation.\n\nSo, if the client ‚Äúsees‚Äù that the server is unavailable, but it desperately needs a response, it is better to wait for a longer period.\n\nIt is recommended to increase the delay between each retry linearly or exponentially. This way you wait , then , then , and so on.\n\nEven though this strategy is a bit better, it still has some drawbacks.\n\nPicture this: your server goes down entirely. Multiple begin retrying their requests, and these retries align in time, generating peak load moments on the already overwhelmed server. This can potentially lead to a self-DDoS attack.\n\nYou need to add a random delay to each retry, also known as jitter.\n\nWhen implementing retries you should remember that some HTTP methods may have side effects.\n\nAccording to REST, you can classify any operation as Create, Read, Update, or Delete (CRUD).\n\nLet‚Äôs say we receive from a server. This does not mean that the request was not handled. It just indicates that we no longer wait for a response.\n\nAs expected our client will do the retry. The behavior will be different depending on the operation:\n‚Ä¢ ‚Äî on the first attempt, the server will delete the resource, and on the second retry, there will be nothing to delete, so the retry should not harm our server\n‚Ä¢ ‚Äî generally, the update operation is not harmful. For example, if you send the same data multiple times, the server should overwrite the resource with identical values\n‚Ä¢ ‚Äî it does not matter, how many times you retrieve the data as fetch is a read-only, side-effect-free operation\n‚Ä¢ ‚Äî retrying the request responsible for creation could result in duplicate entries üòñ\n\nTherefore, the server should ensure idempotency.\n\nOr in plain English, if you have an API endpoint to pay for an order and unpetient users click 10 times, only 1 payment will be charged.\n\nTypically, clients should include a with each request, enabling the server to maintain a record of processed requests:\n\nWe won‚Äôt discuss idempotency in detail here. It is another big topic that deserves its own article üôÉ. Just remember, that if your server does not implement idempotency (which is often the case with third-party apps), retries can cause more issues than solve.\n\nSo, we have timeout and retries. Still, there is another known problem.\n\nLet‚Äôs say our server is overwhelmed with requests and it takes time to respond.\n\nSure we have a timeout, however, during the waiting period, the client continues sending requeues and also runs out of resources, such as memory, TCP connections, available threads, and so on.\n\nOver time the client will deplete its resources and also fail.\n\nSometimes it is better to fail fast instead of trying to send requests that will allocate the client‚Äôs resources and fail anyway.\n\nIt is solved with the Circuit-Breaker pattern. The idea is as follows:\n‚Ä¢ we add a proxy that will gather the statistics about the number of failed requests\n‚Ä¢ if at some point we realize that the server has stopped responding, we should stop all requests for a while. This is known as open-state\n‚Ä¢ from time to time, our proxy goes to a half-open state. It allows some requests through just to verify whether the server has recovered or not\n‚Ä¢ in case, the server starts responding at a reasonable rate, we can get back to the close state when there is no gap in the connection line\n\nThe good news here is that we don‚Äôt need to implement Circuit-Breaker from scratch or add any proxy service here. As before, everything can be done with one configuration line üòÅ:\n\nYou can tune parameters more granularly, depending on your needs, but I will leave it as is because I am lazy üôÉ.\n\nAs you can see, configuring the resiliency pipeline is complex. Microsoft also knows that it is quite easy to f#ck it up üòÖ. You can set policies in the wrong order, set invalid parameters, and so on. Therefore, they give us an extension method, that will register standard policies:\n\nThey look like this:\n\nStill, it is possible to tune some settings, if needed:"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.net.http.httprequestexception?view=net-9.0",
        "document": "Some information relates to prerelease product that may be substantially modified before it‚Äôs released. Microsoft makes no warranties, express or implied, with respect to the information provided here.\n\nA base class for exceptions thrown by the HttpClient and HttpMessageHandler classes.\n\nInitializes a new instance of the HttpRequestException class. Initializes a new instance of the HttpRequestException class with a specific message an inner exception, and an HTTP status code and an HttpRequestError. Initializes a new instance of the HttpRequestException class with a specific message that describes the current exception, an inner exception, and an HTTP status code. Initializes a new instance of the HttpRequestException class with a specific message that describes the current exception and an inner exception. Initializes a new instance of the HttpRequestException class with a specific message that describes the current exception.\n\nGets a collection of key/value pairs that provide additional user-defined information about the exception. (Inherited from Exception) Gets or sets a link to the help file associated with this exception. (Inherited from Exception) Gets or sets HRESULT, a coded numerical value that is assigned to a specific exception. (Inherited from Exception) Gets the HttpRequestError that caused the exception. Gets the Exception instance that caused the current exception. (Inherited from Exception) Gets a message that describes the current exception. (Inherited from Exception) Gets or sets the name of the application or the object that causes the error. (Inherited from Exception) Gets a string representation of the immediate frames on the call stack. (Inherited from Exception) Gets the HTTP status code to be returned with the exception. Gets the method that throws the current exception. (Inherited from Exception)\n\nDetermines whether the specified object is equal to the current object. (Inherited from Object) When overridden in a derived class, returns the Exception that is the root cause of one or more subsequent exceptions. (Inherited from Exception) When overridden in a derived class, sets the SerializationInfo with information about the exception. (Inherited from Exception) Gets the runtime type of the current instance. (Inherited from Exception) Creates and returns a string representation of the current exception. (Inherited from Exception)\n\nOccurs when an exception is serialized to create an exception state object that contains serialized data about the exception. (Inherited from Exception)"
    },
    {
        "link": "https://stackoverflow.com/questions/74816756/c-sharp-system-net-http-httprequestexception-an-error-occurred-while-sending-th",
        "document": "I have given up. Idk why this works on our dev server but not on prod. Our dev and prod are on IIS. I am still new to C# and .NET Framework but after Googling around I still can't fix this error. Nothing works.\n\nHere is my code that is trying to call HttpClient.PostAsync"
    },
    {
        "link": "https://stackoverflow.com/questions/78396053/why-does-running-this-task-return-error-system-net-http-httprequestexception-r",
        "document": "Just as a side project I decided to make a discord bot that allows for users to enter a word and get its defintion. I've gotten most of the things done except for the command that actually gets the definition. I'm using FreeDictionaryAPI and when I run\n\nin theory it should run\n\nLine 18 is the line that contains\n\nIt works fine when the method is but breaks the moment it is switched to\n\nSo far I have tried to have it simply using the method rather than the method, but this has proven futile after the entire program just decides to not run. This is really the only thing I've tried thus far as I don't really know what the issue is. Is there a way to fix this?"
    },
    {
        "link": "https://learn.microsoft.com/en-us/aspnet/web-api/overview/error-handling/exception-handling",
        "document": "This article describes error and exception handling in ASP.NET Web API.\n\nWhat happens if a Web API controller throws an uncaught exception? By default, most exceptions are translated into an HTTP response with status code 500, Internal Server Error.\n\nThe HttpResponseException type is a special case. This exception returns any HTTP status code that you specify in the exception constructor. For example, the following method returns 404, Not Found, if the id parameter is not valid.\n\nFor more control over the response, you can also construct the entire response message and include it with the HttpResponseException:\n\nYou can customize how Web API handles exceptions by writing an exception filter. An exception filter is executed when a controller method throws any unhandled exception that is not an HttpResponseException exception. The HttpResponseException type is a special case, because it is designed specifically for returning an HTTP response.\n\nException filters implement the System.Web.Http.Filters.IExceptionFilter interface. The simplest way to write an exception filter is to derive from the System.Web.Http.Filters.ExceptionFilterAttribute class and override the OnException method.\n\nHere is a filter that converts NotImplementedException exceptions into HTTP status code 501, Not Implemented:\n\nThe Response property of the HttpActionExecutedContext object contains the HTTP response message that will be sent to the client.\n\nThere are several ways to register a Web API exception filter:\n\nTo apply the filter to a specific action, add the filter as an attribute to the action:\n\nTo apply the filter to all of the actions on a controller, add the filter as an attribute to the controller class:\n\nTo apply the filter globally to all Web API controllers, add an instance of the filter to the GlobalConfiguration.Configuration.Filters collection. Exception filters in this collection apply to any Web API controller action.\n\nIf you use the \"ASP.NET MVC 4 Web Application\" project template to create your project, put your Web API configuration code inside the class, which is located in the App_Start folder:\n\nThe HttpError object provides a consistent way to return error information in the response body. The following example shows how to return HTTP status code 404 (Not Found) with an HttpError in the response body.\n\nCreateErrorResponse is an extension method defined in the System.Net.Http.HttpRequestMessageExtensions class. Internally, CreateErrorResponse creates an HttpError instance and then creates an HttpResponseMessage that contains the HttpError.\n\nIn this example, if the method is successful, it returns the product in the HTTP response. But if the requested product is not found, the HTTP response contains an HttpError in the request body. The response might look like the following:\n\nNotice that the HttpError was serialized to JSON in this example. One advantage of using HttpError is that it goes through the same content-negotiation and serialization process as any other strongly-typed model.\n\nFor model validation, you can pass the model state to CreateErrorResponse, to include the validation errors in the response:\n\nThis example might return the following response:\n\nFor more information about model validation, see Model Validation in ASP.NET Web API.\n\nThe previous examples return an HttpResponseMessage message from the controller action, but you can also use HttpResponseException to return an HttpError. This lets you return a strongly-typed model in the normal success case, while still returning HttpError if there is an error:"
    },
    {
        "link": "https://elmah.io/exceptions/System.Net.Http.HttpRequestException",
        "document": "A base class for exceptions thrown by the System.Net.Http.HttpClient and System.Net.Http.HttpMessageHandler classes.\n\nWe haven't written anything about avoiding this exception yet. Got a good tip on how to avoid throwing System.Net.Http.HttpRequestException? Feel free to reach out through the support widget in the lower right corner with your suggestions.\n\nYou are doing it right with ServerCertificateValidationCallback. This is not the problem you are facing. The problem you are facing is most likely the version of SSL/TLS protocol. For example, if your server offers only SSLv3 and TLSv10 and your client needs TLSv12 then you will receive this error message. What you need to do is to make sure that both client and server have a common protocol version supported. When I need a client that is able to connect to as many servers as possible (rather than to be as secure as possible) I use this (together with setting the validation callback):\n\nIt's probably caused by a local network connectivity issue (but also a DNS error is possible). Unfortunately is generic, however you can determine the exact issue catching and then inspecting : if it's a then you can check the property, for example should indicate a DNS resolution problem. It may happen, there isn't much you can do. What I'd suggest to always wrap that (network related) code in a loop with a / block (as also suggested here for other fallible operations). Handle known exceptions, wait a little (say 1000 msec) and try again (for say 3 times). Only if failed all times then you can quit/report an error to your users. Very raw example like this: private const int NumberOfRetries = 3; private const int DelayOnRetry = 1000; public static async Task<HttpResponseMessage> GetFromUrlAsync(string url) { using (var client = new HttpClient()) { for (int i=1; i <= NumberOfRetries; ++i) { try { return await client.GetAsync(url); } catch (Exception e) when (i < NumberOfRetries) { await Task.Delay(DelayOnRetry); } } } }\n\nYou just need to keep digging. The exception \"The response ended prematurely\" isn't the root cause. Keep digging into the inner exceptions until you find the last one. You'll find this: System.IO.IOException: Authentication failed because the remote party has closed the transport stream. So it's not about your code. It seems the server you're hitting either can't handle the load, or is intentionally dropping your requests because you're hitting it too hard."
    }
]