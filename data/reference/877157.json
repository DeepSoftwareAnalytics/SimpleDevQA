[
    {
        "link": "https://vuejs.org/api/composition-api-lifecycle",
        "document": "Registers a callback to be called after the component has been mounted.\n‚Ä¢ None\n‚Ä¢ None All of its synchronous child components have been mounted (does not include async components or components inside trees).\n‚Ä¢ None Its own DOM tree has been created and inserted into the parent container. Note it only guarantees that the component's DOM tree is in-document if the application's root container is also in-document. This hook is typically used for performing side effects that need access to the component's rendered DOM, or for limiting DOM-related code to the client in a server-rendered application. This hook is not called during server-side rendering.\n\nRegisters a callback to be called after the component has updated its DOM tree due to a reactive state change.\n‚Ä¢ None A parent component's updated hook is called after that of its child components. This hook is called after any DOM update of the component, which can be caused by different state changes, because multiple state changes can be batched into a single render cycle for performance reasons. If you need to access the updated DOM after a specific state change, use nextTick() instead. This hook is not called during server-side rendering. Do not mutate component state in the updated hook - this will likely lead to an infinite update loop!\n‚Ä¢ None // text content should be the same as current `count.value`\n\nRegisters a callback to be called after the component has been unmounted.\n‚Ä¢ None\n‚Ä¢ None All of its child components have been unmounted.\n‚Ä¢ None All of its associated reactive effects (render effect and computed / watchers created during ) have been stopped. Use this hook to clean up manually created side effects such as timers, DOM event listeners or server connections. This hook is not called during server-side rendering.\n\nRegisters a hook to be called right before the component is to be mounted.\n‚Ä¢ None When this hook is called, the component has finished setting up its reactive state, but no DOM nodes have been created yet. It is about to execute its DOM render effect for the first time. This hook is not called during server-side rendering.\n\nRegisters a hook to be called right before the component is about to update its DOM tree due to a reactive state change.\n‚Ä¢ None This hook can be used to access the DOM state before Vue updates the DOM. It is also safe to modify component state inside this hook. This hook is not called during server-side rendering.\n\nRegisters a hook to be called right before a component instance is to be unmounted.\n‚Ä¢ None When this hook is called, the component instance is still fully functional. This hook is not called during server-side rendering.\n\nRegisters a hook to be called when an error propagating from a descendant component has been captured.\n‚Ä¢ None Errors can be captured from the following sources: The hook receives three arguments: the error, the component instance that triggered the error, and an information string specifying the error source type. In production, the 3rd argument ( ) will be a shortened code instead of the full information string. You can find the code to string mapping in the Production Error Code Reference. You can modify component state in to display an error state to the user. However, it is important that the error state should not render the original content that caused the error; otherwise the component will be thrown into an infinite render loop. The hook can return to stop the error from propagating further. See error propagation details below.\n‚Ä¢ None By default, all errors are still sent to the application-level if it is defined, so that these errors can still be reported to an analytics service in a single place.\n‚Ä¢ None If multiple hooks exist on a component's inheritance chain or parent chain, all of them will be invoked on the same error, in the order of bottom to top. This is similar to the bubbling mechanism of native DOM events.\n‚Ä¢ None If the hook itself throws an error, both this error and the original captured error are sent to .\n‚Ä¢ None An hook can return to prevent the error from propagating further. This is essentially saying \"this error has been handled and should be ignored.\" It will prevent any additional hooks or from being invoked for this error.\n\nRegisters a debug hook to be called when a reactive dependency has been tracked by the component's render effect.\n\nThis hook is development-mode-only and not called during server-side rendering.\n‚Ä¢ None See also Reactivity in Depth\n\nRegisters a debug hook to be called when a reactive dependency triggers the component's render effect to be re-run.\n\nThis hook is development-mode-only and not called during server-side rendering.\n‚Ä¢ None See also Reactivity in Depth\n\nRegisters a callback to be called after the component instance is inserted into the DOM as part of a tree cached by .\n\nThis hook is not called during server-side rendering.\n‚Ä¢ None See also Guide - Lifecycle of Cached Instance\n\nRegisters a callback to be called after the component instance is removed from the DOM as part of a tree cached by .\n\nThis hook is not called during server-side rendering.\n‚Ä¢ None See also Guide - Lifecycle of Cached Instance\n\nRegisters an async function to be resolved before the component instance is to be rendered on the server.\n‚Ä¢ None If the callback returns a Promise, the server renderer will wait until the Promise is resolved before rendering the component. This hook is only called during server-side rendering can be used to perform server-only data fetching.\n‚Ä¢ None // component is rendered as part of the initial request // pre-fetch data on server as it is faster than on the client // if data is null on mount, it means the component // is dynamically rendered on the client. Perform a"
    },
    {
        "link": "https://medium.com/@hakanbudk0/exploring-the-lifecycle-hooks-in-vue-js-3-onmounted-onupdated-and-onunmounted-3c6c276de119",
        "document": "Hello everyone, I hope everyone is well. In Vue.js 3, the introduction of the Composition API brought a new way to manage component lifecycles through the onMounted(), onUpdated(), and onUnmounted() lifecycle Hooks. In this blog post, we will review these Hooks and discover how they can be used to develop your Vue.js applications.\n\nIn this blog post, we will explore the onMounted(), onUpdated(), and onUnmounted() Hooks in detail, understanding their purpose, benefits, and usage.\n‚Ä¢ In the setup() function, we declare a reactive variable called using the ref() Hook and initialize it with a value of 0.\n‚Ä¢ The onMounted() Hook is used to perform logic after the component is mounted. In this example, it logs a message to the console.\n‚Ä¢ The onUpdated() Hook is used to execute logic after the component is updated. Here, it logs a message to the console whenever the component is re-rendered due to a data change.\n‚Ä¢ The onUnmounted() Hook is used to perform cleanup operations before the component is unmounted. It logs a message to the console when the component is about to be destroyed.\n‚Ä¢ The increment() method is defined to increment the value when the button is clicked.\n\nBy utilizing these lifecycle Hooks, we can execute specific logic at different stages of the component‚Äôs lifecycle. In this example, we log messages to the console to demonstrate the execution of the onMounted(), onUpdated(), and onUnmounted() Hooks."
    },
    {
        "link": "https://stackoverflow.com/questions/74254056/how-do-i-use-the-mounted-function-in-vuejs-3-composition-api",
        "document": "\n‚Ä¢ First of all, this not a good practice to get a html element via , see how to bind events in vue3\n‚Ä¢ If you really want to in Ôºå you can use\n\nBut, just as @kissu commented, is a better way if you have to handle the html tag directly in vue\n‚Ä¢ But none of the above follow the concept of Vue, which is Vue is driven by data.\n\nSince you seem to create a click event listener which will effect the class in html, here is the Vue way:"
    },
    {
        "link": "https://vuejs.org/guide/essentials/lifecycle",
        "document": "Each Vue component instance goes through a series of initialization steps when it's created - for example, it needs to set up data observation, compile the template, mount the instance to the DOM, and update the DOM when data changes. Along the way, it also runs functions called lifecycle hooks, giving users the opportunity to add their own code at specific stages.\n\nFor example, the hook can be used to run code after the component has finished the initial rendering and created the DOM nodes:\n\nThere are also other hooks which will be called at different stages of the instance's lifecycle, with the most commonly used being , , and . , , and .\n\nAll lifecycle hooks are called with their context pointing to the current active instance invoking it. Note this means you should avoid using arrow functions when declaring lifecycle hooks, as you won't be able to access the component instance via if you do so.\n\nWhen calling , Vue automatically associates the registered callback function with the current active component instance. This requires these hooks to be registered synchronously during component setup. For example, do not do this: Do note this doesn't mean that the call must be placed lexically inside or . can be called in an external function as long as the call stack is synchronous and originates from within .\n\nBelow is a diagram for the instance lifecycle. You don't need to fully understand everything going on right now, but as you learn and build more, it will be a useful reference.\n\nConsult the Lifecycle Hooks API referenceLifecycle Hooks API reference for details on all lifecycle hooks and their respective use cases."
    },
    {
        "link": "https://stackoverflow.com/questions/75097818/how-to-access-instance-in-vue3-composition-api-lifecycle-hooks",
        "document": "I stumbled into a totally unexpected problem while refactoring my code to composition API: there doesn't seem to be any (documented) way of accessing current instance from the lifecycle hooks.\n\nI've spent hours trying to find a solution to this and ultimately just used the old options API to get what I want. None of examples, tutorials or documentation - that I read - use in the hooks.\n\nBut I find it unbelievable that only undocumented would be the way to get the current instance from the hook.\n\nSo, which doc did I miss?"
    },
    {
        "link": "https://reddit.com/r/vuejs/comments/1f81pou/transitioning_from_vue_27_to_vue_3_best_practices",
        "document": "I have a Vue 2.7 app where I've been implementing the Composition API with the Script Setup syntax. Now, I'm planning to make the big leap to Vue 3. While preparing for this transition, I came across this article that made me reconsider some of my libraries, such as switching from Vuex to Pinia.\n\nHere are a few questions I have :\n‚Ä¢ General Recommendations: Given that I'm transitioning a large app from Vue 2.7 to Vue 3, are there any other key recommendations or best practices ?\n‚Ä¢ Nuxt Consideration: My app is quite large, but I don't require SSR or SSG. However, I‚Äôm intrigued by Nuxt‚Äôs routing and middleware capabilities. Do you think it's worth incorporating Nuxt 4 into my stack ?\n‚Ä¢ UI Framework Decision: I'm currently using Vuetify 2, but I'm debating whether to upgrade to Vuetify 3 or explore other alternatives like Shadcn-vue or Radix-vue. While I've heard that the initial transition to Vuetify 3 was rocky, it seems that the framework has stabilized and become more efficient.\n\nThank you very much for your advice\n\nPs : Also https://formkit.com/fr seems really efficient"
    },
    {
        "link": "https://medium.com/simform-engineering/a-comprehensive-vue-2-to-vue-3-migration-guide-a00501bbc3f0",
        "document": "Composition API provides a flexible way to organize component logic. This makes it easier to reuse code across components with better type checking. The Composition API is easier to maintain than the Options API.\n\nWhile the Composition API was already available in Vue 2.7 through the officially maintained plugin. In Vue 3, it is primarily used in conjunction with the\n\nVue 3‚Äôs codebase is entirely written in TypeScript with auto-generated type definitions. It has better type inference and support for TypeScript‚Äôs optional chaining and null coalescing operators.\n\nVirtual DOM has been completely redesigned in Vue 3. It utilizes a new diffing algorithm with compiler-based optimizations to speed up rendering.\n\nIn Vue 3, we can create multiple roots for a single component which was not feasible in Vue 2.\n\nVue 3 Syntax: Components now can have multiple root nodes! However, this does require developers to explicitly define where attributes should be distributed.\n\nis a built-in component that allows us to \"teleport\" a part of a component's template into a DOM node that exists outside the DOM hierarchy of that component.\n\nThe target of expects a CSS selector string or an actual DOM node. The teleport the target must be already in the DOM when the component is mounted.\n\nIn Vue 3, style tags support linking CSS values to dynamic component state using the CSS function.\n\nIn Vue 3, filters are removed. Instead, we can use methods or computed properties. You can refer below example.\n‚Ä¢ BREAKING: 's modifier and component option is removed and replaced with an argument on\n‚Ä¢ NEW: Multiple bindings on the same component are possible now\n‚Ä¢ NEW: Added the ability to create custom modifiers.\n\nIn Vue 2, the attribute allowed child components to use their inner content as a template instead of distributing it.\n\nHowever, Vue 3 no longer supports this feature. If you were using in Vue 2, you can refactor the component using the default slot instead. This approach provides explicit data scoping while still allowing you to write child content inline for added convenience.\n\nIn Vue 3, named and scoped slots have different syntaxes. To identify the slot name, use the v-slot directive or its # shorthand.\n\nTechnically, Vue 2 doesn‚Äôt have a concept of an ‚Äúapp‚Äù. What we define as an app is simply a root Vue instance created via . Every root instance created from the same Vue constructor shares the same global configuration.\n\nThis global configuration poses challenges when using the same Vue instance for multiple ‚Äúapps‚Äù on the same page with different global configurations.\n\nTo avoid these problems, Vue 3 introduces a new way to create Vue app ‚Äî createApp.\n\nNEW: is no longer necessary on / / branches since Vue now automatically generates unique .\n\nBREAKING: If you manually provide , each branch must use a unique . \n\nBREAKING: should be placed on the tag (rather than on its children).\n\nIn Vue 2: When using and on the same element, would take precedence.\n\nIn Vue 3: will always have higher precedence than\n\nWe‚Äôll use one sample Vue 2 app to illustrate the migration procedure. You may clone this repository if you would like to practice with it as well.\n\nBefore installing the migration build, you need to check a few things:\n\n1. Update any deprecated named/scoped slot syntax to the latest version. Click here for the ref link.\n\n2. If you are using a custom webpack, update the vue-loader to the latest version.\n\n3. For vue-cli users, upgrade @vue/cli-service to the latest version.\n‚Ä¢ Install also known as Vue‚Äôs migration build, with the same version as the updated one\n\nThen, configure the alias to and compiler options in as shown below.\n\nAfter switching to the migration build, you‚Äôll encounter runtime warnings (in the browser console) and compiler warnings (in the command line). It‚Äôs best to address compiler warnings first, as some may break the application, such as the use of filters.\n\nThe Migration Build may not be fully compatible with Vue 3, so starting your application might not work. First, fix the deprecations.\n\nMany packages are now compatible with Vue 3. Update them to their latest versions. If you can‚Äôt find a Vue 3 compatible version for some packages, find suitable replacements.\n\nYou may be able to execute your app now, but hold off on celebrating just yet. There‚Äôs still work to be done. When you run your application, you‚Äôll encounter console warnings like the ones below.\n\nThese warnings need to be fixed.\n\nEach warning has an identifier (e.g., GLOBAL_MOUNT, OPTIONS_DATA_FN, etc.). You can find a complete list of all the different warnings here.\n\nThis step is not necessary but recommended.\n\nStep 7: Test and Assure Your App Performance and Stability\n\nThoroughly test your migrated components to ensure their functionality in the Vue 3 environment. Leverage the Vue Devtools extension to debug and inspect your application during migration.\n\nOnce testing is complete and your application runs perfectly in Vue 3, it‚Äôs time to wrap things up!\n‚Ä¢ Remove the changes we made at the beginning of the article to vue.config.js."
    },
    {
        "link": "https://v3-migration.vuejs.org",
        "document": "This guide is primarily for users with prior Vue 2 experience who want to learn about the changes between Vue 2 and Vue 3. This is not something you have to read from top to bottom before trying out Vue 3. The recommended way to learn Vue 3 is by reading the new documentation.\n\nSome of the new features to keep an eye on in Vue 3 include:\n‚Ä¢ SFC can now include global rules or rules that target only slotted content\n\n* Now also supported in Vue 2.7 \n\n ** Supported in Vue 2.7, but only for type inference\n\nBreaking changes between Vue 2 and Vue 3 are listed here.\n\nNew framework-level recommendations are listed here.\n\nIf you have an existing Vue 2 project or library that you intend to upgrade to Vue 3, we provide a build of Vue 3 that offers Vue 2 compatible APIs. Check out the Migration Build page for more details."
    },
    {
        "link": "https://reddit.com/r/vuejs/comments/1bp72k5/vue_2_to_vue_3_upgrade_is_one_of_the_most_painful",
        "document": "Sorry but I don't have much good to say about it. The migration docs are out of date. The breaking changes are monumental in a large commercial setting. There is no clear migration path aside from 'there will be a lot of errors and you need to fix them'.\n\nIt's like swimming in PVA glue trying to make the changes to the components alongside changes in the test utils api. The compat build doesn't really help in that regard.\n\nDon't even get me started on having to set attributes as true | undefined.\n\nUse Vue for your next app, if you dare..."
    },
    {
        "link": "https://dev.to/nicolasmontielf/migrate-option-api-to-composition-api-on-vue3-4o3p",
        "document": "Today I will show you how to migrate your components from the \"old\" Option API to the new Composition API on Vue 3.\n\nFirst of all, what is the composition api?\n\nGood question! The official documentation says\n\nOkay, great, but why should I use the Composition API?\n\nThe primary benefit of the Composition API is that it enables clean, efficient logic reuse in the form of composable functions. It solves all the drawbacks of mixins, the primary logic reuse mechanism for the Options API.\n\n Also, it has more adeventajes like:\n‚Ä¢ Better use with Typescript.\n\nOkay, so how are we going to do this?\n\nI prepared this Vuejs component and we will migrate it piece by piece.\n\n\n\n1. Components.\n\n With the Composition API, you don't need to declare the components you want to use, just import them and they will be available in your template.\n\n2. Props.\n\n You can define the props in much the same way as before. You need to declare a variable (usually called props) and use the defineProps method. This method is automatically available inside the tag.\n\n\n\n3. Event emitters.\n\n As with props, you need to define a constant and use a method available within the tag. This is called defineEmits.\n\n\n\n4. Data\n\n With the data, we can now see much cleaner and more readable javascript. For the data on your component, you have two cases: data with reactivity, or a simple constant.\n\nFor the data with reactivity, you need to import and put the initial value of the variable inside the method.\n\n\n\nAnd for the constant variable, as easy as javascript.\n\n\n\n5. Methods.\n\n Methods, like variables, are now just simple javascript functions, lets show some examples:\n\n\n\n6. Computed properties\n\n Okay, this is a bit more tricky, but still not complicated. To do this, we need to import the method and inside it, we put a callback that returns the value of the property.\n\n\n\n7. Watchers\n\n As in some previous cases, you need to import the method from Vue, and this takes two arguments; the first is the data you are watching (this should be reactive data, like in this case), and the second argument is a callback that is invoked when the data changes.\n\n\n\n8. Created\n\n So we don't have a specific onCreated here, we just need to create the function and initialise it inside the . Also, I leave here the list of Lifecycles of a Vue component as a reference. Remember, here the DOM doesn't exist yet.\n\n\n\n9. On Mount\n\n This is a lifecycle that exists in the API, so we need to import it from vue. Inside it takes a callback that is executed after the component is mounted. Here you already have access to the DOM.\n\n\n\nThis is the final result:\n\n\n\nMigrating from the Option API to the Composition API is not something complicated, from my own experience, after a few components, it will be an easy task for you.\n\n Now the question, should you do it? It's up to you, it's not necessary and if you prefer the Option API, you won't have any problem with it in the near future.\n\nIf you have any recommendation or some case is missing, let me know and I can add it :)\n\nThat's all, I hope it can be helpful for you ü•≥"
    }
]