[
    {
        "link": "https://docs.python.org/3/library/json.html",
        "document": "JSON (JavaScript Object Notation), specified by RFC 7159 (which obsoletes RFC 4627) and by ECMA-404, is a lightweight data interchange format inspired by JavaScript object literal syntax (although it is not a strict subset of JavaScript ).\n\nexposes an API familiar to users of the standard library and modules.\n\nUsing from the shell to validate and pretty-print:\n\nSerialize obj as a JSON formatted stream to fp (a -supporting file-like object) using this Python-to-JSON conversion table. Unlike and , JSON is not a framed protocol, so trying to serialize multiple objects with repeated calls to using the same fp will result in an invalid JSON file.\n‚Ä¢ None obj (object) ‚Äì The Python object to be serialized.\n‚Ä¢ None fp (file-like object) ‚Äì The file-like object obj will be serialized to. The module always produces objects, not objects, therefore must support input.\n‚Ä¢ None skipkeys (bool) ‚Äì If , keys that are not of a basic type ( , , , , ) will be skipped instead of raising a . Default .\n‚Ä¢ None ensure_ascii (bool) ‚Äì If (the default), the output is guaranteed to have all incoming non-ASCII characters escaped. If , these characters will be outputted as-is.\n‚Ä¢ None check_circular (bool) ‚Äì If , the circular reference check for container types is skipped and a circular reference will result in a (or worse). Default .\n‚Ä¢ None allow_nan (bool) ‚Äì If , serialization of out-of-range values ( , , ) will result in a , in strict compliance with the JSON specification. If (the default), their JavaScript equivalents ( , , ) are used.\n‚Ä¢ None cls (a subclass) ‚Äì If set, a custom JSON encoder with the method overridden, for serializing into custom datatypes. If (the default), is used.\n‚Ä¢ None indent (int | str | None) ‚Äì If a positive integer or string, JSON array elements and object members will be pretty-printed with that indent level. A positive integer indents that many spaces per level; a string (such as ) is used to indent each level. If zero, negative, or (the empty string), only newlines are inserted. If (the default), the most compact representation is used.\n‚Ä¢ None separators (tuple | None) ‚Äì A two-tuple: . If (the default), separators defaults to if indent is , and otherwise. For the most compact JSON, specify to eliminate whitespace.\n‚Ä¢ None default (callable | None) ‚Äì A function that is called for objects that can‚Äôt otherwise be serialized. It should return a JSON encodable version of the object or raise a . If (the default), is raised.\n‚Ä¢ None sort_keys (bool) ‚Äì If , dictionaries will be outputted sorted by key. Default . Changed in version 3.2: Allow strings for indent in addition to integers. Changed in version 3.4: Use as default if indent is not . Changed in version 3.6: All optional parameters are now keyword-only. Serialize obj to a JSON formatted using this conversion table. The arguments have the same meaning as in . Keys in key/value pairs of JSON are always of the type . When a dictionary is converted into JSON, all the keys of the dictionary are coerced to strings. As a result of this, if a dictionary is converted into JSON and then back into a dictionary, the dictionary may not equal the original one. That is, if x has non-string keys. Deserialize fp to a Python object using the JSON-to-Python conversion table.\n‚Ä¢ None fp (file-like object) ‚Äì A -supporting text file or binary file containing the JSON document to be deserialized.\n‚Ä¢ None cls (a subclass) ‚Äì If set, a custom JSON decoder. Additional keyword arguments to will be passed to the constructor of cls. If (the default), is used.\n‚Ä¢ None object_hook (callable | None) ‚Äì If set, a function that is called with the result of any object literal decoded (a ). The return value of this function will be used instead of the . This feature can be used to implement custom decoders, for example JSON-RPC class hinting. Default .\n‚Ä¢ None object_pairs_hook (callable | None) ‚Äì If set, a function that is called with the result of any object literal decoded with an ordered list of pairs. The return value of this function will be used instead of the . This feature can be used to implement custom decoders. If object_hook is also set, object_pairs_hook takes priority. Default .\n‚Ä¢ None parse_float (callable | None) ‚Äì If set, a function that is called with the string of every JSON float to be decoded. If (the default), it is equivalent to . This can be used to parse JSON floats into custom datatypes, for example .\n‚Ä¢ None parse_int (callable | None) ‚Äì If set, a function that is called with the string of every JSON int to be decoded. If (the default), it is equivalent to . This can be used to parse JSON integers into custom datatypes, for example .\n‚Ä¢ None parse_constant (callable | None) ‚Äì If set, a function that is called with one of the following strings: , , or . This can be used to raise an exception if invalid JSON numbers are encountered. Default .\n‚Ä¢ None JSONDecodeError ‚Äì When the data being deserialized is not a valid JSON document.\n‚Ä¢ None UnicodeDecodeError ‚Äì When the data being deserialized does not contain UTF-8, UTF-16 or UTF-32 encoded data.\n‚Ä¢ None All optional parameters are now keyword-only.\n‚Ä¢ None fp can now be a binary file. The input encoding should be UTF-8, UTF-16 or UTF-32. Changed in version 3.11: The default parse_int of now limits the maximum length of the integer string via the interpreter‚Äôs integer string conversion length limitation to help avoid denial of service attacks. Identical to , but instead of a file-like object, deserialize s (a , or instance containing a JSON document) to a Python object using this conversion table. Changed in version 3.6: s can now be of type or . The input encoding should be UTF-8, UTF-16 or UTF-32. Changed in version 3.9: The keyword argument encoding has been removed.\n\nPerforms the following translations in decoding by default: It also understands , , and as their corresponding values, which is outside the JSON spec. object_hook is an optional function that will be called with the result of every JSON object decoded and its return value will be used in place of the given . This can be used to provide custom deserializations (e.g. to support JSON-RPC class hinting). object_pairs_hook is an optional function that will be called with the result of every JSON object decoded with an ordered list of pairs. The return value of object_pairs_hook will be used instead of the . This feature can be used to implement custom decoders. If object_hook is also defined, the object_pairs_hook takes priority. parse_float is an optional function that will be called with the string of every JSON float to be decoded. By default, this is equivalent to . This can be used to use another datatype or parser for JSON floats (e.g. ). parse_int is an optional function that will be called with the string of every JSON int to be decoded. By default, this is equivalent to . This can be used to use another datatype or parser for JSON integers (e.g. ). parse_constant is an optional function that will be called with one of the following strings: , , . This can be used to raise an exception if invalid JSON numbers are encountered. If strict is false ( is the default), then control characters will be allowed inside strings. Control characters in this context are those with character codes in the 0‚Äì31 range, including (tab), , and . If the data being deserialized is not a valid JSON document, a will be raised. Changed in version 3.6: All parameters are now keyword-only. Return the Python representation of s (a instance containing a JSON document). will be raised if the given JSON document is not valid. Decode a JSON document from s (a beginning with a JSON document) and return a 2-tuple of the Python representation and the index in s where the document ended. This can be used to decode a JSON document from a string that may have extraneous data at the end. Supports the following objects and types by default: Changed in version 3.4: Added support for int- and float-derived Enum classes. To extend this to recognize other objects, subclass and implement a method with another method that returns a serializable object for if possible, otherwise it should call the superclass implementation (to raise ). If skipkeys is false (the default), a will be raised when trying to encode keys that are not , , or . If skipkeys is true, such items are simply skipped. If ensure_ascii is true (the default), the output is guaranteed to have all incoming non-ASCII characters escaped. If ensure_ascii is false, these characters will be output as-is. If check_circular is true (the default), then lists, dicts, and custom encoded objects will be checked for circular references during encoding to prevent an infinite recursion (which would cause a ). Otherwise, no such check takes place. If allow_nan is true (the default), then , , and will be encoded as such. This behavior is not JSON specification compliant, but is consistent with most JavaScript based encoders and decoders. Otherwise, it will be a to encode such floats. If sort_keys is true (default: ), then the output of dictionaries will be sorted by key; this is useful for regression tests to ensure that JSON serializations can be compared on a day-to-day basis. If indent is a non-negative integer or string, then JSON array elements and object members will be pretty-printed with that indent level. An indent level of 0, negative, or will only insert newlines. (the default) selects the most compact representation. Using a positive integer indent indents that many spaces per level. If indent is a string (such as ), that string is used to indent each level. Changed in version 3.2: Allow strings for indent in addition to integers. If specified, separators should be an tuple. The default is if indent is and otherwise. To get the most compact JSON representation, you should specify to eliminate whitespace. Changed in version 3.4: Use as default if indent is not . If specified, default should be a function that gets called for objects that can‚Äôt otherwise be serialized. It should return a JSON encodable version of the object or raise a . If not specified, is raised. Changed in version 3.6: All parameters are now keyword-only. Implement this method in a subclass such that it returns a serializable object for o, or calls the base implementation (to raise a ). For example, to support arbitrary iterators, you could implement like this: # Let the base class default method raise the TypeError Return a JSON string representation of a Python data structure, o. For example: Encode the given object, o, and yield each string representation as available. For example:\n\nThe JSON format is specified by RFC 7159 and by ECMA-404. This section details this module‚Äôs level of compliance with the RFC. For simplicity, and subclasses, and parameters other than those explicitly mentioned, are not considered. This module does not comply with the RFC in a strict fashion, implementing some extensions that are valid JavaScript but not valid JSON. In particular:\n‚Ä¢ None Infinite and NaN number values are accepted and output;\n‚Ä¢ None Repeated names within an object are accepted, and only the value of the last name-value pair is used. Since the RFC permits RFC-compliant parsers to accept input texts that are not RFC-compliant, this module‚Äôs deserializer is technically RFC-compliant under default settings. The RFC requires that JSON be represented using either UTF-8, UTF-16, or UTF-32, with UTF-8 being the recommended default for maximum interoperability. As permitted, though not required, by the RFC, this module‚Äôs serializer sets ensure_ascii=True by default, thus escaping the output so that the resulting strings only contain ASCII characters. Other than the ensure_ascii parameter, this module is defined strictly in terms of conversion between Python objects and , and thus does not otherwise directly address the issue of character encodings. The RFC prohibits adding a byte order mark (BOM) to the start of a JSON text, and this module‚Äôs serializer does not add a BOM to its output. The RFC permits, but does not require, JSON deserializers to ignore an initial BOM in their input. This module‚Äôs deserializer raises a when an initial BOM is present. The RFC does not explicitly forbid JSON strings which contain byte sequences that don‚Äôt correspond to valid Unicode characters (e.g. unpaired UTF-16 surrogates), but it does note that they may cause interoperability problems. By default, this module accepts and outputs (when present in the original ) code points for such sequences. The RFC does not permit the representation of infinite or NaN number values. Despite that, by default, this module accepts and outputs , , and as if they were valid JSON number literal values: # Neither of these calls raises an exception, but the results are not valid JSON In the serializer, the allow_nan parameter can be used to alter this behavior. In the deserializer, the parse_constant parameter can be used to alter this behavior. The RFC specifies that the names within a JSON object should be unique, but does not mandate how repeated names in JSON objects should be handled. By default, this module does not raise an exception; instead, it ignores all but the last name-value pair for a given name: The object_pairs_hook parameter can be used to alter this behavior. The old version of JSON specified by the obsolete RFC 4627 required that the top-level value of a JSON text must be either a JSON object or array (Python or ), and could not be a JSON null, boolean, number, or string value. RFC 7159 removed that restriction, and this module does not and has never implemented that restriction in either its serializer or its deserializer. Regardless, for maximum interoperability, you may wish to voluntarily adhere to the restriction yourself. Some JSON deserializer implementations may set limits on:\n‚Ä¢ None the maximum level of nesting of JSON objects and arrays\n‚Ä¢ None the range and precision of JSON numbers\n‚Ä¢ None the content and maximum length of JSON strings This module does not impose any such limits beyond those of the relevant Python datatypes themselves or the Python interpreter itself. When serializing to JSON, beware any such limitations in applications that may consume your JSON. In particular, it is common for JSON numbers to be deserialized into IEEE 754 double precision numbers and thus subject to that representation‚Äôs range and precision limitations. This is especially relevant when serializing Python values of extremely large magnitude, or when serializing instances of ‚Äúexotic‚Äù numerical types such as .\n\nThe module provides a simple command line interface to validate and pretty-print JSON objects. If the optional and arguments are not specified, and will be used respectively: Changed in version 3.5: The output is now in the same order as the input. Use the option to sort the output of dictionaries alphabetically by key. The JSON file to be validated or pretty-printed: python -m json.tool mp_films.json \"title\": \"And Now for Something Completely Different\", If infile is not specified, read from . Write the output of the infile to the given outfile. Otherwise, write it to . Sort the output of dictionaries alphabetically by key. Disable escaping of non-ascii characters, see for more information."
    },
    {
        "link": "https://realpython.com/python-json",
        "document": "Python‚Äôs module provides you with the tools you need to effectively handle JSON data. You can convert Python data types to a JSON-formatted string with or write them to files using . Similarly, you can read JSON data from files with and parse JSON strings with .\n\nJSON, or JavaScript Object Notation, is a widely-used text-based format for data interchange. Its syntax resembles Python dictionaries but with some differences, such as using only double quotes for strings and lowercase for Boolean values. With built-in tools for validating syntax and manipulating JSON files, Python makes it straightforward to work with JSON data.\n\nBy the end of this tutorial, you‚Äôll understand that:\n‚Ä¢ JSON in Python is handled using the standard-library module, which allows for data interchange between JSON and Python data types.\n‚Ä¢ JSON is a good data format to use with Python as it‚Äôs human-readable and straightforward to serialize and deserialize, which makes it ideal for use in APIs and data storage.\n‚Ä¢ You write JSON with Python using to serialize data to a file.\n‚Ä¢ You can minify and prettify JSON using Python‚Äôs module.\n\nSince its introduction, JSON has rapidly emerged as the predominant standard for the exchange of information. Whether you want to transfer data with an API or store information in a document database, it‚Äôs likely you‚Äôll encounter JSON. Fortunately, Python provides robust tools to facilitate this process and help you manage JSON data efficiently.\n\nWhile JSON is the most common format for data distribution, it‚Äôs not the only option for such tasks. Both XML and YAML serve similar purposes. If you‚Äôre interested in how the formats differ, then you can check out the tutorial on how to serialize your data with Python.\n\nThe acronym JSON stands for JavaScript Object Notation. As the name suggests, JSON originated from JavaScript. However, JSON has transcended its origins to become language-agnostic and is now recognized as the standard for data interchange. The popularity of JSON can be attributed to native support by the JavaScript language, resulting in excellent parsing performance in web browsers. On top of that, JSON‚Äôs straightforward syntax allows both humans and computers to read and write JSON data effortlessly. To get a first impression of JSON, have a look at this example code: You‚Äôll learn more about the JSON syntax later in this tutorial. For now, recognize that the JSON format is text-based. In other words, you can create JSON files using the code editor of your choice. Once you set the file extension to , most code editors display your JSON data with syntax highlighting out of the box: The screenshot above shows how VS Code displays JSON data using the Bearded color theme. You‚Äôll have a closer look at the syntax of the JSON format next! In the previous section, you got a first impression of how JSON data looks. And as a Python developer, the JSON structure probably reminds you of common Python data structures, like a dictionary that contains a string as a key and a value. If you understand the syntax of a dictionary in Python, you already know the general syntax of a JSON object. Note: Later in this tutorial, you‚Äôll learn that you‚Äôre free to use lists and other data types at the top level of a JSON document. The similarity between Python dictionaries and JSON objects is no surprise. One idea behind establishing JSON as the go-to data interchange format was to make working with JSON as convenient as possible, independently of which programming language you use: [A collection of key-value pairs and arrays] are universal data structures. Virtually all modern programming languages support them in one form or another. It makes sense that a data format that is interchangeable with programming languages is also based on these structures. (Source) To explore the JSON syntax further, create a new file named and add a more complex JSON structure as the content of the file: In the code above, you see data about a dog named Frieda, which is formatted as JSON. The top-level value is a JSON object. Just like Python dictionaries, you wrap JSON objects inside curly braces ( ). In line 1, you start the JSON object with an opening curly brace ( ), and then you close the object at the end of line 20 with a closing curly brace ( ). Note: Although whitespace doesn‚Äôt matter in JSON, it‚Äôs customary for JSON documents to be formatted with two or four spaces to indicate indentation. If the file size of the JSON document is important, then you may consider minifying the JSON file by removing the whitespace. You‚Äôll learn more about minifying JSON data later in the tutorial. Inside the JSON object, you can define zero, one, or more key-value pairs. If you add multiple key-value pairs, then you must separate them with a comma ( ). A key-value pair in a JSON object is separated by a colon ( ). On the left side of the colon, you define a key. A key is a string you must wrap in double quotes ( ). Unlike Python, JSON strings don‚Äôt support single quotes ( ). The values in a JSON document are limited to the following data types: Either or without quotes Just like in dictionaries and lists, you‚Äôre able to nest data in JSON objects and arrays. For example, you can include an object as the value of an object. Also, you‚Äôre free to use any other allowed value as an item in a JSON array. As a Python developer, you may need to pay extra attention to the Boolean values. Instead of using or in title case, you must use the lowercase JavaScript-style Booleans or . Unfortunately, there are some other details in the JSON syntax that you may stumble over as a developer. You‚Äôll have a look at them next. The JSON standard doesn‚Äôt allow any comments, trailing commas, or single quotes for strings. This can be confusing to developers who are used to Python dictionaries or JavaScript objects. Here‚Äôs a smaller version of the JSON file from before with invalid syntax:\n‚Ä¢ Line 5 has a trailing comma after the final key-value pair.\n‚Ä¢ Line 10 contains a trailing comma in the array. Using double quotes is something you can get used to as a Python developer. Comments can be helpful in explaining your code, and trailing commas can make moving lines around in your code less fragile. This is why some developers like to use Human JSON (Hjson) or JSON with comments (JSONC). Hjson gives you the freedom to use comments, ditch commas between properties, or create quoteless strings. Apart from the curly braces ( ), the Hjson syntax look like a mix of YAML and JSON. JSONC is a bit stricter than Hjson. Compared to regular JSON, JSONC allows you to use comments and trailing commas. You may have encountered JSONC when editing the file of VS Code. Inside its configuration files, VS Code works in a JSONC mode. For common JSON files, VS Code is more strict and points out JSON syntax errors. If you want to make sure you write valid JSON, then your coding editor can be of great help. The invalid JSON document above contains marks for each occurrence of incorrect JSON syntax: When you don‚Äôt want to rely on your code editor, you can also use online tools to verify that the JSON syntax you write is correct. Popular online tools for validating JSON are JSON Lint and JSON Formatter. Later in the tutorial, you‚Äôll learn how to validate JSON documents from the comfort of your terminal. But before that, it‚Äôs time to find out how you can work with JSON data in Python.\n\nPython supports the JSON format through the built-in module named . The module is specifically designed for reading and writing strings formatted as JSON. That means you can conveniently convert Python data types into JSON data and the other way around. The act of converting data into the JSON format is referred to as serialization. This process involves transforming data into a series of bytes for storage or transmission over a network. The opposite process, deserialization, involves decoding data from the JSON format back into a usable form within Python. You‚Äôll start with the serialization of Python code into JSON data with the help of the module. One of the most common actions when working with JSON in Python is to convert a Python dictionary into a JSON object. To get an impression of how this works, hop over to your Python REPL and follow along with the code below: After importing the module, you can use to convert a Python dictionary to a JSON-formatted string, which represents a JSON object. It‚Äôs important to understand that when you use , you get a Python string in return. In other words, you don‚Äôt create any kind of JSON data type. The result is similar to what you‚Äôd get if you used Python‚Äôs built-in function: Using gets more interesting when your Python dictionary doesn‚Äôt contain strings as keys or when values don‚Äôt directly translate to a JSON format: In the dictionary, the keys , , and are numbers. Once you use , the dictionary keys become strings in the JSON-formatted string. Note: When you convert a dictionary to JSON, the dictionary keys will always be strings in JSON. The Boolean Python values of your dictionary become JSON Booleans. As mentioned before, the tiny but significant difference between JSON Booleans and Python Booleans is that JSON Booleans are lowercase. The cool thing about Python‚Äôs module is that it takes care of the conversion for you. This can come in handy when you‚Äôre using variables as dictionary keys: When converting Python data types into JSON, the module receives the evaluated values. While doing so, sticks tightly to the JSON standard. For example, when converting integer keys like to the string . The module allows you to convert common Python data types to JSON. Here‚Äôs an overview of all Python data types and values that you can convert to JSON values: Note that different Python data types like lists and tuples serialize to the same JSON data type. This can cause problems when you convert JSON data back to Python, as the data type may not be the same as before. You‚Äôll explore this pitfall later in this tutorial when you learn how to read JSON. Dictionaries are probably the most common Python data type that you‚Äôll use as a top-level value in JSON. But you can convert the data types listed above just as smoothly as dictionaries using . Take a Boolean or a list, for example: A JSON document may contain a single scalar value, like a number, at the top level. That‚Äôs still valid JSON. But more often than not, you want to work with a collection of key-value pairs. Similar to how not every data type can be used as a dictionary key in Python, not all keys can be converted into JSON key strings: You can‚Äôt use dictionaries, lists, or tuples as JSON keys. For dictionaries and lists, this rule makes sense as they‚Äôre not hashable. But even when a tuple is hashable and allowed as a key in a dictionary, you‚Äôll get a when you try to use a tuple as a JSON key: : keys must be str, int, float, bool or None, not tuple By providing the argument, you can prevent getting a when creating JSON data with unsupported Python keys: When you set in to , then Python skips the keys that are not supported and would otherwise raise a . The result is a JSON-formatted string that only contains a subset of the input dictionary. In practice, you usually want your JSON data to resemble the input object as close as possible. So, you must use with caution to not lose information when calling . Note: If you‚Äôre ever in a situation where you need to convert an unsupported object into JSON, then you can consider creating a subclass of the and implementing a method. When you use , you can use additional arguments to control the look of the resulting JSON-formatted string. For example, you can sort the dictionary keys by setting the parameter to : When you set to , then Python sorts the keys alphabetically for you when serializing a dictionary. Sorting the keys of a JSON object can come in handy when your dictionary keys formerly represented the column names of a database, and you want to display them in an organized fashion to the user. Another notable parameter of is , which you‚Äôll probably use the most when serializing JSON data. You‚Äôll explore later in this tutorial in the prettify JSON section. When you convert Python data types into the JSON format, you usually have a goal in mind. Most commonly, you‚Äôll use JSON to persist and exchange data. To do so, you need to save your JSON data outside of your running Python program. Conveniently, you‚Äôll explore saving JSON data to a file next. The JSON format can come in handy when you want to save data outside of your Python program. Instead of spinning up a database, you may decide to use a JSON file to store data for your workflows. Again, Python has got you covered. To write Python data into an external JSON file, you use . This is a similar function to the one you saw earlier, but without the s at the end of its name: In lines 3 to 22, you define a dictionary that you write to a JSON file in line 25 using a context manager. To properly indicate that the file contains JSON data, you set the file extension to . When you use , then it‚Äôs good practice to define the encoding. For JSON, you commonly want to use as the encoding when reading and writing files: The RFC requires that JSON be represented using either UTF-8, UTF-16, or UTF-32, with UTF-8 being the recommended default for maximum interoperability. (Source) The function has two required arguments:\n‚Ä¢ The object you want to write\n‚Ä¢ The file you want to write into Other than that, there are a bunch of optional parameters for . The optional parameters of are the same as for . You‚Äôll investigate some of them later in this tutorial when you prettify and minify JSON files.\n\nIn the former sections, you learned how to serialize Python data into JSON-formatted strings and JSON files. Now, you‚Äôll see what happens when you load JSON data back into your Python program. In parallel to and , the library provides two functions to deserialize JSON data into a Python object: As a rule of thumb, you work with when your data is already present in your Python program. You use with external files that are saved on your disk. The conversion from JSON data types and values to Python follows a similar mapping as before when you converted Python objects into the JSON format: When you compare this table to the one in the previous section, you may recognize that Python offers a matching data type for all JSON types. That‚Äôs very convenient because this way, you can be sure you won‚Äôt lose any information when deserializing JSON data to Python. Note: Deserialization is not the exact reverse of the serialization process. The reason for this is that JSON keys are always strings, and not all Python data types can be converted to JSON data types. This discrepancy means that certain Python objects may not retain their original type when serialized and then deserialized. To get a better feeling for the conversion of data types, you‚Äôll start with serializing a Python object to JSON and then convert the JSON data back to Python. That way, you can spot differences between the Python object you serialize and the Python object you end up with after deserializing the JSON data. To investigate how to load a Python dictionary from a JSON object, revisit the example from before. Start by creating a dictionary and then serialize the Python dictionary to a JSON string using : By passing into , you‚Äôre creating a string with a JSON object that you save in . If you want to convert back to a Python dictionary, then you can use : By using , you can convert JSON data back into Python objects. With the knowledge about JSON that you‚Äôve gained so far, you may already suspect that the content of the dictionary is not identical to the content of : The difference between and is subtle but can be impactful in your Python programs. In JSON, the keys must always be strings. When you converted to using , the integer key became the string . When you used , there was no way for Python to know that the string key should be an integer again. That‚Äôs why your dictionary key remained a string after deserialization. You‚Äôll investigate a similar behavior by doing another conversion roundtrip with other Python data types! To explore how different data types behave in a roundtrip from Python to JSON and back, take a portion of the dictionary from a former section. Note how the dictionary contains different data types as values: The dictionary contains a bunch of common Python data types as values. For example, a string in line 2, a Boolean in line 3, a in line 7, and a tuple in line 8, just to name a few. Next, convert to a JSON-formatted string and back to Python again. Afterward, have a look at the newly created dictionary: You can convert every JSON data type perfectly into a matching Python data type. The JSON Boolean deserializes into , converts back into , and objects and arrays become dictionaries and lists. Still, there‚Äôs one exception that you may encounter in roundtrips: When you serialize a Python tuple, it becomes a JSON array. When you load JSON, a JSON array correctly deserializes into a list because Python has no way of knowing that you want the array to be a tuple. Problems like the one described above can always be an issue when you‚Äôre doing data roundtrips. When the roundtrip happens in the same program, you may be more aware of the expected data types. Data type conversions may be even more obfuscated when you‚Äôre dealing with external JSON files that originated in another program. You‚Äôll investigate a situation like this next! In a previous section, you created a file that saved a file. If you need to refresh your memory, you can expand the collapsible section below that shows the code again: Take a look at the data types of the dictionary. Is there a data type in a value that the JSON format doesn‚Äôt support? When you want to write content to a JSON file, you use . The counterpart to is . As the name suggests, you can use to load a JSON file into your Python program. Jump back into the Python REPL and load the JSON file from before: Just like when writing files, it‚Äôs a good idea to use a context manager when reading a file in Python. That way, you don‚Äôt need to bother with closing the file again. When you want to read a JSON file, then you use inside the statement‚Äôs block. The argument for the function must be either a text file or a binary file. The Python object that you get from depends on the top-level data type of your JSON file. In this case, the JSON file contains an object at the top level, which deserializes into a dictionary. When you deserialize a JSON file as a Python object, then you can interact with it natively‚Äîfor example, by accessing the value of the key with square bracket notation ( ). Still, there‚Äôs a word of caution here. Import the original dictionary from before and compare it to : When you load a JSON file as a Python object, then any JSON data type happily deserializes into Python. That‚Äôs because Python knows about all data types that the JSON format supports. Unfortunately, it‚Äôs not the same the other way around. As you learned before, there are Python data types like that you can convert into JSON, but you‚Äôll end up with an data type in the JSON file. Once you convert the JSON data back to Python, then an array deserializes into the Python data type. Generally, being cautious about data type conversions should be the concern of the Python program that writes the JSON. With the knowledge you have about JSON files, you can always anticipate which Python data types you‚Äôll end up with as long as the JSON file is valid. If you use , then the content of the file you load must contain valid JSON syntax. Otherwise, you‚Äôll receive a . Luckily, Python caters to you with more tools you can use to interact with JSON. For example, it allows you to check a JSON file‚Äôs validity from the convenience of the terminal.\n\nSo far, you‚Äôve explored the JSON syntax and have already spotted some common JSON pitfalls like trailing commas and single quotes for strings. When writing JSON, you may have also spotted some annoying details. For example, neatly indented Python dictionaries end up being a blob of JSON data. In the last section of this tutorial, you‚Äôll try out some techniques to make your life easier as you work with JSON data in Python. To start, you‚Äôll give your JSON object a well-deserved glow-up. One huge advantage of the JSON format is that JSON data is human-readable. Even more so, JSON data is human-writable. This means you can open a JSON file in your favorite text editor and change the content to your liking. Well, that‚Äôs the idea, at least! Editing JSON data by hand is not particularly easy when your JSON data looks like this in the text editor: Even with word wrapping and syntax highlighting turned on, JSON data is hard to read when it‚Äôs a single line of code. And as a Python developer, you probably miss some whitespace. But worry not, Python has got you covered! When you call or to serialize a Python object, then you can provide the argument. Start by trying out with different indentation levels: The default value for is . When you call without or with as a value, you‚Äôll end up with one line of a compact JSON-formatted string. If you want linebreaks in your JSON string, then you can set to or provide an empty string. Although probably less useful, you can even provide a negative number as the indentation or any other string. More commonly, you‚Äôll provide values like or for : When you use positive integers as the value for when calling , then you‚Äôll indent every level of the JSON object with the given count as spaces. Also, you‚Äôll have newlines for each key-value pair. Note: To actually see the whitespace in the REPL, you can wrap the calls in function calls. The parameter works exactly the same for as it does for . Go ahead and write the dictionary into a JSON file with an indentation of spaces: When you set the indentation level when serializing JSON data, then you end up with prettified JSON data. Have a look at how the file looks in your editor: Python can work with JSON files no matter how they‚Äôre indented. As a human, you probably prefer a JSON file that contains newlines and is neatly indented. A JSON file that looks like this is way more convenient to edit. The convenience of being able to edit JSON data in the editor comes with a risk. When you move key-value pairs around or add strings with one quote instead of two, you end up with an invalid JSON. To swiftly check if a JSON file is valid, you can leverage Python‚Äôs . You can run the module as an executable in the terminal using the switch. To see in action, also provide as the positional argument: When you run only with an option, then Python validates the JSON file and outputs the JSON file‚Äôs content in the terminal if the JSON is valid. Running in the example above means that contains valid JSON syntax. Note: The prints the JSON data with an indentation of 4 by default. You‚Äôll explore this behavior in the next section. To make complain, you need to invalidate your JSON document. You can make the JSON data of invalid by removing the comma ( ) between the key-value pairs: After saving , run again to validate the file: The module successfully stumbles over the missing comma in . Python notices that there‚Äôs a delimiter missing once the property name enclosed in double quotes starts in line 3 at position 5. Go ahead and try fixing the JSON file again. You can also be creative with invalidating and check how reports your error. But keep in mind that only reports the first error. So you may need to go back and forth between fixing a JSON file and running . Once is valid, you may notice that the output always looks the same. Of course, like any well-made command-line interface, offers you some options to control the program. In the previous section, you used to validate a JSON file. When the JSON syntax was valid, showed the content with newlines and an indentation of four spaces. To control how prints the JSON, you can set the option. If you followed along with the tutorial, then you‚Äôve got a file that doesn‚Äôt contain newlines or indentation. Alternatively, you can download in the materials by clicking the link below: Free Bonus: Click here to download the free sample code that shows you how to work with JSON data in Python. When you pass in to , then you can pretty print the content of the JSON file in your terminal. When you set , then you can control which indentation level uses to display the code: Seeing the prettified JSON data in the terminal is nifty. But you can step up your game even more by providing another option to the run! By default, writes the output to , just like you commonly do when calling the function. But you can also redirect the output of into a file by providing a positional argument: With as the value of the option, you write the output into the JSON file instead of showing the content in the terminal. If the file doesn‚Äôt exist yet, then Python creates the file on the way. If the target file already exists, then you overwrite the file with the new content. Note: You can prettify a JSON file in place by using the same file as and arguments. You can verify that the file exists by running the terminal command: The whitespace you added to comes with a price. Compared to the original, unindented file, the file size of is now around double that. Here, the 308-byte increase may not be significant. But when you‚Äôre dealing with big JSON data, then a good-looking JSON file will take up quite a bit of space. Having a small data footprint is especially useful when serving data over the web. Since the JSON format is the de facto standard for exchanging data over the web, it‚Äôs worth keeping the file size as small as possible. And again, Python‚Äôs has got your back! As you know by now, Python is a great helper when working with JSON. You can minify JSON data with Python in two ways:\n‚Ä¢ Use the module in your Python code Before, you used with the option to add whitespace. Instead of using here, you can use provide to do the opposite and remove any whitespace between the key-value pairs of your JSON: After calling the module, you provide a JSON file as the and another JSON file as the . If the target JSON file exists, then you overwrite its contents. Otherwise, you create a new file with the filename you provide. Just like with , you provide the same file as a source and target file to minify the file in-place. In the example above, you minify into . Run the command to see how many bytes you squeezed out of the original JSON file: Compared to , the file size of is 337 bytes smaller. That‚Äôs even 29 bytes less than the original file that didn‚Äôt contain any indentation. To investigate where Python managed to remove even more whitespace from the original JSON, open the Python REPL again and minify the content of the original file with Python‚Äôs module: In the code above, you use Python‚Äôs to get the content of as text. Then, you use to deserialize to , which is a Python dictionary. You could use to get a Python dictionary right away, but you need the JSON data as a string first to compare it properly. That‚Äôs also why you use to create and then use instead of leveraging directly to save the minified JSON data in . As you learned before, needs JSON data as the first argument and then accepts a value for the indentation. The default value for is , so you could skip setting the argument explicitly like you do above. But with , you‚Äôre making your intention clear that you don‚Äôt want any indentation, which will be a good thing for others who read your code later. The parameter for allows you to define a tuple with two values:\n‚Ä¢ The separator between the key-value pairs or list items. By default, this separator is a comma followed by a space ( ).\n‚Ä¢ The separator between the key and the value. By default, this separator is a colon followed by a space ( ). By setting to , you continue to use valid JSON separators. But you tell Python not to add any spaces after the comma ( ) and the colon ( ). That means that the only whitespace left in your JSON data can be whitespace appearing in key names and values. That‚Äôs pretty tight! With both and containing your JSON strings, it‚Äôs time to compare them: You can already spot the difference between and when you look at the output. You then use the function to verify that the size of is indeed smaller. If you‚Äôre curious about why the length of the JSON strings almost exactly matches the file size of the written files, then looking into Unicode & character encodings in Python is a great idea. Both and are excellent helpers when you want to make JSON data look prettier, or if you want to minify JSON data to save some bytes. With the module, you can conveniently interact with JSON data in your Python programs. That‚Äôs great when you need to have more control over the way you interact with JSON. The module comes in handy when you want to work with JSON data directly in your terminal."
    },
    {
        "link": "https://hackernoon.com/how-to-read-and-write-json-files-in-python",
        "document": "Using Python to Read, Write, and Manipulate JSON Files\n\nJSON (JavaScript Object Notation) is a popular data interchange format that is easy for humans to read and write. JSON often comes into play when interacting with web APIs or HTTP requests within the field of programming. Python provides built-in support for working with JSON files through the module. In this article, we will discuss how to use Python to read, write, and manipulate JSON files.\n\nTo read a JSON file in Python, you can follow these steps:\n‚Ä¢ Open the JSON file using Python's function with the mode set to .\n‚Ä¢ Use the function to load the contents of the file as a Python dictionary.\n\nHere is an example code snippet that demonstrates how to read a JSON file:\n\nTo write data to a JSON file in Python, you can use the module as well. Here are the steps to write data to a JSON file:\n‚Ä¢ Define the data that you want to write as a Python dictionary.\n‚Ä¢ Use the function to write the dictionary data to the file in JSON format.\n\nHere is an example code snippet that demonstrates how to write data to a JSON file:\n\nYou can read the file, modify the data dictionary by adding a new key-value pair, and then save it as another JSON file. Here's an example code snippet to achieve that:\n‚Ä¢ We first read the data from the file.\n‚Ä¢ We then modify the dictionary by adding a new key-value pair.\n‚Ä¢ The modified data is then written to a new JSON file named .\n‚Ä¢ Finally, we read the modified data from and print it.\n\nIn conclusion, Python's module makes it simple to work with JSON files. You can read, write, and manipulate JSON data using Python's built-in functions, making it a powerful tool for handling JSON data in your Python projects.\n\nThank you for taking the time to explore data-related insights with me. I appreciate your engagement. If you find this information helpful, I invite you to follow me or connect with me on LinkedIn or X(@Luca_DataTeam). You can also catch glimpses of my personal life on Instagram, Happy exploring!üëã"
    },
    {
        "link": "https://stackoverflow.com/questions/12309269/how-do-i-write-json-data-to-a-file",
        "document": "TypeError: must be string or buffer, not dict\n\nHow do I write JSON data stored in the dictionary data to a file?\n\nis a Python dictionary. It needs to be encoded as JSON before writing. Use this for maximum compatibility (Python 2 and 3): On a modern system (i.e. Python 3 and UTF-8 support), you can write a nicer file using:\n\nTo get utf8-encoded file as opposed to ascii-encoded in the accepted answer for Python 2 use: The code is simpler in Python 3: On Windows, the argument to is still necessary. To avoid storing an encoded copy of the data in memory (result of ) and to output utf8-encoded bytestrings in both Python 2 and 3, use: The call is redundant in Python 3 but required for Python 2 The use of gives better readability and smaller size: Further improve readability by adding flags (as suggested by dinos66) to arguments of or . This way you'll get a nicely indented sorted structure in the json file at the cost of a slightly larger file size.\n\nI don't have enough reputation to add in comments, so I just write some of my findings of this annoying TypeError here: Basically, I think it's a bug in the function in Python 2 only - It can't dump a Python (dictionary / list) data containing non-ASCII characters, even you open the file with the parameter. (i.e. No matter what you do). But, works on both Python 2 and 3. To illustrate this, following up phihag's answer: the code in his answer breaks in Python 2 with exception TypeError: must be unicode, not str , if contains non-ASCII characters. (Python 2.7.6, Debian): It however works fine in Python 3.\n\nFor people liking oneliners (hence statement is not an option), a cleaner method than leaving a dangling opened file descriptor behind can be to use from and do something like below: This can be handy in some cases in contexts where statements are not allowed like: I'm not claiming it should be preferred to (and it's likely slower), just another option.\n\nBefore write a dictionary into a file as a json, you have to turn that dict onto json string using library. And also you can add indent to json data to look prettier. If you want to sort keys before turning into json, You can use the combination of these two also. Refer the json documentation here for much more features Finally you can write into a json file\n\nIf you like prettified (indented) and keys sorted json with optional encoding: In case you're working on the written file, make sure to either flush or close so that all data caches are written to the disk: fp2.flush() # you may still keep working on the file after this fp2.close() # guaranteed data written to the disk Below example json loading is if you don't already have the json loaded as a dictionary. j1 = json.loads(\"\"\" { \"glossary\": { \"title\": \"example glossary\", \"GlossDiv\": { \"title\": \"S\", \"GlossList\": { \"GlossEntry\": { \"ID\": \"SGML\", \"SortAs\": \"SGML\", \"GlossTerm\": \"Standard Generalized Markup Language\", \"Acronym\": \"SGML\", \"Abbrev\": \"ISO 8879:1986\", \"GlossDef\": { \"para\": \"A meta-markup language, used to create markup languages such as DocBook.\", \"GlossSeeAlso\": [\"GML\", \"XML\"] }, \"GlossSee\": \"markup\" } } } } } \"\"\")\n\nThis is just an extra hint at the usage of (this is not an answer to the problem of the question, but a trick for those who have to dump numpy data types): If there are NumPy data types in the dictionary, needs an additional parameter, credits go to TypeError: Object of type 'ndarray' is not JSON serializable, and it will also fix errors like TypeError: Object of type int64 is not JSON serializable and so on: You may also want to return a string instead of a list in case of a np.array() since arrays are printed as lists that are spread over rows which will blow up the output if you have large or many arrays. The caveat: it is more difficult to access the items from the dumped dictionary later to get them back as the original array. Yet, if you do not mind having just a string of an array, this makes the dictionary more readable. Then exchange:"
    },
    {
        "link": "https://w3schools.com/python/python_json.asp",
        "document": "JSON is a syntax for storing and exchanging data.\n\nPython has a built-in package called , which can be used to work with JSON data.\n\nIf you have a JSON string, you can parse it by using the method.\n\nIf you have a Python object, you can convert it into a JSON string by using the method.\n\nYou can convert Python objects of the following types, into JSON strings:\n\nWhen you convert from Python to JSON, Python objects are converted into the JSON (JavaScript) equivalent:\n\nThe example above prints a JSON string, but it is not very easy to read, with no indentations and line breaks.\n\nThe method has parameters to make it easier to read the result:\n\nYou can also define the separators, default value is (\", \", \": \"), which means using a comma and a space to separate each object, and a colon and a space to separate keys from values:\n\nThe method has parameters to order the keys in the result:\n\nUse the parameter to specify if the result should be sorted or not: Try it Yourself ¬ª"
    },
    {
        "link": "https://medium.com/@james.m.dey/how-to-write-a-simple-chatbot-16229e47654d",
        "document": "With all of the publicity surrounding chatGPT and it‚Äôs ability to respond to almost any prompt that you can throw at it with a fairly accurate response, I figured that I‚Äôd like to have a go myself.\n\nThen I remembered that I don‚Äôt have a multi-million dollar budget\n\nLast week, I heard that OpenAI had produced a GPT builder which allows you to create your own chatbot which has API access to a very advanced large language model that chatGPT uses. However as that costs $20pcm and I don‚Äôt like spending money for no return, I crossed that off my list as well.\n\nHowever, it did inspire me to work out how I might produce a simple chatbot that would help me with my work as a senior data architect.\n\nIn data architecture, we create conceptual data models that represent business concepts and then eventually get down in to the weeds and produce physical data models which can then generate databases which then store the data that is used by front end applications or reporting tools.\n\nAs part of this process, we create data dictionaries which typically end up in a rather large spreadsheet.\n\nSearching for information in a data dictionary can get quite difficult, so how about if I could create a chatbot that would make life easier. As it‚Äôs a narrow focus, I don‚Äôt have to handle a huge variety of potential questions so can take the old fashioned approach of generating a set of rules that can be applied to a query prompt to identify what the user is asking and then create a subsequent action.\n\nI‚Äôll call my chatbot, chatERD as a data model diagram is more formally known as an entity relationship diagram (ERD).\n\nOk, so it‚Äôs fairly trivial to create a JSON file of a data dictionary from an Excel spreadsheet, so I won‚Äôt bother to explain this bit in detail, you can read in an Excel file into pandas and push out a JSON file. I created a simple JSON data dictionary as a test and called it data.json. Here we have customers, sales and orders, with a column or 2 in each.\n\nSo on the left hand side, I‚Äôve created a list of potential sections of a prompt that a user might enter and on the right handside I‚Äôve created a lambda function that does something with it.\n\nSo as an example, if a customer asks ‚Äúhow many entities are there in the model‚Äù or ‚Äúhow many different entities are there?‚Äù or ‚Äúgive me a count of entities‚Äù etc. then it will execute the lamda function that simply counts the number of top level entries in the data.json file which happens to relate to each entity. You can clearly expand this list of potential sections of a prompt as and when you find somebody creating a prompt query that isn‚Äôt captured by these rules. As it‚Äôs a narrow focus, this isn‚Äôt hard to do.\n\nStep 3 ‚Äî Write a function that will process the prompt query\n\nQuery:Tell me how many entities I have in the model\n\nResponse: 3\n\nQuery:Find me column names that contain the word ‚Äúid‚Äù\n\nResponse: [‚Äòcustomers.customer_id‚Äô, ‚Äòsales.sales_id‚Äô, ‚Äòsales.customer_id‚Äô, ‚Äòsales.order_id‚Äô, ‚Äòorders.order_id‚Äô]\n\nQuery:Give me the description for sales_id\n\nResponse: Unique identifier for a sale"
    },
    {
        "link": "https://stackoverflow.com/questions/70829175/json-with-python-chatbot",
        "document": "I have a crappy machine learning chatbot that I trained using some JSON data. For some of the different things you could ask the bot have a list of appropriate responses for the request. The issue I'm having is figuring out what to do for the ones that don't. For those one's I have python functions for those that I would like to run in response to a certain command given. Are there anyways that it could be done because I know that in JSON you can't pass functions.\n\nExample of one python functions\n\nAlso here is the complete code for the machine learning aspect of things"
    },
    {
        "link": "https://analyticsvidhya.com/blog/2021/07/build-a-simple-chatbot-using-python-and-nltk",
        "document": "In today‚Äôs digital age, where communication is increasingly driven by artificial intelligence (AI) technologies, building your own chatbot has never been more accessible. With the rise of platforms like ChatGPT from OpenAI and powerful libraries such as NLTK (Natural Language Toolkit) in Python, creating a basic Python chatbot has become a straightforward endeavor for aspiring data scientists and developers.\n\nIn this article, we‚Äôll embark on a journey to understand the fundamentals of NLTK chatbot development, exploring the synergy between AI, natural language processing (NLP), and the versatility of NLTK, all while taking our first steps into the exciting world of conversational AI. Let‚Äôs bring your conversational AI dreams to life with, one line of code at a time! Also, We will Discuss how does Chatbot Works and how to write a python code to implement Chatbot.\n‚Ä¢ Understand what chatbots are and why we need them.\n‚Ä¢ Learn about the different types of AI chatbots.\n‚Ä¢ Learn how to build your own rule-based chatbot and self-learning chatbot using the Python NLTK library.\n\nThis article was published as a part of the Data Science Blogathon\n\nChatbots are AI-powered software applications designed to simulate human-like conversations with users through text or speech interfaces. They leverage natural language processing (NLP) and machine learning algorithms to understand and respond to user queries or commands in a conversational manner.\n\nChatbots can be deployed across various platforms, including websites, messaging apps, and virtual assistants, to provide a wide range of services such as customer support, information retrieval, task automation, and entertainment. They play a crucial role in improving efficiency, enhancing user experience, and scaling customer service operations for businesses across different industries.\n\nWhy Do We Need Chatbots?\n‚Ä¢ Enhanced Customer Service: Chatbots provide instant responses to customer queries, ensuring round-the-clock support without the need for human intervention. This results in faster resolution times and improved customer satisfaction.\n‚Ä¢ Scalability: With chatbots, businesses can handle multiple customer interactions simultaneously, scaling their support operations to accommodate growing demand without significantly increasing costs.\n‚Ä¢ Cost Efficiency: Implementing chatbots reduces the need for hiring and training additional customer service representatives, resulting in cost savings for businesses over time.\n‚Ä¢ 24/7 Availability: Chatbots operate continuously, offering support to users regardless of the time of day or geographical location. This ensures that customers can receive assistance whenever they need it, leading to higher engagement and retention rates.\n‚Ä¢ Data Collection and Analysis: Chatbots can gather valuable customer data during interactions, such as preferences, frequently asked questions, and pain points. This data can be analyzed to identify trends, improve products or services, and tailor marketing strategies, driving business growth and innovation.\n\nThere are mainly 2 types of AI chatbots.\n\n1) Rule-based Chatbots: As the name suggests, there are certain rules by which chatbot operates. Like a machine learning model, we train the chatbots on user intents and relevant responses, and based on these intents chatbot identifies the new user‚Äôs intent and response to him.\n\n2) Self-learning chatbots: Self-learning bots are highly efficient because they are capable to grab and identify the user‚Äôs intent on their own. they are built using advanced tools and techniques of machine learning, deep learning, and NLP.\n\nSelf-learning bots are further divided into 2 subcategories.\n‚Ä¢ Retrieval-based chatbots: Retrieval-based is somewhat the same as rule-based where predefined input patterns and responses are embedded.\n‚Ä¢ Generative-based chatbots: It is based on the same phenomenon as Machine Translation built using sequence 2 sequences neural network.\n\nMost organizations use self-learning chatbots along with embedding some rules like the hybrid version of both methods which makes chatbots powerful enough to handle each situation during a conversation with a customer.\n\nChatbots are computer programs that simulate conversation with humans. They‚Äôre used in a variety of applications, from providing customer service to answering questions on a website.\n‚Ä¢ User Input: The user starts a conversation with the chatbot by typing in a message or speaking to it through a voice interface.\n‚Ä¢ Understanding the User: The chatbot analyzes the user‚Äôs input using NLP. For rule-based chatbots, this involves matching keywords and phrases. For AI-powered chatbots, it‚Äôs more complex and involves understanding the intent behind the user‚Äôs words.\n‚Ä¢ Generating a Response: Based on its understanding of the user‚Äôs input, the chatbot retrieves a response from its database. This response could be a simple answer, a more complex explanation, or even a question to clarify the user‚Äôs intent.\n‚Ä¢ Conversation Flow: The chatbot delivers the response to the user, and the conversation continues. The user can provide additional information or ask follow-up questions, and the chatbot will respond accordingly.\n\nNow we have an immense understanding of the theory of chatbots and their advancement in the future. Let‚Äôs make our hands dirty by building one simple rule-based chatbot using Python for ourselves.\n\nWe will design a simple GUI using the Python Tkinter module using which we will create a text box and button to submit user intent and on the action, we will build a function where we will match the user intent and respond to him on his intent. If you do not have the Tkinter module installed, then first install it using the pip command.\n\nExplanation ‚Äì First we created a blank window, After that, we created a text field using the entry method and a Button widget which on triggering calls the function send, and in return, it gets the chatbot response. We have used a basic If-else control statement to build a simple rule-based chatbot. And you can interact with the chatbot by running the application from the interface and you can see the output as below figure.\n\nNLTK stands for Natural language toolkit used to deal with NLP applications and chatbot is one among them. Now we will advance our Rule-based chatbots using the NLTK library. Please install the NLTK library first before working using the pip command.\n\nThe first thing is to import the necessary library and classes we need to use.\n‚Ä¢ Chat ‚Äì Chat is a class that contains complete logic for processing the text data that the chatbot receives and finding useful information out of it.\n‚Ä¢ reflections ‚Äì Another import we have done is reflections which is a dictionary containing basic input and corresponding outputs. You can also create your own dictionary with more responses you want. if you print reflections it will be something like this.\n\nAfter importing the libraries, First, we have to create rules. The lines of code given below create a simple set of rules. the first line describes the user input which we have taken as raw string input and the next line is our chatbot response. You can modify these pairs as per the questions and answers you want.\n\nAfter creating pairs of rules, we will define a function to initiate the chat process. The function is very simple which first greets the user and asks for any help. The conversation starts from here by calling a Chat class and passing pairs and reflections to it.\n\nWe have created an amazing Rule-based chatbot just by using Python and NLTK library. The nltk.chat works on various regex patterns present in user Intent and corresponding to it, presents the output to a user. Let‚Äôs run the application and chat with your created chatbot.\n\nTo create a self-learning chatbot using the NLTK library in Python, you‚Äôll need a solid understanding of Python, Keras, and natural language processing (NLP).\n\nHere are the 6 steps to create a chatbot in Python from scratch:\n\nBelow is the step-by-step guide for building a simple chatbot:\n\nBegin by installing the necessary modules using the command:\n\nImport the required packages and load the data file (`intents.json` in this case) containing intents for the chatbot.\n\nThe ‚Äúpreprocess data‚Äù step involves tokenizing, lemmatizing, removing stop words, and removing duplicate words to prepare the text data for further analysis or modeling.\n\nPrepare the training data by converting text into numerical form.\n\nDevelop a graphical user interface to interact with the chatbot.\n\nBy following these steps and running the appropriate files, you can create a self-learning chatbot using the NLTK library in Python.\n\nThis program defines several lists containing greetings, questions, responses, and farewells. The function checks the user‚Äôs message against these lists and returns a predefined response.\n\nThe main loop continuously prompts the user for input and uses the function to generate a reply. The loop exits when the user enters ‚Äúquit‚Äù.\n\nThis is a basic example, and you can enhance it by:\n‚Ä¢ Expanding the conversation lists with more greetings, questions, and responses.\n‚Ä¢ Using regular expressions for more flexible pattern matching in user input.\n‚Ä¢ Using libraries like ChatterBot for more advanced features like training on conversation data.\n\nChatbots are the top application of Natural Language processing and today it is simple to create and integrate with various social media handles and websites. Today most Chatbots are created using tools like Dialogflow, RASA, etc. This was a quick introduction to chatbots to present an understanding of how businesses are transforming using Data science and artificial Intelligence.\n‚Ä¢ Chatbots are AI-powered software applications designed to simulate human-like conversations with users through text or speech interfaces.\n‚Ä¢ The two main types of AI chatbots are rule-based and self-learning.\n‚Ä¢ Self-learning chatbots are of two types: retrieval-based and generative-based chatbots.\n\nThe media shown in this article are not owned by Analytics Vidhya and are used at the Author‚Äôs discretion."
    },
    {
        "link": "https://realpython.com/build-a-chatbot-python-chatterbot",
        "document": "Chatbots can provide real-time customer support and are therefore a valuable asset in many industries. When you understand the basics of the ChatterBot library, you can build and train a self-learning chatbot with just a few lines of Python code.\n\nYou‚Äôll get the basic chatbot up and running right away in step one, but the most interesting part is the learning phase, when you get to train your chatbot. The quality and preparation of your training data will make a big difference in your chatbot‚Äôs performance.\n\nTo simulate a real-world process that you might go through to create an industry-relevant chatbot, you‚Äôll learn how to customize the chatbot‚Äôs responses. You‚Äôll do this by preparing WhatsApp chat data to train the chatbot. You can apply a similar process to train your bot from different conversational data in any domain-specific topic.\n\nIn this tutorial, you‚Äôll learn how to:\n‚Ä¢ Train the chatbot to customize its responses\n‚Ä¢ Perform data cleaning on the chat export using regular expressions\n\nYou‚Äôll also learn how ChatterBot stores your training data, and you‚Äôll find suggestions and pointers for next steps, so you can start collecting real user data and let the chatbot learn from it.\n\nOverall, in this tutorial, you‚Äôll quickly run through the basics of creating a chatbot with ChatterBot and learn how Python allows you to get fun and useful results without needing to write a lot of code.\n\nThe ChatterBot library combines language corpora, text processing, machine learning algorithms, and data storage and retrieval to allow you to build flexible chatbots. You can build an industry-specific chatbot by training it with relevant data. Additionally, the chatbot will remember user responses and continue building its internal graph structure to improve the responses that it can give. Attention: While ChatterBot is still a popular open source solution for building a chatbot in Python, it hasn‚Äôt been actively maintained for a while and has therefore accumulated a significant number of issues. There are multiple forks of the project that implement fixes and updates to the existing codebase, but you‚Äôll have to personally pick the fork that implements the solution you‚Äôre looking for and then install it directly from GitHub. A fork might also come with additional installation instructions. To get started, however, you won‚Äôt use a fork. Instead, you‚Äôll use a specific pinned version of the library, as distributed on PyPI. You‚Äôll find more information about installing ChatterBot in step one. In this tutorial, you‚Äôll start with an untrained chatbot that‚Äôll showcase how quickly you can create an interactive chatbot using Python‚Äôs ChatterBot. You‚Äôll also notice how small the vocabulary of an untrained chatbot is. Next, you‚Äôll learn how you can train such a chatbot and check on the slightly improved results. The more plentiful and high-quality your training data is, the better your chatbot‚Äôs responses will be. Therefore, you‚Äôll either fetch the conversation history of one of your WhatsApp chats or use the provided file that you can download here: Source Code: Click here to download the free source code that you‚Äôll use to build a chatbot. It‚Äôs rare that input data comes exactly in the form that you need it, so you‚Äôll clean the chat export data to get it into a useful input format. This process will show you some tools you can use for data cleaning, which may help you prepare other input data to feed to your chatbot. After data cleaning, you‚Äôll retrain your chatbot and give it another spin to experience the improved performance. When you work through this process from start to finish, you‚Äôll get a good idea of how you can build and train a Python chatbot with the ChatterBot library so that it can provide an interactive experience with relevant replies.\n\nIn this step, you‚Äôll set up a virtual environment and install the necessary dependencies. You‚Äôll also create a working command-line chatbot that can reply to you‚Äîbut it won‚Äôt have very interesting replies for you yet. To get started with your chatbot project, create and activate a virtual environment, then install and : Running these commands in your terminal application installs ChatterBot and its dependencies into a new Python virtual environment. Note: At the time of writing, the ChatterBot library hasn‚Äôt seen a lot of maintenance for a while. It‚Äôs therefore facing some issues that can get annoying quickly. For this tutorial, you‚Äôll use ChatterBot 1.0.4, which also works with newer Python versions on macOS and Linux. On Windows, you‚Äôll have to stay on a Python version below 3.8. ChatterBot 1.0.4 comes with a couple of dependencies that you won‚Äôt need for this project. However, you‚Äôll quickly run into more problems if you try to use a newer version of ChatterBot or remove some of the dependencies. So just relax into this selected version and give it a spin. If you‚Äôre hooked and you need more, then you can switch to a newer version later on. After the installation is complete, running should bring up list of installed dependencies that‚Äôs similar to what you can find in the provided sample code‚Äôs file: Source Code: Click here to download the free source code that you‚Äôll use to build a chatbot. With the installation out of the way, and ignoring some of the issues that the library currently has, you‚Äôre ready to get started! Create a new Python file, call it , and add the code that you need to get a basic chatbot up and running: After importing in line 3, you create an instance of in line 5. The only required argument is a name, and you call this one . No, that‚Äôs not a typo‚Äîyou‚Äôll actually build a chatty flowerpot chatbot in this tutorial! You‚Äôll soon notice that pots may not be the best conversation partners after all. In line 8, you create a loop that‚Äôll keep looping unless you enter one of the exit conditions defined in line 7. Finally, in line 13, you call on the instance that you created earlier and pass it the user input that you collected in line 9 and assigned to . The call to in the final line of the short script is the only interaction with your . And yet‚Äîyou have a functioning command-line chatbot that you can take for a spin. When you run , ChatterBot might download some data and language models associated with the NLTK project. It‚Äôll print some information about that to your console. Python won‚Äôt download this data again during subsequent runs. Note: The NLTK project installs the data that ChatterBot uses into a default location on your operating system: NLTK will automatically create the directory during the first run of your chatbot. If you‚Äôre ready to communicate with your freshly homegrown , then you can go ahead and run the Python file: After the language models are set up, you‚Äôll see the greater than sign ( ) that you defined in as your input prompt. You can now start to interact with your chatty pot: > hello ü™¥ hello > are you a plant? ü™¥ hello > can you chat, pot? ü™¥ hello Well ‚Ä¶ your chat-pot is responding, but it‚Äôs really struggling to branch out. Tough to expect more from a potted plant‚Äîafter all, it‚Äôs never gotten to see the world! Note: On Windows PowerShell, the potted plant emoji (ü™¥) might not render correctly. Feel free to replace it with any other prompt you like. Even if your chat-pot doesn‚Äôt have much to say yet, it‚Äôs already learning and growing. To test this out, stop the current session. You can do this by typing one of the exit conditions‚Äî , , or . Then start the chatbot another time. Enter a different message, and you‚Äôll notice that the chatbot remembers what you typed during the previous run: > hi ü™¥ hello > what's up? ü™¥ are you a plant? During the first run, ChatterBot created a SQLite database file where it stored all your inputs and connected them with possible responses. There should be three new files that have popped up in your working directory: ChatterBot uses the default and creates a SQLite file database unless you specify a different storage adapter. Note: The main database file is , while the other two, ending with and , are temporary support files. Because you said both hello and hi at the beginning of the chat, your chat-pot learned that it can use these messages interchangeably. That means if you chat a lot with your new chatbot, it‚Äôll gradually have better replies for you. But improving its responses manually sounds like a long process! Now that you‚Äôve created a working command-line chatbot, you‚Äôll learn how to train it so you can have slightly more interesting conversations.\n\nIn the previous step, you built a chatbot that you could interact with from your command line. The chatbot started from a clean slate and wasn‚Äôt very interesting to talk to. In this step, you‚Äôll train your chatbot using to make it a little smarter from the start. You‚Äôll also learn about built-in trainers that come with ChatterBot, including their limitations. Your chatbot doesn‚Äôt have to start from scratch, and ChatterBot provides you with a quick way to train your bot. You‚Äôll use ChatterBot‚Äôs to provide some conversation samples that‚Äôll give your chatbot more room to grow: \"No, I'm the pot below the plant!\" In line 4, you import , to which you pass your on line 8 to create . In lines 9 to 12, you set up the first training round, where you pass a list of two strings to . Using injects entries into your database to build upon the graph structure that ChatterBot uses to choose possible replies. Note: If you pass an iterable with exactly two items to , then ChatterBot considers the first item a statement and the second item an acceptable response. You can run more than one training session, so in lines 13 to 16, you add another statement and another reply to your chatbot‚Äôs database. If you now run the interactive chatbot once again using , you can elicit somewhat different responses from it than before: > hi ü™¥ Welcome, friend ü§ó > hello ü™¥ are you a plant? > me? ü™¥ are you a plant? > yes ü™¥ hi > are you a plant? ü™¥ No, I'm the pot below the plant! > cool ü™¥ Welcome, friend ü§ó The conversation isn‚Äôt yet fluent enough that you‚Äôd like to go on a second date, but there‚Äôs additional context that you didn‚Äôt have before! When you train your chatbot with more data, it‚Äôll get better at responding to user inputs. The ChatterBot library comes with some corpora that you can use to train your chatbot. However, at the time of writing, there are some issues if you try to use these resources straight out of the box. Note: The issues come from mismatches between versions of the dependencies, as well as the Python version that you use. You can work around them, but it‚Äôll require some fiddling on your end. Alternatively, you could parse the corpus files yourself using because they‚Äôre stored as YAML files. While the provided corpora might be enough for you, in this tutorial you‚Äôll skip them entirely and instead learn how to adapt your own conversational input data for training with ChatterBot‚Äôs . To train your chatbot to respond to industry-relevant questions, you‚Äôll probably need to work with custom data, for example from existing support requests or chat logs from your company. Moving forward, you‚Äôll work through the steps of converting chat data from a WhatsApp conversation into a format that you can use to train your chatbot. If your own resource is WhatsApp conversation data, then you can use these steps directly. If your data comes from elsewhere, then you can adapt the steps to fit your specific text format. To start off, you‚Äôll learn how to export data from a WhatsApp chat conversation.\n\nAt the end of this step, you‚Äôll have downloaded a TXT file that contains the chat history of a WhatsApp conversation. If you don‚Äôt have a WhatsApp account or don‚Äôt want to work with your own conversational data, then you can download a sample chat export below: Source Code: Click here to download the free source code that you‚Äôll use to build a chatbot. If you‚Äôre going to work with the provided chat history sample, you can skip to the next section, where you‚Äôll clean your chat export. To export the history of a conversation that you‚Äôve had on WhatsApp, you need to open the conversation on your phone. Once you‚Äôre on the conversation screen, you can access the export menu:\n‚Ä¢ Click on the three dots (‚ãÆ) in the top right corner to open the main menu.\n‚Ä¢ Choose More to bring up additional menu options.\n‚Ä¢ Select Export chat to create a TXT export of your conversation. In the stitched-together screenshots below, you can see the three consecutive steps numbered and outlined in red: Once you‚Äôve clicked on Export chat, you need to decide whether or not to include media, such as photos or audio messages. Because your chatbot is only dealing with text, select WITHOUT MEDIA. Then, you can declare where you‚Äôd like to send the file. Again, you can see an example of these next steps in two stitched-together WhatsApp screenshots with red numbers and outlines below: In this example, you saved the chat export file to a Google Drive folder named Chat exports. You‚Äôll have to set up that folder in your Google Drive before you can select it as an option. Of course, you don‚Äôt need to use Google Drive. As long as you save or send your chat export file so that you can access to it on your computer, you‚Äôre good to go. Once that‚Äôs done, switch back to your computer. Find the file that you saved, and download it to your machine. Specifically, you should save the file to the folder that also contains and rename it . Then, open it with your favorite text editor to inspect the data that you received: 9/15/22, 14:50 - Messages and calls are end-to-end encrypted. ‚Æë No one outside of this chat, not even WhatsApp, can read ‚Æë or listen to them. Tap to learn more. 9/15/22, 14:49 - Philipp: Hi Martin, Philipp here! 9/15/22, 14:50 - Philipp: I'm ready to talk about plants! 9/15/22, 14:51 - Martin: Oh that's great! 9/15/22, 14:52 - Martin: I've been waiting for a good convo about ‚Æë plants for a long time 9/15/22, 14:52 - Philipp: We all have. 9/15/22, 14:52 - Martin: Did you know they need water to grow? ... If you remember how ChatterBot handles training data, then you‚Äôll see that the format isn‚Äôt ideal to use for training. ChatterBot uses complete lines as messages when a chatbot replies to a user message. In the case of this chat export, it would therefore include all the message metadata. That means your friendly pot would be studying the dates, times, and usernames! Not exactly great conversation fertilizer. To avoid this problem, you‚Äôll clean the chat export data before using it to train your chatbot.\n\nIn this step, you‚Äôll clean the WhatsApp chat export data so that you can use it as input to train your chatbot on an industry-specific topic. In this example, the topic will be ‚Ä¶ houseplants! Most data that you‚Äôll use to train your chatbot will require some kind of cleaning before it can produce useful results. It‚Äôs just like the old saying goes: Take some time to explore the data that you‚Äôre working with and to identify potential issues: 9/15/22, 14:50 - Messages and calls are end-to-end encrypted. ‚Æë No one outside of this chat, not even WhatsApp, can read ‚Æë or listen to them. Tap to learn more. ... 9/15/22, 14:50 - Philipp: I'm ready to talk about plants! ... 9/16/22, 06:34 - Martin: <Media omitted> ... For example, you may notice that the first line of the provided chat export isn‚Äôt part of the conversation. Also, each actual message starts with metadata that includes a date, a time, and the username of the message sender. If you scroll further down the conversation file, you‚Äôll find lines that aren‚Äôt real messages. Because you didn‚Äôt include media files in the chat export, WhatsApp replaced these files with the text . All of this data would interfere with the output of your chatbot and would certainly make it sound much less conversational. Therefore, it‚Äôs a good idea to remove this data. Open up a new Python file to preprocess your data before handing it to ChatterBot for training. Start by reading in the file content and removing the chat metadata: This function removes conversation-irrelevant message metadata from the chat export file using the built-in module, which allows you to work with regular expressions:\n‚Ä¢ Lines 6 to 9 define multiple regex patterns. Constructing multiple patterns helps you keep track of what you‚Äôre matching and gives you the flexibility to use the separate capturing groups to apply further preprocessing later on. For example, with access to , you could chunk conversations by merging messages sent consecutively by the same user.\n‚Ä¢ Line 10 concatenates the regex patterns that you defined in lines 6 to 9 into a single pattern. The complete pattern matches all the metadata that you want to remove.\n‚Ä¢ Lines 12 and 13 open the chat export file and read the data into memory.\n‚Ä¢ Line 14 uses to replace each occurrence of the pattern that you defined in with an empty string ( ), effectively deleting it from the string.\n‚Ä¢ Line 15 first splits the file content string into list items using . This breaks up into a list where each line represents a separate item. Then, you convert this list into a tuple and return it from .\n‚Ä¢ Lines 17 and 18 use Python‚Äôs name-main idiom to call with as its argument, so that you can inspect the output when you run the script. Eventually, you‚Äôll use as a module and import the functionality directly into . But while you‚Äôre developing the script, it‚Äôs helpful to inspect intermediate outputs, for example with a call, as shown in line 18. Note: It‚Äôs a good idea to run your script often while you‚Äôre developing the code. As an alternative to printing the output, you could use to inspect your code with . If you use a debugger such as , then you can interact with the code objects rather than just printing a static representation. After removing the message metadata from each line, you also want to remove a few complete lines that aren‚Äôt relevant for the conversation. To do this, create a second function in your data cleaning script: In , you‚Äôve written code that allows you to remove irrelevant lines from the conversation corpus:\n‚Ä¢ Line 6 removes the first introduction line, which every WhatsApp chat export comes with, as well as the empty line at the end of the file.\n‚Ä¢ Line 8 creates a tuple where you can define what strings you want to exclude from the data that‚Äôll make it to training. For now, it only contains one string, but if you wanted to remove other content as well, you could quickly add more strings to this tuple as items.\n‚Ä¢ Line 9 filters for the strings defined in using a generator expression that you convert to a tuple before returning it. Finally, you‚Äôve also changed lines 12 to 14. You now collect the return value of the first function call in the variable , then use it as an argument to . You save the result of that function call to and print that value to your console on line 14. Because you want to treat as a module and run the cleaning code in , it‚Äôs best to now refactor the code in the name-main idiom into a main function that you can then import and call in : You refactor your code by moving the function calls from the name-main idiom into a dedicated function, , that you define toward the top of the file. In line 6, you replace with the parameter to make it more general. You‚Äôll provide the filename when calling the function. The function returns the cleaned corpus, which you can use to train your chatbot. After creating your cleaning module, you can now head back over to and integrate the code into your pipeline.\n\nStep 5: Train Your Chatbot on Custom Data and Start Chatting In this step, you‚Äôll train your chatbot with the WhatsApp conversation data that you cleaned in the previous step. You‚Äôll end up with a chatbot that you‚Äôve trained on industry-specific conversational data, and you‚Äôll be able to chat with the bot‚Äîabout houseplants! Open up and include calls to your cleaning functions in the code: You don‚Äôt need to do a lot of extra work in this file, because you‚Äôve prepared your cleaning functions well:\n‚Ä¢ Line 7 defines the filename of your chat export file. In this example, you assume that it‚Äôs called , and it‚Äôs located in the same directory as . If you need more advanced path handling, then take a look at Python‚Äôs module.\n‚Ä¢ Line 12 applies your cleaning code to the chat history file and returns a tuple of cleaned messages, which you call .\n‚Ä¢ Line 13 finally uses that data as input to , effectively training your chatbot with the WhatsApp conversation data. It‚Äôs important to know that ChatterBot will treat an iterable with more than two items slightly differently than when there are only two items, like you had in your previous training runs: If you provide longer lists of training conversations, then this will establish each item in the list as a possible response to its predecessor in the list. (Source) Depending on your input data, this may or may not be exactly what you want. For the provided WhatsApp chat export data, this isn‚Äôt ideal because not every line represents a question followed by an answer. To deal with this, you could apply additional preprocessing on your data, where you might want to group all messages sent by the same person into one line, or chunk the chat export by time and date. That way, messages sent within a certain time period could be considered a single conversation. There‚Äôs always more to clean to improve your input data! For this tutorial, however, it‚Äôs time to give the conversational houseplant chatbot another go. Run and chat with your chatty pot to test how its responses have changed due to training: > hi ü™¥ Welcome, friend ü§ó > thanks for the green welcome ü™¥ I let you > you let me be here? ü™¥ It's a monsters! > did you mean monstera? ü™¥ The leafs are getting dryer and dryer. But she's growing new ones > who? ü™¥ Do raindrops touch their leaves? > very philosophical! ü™¥ Lol > ;) ü™¥ I don't grow any crop at home > no crops in pots ü™¥ Ah, gotcha! > ah, I just thought you meant that ü™¥ But water makes sense > yes, water in pots ü™¥ Do you have any plant care pro tips? > water. ü™¥ I always thought that love and music was more than enough > haha ü™¥ Well, no. Just the balcony. This worked best > ok, balcony is notes ü™¥ I let you Your chatbot has increased its range of responses based on the training data that you fed to it. As you might notice when you interact with your chatbot, the responses don‚Äôt always make a lot of sense. ChatterBot uses complete sentences as replies, and you trained it on just a small sample of conversational data. The small size of the training data means that it doesn‚Äôt have a big pool of replies to pick from. And because the data is conversational, not all of the sentences are very useful as replies. But is doing all it can to find the best matching reply to any new message that you type! To select a response to your input, ChatterBot uses the logic adapter by default. This logic adapter uses the Levenshtein distance to compare the input string to all statements in the database. It then picks a reply to the statement that‚Äôs closest to the input string. If you use well-structured input data, then the default settings of ChatterBot give you decent results out of the box. And if you‚Äôre ready to do some extra work to get just what you want, then you‚Äôre in luck! ChatterBot allows for a lot of customization and provides some instructions to guide you in the right direction: Write a function that takes two statements and returns a number between 0 and 1 ChatterBot provides you with reasonable defaults. But if you want to customize any part of the process, then it gives you all the freedom to do so. In this section, you put everything back together and trained your chatbot with the cleaned corpus from your WhatsApp conversation chat export. At this point, you can already have fun conversations with your chatbot, even though they may be somewhat nonsensical. Depending on the amount and quality of your training data, your chatbot might already be more or less useful.\n\nChatterBot provides a way to install the library as a Django app. As a next step, you could integrate ChatterBot in your Django project and deploy it as a web app. You can also swap out the database back end by using a different storage adapter and connect your Django ChatterBot to a production-ready database. After you‚Äôve completed that setup, your deployed chatbot can keep improving based on submitted user responses from all over the world. Even if you keep running your chatbot on the CLI for now, there are many ways that you can improve the project and continue to learn about the ChatterBot library:\n‚Ä¢ Handle more edge cases: Your regex pattern might not catch all WhatsApp usernames. You can throw some edge cases at it and improve the stability of your parsing while building tests for your code.\n‚Ä¢ Improve conversations: Group your input data as conversations so that your training input considers consecutive messages sent by the same user within an hour a single message.\n‚Ä¢ Parse the ChatterBot corpus: Skip the dependency conflicts, install directly, and parse some of the training corpora provided in chatterbot-corpus yourself. Use one or more of them to continue training your chatbot.\n‚Ä¢ Build a custom preprocessor: ChatterBot can modify user input before sending it to a logic adapter. You can use built-in preprocessors, for example to remove whitespace. Build a custom preprocessor that can replace swear words in your user input.\n‚Ä¢ Include additional logic adapters: ChatterBot comes with a few preinstalled logic adapters, such as ones for mathematical evaluations and time logic. Add these logic adapters to your chatbot so it can perform calculations and tell you the current time.\n‚Ä¢ Write a custom logic adapter: Create a custom logic adapter that triggers on specific user inputs, for example when your users ask for a joke.\n‚Ä¢ Incorporate an API call: Build a logic adapter that can interact with an API service, for example by repurposing your weather CLI project so that it works within your chatbot. There‚Äôs a lot that you can do! Check out what your chatbot suggests: > what should i do next? ü™¥ Yeah! I want them to be strong and take care of themselves at some point Great advice! Or ‚Ä¶ at least it seems like your chatbot is telling you that you should help it become more self-sufficient? A great next step for your chatbot to become better at handling inputs is to include more and better training data. If you do that, and utilize all the features for customization that ChatterBot offers, then you can create a chatbot that responds a little more on point than here. If you‚Äôre not interested in houseplants, then pick your own chatbot idea with unique data to use for training. Repeat the process that you learned in this tutorial, but clean and use your own data for training. Did you decide to adapt your chatbot for a specific use case? Did you manage to have a philosophical conversation with it? Or did your chatbot keep switching topics in a funny way? Share your experience in the comments below!"
    },
    {
        "link": "https://community.openai.com/t/creating-a-chatbot-using-the-data-stored-in-my-huge-database/245942",
        "document": "Open-source vector similarity search for Postgres. Contribute to pgvector/pgvector development by creating an account on GitHub."
    }
]