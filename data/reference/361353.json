[
    {
        "link": "https://programiz.com/c-programming/c-file-input-output",
        "document": "A file is a container in computer storage devices used for storing data.\n‚Ä¢ When a program is terminated, the entire data is lost. Storing in a file will preserve your data even if the program terminates.\n‚Ä¢ If you have to enter a large number of data, it will take a lot of time to enter them all.\n\n However, if you have a file containing all the data, you can easily access the contents of the file using a few commands in C.\n‚Ä¢ You can easily move your data from one computer to another without any changes.\n\nWhen dealing with files, there are two types of files you should know about:\n\nText files are the normal .txt files. You can easily create text files using any simple text editors such as Notepad.\n\nWhen you open those files, you'll see all the contents within the file as plain text. You can easily edit or delete the contents.\n\nThey take minimum effort to maintain, are easily readable, and provide the least security and takes bigger storage space.\n\nBinary files are mostly the .bin files in your computer.\n\nInstead of storing data in plain text, they store it in the binary form (0's and 1's).\n\nThey can hold a higher amount of data, are not readable easily, and provides better security than text files.\n\nIn C, you can perform four major operations on files, either text or binary:\n‚Ä¢ Reading from and writing information to a file\n\nWhen working with files, you need to declare a pointer of type file. This declaration is needed for communication between the file and the program.\n\nOpening a file is performed using the function defined in the header file.\n\nThe syntax for opening a file in standard I/O is:\n‚Ä¢ Let's suppose the file doesn't exist in the location . The first function creates a new file named and opens it for writing as per the mode 'w'.\n\n The writing mode allows you to create and edit (overwrite) the contents of the file.\n‚Ä¢ Now let's suppose the second binary file exists in the location . The second function opens the existing file for reading in binary mode 'rb'.\n\n The reading mode only allows you to read the file, you cannot write into the file.\n\nThe file (both text and binary) should be closed after reading/writing.\n\nClosing a file is performed using the function.\n\nHere, is a file pointer associated with the file to be closed.\n\nFor reading and writing to a text file, we use the functions and\n\nThey are just the file versions of and . The only difference is that and expects a pointer to the structure FILE.\n\nThis program takes a number from the user and stores in the file .\n\nAfter you compile and run this program, you can see a text file created in C drive of your computer. When you open the file, you can see the integer you entered.\n\nThis program reads the integer present in the file and prints it onto the screen.\n\nIf you successfully created the file from Example 1, running this program will get you the integer you entered.\n\nOther functions like , etc. can be used in a similar way.\n\nFunctions and are used for reading from and writing to a file on the disk respectively in case of binary files.\n\nTo write into a binary file, you need to use the function. The functions take four arguments:\n‚Ä¢ address of data to be written in the disk\n‚Ä¢ size of data to be written in the disk\n‚Ä¢ number of such type of data\n‚Ä¢ pointer to the file where you want to write.\n\nExample 3: Write to a binary file using fwrite()\n\nIn this program, we create a new file in the C drive.\n\nWe declare a structure with three numbers - , and define it in the main function as num.\n\nNow, inside the for loop, we store the value into the file using .\n\nThe first parameter takes the address of and the second parameter takes the size of the structure .\n\nSince we're only inserting one instance of , the third parameter is . And, the last parameter points to the file we're storing the data.\n\nFunction also take 4 arguments similar to the function as above.\n\nExample 4: Read from a binary file using fread()\n\nIn this program, you read the same file and loop through the records one by one.\n\nIn simple terms, you read one record of size from the file pointed by into the structure .\n\nYou'll get the same records you inserted in Example 3.\n\nIf you have many records inside a file and need to access a record at a specific position, you need to loop through all the records before it to get the record.\n\nThis will waste a lot of memory and operation time. An easier way to get to the required data can be achieved using .\n\nAs the name suggests, seeks the cursor to the given record in the file.\n\nThe first parameter stream is the pointer to the file. The second parameter is the position of the record to be found, and the third parameter specifies the location where the offset starts.\n\nThis program will start reading the records from the file in the reverse order (last to first) and prints it."
    },
    {
        "link": "https://geeksforgeeks.org/c-file-io",
        "document": "In this article, we will learn how to operate over files using a C program. A single C file can read, write, move, and create files in our computer easily using a few functions and elements included in the C File I/O system. We can easily manipulate data in a file regardless of whether the file is a text file or a binary file using functions like fopen(), fclose(), fprintf(), fscanf(), getc(), putc(), getw(), fseek(), etc.\n\nWhat are files in C?\n\nA file is used to store huge data. C provides multiple file management functions like file creation, opening and reading files, Writing to the file, and closing a file. The file is used to store relevant data and file handling in C is used to manipulate the data.\n\nTypes of Files in C\n\nThere are mainly two types of files that can be handled using File Handling in C as mentioned below:\n\nThese are simple text files that are saved by the (.txt) extension and can be created or modified by any text editor. Text file stores data in the form of ASCII characters and is used to store a stream of characters.\n\nIt is stored in binary format instead of ASCII characters. Binary files are normally used to store numeric Information (int, float, double). Here data is stored in binary form i.e, (0‚Äôs and 1‚Äôs).\n\nC Files can perform multiple useful operations that are mentioned below:\n\nFor performing operations on the file, a special pointer called File pointer is used that can be declared as:\n\nWe can open the file as\n\nThe second parameter i.e, ‚Äúw‚Äù can be changed according to the table below:\n\nSearches file. If the file is opened successfully fopen( ) loads it into memory and sets up a pointer that points to the first character in it. If the file cannot be opened fopen( ) then it returns NULL. Open for reading in binary mode. If the file does not exist then fopen( ) will return NULL. Searches file. Contents are overwritten if the file exists. A new file is created if the file doesn‚Äôt exist. Returns NULL, if unable to open the file. Open for writing in binary mode. Its contents are overwritten if the file exists, else the file will be created. Searches file. If the file is opened successfully fopen( ) loads it into memory and sets up a pointer that points to the last character in it. If the file doesn‚Äôt exist, a new file is created. Returns NULL, if unable to open the file. Open for append in binary mode. Data is added to the end of the file. A file will be created if it does not exist. Searches file. It is opened successfully fopen( ) loads it into memory and sets up a pointer that points to the first character in it. If it is unable to open the file it Returns NULL. Open for both reading and writing in binary mode. fopen( ) returns NULL if the file does not exist. Searches file. Its contents are overwritten if the file exists. A new file is created if the file doesn‚Äôt exist. Returns NULL, if unable to open the file. Open for both reading and writing in binary mode. Contents are overwritten if the file exists. It will be created if the file does not exist. Searches file. If the file is opened successfully fopen( ) loads it into memory and sets up a pointer that points to the last character in it. If the file doesn‚Äôt exist, a new file is created. Returns NULL, if unable to open the file. Open for both reading and appending in binary mode. A file will be created if the file does not exist.\n\nIf you want to handle binary files then access modes like ‚Äúrb‚Äù, ‚Äúwb‚Äù, ‚Äúab‚Äù, ‚Äúrb+‚Äù, r+b‚Äù, ‚Äúwb+‚Äù, ‚Äúw+b‚Äù, ‚Äúab+‚Äù, ‚Äúa+b‚Äù will be used mostly.\n\nTo perform the opening and creation of a file in c we can use the fopen() function which comes under stdio.h header file.\n\nAs now we know how to open a file using fopen() now the question arises about creation. The creation of a file is as simple as opening a file. As, if the while opening a file for writing or appending is done with either write(‚Äúw‚Äù) or append(‚Äúa‚Äù) mode then in the case where the file doesn‚Äôt exist a new file is created.\n\n1. Writing to a text file in C\n\nfprintf() and fscanf() are used to read and write in a text file in C programming. They expect a pointer to the structure FILE since they are file versions of print() and scanf().\n\nThe above program takes a string from a user and stores it in text_file.text.After compiling this program a text file named temp_text.txt will be created in the C_Program folder. Inside the file, we can see the string that we entered.\n\nfwrite() function takes four arguments address of data, size of the data which is to be written on the disk, number of data types, and a pointer to the file where we want to write.\n\nBelow is the C program to write to a binary file:\n\nBelow is the C program to read the contents from the file:\n\nfread() function also takes four arguments that are similar to fwrite() function in C Programming.\n\nBelow is the C program to read from a binary file:\n\nExplanation: In the above program, we have read the same file GFG.bin and are looping through records one by one. We read a single Num record of Num size from the file pointed by *fptr into the structure Num. We‚Äôll get the same record that we inserted in the previous program.\n\nfseek() and rewind() are the two methods in C programming that can be used to move the file pointer. Let us check both methods:\n\nfseek() function is used to set the file pointer to the specified offset and write data into the file.\n‚Ä¢ whence can be SEEK_SET, SEEK_CUR and SEEK_END.\n‚Ä¢ SEEK_END: It denotes the end of the file.\n‚Ä¢ SEEK_SET: It denotes starting of the file.\n\nBelow is the C program to implement fseek():\n\nrewind() function sets the file pointer to the beginning of the file.\n\nBelow is the C Program to implement rewind():\n\nHow to open a file in C?\n\nHow to create a file in C?\n\nHow to read a file in C?\n\nHow to write to a file in C?\n\nWhat are modes in C file io?\n\nWhat are different operations which can be performed on a file in C?"
    },
    {
        "link": "https://geeksforgeeks.org/basics-file-handling-c",
        "document": "File handling in C is the process in which we create, open, read, write, and close operations on a file. C language provides different functions such as fopen(), fwrite(), fread(), fseek(), fprintf(), etc. to perform input, output, and many different C file operations in our program.\n\nWhy do we need File Handling in C?\n\nSo far the operations using the C program are done on a prompt/terminal which is not stored anywhere. The output is deleted when the program is closed. But in the software industry, most programs are written to store the information fetched from the program. The use of file handling is exactly what the situation calls for.\n\nIn order to understand why file handling is important, let us look at a few features of using files:\n‚Ä¢ Reusability: The data stored in the file can be accessed, updated, and deleted anywhere and anytime providing high reusability.\n‚Ä¢ Portability: Without losing any data, files can be transferred to another in the computer system. The risk of flawed coding is minimized with this feature.\n‚Ä¢ Efficient: A large amount of input may be required for some programs. File handling allows you to easily access a part of a file using few instructions which saves a lot of time and reduces the chance of errors.\n‚Ä¢ Storage Capacity: Files allow you to store a large amount of data without having to worry about storing everything simultaneously in a program.\n\nTypes of Files in C\n\nA file can be classified into two types based on the way the file stores the data. They are as follows:\n\nA text file contains data in the form of ASCII characters and is generally used to store a stream of characters.\n‚Ä¢ None Each line in a text file ends with a new line character (‚Äò\n\n‚Äô).\n‚Ä¢ None It can be read or written by any text editor.\n‚Ä¢ None They are generally stored with .txt\n‚Ä¢ None Text files can also be used to store the source code.\n\nA binary file contains data in binary form (i.e. 0‚Äôs and 1‚Äôs) instead of ASCII characters. They contain data that is stored in a similar manner to how it is stored in the main memory.\n‚Ä¢ None The binary files can be created only from within a program and their contents can only be read by a program.\n‚Ä¢ None More secure as they are not easily readable.\n‚Ä¢ None They are generally stored with .bin\n\nC file operations refer to the different possible operations that we can perform on a file in C such as:\n‚Ä¢ fopen() with attributes as ‚Äúa‚Äù or ‚Äúa+‚Äù or ‚Äúw‚Äù or ‚Äúw+‚Äù\n\nThe highlighted text mentions the C function used to perform the file operations.\n\nA file pointer is a reference to a particular position in the opened file. It is used in file handling to perform all file operations such as read, write, close, etc. We use the FILE macro to declare the file pointer variable. The FILE macro is defined inside <stdio.h> header file.\n\nFile Pointer is used in almost all the file operations in C.\n\nFor opening a file in C, the fopen() function is used with the filename or file path along with the required access modes.\n‚Ä¢ file_name: name of the file when present in the same directory as the source file. Otherwise, full path.\n‚Ä¢ access_mode: Specifies for what operation the file is being opened.\n‚Ä¢ None If the file is opened successfully, returns a file pointer to it.\n‚Ä¢ None If the file is not opened, then returns NULL.\n\nFile opening modes or access modes specify the allowed operations on the file to be opened. They are passed as an argument to the fopen() function. Some of the commonly used file access modes are listed below:\n\nSearches file. If the file is opened successfully fopen( ) loads it into memory and sets up a pointer that points to the first character in it. If the file cannot be opened fopen( ) returns NULL. Open for reading in binary mode. If the file does not exist, fopen( ) returns NULL. Open for writing in text mode. If the file exists, its contents are overwritten. If the file doesn‚Äôt exist, a new file is created. Returns NULL, if unable to open the file. Open for writing in binary mode. If the file exists, its contents are overwritten. If the file does not exist, it will be created. Searches file. If the file is opened successfully fopen( ) loads it into memory and sets up a pointer that points to the last character in it. It opens only in the append mode. If the file doesn‚Äôt exist, a new file is created. Returns NULL, if unable to open the file. Open for append in binary mode. Data is added to the end of the file. If the file does not exist, it will be created. Searches file. It is opened successfully fopen( ) loads it into memory and sets up a pointer that points to the first character in it. Returns NULL, if unable to open the file. Open for both reading and writing in binary mode. If the file does not exist, fopen( ) returns NULL. Searches file. If the file exists, its contents are overwritten. If the file doesn‚Äôt exist a new file is created. Returns NULL, if unable to open the file. Open for both reading and writing in binary mode. If the file exists, its contents are overwritten. If the file does not exist, it will be created. Searches file. If the file is opened successfully fopen( ) loads it into memory and sets up a pointer that points to the last character in it. It opens the file in both reading and append mode. If the file doesn‚Äôt exist, a new file is created. Returns NULL, if unable to open the file. Open for both reading and appending in binary mode. If the file does not exist, it will be created.\n\nAs given above, if you want to perform operations on a binary file, then you have to append ‚Äòb‚Äô at the last. For example, instead of ‚Äúw‚Äù, you have to use ‚Äúwb‚Äù, instead of ‚Äúa+‚Äù you have to use ‚Äúa+b‚Äù.\n\nThe file is not opened because it does not exist in the source directory. But the fopen() function is also capable of creating a file if it does not exist. It is shown below\n\nThe fopen() function can not only open a file but also can create a file if it does not exist already. For that, we have to use the modes that allow the creation of a file if not found such as w, w+, wb, wb+, a, a+, ab, and ab+.\n\nThe file read operation in C can be performed using functions fscanf() or fgets(). Both the functions performed the same operations as that of scanf and gets but with an additional parameter, the file pointer. There are also other functions we can use to read from a file. Such functions are listed below:\n\nSo, it depends on you if you want to read the file line by line or character by character.\n\nThe getc() and some other file reading functions return EOF (End Of File) when they reach the end of the file while reading. EOF indicates the end of the file and its value is implementation-defined.\n\nThe file write operations can be performed by the functions fprintf() and fputs() with similarities to read operations. C programming also provides some other functions that can be used to write data to a file such as:\n\nThe fclose() function is used to close the file. After successful file operations, you must always close a file to remove it from the memory.\n\nwhere the file_pointer is the pointer to the opened file.\n\nExamples of File Handing in C\n\nExample 1: Program to Create a File, Write in it, And Close the File\n\nThis program will create a file named GfgTest.c in the same directory as the source file which will contain the following text: ‚ÄúGeeksforGeeks-A Computer Science Portal for Geeks‚Äù.\n\nExample 2: Program to Open a File, Read from it, And Close the File\n\nThis program reads the text from the file named GfgTest.c which we created in the previous example and prints it in the console.\n\nTill now, we have only discussed text file operations. The operations on a binary file are similar to text file operations with little difference.\n\nTo open a file in binary mode, we use the rb, rb+, ab, ab+, wb, and wb+ access mode in the fopen() function. We also use the .bin file extension in the binary filename.\n\nWe use fwrite() function to write data to a binary file. The data is written to the binary file in the from of bits (0‚Äôs and 1‚Äôs).\n‚Ä¢ ptr: pointer to the block of memory to be written.\n‚Ä¢ size: size of each element to be written (in bytes).\n\nExample: Program to write to a Binary file using fwrite()\n\nThe fread() function can be used to read data from a binary file in C. The data is read from the file in the same form as it is stored i.e. binary form.\n‚Ä¢ ptr: pointer to the block of memory to read.\n‚Ä¢ size: the size of each element to read(in bytes).\n\nExample: Program to Read from a binary file using fread()\n\nIf we have multiple records inside a file and need to access a particular record that is at a specific position, so we need to loop through all the records before it to get the record. Doing this will waste a lot of memory and operational time. To reduce memory consumption and operational time we can use fseek() which provides an easier way to get to the required data. fseek() function in C seeks the cursor to the given record in the file.\n\nThe rewind() function is used to bring the file pointer to the beginning of the file. It can be used in place of fseek() when you want the file pointer at the start.\n\nMore Functions for C File Operations\n\nThe following table lists some more functions that can be used to perform file operations or assist in performing them."
    },
    {
        "link": "https://tutorialspoint.com/cprogramming/c_file_io.htm",
        "document": "File handling in C is the process of handling file operations such as creating, opening, writing data, reading data, renaming, and deleting using the C language functions. With the help of these functions, we can perform file operations to store and retrieve the data in/from the file in our program.\n\nNeed of File Handling in C\n\nIf we perform input and output operations using the C program, the data exists as long as the program is running, when the program is terminated, we cannot use that data again. File handling is required to work with files stored in the external memory i.e., to store and access the information to/from the computer's external memory. You can keep the data permanently using file handling.\n\nA file represents a sequence of bytes. There are two types of files: text files and binary files ‚àí\n‚Ä¢ Text file ‚àí A text file contains data in the form of ASCII characters and is generally used to store a stream of characters. Each line in a text file ends with a new line character (\"\n\n\"), and generally has a \".txt\" extension.\n‚Ä¢ Binary file ‚àí A binary file contains data in raw bits (0 and 1). Different application programs have different ways to represent bits and bytes and use different file formats. The image files (.png, .jpg), the executable files (.exe, .com), etc. are the examples of binary files.\n\nWhile working with file handling, you need a file pointer to store the reference of the FILE structure returned by the fopen() function. The file pointer is required for all file-handling operations.\n\nThe fopen() function returns a pointer of the FILE type. FILE is a predefined struct type in stdio.h and contains attributes such as the file descriptor, size, and position, etc.\n\nBelow is the syntax to declare a file pointer ‚àí\n\nA file must be opened to perform any operation. The fopen() function is used to create a new file or open an existing file. You need to specify the mode in which you want to open. There are various file opening modes explained below, any one of them can be used during creating/opening a file.\n\nThe fopen() function returns a FILE pointer which will be used for other operations such as reading, writing, and closing the files.\n\nBelow is the syntax to open a file ‚àí\n\nHere, filename is the name of the file to be opened, and mode defines the file's opening mode.\n\nThe file access modes by default open the file in the text or ASCII mode. If you are going to handle binary files, then you will use the following access modes instead of the above-mentioned ones:\n\nThere are various modes in which a file can be opened. The following are the different file opening modes ‚àí\n\nIn the following example, we are creating a new file. The file mode to create a new file will be \"w\" (write-mode).\n\nIn the following example, we are opening an existing file. The file mode to open an existing file will be \"r\" (read-only). You may also use other file opening mode options explained above.\n\nNote: There must be a file to be opened.\n\nEach file must be closed after performing operations on it. The fclose() function closes an opened file.\n\nBelow is the syntax of fclose() function ‚àí\n\nThe fclose() function returns zero on success, or EOF if there is an error in closing the file.\n\nThe fclose() function actually flushes any data still pending in the buffer to the file, closes the file, and releases any memory used for the file. The EOF is a constant defined in the header file stdio.h.\n\nIn the following example, we are closing an opened file ‚àí\n\nThe following library functions are provided to write data in a file opened in writeable mode ‚àí\n\nThe fputc() function is an unformatted function that writes a single character value of the argument \"c\" to the output stream referenced by \"fp\".\n\nIn the following code, one character from a given char array is written into a file opened in the \"w\" mode:\n\nThe fputs() function writes the string \"s\" to the output stream referenced by \"fp\". It returns a non-negative value on success, else EOF is returned in case of any error.\n\nThe following program writes strings from the given two-dimensional char array to a file ‚àí\n\nWhen the program is run, a file named \"file2.txt\" is created in the current folder and save the following lines ‚àí\n\nThe fprintf() function sends a formatted stream of data to the disk file represented by the FILE pointer.\n\nIn the following program, we have an array of struct type called \"employee\". The structure has a string, an integer, and a float element. Using the fprintf() function, the data is written to a file.\n\nThe following library functions are provided to read data from a file that is opened in read mode ‚àí\n\nThe fgetc() function reads a character from the input file referenced by \"fp\". The return value is the character read, or in case of any error, it returns EOF.\n\nThe following example reads the given file in a character by character manner till it reaches the end of file.\n\nRun the code and check its output ‚àí\n\nThe fgets() function reads up to \"n 1\" characters from the input stream referenced by \"fp\". It copies the read string into the buffer \"buf\", appending a null character to terminate the string.\n\nThis following program reads each line in the given file till the end of the file is detected ‚àí\n\nRun the code and check its output ‚àí\n\nThe fscanf() function in C programming language is used to read formatted input from a file.\n\nIn the following program, we use the fscanf() function to read the formatted data in different types of variables. Usual format specifiers are used to indicate the field types (%d, %f, %s, etc.)\n\nWhen the above program is executed, it opens the text file \"file3.txt\" and prints its contents on the screen. After running the code, you will get an output like this ‚àí\n\nThe read/write operations are done in a binary form in the case of a binary file. You need to include the character \"b\" in the access mode (\"wb\" for writing a binary file, \"rb\" for reading a binary file).\n\nThere are two functions that can be used for binary input and output: the fread() function and the fwrite() function. Both of these functions should be used to read or write blocks of memories, usually arrays or structures.\n\nThe fwrite() function writes a specified chunk of bytes from a buffer to a file opened in binary write mode. Here is the prototype to use this function:\n\nIn the following program, an array of a struct type called \"employee\" has been declared. We use the fwrite() function to write one block of byte, equivalent to the size of one employee data, in a file that is opened in \"wb\" mode.\n\nThe fread() function reads a specified chunk of bytes from a file opened in binary read mode to a buffer of the specified size. Here is the prototype to use this function:\n\nIn the following program, an array of a struct type called \"employee\" has been declared. We use the fread() function to read one block of byte, equivalent to the size of one employee data, in a file that is opened in \"rb\" mode.\n\nWhen the above program is executed, it opens the file \"file4.dat\" and prints its contents on the screen. After running the code, you will get an output like this ‚àí\n\nThe rename() function is used to rename an existing file from an old file name to a new file name.\n\nBelow is the syntax to rename a file ‚àí\n\nIf there is a file (file1.txt) available, the following will be the output ‚àí"
    },
    {
        "link": "https://dev.to/angelotheman/exploring-file-io-in-c-1j07",
        "document": "File handling is a fundamental aspect of programming that allows us to interact with data stored on our computers. Whether it's reading text from a file, writing data to it, or manipulating its contents, mastering Input/Output (IO) operations is essential for any developer.\n\nIn this article, we would cover some file handling concepts in C, low-level and high-level File I/O, file descriptors and more.\n‚Ä¢ When a program is terminated, the entire data is lost. Storing in a file will preserve data even if the program terminates.\n‚Ä¢ If you have to enter a large number of data, it'll take sometime. However, if you have a file containing all the data, you can easily access the contents with few commands.\n‚Ä¢ File handling enables the reading and writing of configuration files, allowing users to tailor software settings to their preferences.\n‚Ä¢ Through file handling, programs that need to exchange data with other programs or systems can share data in various formats with external entities.\n‚Ä¢ Regularly saving data to files ensures that valuable information can be restored in case of system failures or data loss\n\nAt its core, file handling involves performing operations on files which include opening, reading, writing and closing files. In C programming, file handling is achieved through the following\n\nLet's look at these more closely\n\nThese are a fundamental abstraction for file handling in C. They provide a high-level interface for reading and writing to files. In C, there are standard streams like (standard input) (standard output) and (standard error) which are automatically available for input and output.\n\nA file pointer is a mechanism used to keep track of the current position within a file. It determines where the next read or write operation will occur. File pointers are essential for sequential file access and help navigate through the file's contents.\n\nThese are low-level integer identifiers that represent open files in C. Each descriptor corresponds to a particular stream as we found above.\n\nBelow is a table to summarize the various descriptors and their corresponding streams.\n\nNOTE\n\n : It is used to read input from the user or another program.\n\n : Used to write output to the user or another program.\n\n : Used to write error messages and other diagnostics output to the user.\n\nBasic operations in File handling with C\n\nThere are four (4) basic operations in file handling with C. They are opening, reading, writing and closing. These operations must be followed in order when handling and manipulating files.\n\nAside the four (4) basic operations, there are generally two (2) approaches to handling them. They are low-level approach with system calls and high-level approach with standard library.\n\nAnother point to note is that files come in different formats such as csv, binary and text. This article would focus on the text files only.\n\nLet us look at the basic operations in file handling. For each operation, we would look at its implementation in both the high-level and low-level approaches.\n‚Ä¢ This is the first step in file handling. It establishes connection between your program and the file on disk.\n‚Ä¢ During file opening, you specify the following parameters\n‚Ä¢ Mode with which you want to open the file in. These modes specify what exactly you would like to do with the file you are opening. These includes: reading only, writing only, appending etc. Man fopen\n\nRETURN VALUE: FILE pointer if successful, NULL if otherwise\n\nman open\n\n RETURN VALUE: New file descriptor if successful, -1 if an error occurred.\n\nBelow is a table to understand various modes and how they correspond to each other in high-level and low-level approaches.\n‚Ä¢ This involves retrieving data from existing file on disk.\n‚Ä¢ You can read data character by character, line by line or in larger chunks depending on your program's requirement.\n\nThere are two ways to read from files with this approach. They are:\n\n fgets(): This reads texts line by line and stores in a buffer.\n\n\n\nRETURN VALUE: A string on success, NULL on error.\n\n man fgets\n\n fread(): This reads specified number of bytes from a file or for reading binary files also into a buffer.\n\n man fread\n\n\n\nThis uses the function.\n\n\n\nNOTE: The is the return value of the function\n\n man read\n‚Ä¢ This adds or updates data in a file.\n‚Ä¢ You can write character by character, line by line or in larger blocks as well.\n‚Ä¢ Writing is essential for tasks like creating log files, saving program output or storing user-generated content.\n\nThis method uses (Write formatted text data to a file)\n\n\n\nman fprintf\n\n (Writes a specified number of bytes from the buffer to a file)\n\n\n\nis the function used here.\n\n\n\nNOTE: Modify the various modes/flags of the write operation to get the desired results like append etc.\n\nIn the low-level approach, you have more control over the writing process and can directly manipulate the binary data. However, you need to manage buffering and handle text encoding yourself if you're working with text files.\n‚Ä¢ This is the final step in the file handling and it's essential to release the system resources and ensure data integrity.\n‚Ä¢ Once you finish reading or writing, you should close the file to free up the file descriptors and ensure that all pending changes are saved.\n‚Ä¢ Failing to close a file property can result in resource leaks and data corruption.\n\nUntil now you might have realized that there are two approaches to handline files in C. The commonest one used is the high-level approach. However, let us look at some differences between the two. This would help inform our decisions as to which of them to use at what point in time.\n\nNow let's look at some examples with practical questions\n\n\n\n Implement a program to append some text to a file. This program should take the text from the user (stdin) and then append to the file\n\nNOTE: In low-level implementation, the function has an optional argument known as permissions. These are file permissions that you can set to the file are read, write and execute permissions represented by their numerical values.\n\n More about file permissions here\n\nCongratulations on making it this far üëèüèæ. As you have studied, file handling is a very useful programming concept. I would love to know what your experience is with File handling in the comment section.\n\nFollow me on Github, let's get interactive on Twitter and form great connections on LinkedIn üòä"
    },
    {
        "link": "https://medium.com/@hatronix/mastering-structs-in-c-an-in-depth-guide-4a524af06fd4",
        "document": "This is an anonymous structure because it is not given a name. \n\nIn C and C++, you can define structures without naming them. \n\nIn this case, you are defining a structure with two members: an integer ‚Äòa‚Äô and a character ‚Äòb‚Äô.\n\nCalling an anonymous structure is not straightforward because you cannot create variables of this type directly. It‚Äôs not recommended to use anonymous structures in practice.\n\nThis is a named structure called ‚Äúname_top.‚Äù You are defining a structure with the name ‚Äúname_top‚Äù that has two members: an integer ‚Äòa‚Äô and a character ‚Äòb‚Äô.\n\nTo use this structure, you can declare variables of this type like this:\n\nHere, ‚ÄúmyStruct‚Äù is a variable of type ‚Äústruct name_top,‚Äù and you can access its members as `myStruct.a` and `myStruct.b`.\n\nIn this example, you are defining a structure similar to the anonymous structure, but you are also declaring a variable of this structure type named ‚Äúname_bot.‚Äù\n\nTo use this structure and its associated variable, you can declare variables of this type like this:\n\nHere, ‚ÄúmyStruct‚Äù is a variable of the anonymous structure type with the name ‚Äúname_bot,‚Äù and you can access its members as `myStruct.a` and `myStruct.b`.\n\nIt‚Äôs important to note that anonymous structures are not commonly used because they cannot be easily reused, and their members are not directly accessible in other parts of the code. Named structures, on the other hand, provide a clear and reusable way to define complex data structures in C and C++.\n‚Ä¢ Structure Definition:\n\nYou are defining a structure named ‚Äúname_top‚Äù with two members: an integer ‚Äòa‚Äô and a character ‚Äòb‚Äô. This structure can be used to create variables of type ‚Äústruct name_top.‚Äù\n‚Ä¢ Variable Declaration:\n\nYou are also declaring a variable named ‚Äúname_bot‚Äù of type ‚Äústruct name_top.‚Äù This means you‚Äôve created a variable of the ‚Äúname_top‚Äù structure type and named it ‚Äúname_bot.‚Äù\n\nTo use this structure and variable, you can access the members like this:\n\nIn this example, ‚ÄúmyStruct‚Äù is an instance of the ‚Äúname_top‚Äù structure, and you can access and manipulate its members using the dot notation, as shown above."
    },
    {
        "link": "https://reddit.com/r/C_Programming/comments/n6sdzk/best_practice_with_structs",
        "document": "Hi, I'm studying C and ARM assembly right now at university and I'm a bit conflicted about how to build structs with struct fields. I'm wondering whether it's best to have pointer variables or implicit variables. As an example, let's say I have this struct:\n\nAnd I want to use it in other structs, which one of these would be best practice/optimal?"
    },
    {
        "link": "https://geeksforgeeks.org/structures-c",
        "document": "In C, a structure is a user-defined data type that can be used to group items of possibly different types into a single type. The struct keyword is used to define a structure. The items in the structure are called its member and they can be of any valid data type.\n\nExplanation: In this example, a structure A is defined to hold an integer member x. A variable a of type struct A is created and its member x is initialized to 11 by accessing it using dot operator. The value of a.x is then printed to the console.\n\nStructures are used when you want to store a collection of different data types, such as integers, floats, or even other structures under a single name. To understand how structures are foundational to building complex data structures, the C Programming Course Online with Data Structures provides practical applications and detailed explanations.\n\nThere are two steps of creating a structure in C:\n\nA structure is defined using the struct keyword followed by the structure name and its members. It is also called a structure template or structure prototype, and no memory is allocated to the structure in the declaration.\n‚Ä¢ structure_name: Name of the structure.\n‚Ä¢ member1, member2, ‚Ä¶: Name of the members.\n\nBe careful not to forget the semicolon at the end.\n\nAfter structure definition, we have to create variable of that structure to use it. It is similar to the any other type of variable declaration:\n\nWe can also declare structure variables with structure definition.\n\nFollowing are the basic operations commonly used on structures:\n\nTo access or modify members of a structure, we use the ( . ) dot operator. This is applicable when we are using structure variables directly.\n\nIn the case where we have a pointer to the structure, we can also use the arrow operator to access the members.\n\nStructure members cannot be initialized with the declaration. For example, the following C program fails in the compilation.\n\nThe reason for the above error is simple. When a datatype is declared, no memory is allocated for it. Memory is allocated only when variables are created. So there is no space to store the value assigned.\n\nWe can initialize structure members in 4 ways which are as follows:\n\nBy default, structure members are not automatically initialized to 0 or NULL. Uninitialized structure members will contain garbage values. However, when a structure variable is declared with an initializer, all members not explicitly initialized are zero-initialized.\n\nNote: We cannot initialize the arrays or strings using assignment operator after variable declaration.\n\nIn this type of initialization, the values are assigned in sequential order as they are declared in the structure template.\n\nDesignated Initialization allows structure members to be initialized in any order. This feature has been added in the C99 standard.\n\nThe Designated Initialization is only supported in C but not in C++.\n\nCopying structure is simple as copying any other variables. For example, s1 is copied into s2 using assignment operator.\n\nBut this method only creates a shallow copy of s1 i.e. if the structure s1 have some dynamic resources allocated by malloc, and it contains pointer to that resource, then only the pointer will be copied to s2. If the dynamic resource is also needed, then it has to be copied manually (deep copy).\n\nStructure can be passed to a function in the same way as normal variables. Though, it is recommended to pass it as a pointer to avoid copying a large amount of data.\n\nThe typedef keyword is used to define an alias for the already existing datatype. In structures, we have to use the struct keyword along with the structure name to define the variables. Sometimes, this increases the length and complexity of the code. We can use the typedef to define some new shorter name for the structure.\n\nExplanation: In this code, str1 and str2 are defined as aliases for the unnamed structures, allowing the creation of structure variables (var1 and var2) using these new names. This simplifies the syntax when declaring variables of the structure.\n\nTechnically, the size of the structure in C should be the sum of the sizes of its members. But it may not be true for most cases. The reason for this is Structure Padding.\n\nStructure padding is the concept of adding multiple empty bytes in the structure to naturally align the data members in the memory. It is done to minimize the CPU read cycles to retrieve different data members in the structure.\n\nThere are some situations where we need to pack the structure tightly by removing the empty bytes. In such cases, we use Structure Packing. C language provides two ways for structure packing:\n\nTo know more about structure padding and packing, refer to this article ‚Äì Structure Member Alignment, Padding and Data Packing.\n\nIn C, a nested structure refers to a structure that contains another structure as one of its members. This allows you to create more complex data types by grouping multiple structures together, which is useful when dealing with related data that needs to be grouped within a larger structure.\n\nThere are two ways in which we can nest one structure into another:\n‚Ä¢ Embedded Structure Nesting: The structure being nested is also declared inside the parent structure.\n‚Ä¢ Separate Structure Nesting: Two structures are declared separately and then the member structure is nested inside the parent structure.\n\nWe can access nested Members by using the same ( . ) dot operator two times as shown:\n\nExplanation: In this code, the structure parent contains another structure child as a member. The parent structure is then initialized with values, including the values for the child structure‚Äôs members.\n\nA pointer to a structure allows us to access structure members using the ( -> ) arrow operator instead of the dot operator.\n\nExplanation: In this example, ptr is a pointer to the structure Point. It holds the address of the structure variable p. The structure members x and y are accessed using the -> operator, which is used to dereference the pointer and access the members of the structure.\n\nThe self-referential structures are those structures that contain references to the same type as themselves i.e. they contain a member of the type pointer pointing to the same structure type.\n\nSuch kinds of structures are used in different data structures such as to define the nodes of linked lists, trees, etc.\n\nBit Fields are used to specify the length of the structure members in bits. When we know the maximum length of the member, we can use bit fields to specify the size and reduce memory consumption.\n\nUses of Structure in C\n\nC structures are used for the following:\n‚Ä¢ None The structure can be used to define the custom data types that can be used to create some complex data types such as dates, time, complex numbers, etc. which are not present in the language.\n‚Ä¢ None It can also be used in data organization where a large amount of data can be stored in different fields.\n‚Ä¢ None Structures are used to create data structures such as trees, linked lists, etc.\n‚Ä¢ None They can also be used for returning multiple values from a function."
    },
    {
        "link": "https://quora.com/What-are-some-best-practices-for-struct-members-in-C-C",
        "document": "Something went wrong. Wait a moment and try again."
    },
    {
        "link": "https://w3schools.com/c/c_structs.php",
        "document": "Structures (also called structs) are a way to group several related variables into one place. Each variable in the structure is known as a member of the structure.\n\nUnlike an array, a structure can contain many different data types (int, float, char, etc.).\n\nYou can create a structure by using the keyword and declare each of its members inside curly braces:\n\nTo access the structure, you must create a variable of it.\n\nUse the keyword inside the method, followed by the name of the structure and then the name of the structure variable:\n\nTo access members of a structure, use the dot syntax ( ):\n\nNow you can easily create multiple structure variables with different values, using just one structure:\n\nWhat About Strings in Structures?\n\nRemember that strings in C are actually an array of characters, and unfortunately, you can't assign a value to an array like this:\n\nHowever, there is a solution for this! You can use the function and assign the value to , like this:\n\nYou can also assign values to members of a structure variable at declaration time, in a single line.\n\nJust insert the values in a comma-separated list inside curly braces . Note that you don't have to use the function for string values with this technique:\n\nYou can also assign one structure to another.\n\nIn the following example, the values of s1 are copied to s2:\n\nIf you want to change/modify a value, you can use the dot syntax ( ).\n\nAnd to modify a string value, the function is useful again:\n\nModifying values are especially useful when you copy structure values:\n\nOk, so, how are structures useful? Imagine you have to write a program to store different information about Cars, such as brand, model, and year. What's great about structures is that you can create a single \"Car template\" and use it for every cars you make. See below for a real life example.\n\nUse a structure to store different information about Cars:"
    }
]