[
    {
        "link": "https://mobx.js.org/react-integration.html",
        "document": "While MobX works independently from React, they are most commonly used together. In The gist of MobX you have already seen the most important part of this integration: the HoC that you can wrap around a React component.\n\nis provided by a separate React bindings package you choose during installation. In this example, we're going to use the more lightweight package.\n\nHint: you can play with the above example yourself on CodeSandbox.\n\nThe HoC automatically subscribes React components to any observables that are used during rendering. As a result, components will automatically re-render when relevant observables change. It also makes sure that components don't re-render when there are no relevant changes. So, observables that are accessible by the component, but not actually read, won't ever cause a re-render.\n\nIn practice this makes MobX applications very well optimized out of the box and they typically don't need any additional code to prevent excessive rendering.\n\nFor to work, it doesn't matter how the observables arrive in the component, only that they are read. Reading observables deeply is fine, complex expression like work out of the box. This makes the subscription mechanism much more precise and efficient compared to other frameworks in which data dependencies have to be declared explicitly or be pre-computed (e.g. selectors).\n\nThere is great flexibility in how state is organized, since it doesn't matter (technically that is) which observables we read or where observables originated from. The examples below demonstrate different patterns on how external and local observable state can be used in components wrapped with .\n\nSince observables used by can come from anywhere, they can be local state as well. Again, different options are available for us.\n\nYou might not need locally observable state\n\nIn general, we recommend to not resort to MobX observables for local component state too quickly, as this can theoretically lock you out of some features of React's Suspense mechanism. As a rule of thumb, use MobX observables when the state captures domain data that is shared among components (including children). Such as todo items, users, bookings, etc.\n\nState that only captures UI state, like loading state, selections, etc, might be better served by the hook, since this will allow you to leverage React suspense features in the future.\n\nUsing observables inside React components adds value as soon as they are either 1) deep, 2) have computed values or 3) are shared with other components.\n\nYou might be wondering, when do I apply ? The rule of thumb is: apply to all components that read observable data.\n\nonly enhances the component you are decorating, not the components called by it. So usually all your components should be wrapped by . Don't worry, this is not inefficient. On the contrary, more components make rendering more efficient as updates become more fine-grained.\n\nTip: Grab values from objects as late as possible\n\nworks best if you pass object references around as long as possible, and only read their properties inside the based components that are going to render them into the DOM / low-level components. In other words, reacts to the fact that you 'dereference' a value from an object.\n\nIn the above example, the component would not react to future changes if it was defined as follows, because the is not read inside the component, but outside, and is hence not tracked:\n\nNote that this is a different mindset from other libraries like , where it is a good practice to dereference early and pass primitives down, to better leverage memoization. If the problem is not entirely clear, make sure to check out the Understanding reactivity section.\n\nComponents wrapped with only subscribe to observables used during their own rendering of the component. So if observable objects / arrays / maps are passed to child components, those have to be wrapped with as well. This is also true for any callback based components.\n\nIf you want to pass observables to a component that isn't an , either because it is a third-party component, or because you want to keep that component MobX agnostic, you will have to convert the observables to plain JavaScript values or structures before passing them on.\n\nTo elaborate on the above, take the following example observable object, a component (observer) and an imaginary component that takes a column / value mapping, but which isn't an :\n\nImagine the same example, where takes an callback instead. Since is part of the rendering cycle of , rather than 's render (even though that is where it syntactically appears), we have to make sure that the callback component uses an component. Or, we can create an in-line anonymous observer using :\n\nIf is used in server side rendering context; make sure to call , so that won't subscribe to any observables used, and no GC problems are introduced.\n\nIn this documentation we used as default. mobx-react is it's big brother, which uses under the hood. It offers a few more features which are typically not needed anymore in greenfield projects. The additional things offered by mobx-react:\n‚Ä¢ and . MobX's own React.createContext predecessor which is not needed anymore.\n\nNote that fully repackages and re-exports , including functional component support. If you use , there is no need to add as a dependency or import from it anywhere.\n\nautomatically applies , so components never need to be wrapped in . can be applied safely to observer components because mutations (deeply) inside the props will be picked up by anyway if relevant.\n\nAs stated above, class based components are only supported through , and not . Briefly, you can wrap class-based components in just like you can wrap function components:\n\nCheck out mobx-react docs for more information.\n\nReact DevTools uses the display name information of components to properly display the component hierarchy.\n\nIf you use:\n\nthen no display name will be visible in the DevTools.\n\nThe following approaches can be used to fix this:\n‚Ä¢ None use with a name instead of an arrow function. infers component name from the function name:\n‚Ä¢ None Transpilers (like Babel or TypeScript) infer component name from the variable name:\n‚Ä¢ None Infer from the variable name again, using default export:\n‚Ä¢ This is broken in React 16 at the time of writing; mobx-react uses a React.memo and runs into this bug: https://github.com/facebook/react/issues/18026, but it will be fixed in React 17.\n\nNow you can see component names:\n\n{üöÄ} Tip: when combining with other higher-order-components, apply first\n\nWhen needs to be combined with other decorators or higher-order-components, make sure that is the innermost (first applied) decorator; otherwise it might do nothing at all.\n\nIn some cases the computed values of your local observables might depend on some of the props your component receives. However, the set of props that a React component receives is in itself not observable, so changes to the props won't be reflected in any computed values. You have to manually update local observable state in order to properly derive computed values from latest data.\n\nIn practice you will rarely need this pattern, since is a much simpler, albeit slightly less efficient solution.\n\ncan be used to set up side effects that need to happen, and which are bound to the life-cycle of the React component. Using requires specifying dependencies. With MobX that isn't really needed, since MobX has already a way to automatically determine the dependencies of an effect, . Combining and coupling it to the life-cycle of the component using is luckily straightforward:\n\nNote that we return the disposer created by from our effect function. This is important, since it makes sure the gets cleaned up once the component unmounts!\n\nThe dependency array can typically be left empty, unless a non-observable value should trigger a re-run of the autorun, in which case you will need to add it there. To make your linter happy, you can define (in the above example) as a dependency. That is safe and has no further effect, since the reference will never actually change.\n\nIf you'd rather explicitly define which observables should trigger the effect, use instead of , beyond that the pattern remains identical.\n\nHow can I further optimize my React components?\n‚Ä¢ Make sure you didn't forget (yes, this is the most common mistake).\n‚Ä¢ Verify that the thing you intend to react to is indeed observable. Use utilities like , if needed to verify this at runtime.\n‚Ä¢ Check the console logs in the browsers for any warnings or errors.\n‚Ä¢ Make sure you grok how tracking works in general. Check out the Understanding reactivity section.\n‚Ä¢ Read the common pitfalls as described above.\n‚Ä¢ Configure MobX to warn you of unsound usage of mechanisms and check the console logs.\n‚Ä¢ Use trace to verify that you are subscribing to the right things or check what MobX is doing in general using spy / the mobx-log package."
    },
    {
        "link": "https://legacy.reactjs.org/docs/higher-order-components.html",
        "document": "A higher-order component (HOC) is an advanced technique in React for reusing component logic. HOCs are not part of the React API, per se. They are a pattern that emerges from React‚Äôs compositional nature.\n\nConcretely, a higher-order component is a function that takes a component and returns a new component.\n\nWhereas a component transforms props into UI, a higher-order component transforms a component into another component.\n\nHOCs are common in third-party React libraries, such as Redux‚Äôs and Relay‚Äôs .\n\nIn this document, we‚Äôll discuss why higher-order components are useful, and how to write your own.\n\nComponents are the primary unit of code reuse in React. However, you‚Äôll find that some patterns aren‚Äôt a straightforward fit for traditional components.\n\nFor example, say you have a component that subscribes to an external data source to render a list of comments:\n\nLater, you write a component for subscribing to a single blog post, which follows a similar pattern:\n\nand aren‚Äôt identical ‚Äî they call different methods on , and they render different output. But much of their implementation is the same:\n‚Ä¢ Inside the listener, call whenever the data source changes.\n\nYou can imagine that in a large app, this same pattern of subscribing to and calling will occur over and over again. We want an abstraction that allows us to define this logic in a single place and share it across many components. This is where higher-order components excel.\n\nWe can write a function that creates components, like and , that subscribe to . The function will accept as one of its arguments a child component that receives the subscribed data as a prop. Let‚Äôs call the function :\n\nThe first parameter is the wrapped component. The second parameter retrieves the data we‚Äôre interested in, given a and the current props.\n\nWhen and are rendered, and will be passed a prop with the most current data retrieved from :\n\nNote that a HOC doesn‚Äôt modify the input component, nor does it use inheritance to copy its behavior. Rather, a HOC composes the original component by wrapping it in a container component. A HOC is a pure function with zero side-effects.\n\nAnd that‚Äôs it! The wrapped component receives all the props of the container, along with a new prop, , which it uses to render its output. The HOC isn‚Äôt concerned with how or why the data is used, and the wrapped component isn‚Äôt concerned with where the data came from.\n\nBecause is a normal function, you can add as many or as few arguments as you like. For example, you may want to make the name of the prop configurable, to further isolate the HOC from the wrapped component. Or you could accept an argument that configures , or one that configures the data source. These are all possible because the HOC has full control over how the component is defined.\n\nLike components, the contract between and the wrapped component is entirely props-based. This makes it easy to swap one HOC for a different one, as long as they provide the same props to the wrapped component. This may be useful if you change data-fetching libraries, for example.\n\nResist the temptation to modify a component‚Äôs prototype (or otherwise mutate it) inside a HOC.\n\nThere are a few problems with this. One is that the input component cannot be reused separately from the enhanced component. More crucially, if you apply another HOC to that also mutates , the first HOC‚Äôs functionality will be overridden! This HOC also won‚Äôt work with function components, which do not have lifecycle methods.\n\nMutating HOCs are a leaky abstraction‚Äîthe consumer must know how they are implemented in order to avoid conflicts with other HOCs.\n\nInstead of mutation, HOCs should use composition, by wrapping the input component in a container component:\n\nThis HOC has the same functionality as the mutating version while avoiding the potential for clashes. It works equally well with class and function components. And because it‚Äôs a pure function, it‚Äôs composable with other HOCs, or even with itself.\n\nYou may have noticed similarities between HOCs and a pattern called container components. Container components are part of a strategy of separating responsibility between high-level and low-level concerns. Containers manage things like subscriptions and state, and pass props to components that handle things like rendering UI. HOCs use containers as part of their implementation. You can think of HOCs as parameterized container component definitions.\n\nConvention: Pass Unrelated Props Through to the Wrapped Component\n\nHOCs add features to a component. They shouldn‚Äôt drastically alter its contract. It‚Äôs expected that the component returned from a HOC has a similar interface to the wrapped component.\n\nHOCs should pass through props that are unrelated to its specific concern. Most HOCs contain a render method that looks something like this:\n\nThis convention helps ensure that HOCs are as flexible and reusable as possible.\n\nNot all HOCs look the same. Sometimes they accept only a single argument, the wrapped component:\n\nUsually, HOCs accept additional arguments. In this example from Relay, a config object is used to specify a component‚Äôs data dependencies:\n\nThe most common signature for HOCs looks like this:\n\nWhat?! If you break it apart, it‚Äôs easier to see what‚Äôs going on.\n\nIn other words, is a higher-order function that returns a higher-order component!\n\nThis form may seem confusing or unnecessary, but it has a useful property. Single-argument HOCs like the one returned by the function have the signature . Functions whose output type is the same as its input type are really easy to compose together.\n\nThe utility function is provided by many third-party libraries including lodash (as ), Redux, and Ramda.\n\nConvention: Wrap the Display Name for Easy Debugging\n\nThe container components created by HOCs show up in the React Developer Tools like any other component. To ease debugging, choose a display name that communicates that it‚Äôs the result of a HOC.\n\nThe most common technique is to wrap the display name of the wrapped component. So if your higher-order component is named , and the wrapped component‚Äôs display name is , use the display name :\n\nHigher-order components come with a few caveats that aren‚Äôt immediately obvious if you‚Äôre new to React.\n\nReact‚Äôs diffing algorithm (called Reconciliation) uses component identity to determine whether it should update the existing subtree or throw it away and mount a new one. If the component returned from is identical ( ) to the component from the previous render, React recursively updates the subtree by diffing it with the new one. If they‚Äôre not equal, the previous subtree is unmounted completely.\n\nNormally, you shouldn‚Äôt need to think about this. But it matters for HOCs because it means you can‚Äôt apply a HOC to a component within the render method of a component:\n\nThe problem here isn‚Äôt just about performance ‚Äî remounting a component causes the state of that component and all of its children to be lost.\n\nInstead, apply HOCs outside the component definition so that the resulting component is created only once. Then, its identity will be consistent across renders. This is usually what you want, anyway.\n\nIn those rare cases where you need to apply a HOC dynamically, you can also do it inside a component‚Äôs lifecycle methods or its constructor.\n\nStatic Methods Must Be Copied Over\n\nSometimes it‚Äôs useful to define a static method on a React component. For example, Relay containers expose a static method to facilitate the composition of GraphQL fragments.\n\nWhen you apply a HOC to a component, though, the original component is wrapped with a container component. That means the new component does not have any of the static methods of the original component.\n\nTo solve this, you could copy the methods onto the container before returning it:\n\nHowever, this requires you to know exactly which methods need to be copied. You can use hoist-non-react-statics to automatically copy all non-React static methods:\n\nAnother possible solution is to export the static method separately from the component itself.\n\nWhile the convention for higher-order components is to pass through all props to the wrapped component, this does not work for refs. That‚Äôs because is not really a prop ‚Äî like , it‚Äôs handled specially by React. If you add a ref to an element whose component is the result of a HOC, the ref refers to an instance of the outermost container component, not the wrapped component.\n\nThe solution for this problem is to use the API (introduced with React 16.3). Learn more about it in the forwarding refs section."
    },
    {
        "link": "https://mobx.js.org/getting-started",
        "document": "is a simple, scalable and battle tested state management solution. This tutorial will teach you all the important concepts of MobX in ten minutes. MobX is a standalone library, but most people are using it with React and this tutorial focuses on that combination. State is the heart of each application and there is no quicker way to create buggy, unmanageable applications than by producing an inconsistent state or state that is out-of-sync with local variables that linger around. Hence many state management solutions try to restrict the ways in which you can modify state, for example by making state immutable. But this introduces new problems; data needs to be normalized, referential integrity can no longer be guaranteed and it becomes next to impossible to use powerful concepts like classes in case you fancy those. MobX makes state management simple again by addressing the root issue: it makes it impossible to produce an inconsistent state. The strategy to achieve that is simple: Make sure that everything that can be derived from the application state, will be derived. Automatically.\n‚Ä¢ First of all, there is the application state. Graphs of objects, arrays, primitives, references that forms the model of your application. These values are the ‚Äúdata cells‚Äù of your application.\n‚Ä¢ Secondly there are derivations. Basically, any value that can be computed automatically from the state of your application. These derivations, or computed values, can range from simple values, like the number of unfinished todos, to complex stuff like a visual HTML representation of your todos. In spreadsheet terms: these are the formulas and charts of your application.\n‚Ä¢ Reactions are very similar to derivations. The main difference is these functions don't produce a value. Instead, they run automatically to perform some task. Usually this is I/O related. They make sure that the DOM is updated or that network requests are made automatically at the right time.\n‚Ä¢ Finally there are actions. Actions are all the things that alter the state. MobX will make sure that all changes to the application state caused by your actions are automatically processed by all derivations and reactions. Synchronously and glitch-free. Enough theory, seeing it in action probably explains more than carefully reading the above stuff. For originality's sake let's start with a very simple ToDo store. Note that all the code blocks below are editable, So use the run code buttons to execute them. Below is a very straightforward that maintains a collection of todos. No MobX involved yet. We just created a instance with a collection. Time to fill the todoStore with some objects. To make sure we see the effects of our changes we invoke after each change and log it. Note that the report intentionally always prints the first task only. It makes this example a bit artificial, but as we will see later on it nicely demonstrates that MobX's dependency tracking is dynamic. todoStore.addTodo(\"read MobX tutorial\"); console.log(todoStore.report()); todoStore.addTodo(\"try MobX\"); console.log(todoStore.report()); todoStore.todos[0].completed = true; console.log(todoStore.report()); todoStore.todos[1].task = \"try MobX in own project\"; console.log(todoStore.report()); todoStore.todos[0].task = \"grok MobX tutorial\"; console.log(todoStore.report()); So far, there is nothing special about this code. But what if we didn't have to call explicitly, but that we could declare instead that it should be invoked upon each relevant state change? That would free us from the responsibility of calling from any place in our code base that might affect the report. We do want to be sure the latest report is printed. But we don't wanna be bothered by organizing that. Luckily that is exactly what MobX can do for us. Automatically execute code that solely depends on state. So that our function updates automatically, just like a chart in a spreadsheet. To achieve that, the has to become observable so that MobX can track all the changes that are being made. Let's alter the class just enough to achieve that. Also, the property could be derived automatically from the todo list. By using the and annotations we can introduce observable properties on an object. In the example below we use to show the annotations explicitly, but we could have used instead to simplify this process. class ObservableTodoStore { todos = []; pendingRequests = 0; constructor() { makeObservable(this, { todos: observable, pendingRequests: observable, completedTodosCount: computed, report: computed, addTodo: action, }); autorun(() => console.log(this.report)); } get completedTodosCount() { return this.todos.filter( todo => todo.completed === true ).length; } get report() { if (this.todos.length === 0) return \" That's it! We marked some properties as being to signal MobX that these values can change over time. The computations are decorated with to identify that these can be derived from the state and caches as long as no underlying state changed. The and attributes are not used so far, but will be used later in this tutorial. In the constructor we created a small function that prints the and wrapped it in . Autorun creates a reaction that runs once, and after that automatically re-runs whenever any observable data that was used inside the function changes. Because uses the observable property, it will print the report whenever appropriate. This is demonstrated in the next listing. Just press the run button: observableTodoStore.addTodo(\"read MobX tutorial\"); observableTodoStore.addTodo(\"try MobX\"); observableTodoStore.todos[0].completed = true; observableTodoStore.todos[1].task = \"try MobX in own project\"; observableTodoStore.todos[0].task = \"grok MobX tutorial\"; Pure fun, right? The did print automatically, synchronously and without leaking intermediate values. If you investigate the log carefully, you will see that the fifth line didn't result in a new log-line. Because the report did not actually change as a result of the rename, although the backing data did. On the other hand, changing the name of the first todo did update the report, since that name is actively used in the report. This demonstrates nicely that not just the array is being observed by the , but also the individual properties inside the todo items. Ok, so far we made a silly report reactive. Time to build a reactive user interface around this very same store. React components are (despite their name) not reactive out of the box. The HoC wrapper from the package fixes that by basically wrapping the React component in . This keeps the component in sync with the state. This is conceptually not different from what we did with the before. The next listing defines a few React components. The only MobX specific code in there is the wrapping. That is enough to make sure that each component individually re-renders when relevant data changes. We don't have to call state setters anymore, nor do we have to figure out how to subscribe to the proper parts of the application state using selectors or higher order components that need configuration. Basically, all components have become smart. Yet they are defined in a dumb, declarative manner. Press the Run code button to see the code below in action. The listing is editable so feel free to play with it. Try for example to remove all the calls, or just the one decorating the . The numbers in the preview on the right highlight how often a component is rendered. The next listing nicely demonstrates that we only have to alter the data, without doing any further bookkeeping. MobX will automatically derive and update the relevant parts of the user interface again from the state in the store. const store = observableTodoStore; store.todos[0].completed = !store.todos[0].completed; store.todos[1].task = \"Random todo \" + Math.random(); store.todos.push({ task: \"Find a fine cheese\", completed: true }); // etc etc.. add your own statements here... So far we have created observable objects (both prototyped and plain objects), arrays and primitives. You might be wondering, how are references handled in MobX? Is my state allowed to form a graph? In the previous listings you might have noticed that there is an property on the todos. Let's give them some values by introducing another ‚Äústore‚Äù (ok, it's just a glorified array) containing people, and assign tasks to them. const peopleStore = observable([ { name: \"Michel\" }, { name: \"Me\" } ]); observableTodoStore.todos[0].assignee = peopleStore[0]; observableTodoStore.todos[1].assignee = peopleStore[1]; peopleStore[0].name = \"Michel Weststrate\"; We now have two independent stores. One with people and one with todos. To assign an to a person from the people store, we just assigned a reference. These changes will be picked up automatically by the . With MobX there is no need to normalize data first and to write selectors to make sure our components will be updated. In fact, it doesn't even matter where the data is stored. As long as objects are made observable, MobX will be able to track them. Real JavaScript references will just work. MobX will track them automatically if they are relevant for a derivation. To test that, just try changing your name in the next input box (make sure you have pressed the above Run code button first!). By the way, the HTML of the above input box is simply: Since everything in our small Todo application is derived from the state, it really doesn't matter when state is changed. That makes creating asynchronous actions really straightforward. Just press the the following button (multiple times) to emulate asynchronously loading new todo items: The code behind that is really straightforward. We start with updating the store property to have the UI reflect the current loading status. Once loading is finished, we update the todos of the store and decrease the counter again. Just compare this snippet with the earlier definition to see how the pendingRequests property is used. Note that the timeout function is wrapped in . This isn't strictly necessary, but it makes sure that both mutations are processed in a single transaction, making sure any observers are only notified after both updates have completed. That's all! No boilerplate. Just some simple, declarative components that form our complete UI. And which are derived completely, reactively from our state. You are now ready to start using the and packages in your own applications. A short summary of the things you learned so far:\n‚Ä¢ Use the decorator or functions to make objects trackable for MobX.\n‚Ä¢ The decorator can be used to create functions that can automatically derive value from the state and cache them.\n‚Ä¢ Use to automatically run functions that depend on some observable state. This is useful for logging, making network requests, etc.\n‚Ä¢ Use the wrapper from the package to make your React components truly reactive. They will update automatically and efficiently. Even when used in large complex applications with large amounts of data. Feel free to play around a bit longer with the editable code blocks above to get a basic feeling how MobX reacts to all your changes. You could for example add a log statement to the function to see when it is called. Or don't show the at all and see how that influences the rendering of the . Or show it only under specific circumstances... Please note that the above examples are contrived and it is recommended to use proper engineering practices like encapsulating logic in methods, organize them in stores or controllers, view-models etc. Many different architectural patterns can be applied, and some are further discussed inside the official docs. The above examples, and the examples in the official documentation show how MobX could be used, not how it must be used. Or, as somebody on HackerNews put it: ‚ÄúMobX, it's been mentioned elsewhere but I can't help but sing its praises. Writing in MobX means that using controllers/ dispatchers/ actions/ supervisors or another form of managing dataflow returns to being an architectural concern you can pattern to your application's needs, rather than being something that's required by default for anything more than a Todo app.‚Äù\n\nRead on and press any run buttons you encounter!"
    },
    {
        "link": "https://dev.to/shevchenkonik/react-typescript-mobx-4mei",
        "document": "I want to share my R&D process of using React, TS, and Mobx. It‚Äôs about conceptual approaches to building large scalable applications. The second part of this article series will talk about building real application with 3rd services and ML preprocessing üî•\n\nI build the web application that allows us to work with Mobx, TypeScript, React, and 3rd API Services. This article focuses on practical examples as the best way to understand the concepts of technologies and part of patterns theory.\n\nI'll use two ways of organizing React Components for showing different ways of using stores, Class-based Components, and Functional Components with React Hooks.\n\nI'll provide a short introduction to the setup process, you can skip this section if you already know it. If you need a more specific application, please use custom webpack/rollup/parcel or something else, but we'll use Create React App with TypeScript support for simple process of setup:\n‚Ä¢ Install Mobx and its connection to React\n\nApp's source code is nested beneath the directory. And structure of application will be:\n\nI started developing my application by designing stores in the domain area. A few main concepts of stores composition that I need for my application:\n\nSo I designed my application approach with MVC like Design Pattern and layered architecture as follows:\n‚Ä¢ All backend communications (in our case we use only Spotify API as 3rd Service) are done by Service Layer.\n‚Ä¢ The store has a state of the application so it consumes service Defining data stores. All service functions will be called in the only store, components execute Store actions when the state is needed.\n‚Ä¢ Presentational Component can use the store directly by injecting the store or Props from Container Component can be passed in it.\n‚Ä¢ Container or Presentational Component can invoke store actions and automatic rendering of components will be done by Mobx.\n\nServices are a place for communication between application and Backend Services. We use this separation for a more flexible and elegant way to organize our codebase, cause if we'll use service calls inside the store then we'll find complicated stores with harder test writing process when an application will scale. Inside a store, we call the service method and update the store only inside the decorator of Mobx. Service methods are needed only for communication and they don‚Äôt modify Stores, we can modify observable variables only inside calls in Stores.\n‚Ä¢ A standalone testable place that can be used in both Frontend and Backend JavaScript. And you can write really simple unit tests for your Stores & Services with any codebase size.\n\nBut Mobx-State-Tree (MST) is a like framework based on Mobx and when you start using MST you need to implement practices and API from MST. But I want to use more native way of my codebase and less overkill for my needs. If you want to see the big codebase of MST and Mobx, you can check my previous big opensource project of data labeling and annotation tools for ML on React, Mobx, and MST - Label Studio and Frontend Part of Label Studio. In MST we have many awesome things like a Tree, Snapshots, Time Travelling, etc.\n\nThe primary purpose of Mobx is to simplify the management of Stores. As application scales, the amount of state you manage will also increase. This requires some techniques to break down your application state and to divvy it up across a set of stores. Of course, putting everything in one Store is not prudent, so we apply divide-and-conquer instead.\n\nAnd don't write your business logic in your components, because when you writing it, you have no way to reuse it. Better way is writing the business logic with methods in the Stores and call these methods from your containers and components.\n\nThe main concept of stores communication is using Root Store as a global store where we create all different stores and pass global inside a constructor of Root Store. Stores are the place of the truth for application.\n\nRoot Store collects all other stores in one place. If your children store needs methods or data from another store, you can pass into a store like as User Store for easy communication between stores. The main advantages of this pattern are:\n‚Ä¢ Simple to set up your application.\n‚Ä¢ Makes complex unit tests easy as you just have to instantiate a root store.\n\nAnd then you can use methods from Auth Store in User Store for example:\n\nContext provides a way to pass data through the component tree without having to pass props down manually at every level. Nothing spectacular about it, better to read React Context if you are unsure though. Let's create Provider for our Application:\n\nAnd you can use in the entry point of Application:\n\nWe can use both ways of our components ‚Äî Class-based components and Functional components with React Hooks as a modern way to organize React Application.\n\nIf you are using use only Functional Components with React Hooks, you can use instead of to reduce size bundle. If you are using Class-based components and Functional components, please use only which includes and uses it automatically for function components.\n\nReact Context replaces the Legacy Context which was fairly awkward to use. In simple words, React Context is used to store some data in one place and use it all over the app. Previously, Mobx had pattern, but currently this pattern is deprecated and we must use only one way - Context. And again, it's not mandatory to use React Context with Mobx but it's recommended now officially on the website. You can read more info about it here - Why is Store Injecting obsolete?\n\nAnd Class based Component will be:\n\nThis one is an elegant way to use Stores inside Components. If you want to use , the code will be:\n\nWe add a function to help us to get the stores inside the React Functional Components. Using that React provides us, we pass the previously created context to it and get the value we spicified.\n\nIf you want to use functional components, you need to use only function from bindings and hook of our Application:\n\nServices layer is the place of communications with Backend, 3rd API. Don't call your REST API Interfaces from within your stores. It really makes them hard to test your code. Instead of, please put these API Calls into extra classes (Services) and pass these instances to each store using the store's constructor. When you write tests, you can easily mock these API calls and pass your mock API Instance to each store.\n\nFor example, we need a class where we can use API and this class is . I use Singleton pattern because I want just a single instance available to all Stores.\n\nAnd you can use in your Stores in this way:\n\nTo sum up, this guide shows how we can connect React with Hooks and Classes with Mobx and TypeScript. I think this combination of MVC pattern with Mobx, React and TypeScript produces highly typed, straightforward and scalable code.\n\nThe source code will be available on my github & will be under the MIT License for your using when I'll publish the second part of the article series.\n\nI hope this walkthrough was interesting and you can could find some information that helped in your projects. If you have any feedback or something else, please write to me on twitter and we will discuss any moments.\n‚Ä¢ Best Practices for building large scale maintainable projects with Mobx"
    },
    {
        "link": "https://reddit.com/r/reactjs/comments/1dh55xa/as_an_experienced_react_developer_do_you_use",
        "document": "I've been developing React and Next applications for around 5 years now. I started with class-based components, but I never use them these days. Infact, last time I used class-based components in my React project was back in 2019. I've been exclusively using functional components with hooks ever since.\n\nIs it weird that I haven't used class-based components for so long? As a seasonal React developer do you stick to one architecture or do you like to experiment with different architectures?"
    },
    {
        "link": "https://mobx.js.org/react-integration.html",
        "document": "While MobX works independently from React, they are most commonly used together. In The gist of MobX you have already seen the most important part of this integration: the HoC that you can wrap around a React component.\n\nis provided by a separate React bindings package you choose during installation. In this example, we're going to use the more lightweight package.\n\nHint: you can play with the above example yourself on CodeSandbox.\n\nThe HoC automatically subscribes React components to any observables that are used during rendering. As a result, components will automatically re-render when relevant observables change. It also makes sure that components don't re-render when there are no relevant changes. So, observables that are accessible by the component, but not actually read, won't ever cause a re-render.\n\nIn practice this makes MobX applications very well optimized out of the box and they typically don't need any additional code to prevent excessive rendering.\n\nFor to work, it doesn't matter how the observables arrive in the component, only that they are read. Reading observables deeply is fine, complex expression like work out of the box. This makes the subscription mechanism much more precise and efficient compared to other frameworks in which data dependencies have to be declared explicitly or be pre-computed (e.g. selectors).\n\nThere is great flexibility in how state is organized, since it doesn't matter (technically that is) which observables we read or where observables originated from. The examples below demonstrate different patterns on how external and local observable state can be used in components wrapped with .\n\nSince observables used by can come from anywhere, they can be local state as well. Again, different options are available for us.\n\nYou might not need locally observable state\n\nIn general, we recommend to not resort to MobX observables for local component state too quickly, as this can theoretically lock you out of some features of React's Suspense mechanism. As a rule of thumb, use MobX observables when the state captures domain data that is shared among components (including children). Such as todo items, users, bookings, etc.\n\nState that only captures UI state, like loading state, selections, etc, might be better served by the hook, since this will allow you to leverage React suspense features in the future.\n\nUsing observables inside React components adds value as soon as they are either 1) deep, 2) have computed values or 3) are shared with other components.\n\nYou might be wondering, when do I apply ? The rule of thumb is: apply to all components that read observable data.\n\nonly enhances the component you are decorating, not the components called by it. So usually all your components should be wrapped by . Don't worry, this is not inefficient. On the contrary, more components make rendering more efficient as updates become more fine-grained.\n\nTip: Grab values from objects as late as possible\n\nworks best if you pass object references around as long as possible, and only read their properties inside the based components that are going to render them into the DOM / low-level components. In other words, reacts to the fact that you 'dereference' a value from an object.\n\nIn the above example, the component would not react to future changes if it was defined as follows, because the is not read inside the component, but outside, and is hence not tracked:\n\nNote that this is a different mindset from other libraries like , where it is a good practice to dereference early and pass primitives down, to better leverage memoization. If the problem is not entirely clear, make sure to check out the Understanding reactivity section.\n\nComponents wrapped with only subscribe to observables used during their own rendering of the component. So if observable objects / arrays / maps are passed to child components, those have to be wrapped with as well. This is also true for any callback based components.\n\nIf you want to pass observables to a component that isn't an , either because it is a third-party component, or because you want to keep that component MobX agnostic, you will have to convert the observables to plain JavaScript values or structures before passing them on.\n\nTo elaborate on the above, take the following example observable object, a component (observer) and an imaginary component that takes a column / value mapping, but which isn't an :\n\nImagine the same example, where takes an callback instead. Since is part of the rendering cycle of , rather than 's render (even though that is where it syntactically appears), we have to make sure that the callback component uses an component. Or, we can create an in-line anonymous observer using :\n\nIf is used in server side rendering context; make sure to call , so that won't subscribe to any observables used, and no GC problems are introduced.\n\nIn this documentation we used as default. mobx-react is it's big brother, which uses under the hood. It offers a few more features which are typically not needed anymore in greenfield projects. The additional things offered by mobx-react:\n‚Ä¢ and . MobX's own React.createContext predecessor which is not needed anymore.\n\nNote that fully repackages and re-exports , including functional component support. If you use , there is no need to add as a dependency or import from it anywhere.\n\nautomatically applies , so components never need to be wrapped in . can be applied safely to observer components because mutations (deeply) inside the props will be picked up by anyway if relevant.\n\nAs stated above, class based components are only supported through , and not . Briefly, you can wrap class-based components in just like you can wrap function components:\n\nCheck out mobx-react docs for more information.\n\nReact DevTools uses the display name information of components to properly display the component hierarchy.\n\nIf you use:\n\nthen no display name will be visible in the DevTools.\n\nThe following approaches can be used to fix this:\n‚Ä¢ None use with a name instead of an arrow function. infers component name from the function name:\n‚Ä¢ None Transpilers (like Babel or TypeScript) infer component name from the variable name:\n‚Ä¢ None Infer from the variable name again, using default export:\n‚Ä¢ This is broken in React 16 at the time of writing; mobx-react uses a React.memo and runs into this bug: https://github.com/facebook/react/issues/18026, but it will be fixed in React 17.\n\nNow you can see component names:\n\n{üöÄ} Tip: when combining with other higher-order-components, apply first\n\nWhen needs to be combined with other decorators or higher-order-components, make sure that is the innermost (first applied) decorator; otherwise it might do nothing at all.\n\nIn some cases the computed values of your local observables might depend on some of the props your component receives. However, the set of props that a React component receives is in itself not observable, so changes to the props won't be reflected in any computed values. You have to manually update local observable state in order to properly derive computed values from latest data.\n\nIn practice you will rarely need this pattern, since is a much simpler, albeit slightly less efficient solution.\n\ncan be used to set up side effects that need to happen, and which are bound to the life-cycle of the React component. Using requires specifying dependencies. With MobX that isn't really needed, since MobX has already a way to automatically determine the dependencies of an effect, . Combining and coupling it to the life-cycle of the component using is luckily straightforward:\n\nNote that we return the disposer created by from our effect function. This is important, since it makes sure the gets cleaned up once the component unmounts!\n\nThe dependency array can typically be left empty, unless a non-observable value should trigger a re-run of the autorun, in which case you will need to add it there. To make your linter happy, you can define (in the above example) as a dependency. That is safe and has no further effect, since the reference will never actually change.\n\nIf you'd rather explicitly define which observables should trigger the effect, use instead of , beyond that the pattern remains identical.\n\nHow can I further optimize my React components?\n‚Ä¢ Make sure you didn't forget (yes, this is the most common mistake).\n‚Ä¢ Verify that the thing you intend to react to is indeed observable. Use utilities like , if needed to verify this at runtime.\n‚Ä¢ Check the console logs in the browsers for any warnings or errors.\n‚Ä¢ Make sure you grok how tracking works in general. Check out the Understanding reactivity section.\n‚Ä¢ Read the common pitfalls as described above.\n‚Ä¢ Configure MobX to warn you of unsound usage of mechanisms and check the console logs.\n‚Ä¢ Use trace to verify that you are subscribing to the right things or check what MobX is doing in general using spy / the mobx-log package."
    },
    {
        "link": "https://stackoverflow.com/questions/48437102/mobx-why-should-i-use-observer-when-i-could-use-inject-when-injecting-data",
        "document": "I believe you are correct in your assessment. Let me try to rephrase for clarity:\n\ntracks which observables are used by and automatically re-renders the component when one of these values changes.\n\nWe should note that values used by might be deeply nested within a given , per your example:\n\nAlthough there's a quirk with , as you'll see in a moment...\n\nOn the other hand you have which makes available to a component (via ) specific data structures defined by a .\n\nwill only spawn a re-render if the itself has recognized changes.\n\nThis is effectively the same issue with shouldComponentUpdate() and a deep-comparison of -- though seems to be far more efficient than .\n\nI wouldn't necessarily go that far... it all depends on how you have your code structured.\n\nIf I modify your original example as so:\n\n...the addition of won't actually get picked up as an observable change (i.e. re-render) because that property didn't exist when we originally tagged as an observable value. So that's one problem.\n\nA different approach could be to do something like this:\n\nThis allows you to spread the observable values out across classes -- so you might still want to inject into a component (to access but ultimately any observable changes come from updating ."
    },
    {
        "link": "https://github.com/mobxjs/mobx-react/issues/553",
        "document": "I'm new to MobX and I'm wondering why I should use the inject decorator instead of directly using my stores. (I'm using typescript, but that doesn't affect anything). Both of the examples have the same result. I do understand that injecting stores in a 'Dependency Injection' kind of way improves testability, but this can also be done by mocking imports (https://jestjs.io/docs/en/es6-class-mocks). Am I missing something?\n\nI also have to pass the rootStore to the Provider\n\nI don't have to create a rootStore, all stores are imported in the components that use them."
    },
    {
        "link": "https://github.com/mobxjs/mobx-react",
        "document": "Package with React component wrapper for combining React with MobX. Exports the decorator and other utilities. For documentation, see the MobX project. There is also work-in-progress user guide for additional information. This package supports both React and React Native.\n\nThere are currently two actively maintained versions of mobx-react:\n\nmobx-react 6 / 7 is a repackage of the smaller mobx-react-lite package + following features from the package added:\n‚Ä¢ Support for class based components for and\n‚Ä¢ to pass stores around (but consider to use instead)\n‚Ä¢ to describe observable based property checkers (but consider to use TypeScript instead)\n‚Ä¢ The utility / decorator to easily clean up resources such as reactions created in your class based components.\n\nThis package provides the bindings for MobX and React. See the official documentation for how to get started.\n\nFor greenfield projects you might want to consider to use mobx-react-lite, if you intend to only use function based components. can be used to pass stores around.\n\nPlease check mobx.js.org for the general documentation. The documentation below highlights some specifics.\n\nFunction (and decorator) that converts a React component definition, React component class, or stand-alone render function, into a reactive component. A converted component will track which observables are used by its effective and automatically re-render the component when one of these values changes.\n\nis automatically applied to functional components provided to . does not accept a functional component already wrapped in , or an , in order to avoid consequences that might arise as a result of wrapping it twice.\n\nWhen using component classes, and will be made observables, so the component will react to all changes in props and state that are used by .\n\nis not supported. As such, it is recommended that class components extend . The will automatically patch non-pure class components with an internal implementation of if necessary.\n\nSee the MobX documentation for more details.\n\nis a React component, which applies to an anonymous region in your component. It takes as children a single, argumentless function which should return exactly one React component. The rendering in the function will be tracked and automatically re-rendered when needed. This can come in handy when needing to pass render function to external components (for example the React Native listview), or if you dislike the decorator / function.\n\nIn case you are a fan of render props, you can use that instead of children. Be advised, that you cannot use both approaches at once, children have a precedence. Example\n\nLocal observable state can be introduced by using the hook, that runs once to create an observable store. A quick example would be:\n\nWhen using , all properties of the returned object will be made observable automatically, getters will be turned into computed properties, and methods will be bound to the store and apply mobx transactions automatically. If new class instances are returned from the initializer, they will be kept as is.\n\nIt is important to realize that the store is created only once! It is not possible to specify dependencies to force re-creation, nor should you directly be referring to props for the initializer function, as changes in those won't propagate.\n\nInstead, if your store needs to refer to props (or based local state), the should be combined with the hook, see below.\n\nNote that in many cases it is possible to extract the initializer function to a function outside the component definition. Which makes it possible to test the store itself in a more straight-forward manner, and avoids creating the initializer closure on each re-render.\n\nNote: using is mostly beneficial for really complex local state, or to obtain more uniform code base. Note that using a local store might conflict with future React features like concurrent rendering.\n\nWhen using server side rendering, normal lifecycle hooks of React components are not fired, as the components are rendered only once. Since components are never unmounted, components would in this case leak memory when being rendered server side. To avoid leaking memory, call when using server side rendering.\n\nThis makes sure the component won't try to react to any future data changes.\n\nThe simple rule of thumb is: all components that render observable data. If you don't want to mark a component as observer, for example to reduce the dependencies of a generic component package, make sure you only pass it plain data.\n\nDecorators are currently a stage-2 ESNext feature. How to enable them is documented here.\n\nSee this thread. TL;DR: the conceptual distinction makes a lot of sense when using MobX as well, but use on all components.\n\nMobX-react provides the following additional which can be used to validate against MobX structures:\n\nUse to import them, then use for example\n\nSee also the migration guide to React Hooks.\n\nNote: usually there is no need anymore to use / in new code bases; most of its features are now covered by .\n\nis a component that can pass stores (or other stuff) using React's context mechanism to child components. This is useful if you have things that you don't want to pass through multiple layers of components explicitly.\n\ncan be used to pick up those stores. It is a higher order component that takes a list of strings and makes those stores available to the wrapped component.\n\nExample (based on the official context docs):\n‚Ä¢ It is possible to read the stores provided by using , by using the context that can be imported from .\n‚Ä¢ If a component asks for a store and receives a store via a property with the same name, the property takes precedence. Use this to your advantage when testing!\n‚Ä¢ When using both and , make sure to apply them in the correct order: should be the inner decorator, the outer. There might be additional decorators in between.\n‚Ä¢ The original component wrapped by is available as the property of the created higher order component.\n\nValues provided through should be final. Make sure that if you put things in that might change over time, that they are or provide some other means to listen to changes, like callbacks. However, if your stores will change over time, like an observable value of another store, MobX will throw an error. This restriction exists mainly for legacy reasons. If you have a scenario where you need to modify the set of stores, please leave a comment about it in this issue #745. Or a preferred way is to use React Context directly which does not have this restriction.\n\nThe above example in ES5 would start like:\n\nA functional stateless component would look like:\n\nInstead of passing a list of store names, it is also possible to create a custom mapper function and pass it to inject. The mapper function receives all stores as argument, the properties with which the components are invoked and the context, and should produce a new set of properties, that are mapped into the original:\n\nSince version 4.0 the itself is tracked as well, so it is possible to do things like:\n\nN.B. note that in this specific case neither nor needs to be decorated with , since the observable dereferencing is done in the mapper function\n\nInject wraps a new component around the component you pass into it. This means that assigning a static property to the resulting component, will be applied to the HoC, and not to the original component. So if you take the following example:\n\nThe above propTypes are incorrect, needs to be provided by the caller of the component and is checked by React. However, does not need to be required! Although it is required for the original stateless function component, it is not required for the resulting inject component. After all, the whole point of that component is to provide that itself.\n\nSo if you want to make assertions on the data that is being injected (either stores or data resulting from a mapper function), the propTypes should be defined on the wrapped component. Which is available through the static property on the inject component:\n\nThe same principle applies to and other static React properties. Note that it is not allowed to redefine on components (but is possible to define it on )\n\nFinally, mobx-react will automatically move non React related static properties from wrappedComponent to the inject component so that all static fields are actually available to the outside world without needing .\n\nalso accepts a function ( ) that can be used to pick all the desired stores from the available stores like this. The will be merged into the original before being provided to the next component.\n\nMake sure to mark as an optional property. It should not (necessarily) be passed in by parent components at all!\n\nNote: If you have strict null checking enabled, you could muffle the nullable type by using the operator:\n\nBy migrating to React Hooks you can avoid problems with TypeScript.\n\nIt is allowed to pass any declared store in directly as a property as well. This makes it easy to set up individual component tests without a provider.\n\nSo if you have in your app something like:\n\nIn your test you can easily test the component by passing the necessary store as prop directly:\n\nBear in mind that using shallow rendering won't provide any useful results when testing injected components; only the injector will be rendered. To test with shallow rendering, instantiate the instead:\n\nFunction (and decorator) that makes sure a function (usually a disposer such as the ones returned by , , etc.) is automatically executed as part of the componentWillUnmount lifecycle event.\n\nand higher are no longer compatible with the mobx-react-devtools. That is, the MobX react devtools will no longer show render timings or dependency trees of the component. The reason is that the standard React devtools are also capable of highlighting re-rendering components. And the dependency tree of a component can now be inspected by the standard devtools as well, as shown in the image below:\n\nShould I use for each component?\n\nYou should use on every component that displays observable data. Even the small ones. allows components to render independently from their parent and in general this means that the more you use , the better the performance become. The overhead of itself is negligible. See also Do child components need ?\n\nI see React warnings about / from React\n\nThe following warning will appear if you trigger a re-rendering between instantiating and rendering a component:\n\nUsually this means that (another) component is trying to modify observables used by this components in their or methods. This violates the React Lifecycle, should be used instead if state needs to be modified before mounting."
    },
    {
        "link": "https://stackoverflow.com/questions/54393475/correct-way-of-creating-multiple-stores-with-mobx-and-injecting-it-into-to-a-com",
        "document": "As suggested here in the Mobx documentation I have created multiple stores in the following manner:\n\nAnd finally creating a root store in the following manner. Also I prefer to construct children stores within master's store constructor. Moreover, I found that sometimes my child store has to observe some data from parent store, so I pass this into child constructors\n\nProviding to the App in following manner:\n\nAnd injecting to the component in like this:\n\nQuestion 1: Is it this the correct and most efficient way to inject the root store into the component every time even if it needs a part of the root store?\n\nQuestion 2: If not, what is the best way to inject the auth store into the user component?\n\nEDIT: I have made an answer concluding the github discussion. Link of the discussion provided in the answer"
    },
    {
        "link": "https://legacy.reactjs.org/docs/code-splitting.html",
        "document": "Most React apps will have their files ‚Äúbundled‚Äù using tools like Webpack, Rollup or Browserify. Bundling is the process of following imported files and merging them into a single file: a ‚Äúbundle‚Äù. This bundle can then be included on a webpage to load an entire app at once.\n\nIf you‚Äôre using Create React App, Next.js, Gatsby, or a similar tool, you will have a Webpack setup out of the box to bundle your app.\n\nIf you aren‚Äôt, you‚Äôll need to set up bundling yourself. For example, see the Installation and Getting Started guides on the Webpack docs.\n\nBundling is great, but as your app grows, your bundle will grow too. Especially if you are including large third-party libraries. You need to keep an eye on the code you are including in your bundle so that you don‚Äôt accidentally make it so large that your app takes a long time to load.\n\nTo avoid winding up with a large bundle, it‚Äôs good to get ahead of the problem and start ‚Äúsplitting‚Äù your bundle. Code-Splitting is a feature supported by bundlers like Webpack, Rollup and Browserify (via factor-bundle) which can create multiple bundles that can be dynamically loaded at runtime.\n\nCode-splitting your app can help you ‚Äúlazy-load‚Äù just the things that are currently needed by the user, which can dramatically improve the performance of your app. While you haven‚Äôt reduced the overall amount of code in your app, you‚Äôve avoided loading code that the user may never need, and reduced the amount of code needed during the initial load.\n\nThe best way to introduce code-splitting into your app is through the dynamic syntax.\n\nWhen Webpack comes across this syntax, it automatically starts code-splitting your app. If you‚Äôre using Create React App, this is already configured for you and you can start using it immediately. It‚Äôs also supported out of the box in Next.js.\n\nIf you‚Äôre setting up Webpack yourself, you‚Äôll probably want to read Webpack‚Äôs guide on code splitting. Your Webpack config should look vaguely like this.\n\nWhen using Babel, you‚Äôll need to make sure that Babel can parse the dynamic import syntax but is not transforming it. For that you will need @babel/plugin-syntax-dynamic-import.\n\nThe function lets you render a dynamic import as a regular component.\n\nThis will automatically load the bundle containing the when this component is first rendered.\n\ntakes a function that must call a dynamic . This must return a which resolves to a module with a export containing a React component.\n\nThe lazy component should then be rendered inside a component, which allows us to show some fallback content (such as a loading indicator) while we‚Äôre waiting for the lazy component to load.\n\nThe prop accepts any React elements that you want to render while waiting for the component to load. You can place the component anywhere above the lazy component. You can even wrap multiple lazy components with a single component.\n\nAny component may suspend as a result of rendering, even components that were already shown to the user. In order for screen content to always be consistent, if an already shown component suspends, React has to hide its tree up to the closest boundary. However, from the user‚Äôs perspective, this can be disorienting.\n\nIn this example, if tab gets changed from to , but suspends, the user will see a glimmer. This makes sense because the user no longer wants to see , the component is not ready to render anything, and React needs to keep the user experience consistent, so it has no choice but to show the above.\n\nHowever, sometimes this user experience is not desirable. In particular, it is sometimes better to show the ‚Äúold‚Äù UI while the new UI is being prepared. You can use the new API to make React do this:\n\nHere, you tell React that setting tab to is not an urgent update, but is a transition that may take some time. React will then keep the old UI in place and interactive, and will switch to showing when it is ready. See Transitions for more info.\n\nIf the other module fails to load (for example, due to network failure), it will trigger an error. You can handle these errors to show a nice user experience and manage recovery with Error Boundaries. Once you‚Äôve created your Error Boundary, you can use it anywhere above your lazy components to display an error state when there‚Äôs a network error.\n\nDeciding where in your app to introduce code splitting can be a bit tricky. You want to make sure you choose places that will split bundles evenly, but won‚Äôt disrupt the user experience.\n\nA good place to start is with routes. Most people on the web are used to page transitions taking some amount of time to load. You also tend to be re-rendering the entire page at once so your users are unlikely to be interacting with other elements on the page at the same time.\n\nHere‚Äôs an example of how to setup route-based code splitting into your app using libraries like React Router with .\n\ncurrently only supports default exports. If the module you want to import uses named exports, you can create an intermediate module that reexports it as the default. This ensures that tree shaking keeps working and that you don‚Äôt pull in unused components."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/react-react-loadable",
        "document": "Code splitting is a technique used more in more with modern web app development that allows to load chunks of code only when needed. For example, with route-based code splitting, a user can be navigating to different routes of an app and behind the scenes the code for each route only loads upon accessing for the first time. With code splitting, only the minimal amount of code can be loaded when the app initializes and additional code is loaded on demand. This can help tremendously with performance by allowing for a reduced initial bundle size.\n\nReact Loadable is a library by @jamiebuilds that makes it easy to implement code splitting in React and that embraces React‚Äôs component model. It accomplish its magic using dynamic imports and webpack automatically splits dynamic imports into separate chunks when bundling.\n\nLet‚Äôs quickly go over how to use React Loadable.\n\nJust add the package to your project using npm or Yarn:\n\nLet‚Äôs create a contrived example to illustrate how simple Loadable is. First, :\n\nAnd then let‚Äôs use it in our component:\n\nNotice how the component is only rendered into the view once the user clicks on the button. Obviously with such a simple component it doesn‚Äôt make a difference, but with larger components in an app that‚Äôs non-trivial, code-splitting that component away can be a good idea.\n\nThe higher-order component takes an object with two keys: and :\n‚Ä¢ loader: Expects a function that returns a promise that resolves to a React component. Dynamic imports using return a promise, so all we have to do is point to the location of the component to load.\n‚Ä¢ loading: Expects a component to render while the code is being loaded.\n\nAnd it‚Äôs as easy as that! If you have a look at the Network tab in your browser‚Äôs Devtools, you‚Äôll see the chunk being loaded when the button is clicked.\n\nIf components are loaded quickly, having an intermediary loading component can become a source of visual annoyance in the UI. Luckily, Loadable provides an easy workaround in the form of a prop that‚Äôs passed to the loading component and that evaluates to true once a certain delay has passed:\n\nThe default delay is 200ms, but you can change that by passing a config to the Loadable HOC. Here for example we change the maximum delay to 60ms:\n\nAnother prop gets passed-in to the loading component, , which makes it easy to render something else if an error occurs while trying to load the component:\n\nOftentimes the easiest way to code-split an app is at the route level. Since routes in React when using React Router v4 are just components, it‚Äôs just as easy to use React Loadable to load the code for the different routes on-demand.\n\nHere we‚Äôll go over a simple example of route-based code splitting using React Loadable. First, make sure that we also have available in our project:\n\nIn the following example, we import the component statically as it‚Äôll be needed immediately on the root route and we use Loadable to only load the and components when their respective route is activated:\n\nüèá And with this, you should be off to the races with code splitting! Have a look at the project‚Äôs Readme for a mode in-depth look at the API and for documentation on advanced topics such as server-side rendering."
    },
    {
        "link": "https://medium.com/@sushilkundu143/implementing-code-splitting-with-loadable-component-and-react-router-6-9e3e7c7a8c2e",
        "document": "In modern web development, optimizing the performance of React applications is crucial for delivering a smooth user experience. Code splitting is an effective technique that allows us to load only the necessary JavaScript code when required. In this technical blog post, we will explore how to implement code splitting using Loadable Component and React Router 6. We will cover dynamic imports, fallback UI with suspense, specifying chunk names, and provide examples for home, about, login, and signup routes.\n\nLoadable Component and React Router 6 are powerful tools for implementing code splitting in React applications. By utilizing dynamic imports, providing fallback UI with suspense, and specifying chunk names, we can significantly enhance our application‚Äôs performance. Implementing code splitting with Loadable Component and React Router 6 allows for efficient loading of necessary code chunks, resulting in faster initial page loads and improved user experiences.\n\na. Code splitting optimizes performance by loading only necessary code. \n\nb. Loadable Component simplifies code splitting implementation in React.\n\nc. React Router 6 provides a convenient way to define and manage routes.\n\ne. Fallback UI with suspense ensures a better user experience during component loading.\n\nf. Specifying chunk names helps with debugging and tracking loaded code chunks.\n\na. Dynamic Imports: Dynamic imports allow us to load components asynchronously when they are needed in our application. We can leverage Loadable Component to easily implement dynamic imports in React. Here‚Äôs an example of dynamically importing a component:\n\nb. Fallback UI with Suspense: While the dynamically imported components are being loaded, we can provide a fallback UI to maintain a seamless user experience. By using React‚Äôs component, we can achieve this easily. Here's an example:\n\nc. Specifying Chunk Names: Assigning meaningful names to code chunks is beneficial for debugging and tracking purposes. Loadable Component allows us to specify chunk names using the comment. Here's an example:\n\nLet‚Äôs consider a scenario where we have a React application with four routes: home, about, login, and signup. We can implement code splitting for each route using Loadable Component (using Suspense, ChunkName, dynamic Import & fallback UI) and React Router 6.\n\nThe code imports the necessary modules: from , from , and , , and from .\n\nis a function provided by Loadable Component that allows us to dynamically import components. Here, we use it to create separate chunks for each component: , , , and . Each component is imported dynamically using the function, and we specify the chunk names using the comment. Make sure the file paths for the components are correct.\n\nThe function is the root component of the application.\n\nis a component provided by React that allows us to specify a fallback UI while the dynamic components are being loaded. In this case, we provide a simple fallback UI with the text \"Loading...\" wrapped in a .\n\nsets up the routing functionality for the application using React Router.\n\nis used to define the routes within the application.\n\nis used to define individual routes. Each specifies a attribute and an attribute, which represents the component to render when the corresponding route is accessed. Here, we map the routes to the dynamically imported components , , , and .\n\nMake sure to install the necessary dependencies ( , , and ) and import them correctly in your project.\n\nLoadable Component combined with React Router 6 offers a powerful solution for implementing code splitting in React applications. By utilizing dynamic imports, providing fallback UI with suspense, and specifying chunk names, we can significantly optimize performance and deliver faster initial page loads. Proper code splitting helps improve user experiences by ensuring that only the necessary code is loaded, resulting in reduced load times and enhanced responsiveness.\n\nIn this technical blog post, we explored the implementation of code splitting using Loadable Component and React Router 6 in a React application. We discussed the key concepts of dynamic imports, fallback UI with suspense, and specifying chunk names. By following the provided examples and leveraging these powerful tools, developers can optimize the performance of their React applications, delivering faster and more efficient user experiences"
    },
    {
        "link": "https://geeksforgeeks.org/code-splitting-in-react",
        "document": "Code-Splitting is a feature supported by bundlers like Webpack, Rollup, and Browserify which can create multiple bundles that can be dynamically loaded at runtime.\n\nAs websites grow larger and go deeper into components, it becomes heavier. This is especially the case when libraries from third parties are included. Code Splitting is a method that helps to generate bundles that are able to run dynamically. It also helps to make the code efficient because the bundle contains all required imports and files.\n\nBundling and its efficiency: Bundling is the method of combining imported files with a single file. It is done with the help of Webpack, Rollup, and Browserify as they can create many bundles that can be loaded dynamically at runtime.\n\nWith the help of code splitting, ‚Äòlazy load‚Äô can be implemented, which means just using the code which is currently needed.\n‚Ä¢ The default way of importing is as follows:\n‚Ä¢ Using code-splitting this can be done as follows:\n\nAs soon as Webpack gets this type of syntax, code-splitting is started automatically. When using the Create React App, it is already set up and can be used immediately.\n\nThe Webpack guide on code splitting should be followed if using Webpack. The instructions can be found here.\n\nWhen Babel is being used, it has to be made sure that Babel is not transforming the import syntax, but can parse it dynamically. This can be done using babel-plugin-syntax-dynamic-import.\n\nAs both React.lazy and Suspense are not available for rendering on the server yet now, it is recommended to use loadable-components for code-splitting in a server-rendered app. React.lazy is helpful for rendering dynamic import as a regular component.\n\nBefore:\n\nThe Bundle will be loaded on its own which contains the Component when this component is rendered first. \n\nThe Lazy component should then be rendered inside Suspense Component which helps to reflect some fallback content meanwhile the lazy component loads.\n\nThe fallback prop can accept any element of React which will be rendered while waiting for the loading of the Component. The Suspense Component can be placed anywhere above the lazy component. Moreover, multiple lazy components can be wrapped with a single Suspense Component.\n\nError Boundaries are React components that help when some modules fail to load due to any issue, an error will be triggered. These errors can be handled properly and provide a good experience to the user by the use of a suitable error page.\n\nIt can be difficult to implement code-splitting in code, the bundles can be split evenly, which will improve the experience for the user.\n\nHere you can see the example code for this.\n\nReact.lazy currently supports only default exports. An intermediate module that re-exports as default has to be created if one wants to import a module that uses named exports. This ensures the working of tree shaking and prevents the pulling in of unused components."
    },
    {
        "link": "https://medium.com/@atatijr/code-splitting-in-react-applications-21cdbfd3a7a6",
        "document": "This is a continuation of Web performance, code splitting strategies, and a React case study.\n\nIn React applications, we have different approaches to do code splitting. The most common ones are: using , using , and using . All three are very similar in syntax and the result is pretty much the same. Or almost the same. I have used before but it's not maintained anymore, so I won't focus on that. In this post, we'll see examples using as I have never used before.\n\nLet‚Äôs say we have a product with a Home page and a Search, the same way we talked before:\n\nWe want our app to be split into two separate bundles, one for the home and the other for the search.\n\nTo do this using the lib, we can just create loadable components and dynamically import both search and home components.\n\nOne caveat: both and components need to be default exported. If they are only exported using named export, it won't work (not only in , but also in and ).\n\nAfter creating these components, we can use them on our routes. As we want to code split them per page.\n\nIf you are using , the code would look like this:\n\nNow, when the user accesses , it will download only the home bundle and not the search one. If the user accesses , it will be the other way around: downloading the search bundle but not the home.\n\nWe can make sure this works by looking at the network tab on the DevTools. There, you‚Äôll see all JavaScript being downloaded. Don‚Äôt forget to filter by to make it easier to see JavaScript-related bundles only.\n\nCutting JavaScript that is below the fold and putting it in a separate bundle is a pretty nice strategy to reduce the bundle and serve only the necessary JavaScript to the user.\n\nAs we already talked about, we can implement that using the Intersection Observer API. I have already shown a simple code snippet on how to use the API but now I want to show an example in React. The concept is pretty much the same though.\n\nI will show an example using a nice library called . The API is super simple to use and reason about. Take a look at it:\n\nFor any component, we can use this hook and get interesting information from the observer. But the most important ones, at least for our performance case now, are the and the .\n\nThey have a pretty good naming and you can get from it. The is the reference of the component or element you want to observe. We can call it your target element as you need to assign this ref to the DOM element you want to monitor. And the is just a boolean telling you if this target element is in the intersection with the viewport or not.\n\nIf you want to try this out, consider creating a new component, and logging the in the console to see if it's working correctly. Try this out:\n\nNow, every time you reach this component when scrolling down (or up) the page, you see a in the DevTools console. Pretty nice, uh?\n\nNow, back to the code splitting strategy. Imagine you have this ‚Äúbelow the fold‚Äù component:\n\nWe want to download the JavaScript only when the user reaches this component that‚Äôs below the fold, right? The first step is to extract this component into a separate bundle. We do that the same way we did for the code splitting by page strategy, using the .\n\nExtract the component into a new file and default export it:\n\nCreate a loadable component that will dynamically import it\n\nWith that, we can now use it in the target element we will be monitoring.\n\nAgain using the hook, assigning the to the target DOM element, and using the boolean to know if the component is in the intersection with the viewport or not. If it's, it will evaluate to and render the . Now the loadable will dynamically import the \"below the fold\" component, the browser will download the separate bundle, and it will be rendered for the user.\n\nIt‚Äôs just a small example but it shows the whole concept. We can use it for any other type of component that‚Äôs below the fold. We can make the bundle more granular or put everything in the same ‚Äúbelow the fold‚Äù bundle.\n\nThe conditional content is very similar to the below the fold strategy. The concept is to code split components that are not visible in the first render, create a new separate bundle for them, and download them when the user wants to see this content.\n\nOne common example is Modals (or overlays, or dialogs, ‚Ä¶ so many names for the same thing‚ùì). In the first load, the modal shouldn‚Äôt be downloaded together with the main bundle. The user doesn‚Äôt even know if exists yet. So we separate it into a new bundle and when the user clicks something to open this modal, we download it, and render it to the screen.\n\nTo the code! We start separating the modal component into a new file:\n\nNow we create the loadable:\n\nWith the two components created, now we should just render this modal when it should be open. If it‚Äôs not open, we don‚Äôt want to penalize the user with more JavaScript being downloaded. We can even use the flag to handle this condition for when to load and render the modal or not."
    }
]