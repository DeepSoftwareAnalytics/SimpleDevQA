[
    {
        "link": "https://docs.python-telegram-bot.org/en/v13.13",
        "document": "If you‚Äôre just starting out with the library, we recommend following our ‚ÄúYour first Bot‚Äù tutorial that you can find on our wiki. On our wiki you will also find guides like how to use handlers, webhooks, emoji, proxies and much more.\n\nA great way to learn is by looking at examples. Ours can be found in our examples folder on Github."
    },
    {
        "link": "https://docs.python-telegram-bot.org/en/v13.0",
        "document": "If you‚Äôre just starting out with the library, we recommend following our ‚ÄúYour first Bot‚Äù tutorial that you can find on our wiki. On our wiki you will also find guides like how to use handlers, webhooks, emoji, proxies and much more.\n\nA great way to learn is by looking at examples. Ours can be found at our github in the examples folder."
    },
    {
        "link": "https://pypi.org/project/python-telegram-bot/13.14",
        "document": "A required part of this site couldn‚Äôt load. This may be due to a browser extension, network issues, or browser settings. Please check your connection, disable any ad blockers, or try using a different browser."
    },
    {
        "link": "https://media.readthedocs.org/pdf/python-telegram-bot/latest/python-telegram-bot.pdf",
        "document": ""
    },
    {
        "link": "https://pypi.org/project/python-telegram-bot/13.15",
        "document": "A required part of this site couldn‚Äôt load. This may be due to a browser extension, network issues, or browser settings. Please check your connection, disable any ad blockers, or try using a different browser."
    },
    {
        "link": "https://medium.com/@moraneus/building-telegram-bot-with-python-telegram-bot-a-comprehensive-guide-7e33f014dc79",
        "document": "Creating a Telegram bot can significantly extend the functionality of your messaging experience, allowing for everything from automated responses to sophisticated interactions. This comprehensive guide will walk you through the process of building a basic Telegram bot with Python, incorporating user commands, message handling, and custom keyboards. We‚Äôll use the library for its simplicity and powerful features.\n\nIn this article, I will demonstrate a very simple Car Sales Listing Bot that is designed to streamline the process of gathering some necessary information from users wishing to list their cars for sale. By engaging in a structured conversation, the bot collects details such as the car‚Äôs type, color, and mileage, and even allows for photo uploads, culminating in a summary that confirms the listing‚Äôs details.\n‚Ä¢ Ability to upload a photo of the car.\n‚Ä¢ Summary of the listing details for confirmation.\n‚Ä¢ Create Your Bot: Open Telegram and search for the ‚ÄúBotFather‚Äù account. Start a conversation and use the command to create a new bot. Follow the prompts to set up your bot's name and username. BotFather will then give you a token, which is crucial for accessing the Telegram Bot API. Keep this token secure and do not share it.\n\nNow, let‚Äôs dive into coding your bot. Please create a new Python file, e.g., and open it in your favorite text editor. Then, follow these steps to write your bot.\n\nStart by importing necessary modules and setting up logging to help with debugging:\n\nStates in a Telegram bot, especially when using a conversation handler, serve as a framework to manage the flow of interaction between the bot and the user. They are essentially markers or checkpoints that define what part of the conversation the user is currently engaged with and determine what the bot should do next based on the user‚Äôs input. Here‚Äôs a more general overview of the role and functionality of states in managing bot conversations. The purpose and functionality of states in the Telegram bot are:\n‚Ä¢ Sequential Flow Management: States allow the bot to manage a sequential flow of conversation. By moving from one state to another, the bot can guide the user through a series of steps, questions, or options in a logical order.\n‚Ä¢ Context Awareness: They help the bot maintain context in a conversation. By knowing the current state, the bot understands what information has been provided by the user and what information is still needed, enabling it to respond appropriately.\n‚Ä¢ User Input Processing: Based on the current state, the bot can process user inputs differently. For example, an input in the ‚ÄúCAR_TYPE‚Äù state would be understood as the user specifying the type of car they‚Äôre selling, while the same input in the ‚ÄúCAR_COLOR‚Äù state would be interpreted as the color of the car.\n‚Ä¢ Conditional Logic Implementation: States allow for the implementation of conditional logic in the conversation. Depending on user responses or choices, the bot can decide to skip certain states, repeat them, or take the user down a different conversational path.\n‚Ä¢ Error Handling and Repetition: They facilitate error handling and the repetition of questions if the user provides unexpected or invalid responses. By keeping track of the current state, the bot can re-prompt the user for information correctly.\n‚Ä¢ State Persistence: In more complex bots, states can be stored and persisted across sessions, allowing users to pick up the conversation where they left off, even if they temporarily leave the chat or if the bot restarts.\n\nLet‚Äôs enumerate the states for our bot to manage the flow:\n\nConversation handlers in Telegram bots, particularly when using libraries like , are powerful tools that manage the flow of conversations based on user inputs and predefined states. They are crucial for developing bots that require a sequence of interactions, such as collecting information, guiding users through menus, or executing commands in a specific order. Here's a closer look at how conversation handlers work and their role in bot development:\n‚Ä¢ Managing Conversational States: Conversation handlers keep track of the current state of the dialogue with each user. They determine what the bot should do next based on the user‚Äôs input and the current state, allowing for a smooth and logical progression through different stages of interaction.\n‚Ä¢ Routing User Inputs: They route user inputs to different callback functions based on the current state. This means that the same input can lead to different outcomes depending on where the user is in the conversation flow.\n‚Ä¢ Handling Commands and Text: Conversation handlers can differentiate between commands (like or ) and regular text messages, allowing developers to specify distinct responses or actions for each type of input.\n‚Ä¢ Integrating with Keyboards and Buttons: They work seamlessly with custom keyboards and inline buttons, enabling developers to create interactive and user-friendly interfaces within the conversation. Users can select options or navigate through the bot‚Äôs features using these UI elements.\n‚Ä¢ Fallbacks and Timeouts: Conversation handlers support fallback functions, which can be triggered when the user sends unexpected input or when the conversation needs to be reset. They can also handle timeouts, ending a conversation automatically after a period of inactivity.\n‚Ä¢ Entry Points: These are triggers that start the conversation. Commonly, the command is used as an entry point, but you can define multiple entry points for different conversation flows.\n‚Ä¢ States: As discussed, states represent different points in the conversation. Each state is associated with one or more callback functions that define the bot‚Äôs behavior at that stage. Developers map states to these callbacks, dictating the flow of the conversation.\n‚Ä¢ Fallbacks: Fallback functions are defined to handle unexpected situations or to provide a way to exit or reset the conversation. A common fallback is a command that allows users to stop the conversation at any point.\n\nFollowing, is the handler function initiates the conversation (entry point), presenting the user with a selection of car types:\n\nHere you can find the rest of the handlers:\n\n\n\nasync def car_type(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Stores the user's car type.\"\"\"\n\n user = update.message.from_user\n\n context.user_data['car_type'] = update.message.text\n\n cars = {\"Sedan\": \"üöó\", \"SUV\": \"üöô\", \"Sport\": \"üèéÔ∏è\", \"Electric\": \"‚ö°\"}\n\n logger.info('Car type of %s: %s', user.first_name, update.message.text)\n\n await update.message.reply_text(\n\n f'<b>You selected {update.message.text} car {cars[update.message.text]}.\n\n'\n\n f'What color your car is?</b>',\n\n parse_mode='HTML',\n\n reply_markup=ReplyKeyboardRemove(),\n\n )\n\n\n\n # Define inline buttons for car color selection\n\n keyboard = [\n\n [InlineKeyboardButton('Red', callback_data='Red')],\n\n [InlineKeyboardButton('Blue', callback_data='Blue')],\n\n [InlineKeyboardButton('Black', callback_data='Black')],\n\n [InlineKeyboardButton('White', callback_data='White')],\n\n ]\n\n reply_markup = InlineKeyboardMarkup(keyboard)\n\n await update.message.reply_text('<b>Please choose:</b>', parse_mode='HTML', reply_markup=reply_markup)\n\n\n\n return CAR_COLOR\n\n\n\n\n\nasync def car_color(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Stores the user's car color.\"\"\"\n\n query = update.callback_query\n\n await query.answer()\n\n context.user_data['car_color'] = query.data\n\n await query.edit_message_text(\n\n text=f'<b>You selected {query.data} color.\n\n'\n\n f'Would you like to fill in the mileage for your car?</b>',\n\n parse_mode='HTML'\n\n )\n\n\n\n # Define inline buttons for mileage decision\n\n keyboard = [\n\n [InlineKeyboardButton('Fill', callback_data='Fill')],\n\n [InlineKeyboardButton('Skip', callback_data='Skip')],\n\n ]\n\n reply_markup = InlineKeyboardMarkup(keyboard)\n\n await query.message.reply_text('<b>Choose an option:</b>', parse_mode='HTML', reply_markup=reply_markup)\n\n\n\n return CAR_MILEAGE_DECISION\n\n\n\n\n\nasync def car_mileage_decision(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Asks the user to fill in the mileage or skip.\"\"\"\n\n query = update.callback_query\n\n await query.answer()\n\n decision = query.data\n\n\n\n if decision == 'Fill':\n\n await query.edit_message_text(text='<b>Please type in the mileage (e.g., 50000):</b>', parse_mode='HTML')\n\n return CAR_MILEAGE\n\n else:\n\n await query.edit_message_text(text='<b>Mileage step skipped.</b>', parse_mode='HTML')\n\n return await skip_mileage(update, context)\n\n\n\n\n\nasync def car_mileage(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Stores the car mileage.\"\"\"\n\n context.user_data['car_mileage'] = update.message.text\n\n await update.message.reply_text('<b>Mileage noted.\n\n'\n\n 'Please upload a photo of your car üì∑, or send /skip.</b>',\n\n parse_mode='HTML')\n\n return PHOTO\n\n\n\n\n\nasync def skip_mileage(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Skips the mileage input.\"\"\"\n\n context.user_data['car_mileage'] = 'Not provided'\n\n\n\n text = '<b>Please upload a photo of your car üì∑, or send /skip.</b>'\n\n\n\n # Determine the correct way to send a reply based on the update type\n\n if update.callback_query:\n\n # If called from a callback query, use the callback_query's message\n\n chat_id = update.callback_query.message.chat_id\n\n await context.bot.send_message(chat_id=chat_id, text=text, parse_mode='HTML')\n\n # Optionally, you might want to acknowledge the callback query\n\n await update.callback_query.answer()\n\n elif update.message:\n\n # If called from a direct message\n\n await update.message.reply_text(text)\n\n else:\n\n # Handle other cases or log an error/warning\n\n logger.warning('skip_mileage was called without a message or callback_query context.')\n\n\n\n return PHOTO\n\n\n\n\n\nasync def photo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Stores the photo.\"\"\"\n\n photo_file = await update.message.photo[-1].get_file()\n\n # Correctly store the file_id of the uploaded photo for later use\n\n context.user_data['car_photo'] = photo_file.file_id # Preserve this line\n\n\n\n # Inform user and transition to summary\n\n await update.message.reply_text('<b>Photo uploaded successfully.\n\n'\n\n 'Let\\'s summarize your selections.</b>',\n\n parse_mode='HTML'\n\n )\n\n await summary(update, context) # Proceed to summary\n\n\n\n\n\nasync def skip_photo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Skips the photo upload.\"\"\"\n\n await update.message.reply_text('<b>No photo uploaded.\n\n'\n\n 'Let\\'s summarize your selections.</b>',\n\n parse_mode='HTML')\n\n await summary(update, context)\n\n\n\n\n\nasync def summary(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Summarizes the user's selections and ends the conversation, including the uploaded image.\"\"\"\n\n selections = context.user_data\n\n # Construct the summary text\n\n summary_text = (f\"<b>Here's what you told me about your car:\n\n</b>\"\n\n f\"<b>Car Type:</b> {selections.get('car_type')}\n\n\"\n\n f\"<b>Color:</b> {selections.get('car_color')}\n\n\"\n\n f\"<b>Mileage:</b> {selections.get('car_mileage')}\n\n\"\n\n f\"<b>Photo:</b> {'Uploaded' if 'car_photo' in selections else 'Not provided'}\")\n\n\n\n chat_id = update.effective_chat.id\n\n\n\n # If a photo was uploaded, send it back with the summary as the caption\n\n if 'car_photo' in selections and selections['car_photo'] != 'Not provided':\n\n await context.bot.send_photo(chat_id=chat_id, photo=selections['car_photo'], caption=summary_text, parse_mode='HTML')\n\n else:\n\n # If no photo was uploaded, just send the summary text\n\n await context.bot.send_message(chat_id=chat_id, text=summary_text, parse_mode='HTML')\n\n\n\n return ConversationHandler.END\n\n\n\n\n\nasync def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Cancels and ends the conversation.\"\"\"\n\n await update.message.reply_text('Bye! Hope to talk to you again soon.', reply_markup=ReplyKeyboardRemove())\n\n return ConversationHandler.END\n\nIn the function, set up the and , including entry points, states, and fallbacks. Start the bot with polling to listen for updates:\n\nComplete your script with a call to the function. Run your bot by executing the Python script in your terminal.\n\nHere you can find the whole code:\n\nimport logging\n\nfrom telegram import (ReplyKeyboardMarkup, ReplyKeyboardRemove, Update,\n\n InlineKeyboardButton, InlineKeyboardMarkup)\n\nfrom telegram.ext import (Application, CallbackQueryHandler, CommandHandler,\n\n ContextTypes, ConversationHandler, MessageHandler, filters)\n\n\n\n# Enable logging\n\nlogging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n\n level=logging.INFO)\n\n\n\nlogger = logging.getLogger(__name__)\n\n\n\n# Define states\n\nCAR_TYPE, CAR_COLOR, CAR_MILEAGE_DECISION, CAR_MILEAGE, PHOTO, SUMMARY = range(6)\n\n\n\n\n\nasync def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Starts the conversation and asks the user about their preferred car type.\"\"\"\n\n reply_keyboard = [['Sedan', 'SUV', 'Sports', 'Electric']]\n\n\n\n await update.message.reply_text(\n\n '<b>Welcome to the Car Sales Listing Bot!\n\n'\n\n 'Let\\'s get some details about the car you\\'re selling.\n\n'\n\n 'What is your car type?</b>',\n\n parse_mode='HTML',\n\n reply_markup=ReplyKeyboardMarkup(reply_keyboard, one_time_keyboard=True, resize_keyboard=True),\n\n )\n\n\n\n return CAR_TYPE\n\n\n\n\n\nasync def car_type(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Stores the user's car type.\"\"\"\n\n user = update.message.from_user\n\n context.user_data['car_type'] = update.message.text\n\n cars = {\"Sedan\": \"üöó\", \"SUV\": \"üöô\", \"Sports\": \"üèéÔ∏è\", \"Electric\": \"‚ö°\"}\n\n logger.info('Car type of %s: %s', user.first_name, update.message.text)\n\n await update.message.reply_text(\n\n f'<b>You selected {update.message.text} car {cars[update.message.text]}.\n\n'\n\n f'What color your car is?</b>',\n\n parse_mode='HTML',\n\n reply_markup=ReplyKeyboardRemove(),\n\n )\n\n\n\n # Define inline buttons for car color selection\n\n keyboard = [\n\n [InlineKeyboardButton('Red', callback_data='Red')],\n\n [InlineKeyboardButton('Blue', callback_data='Blue')],\n\n [InlineKeyboardButton('Black', callback_data='Black')],\n\n [InlineKeyboardButton('White', callback_data='White')],\n\n ]\n\n reply_markup = InlineKeyboardMarkup(keyboard)\n\n await update.message.reply_text('<b>Please choose:</b>', parse_mode='HTML', reply_markup=reply_markup)\n\n\n\n return CAR_COLOR\n\n\n\n\n\nasync def car_color(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Stores the user's car color.\"\"\"\n\n query = update.callback_query\n\n await query.answer()\n\n context.user_data['car_color'] = query.data\n\n await query.edit_message_text(\n\n text=f'<b>You selected {query.data} color.\n\n'\n\n f'Would you like to fill in the mileage for your car?</b>',\n\n parse_mode='HTML'\n\n )\n\n\n\n # Define inline buttons for mileage decision\n\n keyboard = [\n\n [InlineKeyboardButton('Fill', callback_data='Fill')],\n\n [InlineKeyboardButton('Skip', callback_data='Skip')],\n\n ]\n\n reply_markup = InlineKeyboardMarkup(keyboard)\n\n await query.message.reply_text('<b>Choose an option:</b>', parse_mode='HTML', reply_markup=reply_markup)\n\n\n\n return CAR_MILEAGE_DECISION\n\n\n\n\n\nasync def car_mileage_decision(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Asks the user to fill in the mileage or skip.\"\"\"\n\n query = update.callback_query\n\n await query.answer()\n\n decision = query.data\n\n\n\n if decision == 'Fill':\n\n await query.edit_message_text(text='<b>Please type in the mileage (e.g., 50000):</b>', parse_mode='HTML')\n\n return CAR_MILEAGE\n\n else:\n\n await query.edit_message_text(text='<b>Mileage step skipped.</b>', parse_mode='HTML')\n\n return await skip_mileage(update, context)\n\n\n\n\n\nasync def car_mileage(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Stores the car mileage.\"\"\"\n\n context.user_data['car_mileage'] = update.message.text\n\n await update.message.reply_text('<b>Mileage noted.\n\n'\n\n 'Please upload a photo of your car üì∑, or send /skip.</b>',\n\n parse_mode='HTML')\n\n return PHOTO\n\n\n\n\n\nasync def skip_mileage(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Skips the mileage input.\"\"\"\n\n context.user_data['car_mileage'] = 'Not provided'\n\n\n\n text = '<b>Please upload a photo of your car üì∑, or send /skip.</b>'\n\n\n\n # Determine the correct way to send a reply based on the update type\n\n if update.callback_query:\n\n # If called from a callback query, use the callback_query's message\n\n chat_id = update.callback_query.message.chat_id\n\n await context.bot.send_message(chat_id=chat_id, text=text, parse_mode='HTML')\n\n # Optionally, you might want to acknowledge the callback query\n\n await update.callback_query.answer()\n\n elif update.message:\n\n # If called from a direct message\n\n await update.message.reply_text(text)\n\n else:\n\n # Handle other cases or log an error/warning\n\n logger.warning('skip_mileage was called without a message or callback_query context.')\n\n\n\n return PHOTO\n\n\n\n\n\nasync def photo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Stores the photo.\"\"\"\n\n photo_file = await update.message.photo[-1].get_file()\n\n # Correctly store the file_id of the uploaded photo for later use\n\n context.user_data['car_photo'] = photo_file.file_id # Preserve this line\n\n\n\n # Inform user and transition to summary\n\n await update.message.reply_text('<b>Photo uploaded successfully.\n\n'\n\n 'Let\\'s summarize your selections.</b>',\n\n parse_mode='HTML'\n\n )\n\n await summary(update, context) # Proceed to summary\n\n\n\n\n\nasync def skip_photo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Skips the photo upload.\"\"\"\n\n await update.message.reply_text('<b>No photo uploaded.\n\n'\n\n 'Let\\'s summarize your selections.</b>',\n\n parse_mode='HTML')\n\n await summary(update, context)\n\n\n\n\n\nasync def summary(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Summarizes the user's selections and ends the conversation, including the uploaded image.\"\"\"\n\n selections = context.user_data\n\n # Construct the summary text\n\n summary_text = (f\"<b>Here's what you told me about your car:\n\n</b>\"\n\n f\"<b>Car Type:</b> {selections.get('car_type')}\n\n\"\n\n f\"<b>Color:</b> {selections.get('car_color')}\n\n\"\n\n f\"<b>Mileage:</b> {selections.get('car_mileage')}\n\n\"\n\n f\"<b>Photo:</b> {'Uploaded' if 'car_photo' in selections else 'Not provided'}\")\n\n\n\n chat_id = update.effective_chat.id\n\n\n\n # If a photo was uploaded, send it back with the summary as the caption\n\n if 'car_photo' in selections and selections['car_photo'] != 'Not provided':\n\n await context.bot.send_photo(chat_id=chat_id, photo=selections['car_photo'], caption=summary_text, parse_mode='HTML')\n\n else:\n\n # If no photo was uploaded, just send the summary text\n\n await context.bot.send_message(chat_id=chat_id, text=summary_text, parse_mode='HTML')\n\n\n\n return ConversationHandler.END\n\n\n\n\n\nasync def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Cancels and ends the conversation.\"\"\"\n\n await update.message.reply_text('Bye! Hope to talk to you again soon.', reply_markup=ReplyKeyboardRemove())\n\n return ConversationHandler.END\n\n\n\n\n\ndef main() -> None:\n\n \"\"\"Run the bot.\"\"\"\n\n application = Application.builder().token(\"YOUR TOKEN HERE\").build()\n\n\n\n conv_handler = ConversationHandler(\n\n entry_points=[CommandHandler('start', start)],\n\n states={\n\n CAR_TYPE: [MessageHandler(filters.TEXT & ~filters.COMMAND, car_type)],\n\n CAR_COLOR: [CallbackQueryHandler(car_color)],\n\n CAR_MILEAGE_DECISION: [CallbackQueryHandler(car_mileage_decision)],\n\n CAR_MILEAGE: [MessageHandler(filters.TEXT & ~filters.COMMAND, car_mileage)],\n\n PHOTO: [\n\n MessageHandler(filters.PHOTO, photo),\n\n CommandHandler('skip', skip_photo)\n\n ],\n\n SUMMARY: [MessageHandler(filters.ALL, summary)]\n\n },\n\n fallbacks=[CommandHandler('cancel', cancel)],\n\n )\n\n\n\n application.add_handler(conv_handler)\n\n\n\n # Handle the case when a user sends /start but they're not in a conversation\n\n application.add_handler(CommandHandler('start', start))\n\n\n\n application.run_polling()\n\n\n\n\n\nif __name__ == '__main__':\n\n main()\n\nStep 3: Testing and Interacting with Your Bot\n\nAfter running your script, find your bot on Telegram and start interacting with it. You should now be able to use the command to start a conversation, which will guide you through listing a car for sale."
    },
    {
        "link": "https://stackoverflow.com/questions/67930142/how-can-i-add-custom-command-using-python-telegram-bot",
        "document": "There is (almost) nothing wrong with the code that you showed. The only thing that comes to mind about is the wrong placement of that furas already pointed out in the comments.\n\nIf the bot actually sends as a text message in the chat, this must be because you coded it to. That is, the update is already handled by another handler with probably prevents your from handling the update. Please carefully read the documentation of and double check that you add your handlers in the right order.\n\nIf you want that your command shows up in the auto-completion in the app, you can either use for that or set it up with @BotFather.\n\nIn order to show errors, please see here and here.\n\nDisclaimer: I'm currently the maintainer of ."
    },
    {
        "link": "https://stackoverflow.com/questions/71321354/how-to-handle-messages-in-a-telegram-bot",
        "document": "My goal is to make a Telegram Bot using Python that does the following:\n‚Ä¢ The bot explains what the user should type next.\n‚Ä¢ I use that info to fetch a value in a python dictionary.\n‚Ä¢ The bot replies with that info\n\nI have already created the bot and set the command. The problem is that I don't know how to keep the bot \"listening\" . I have looked up in the docs but I have only found getUpdates, which gets the user's responses but only when you hit run.\n\nI would like to set a webhook, and I know there is a method for this but I'm not shure about how this works."
    },
    {
        "link": "https://github.com/python-telegram-bot/python-telegram-bot/discussions/3479",
        "document": "To see all available qualifiers, see our documentation .\n\nSaved searches Use saved searches to filter your results more quickly\n\nWe read every piece of feedback, and take your input very seriously.\n\nYou signed in with another tab or window. Reload to refresh your session.\n\nYou signed out in another tab or window. Reload to refresh your session.\n\nYou switched accounts on another tab or window. Reload to refresh your session."
    },
    {
        "link": "https://docs.python-telegram-bot.org/en/v21.5/telegram.ext.commandhandler.html",
        "document": "Commands are Telegram messages that start with , optionally followed by an and the bot‚Äôs name and/or some additional text. The handler will add a to the named . It will contain a list of strings, which is the text following the command split on single or consecutive whitespace characters.\n\nBy default, the handler listens to messages as well as edited messages. To change this behavior use in the filter argument.\n\ndoes not handle (edited) channel posts and does not handle commands that are part of a caption. Please use with a suitable combination of filters (e.g. , and ) to handle those messages.\n‚Ä¢ None command ( | Collection[ ]) ‚Äì The command or list of commands this handler should listen for. Case-insensitive. Limitations are the same as for .\n‚Ä¢ None The callback function for this handler. Will be called when has determined that an update should be processed by this handler. Callback signature: The return value of the callback is usually ignored except for the special case of .\n‚Ä¢ None filters ( , optional) ‚Äì A filter inheriting from . Standard filters can be found in . Filters can be combined using bitwise operators ( for , for , for )\n‚Ä¢ None Determines whether the return value of the callback should be awaited before processing the next handler in . Defaults to .\n‚Ä¢ None Determines whether the command handler should process the update or not. If , the handler will process any non-zero number of args. If , the handler will only process if there are no args. if , the handler will only process if there are exactly that many args. Defaults to , which means the handler will process any or no args. ValueError ‚Äì When the command is too long or has illegal chars."
    }
]