[
    {
        "link": "https://gnu.org/s/coreutils/manual/coreutils.html",
        "document": "This manual documents version 9.6 of the GNU core utilities, including the standard programs for text and file manipulation."
    },
    {
        "link": "https://gnu.org/software/coreutils/dd",
        "document": "copies input to output with a changeable I/O block size, while optionally performing conversions on the data. Synopses:\n\nThe only options are and . See Common options.\n\nBy default, copies standard input to standard output. To copy, repeatedly does the following steps in order:\n‚Ä¢ If converting via ‚Äò ‚Äô, pad as needed to meet the input block size. Pad with spaces if converting via ‚Äò ‚Äô or ‚Äò ‚Äô, NUL bytes otherwise.\n‚Ä¢ If ‚Äò ‚Äô is given and no conversion mentioned in steps (4) or (5) is given, output the data as a single block and skip all remaining steps.\n‚Ä¢ If the ‚Äò ‚Äô conversion is given, swap each pair of input bytes. If the input data length is odd, preserve the last input byte (since there is nothing to swap it with).\n‚Ä¢ If any of the conversions ‚Äò ‚Äô, ‚Äò ‚Äô, ‚Äò ‚Äô, ‚Äò ‚Äô, ‚Äò ‚Äô, ‚Äò ‚Äô, ‚Äò ‚Äô and ‚Äò ‚Äô are given, do these conversions. These conversions operate independently of input blocking, and might deal with records that span block boundaries.\n‚Ä¢ Aggregate the resulting data into output blocks of the specified size, and output each output block in turn. Do not pad the last output block; it can be shorter than usual.\n\naccepts the following operands, whose syntax was inspired by the DD (data definition) statement of OS/360 JCL.\n\nRead from instead of standard input. Write to instead of standard output. Unless ‚Äò ‚Äô is given, truncate before writing it. Set the input block size to . This makes read per block. The default is 512 bytes. Set the output block size to . This makes write per block. The default is 512 bytes. Set both input and output block sizes to . This makes read and write per block, overriding any ‚Äò ‚Äô and ‚Äò ‚Äô settings. In addition, if no data-transforming operand is specified, input is copied to the output as soon as it‚Äôs read, even if it is smaller than the block size. Set the conversion block size to . When converting variable-length records to fixed-length ones ( ) or the reverse ( ), use as the fixed record length. Skip ‚Äò ‚Äô-byte blocks in the input file before copying. If ends in the letter ‚Äò ‚Äô, interpret as a byte count rather than a block count. (‚Äò ‚Äô and the ‚Äò ‚Äô spelling are GNU extensions to POSIX.) Skip ‚Äò ‚Äô-byte blocks in the output file before truncating or copying. If ends in the letter ‚Äò ‚Äô, interpret as a byte count rather than a block count. (‚Äò ‚Äô and the ‚Äò ‚Äô spelling are GNU extensions to POSIX.) Copy ‚Äò ‚Äô-byte blocks from the input file, instead of everything until the end of the file. If ends in the letter ‚Äò ‚Äô, interpret as a byte count rather than a block count; this is a GNU extension to POSIX. If short reads occur, as could be the case when reading from a pipe for example, ‚Äò ‚Äô ensures that ‚Äò ‚Äô counts complete input blocks rather than input read operations. As an extension to POSIX, ‚Äò ‚Äô copies zero blocks instead of copying all blocks. Specify the amount of information printed. If this operand is given multiple times, the last one takes precedence. The value can be one of the following: Do not print any informational or warning messages to standard error. Error messages are output as normal. Do not print the final transfer rate and volume statistics that normally make up the last status line. Print the transfer rate and volume statistics on standard error, when processing each input block. Statistics are output on a single line at most once every second, but updates can be delayed when waiting on I/O. Transfer information is normally output to standard error upon receipt of the ‚Äò ‚Äô signal or when exits, and defaults to the following form in the C locale: The notation ‚Äò ‚Äô stands for whole blocks and partial blocks. A partial block occurs when a read or write operation succeeds but transfers less data than the block size. An additional line like ‚Äò ‚Äô or ‚Äò ‚Äô is output after the ‚Äò ‚Äô line if ‚Äò ‚Äô processing truncated one or more input records. The ‚Äò ‚Äô operand is a GNU extension to POSIX. Convert the file as specified by the argument(s). (No spaces around any comma(s).) Convert EBCDIC to ASCII, using the conversion table specified by POSIX. This provides a 1:1 translation for all 256 bytes. This implies ‚Äò ‚Äô; input is converted to ASCII before trailing spaces are deleted. Convert ASCII to EBCDIC. This is the inverse of the ‚Äò ‚Äô conversion. This implies ‚Äò ‚Äô; trailing spaces are added before being converted to EBCDIC. This acts like ‚Äò ‚Äô, except it uses the alternate conversion table specified by POSIX. This is not a 1:1 translation, but reflects common historical practice for ‚Äò ‚Äô, ‚Äò ‚Äô, and ‚Äò ‚Äô. The ‚Äò ‚Äô, ‚Äò ‚Äô, and ‚Äò ‚Äô conversions are mutually exclusive. If you use any of these conversions, you should also use the ‚Äò ‚Äô operand. For each line in the input, output ‚Äò ‚Äô bytes, replacing the input newline with a space and truncating or padding input lines with spaces as necessary. Remove any trailing spaces in each ‚Äò ‚Äô-sized input block, and append a newline. The ‚Äò ‚Äô and ‚Äò ‚Äô conversions are mutually exclusive. If you use either of these conversions, you should also use the ‚Äò ‚Äô operand. The ‚Äò ‚Äô and ‚Äò ‚Äô conversions are mutually exclusive. Try to seek rather than write NUL output blocks. On a file system that supports sparse files, this will create sparse output when extending the output file. Be careful when using this conversion in conjunction with ‚Äò ‚Äô or ‚Äò ‚Äô. With ‚Äò ‚Äô, existing data in the output file corresponding to NUL blocks from the input, will be untouched. With ‚Äò ‚Äô the seeks performed will be ineffective. Similarly, when the output is a device rather than a file, NUL input blocks are not copied, and therefore this conversion is most useful with virtual or pre zeroed devices. The ‚Äò ‚Äô conversion is a GNU extension to POSIX. Pad every input block to size of ‚Äò ‚Äô with trailing zero bytes. When used with ‚Äò ‚Äô or ‚Äò ‚Äô, pad with spaces instead of zero bytes. The following ‚Äúconversions‚Äù are really file flags and don‚Äôt affect internal processing: Fail if the output file already exists; must create the output file itself. Do not create the output file; the output file must already exist. The ‚Äò ‚Äô and ‚Äò ‚Äô conversions are mutually exclusive, and are GNU extensions to POSIX. Do not truncate the output file. Synchronize output data just before finishing, even if there were write errors. This forces a physical write of output data, so that even if power is lost the output data will be preserved. If neither this nor ‚Äò ‚Äô are specified, output is treated as usual with file systems, i.e., output data and metadata may be cached in primary memory for some time before the operating system physically writes it, and thus output data and metadata may be lost if power is lost. See : Synchronize cached writes to persistent storage. This conversion is a GNU extension to POSIX. Synchronize output data and metadata just before finishing, even if there were write errors. This acts like ‚Äò ‚Äô except it also preserves output metadata, such as the last-modified time of the output file; for this reason it may be a bit slower than ‚Äò ‚Äô although the performance difference is typically insignificant for . This conversion is a GNU extension to POSIX. Access the input file using the flags specified by the argument(s). (No spaces around any comma(s).) Access the output file using the flags specified by the argument(s). (No spaces around any comma(s).) Write in append mode, so that even if some other process is writing to this file, every write will append to the current contents of the file. This flag makes sense only for output. If you combine this flag with the ‚Äò ‚Äô operand, you should also specify ‚Äò ‚Äô unless you want the output file to be truncated before being appended to. Use concurrent I/O mode for data. This mode performs direct I/O and drops the POSIX requirement to serialize all I/O to the same file. A file cannot be opened in CIO mode and with a standard open at the same time. Use direct I/O for data, avoiding the buffer cache. The kernel may impose restrictions on read or write buffer sizes. For example, with an ext4 destination file system and a Linux-based kernel, using ‚Äò ‚Äô will cause writes to fail with if the output buffer size is not a multiple of 512. Fail unless the file is a directory. Most operating systems do not allow I/O to a directory, so this flag has limited utility. Use synchronized I/O for data. For the output file, this forces a physical write of output data on each write. For the input file, this flag can matter when reading from a remote file that has been written to synchronously by some other process. Metadata (e.g., last-access and last-modified time) is not necessarily synchronized. Use synchronized I/O for both data and metadata. Request to discard the system data cache for a file. When count=0 all cached data for the file is specified, otherwise the cache is dropped for the processed portion of the file. Also when count=0, failure to discard the cache is diagnosed and reflected in the exit status. Because data not already persisted to storage is not discarded from the cache, the ‚Äò ‚Äô conversions in the following examples maximize the effectiveness of the ‚Äò ‚Äô flag. Here are some usage examples: # Advise to drop cache for whole file dd if=ifile iflag=nocache count=0 # Ensure drop cache for the whole file dd of=ofile oflag=nocache conv=notrunc,fdatasync count=0 # Advise to drop cache for part of file # The kernel will consider only complete and # already persisted pages. dd if=ifile iflag=nocache skip=10 count=10 of=/dev/null # Stream data using just the read-ahead cache. # See also the ‚Äò ‚Äô flag. dd if=ifile of=ofile iflag=nocache oflag=nocache,sync Do not update the file‚Äôs access timestamp. See File timestamps. Some older file systems silently ignore this flag, so it is a good idea to test it on your files before relying on it. Do not assign the file to be a controlling terminal for . This has no effect when the file is not a terminal. On many hosts (e.g., GNU/Linux hosts), this flag has no effect at all. Fail if the file has multiple hard links. Use binary I/O. This flag has an effect only on nonstandard platforms that distinguish binary from text I/O. Use text I/O. Like ‚Äò ‚Äô, this flag has no effect on standard platforms. Accumulate full blocks from input. The system call may return early if a full block is not available. When that happens, continue calling to fill the remainder of the block. This flag can be used only with . This flag is useful with pipes for example as they may return short reads. In that case, this flag is needed to ensure that a ‚Äò ‚Äô argument is interpreted as a block count rather than a count of read operations. These flags are all GNU extensions to POSIX. They are not supported on all systems, and ‚Äò ‚Äô rejects attempts to use them when they are not supported. When reading from standard input or writing to standard output, the ‚Äò ‚Äô and ‚Äò ‚Äô flags should not be specified, and the other flags (e.g., ‚Äò ‚Äô) can affect how other processes behave with the affected file descriptors, even after exits.\n\nThe behavior of is unspecified if operands other than ‚Äò ‚Äô, ‚Äò ‚Äô, ‚Äò ‚Äô, and ‚Äò ‚Äô are specified more than once.\n\nThe numeric-valued strings above ( and ) are unsigned decimal integers that can be followed by a multiplier: ‚Äò ‚Äô=512, ‚Äò ‚Äô=1, ‚Äò ‚Äô=2, ‚Äò ‚Äô= , or any of the standard block size suffixes like ‚Äò ‚Äô=1024 (see Block size). These multipliers are GNU extensions to POSIX, except that POSIX allows to be followed by ‚Äò ‚Äô, ‚Äò ‚Äô, and ‚Äò ‚Äô. An ‚Äò ‚Äô can be used more than once in a number. Block sizes (i.e., specified by strings) must be nonzero.\n\nAny block size you specify via ‚Äò ‚Äô, ‚Äò ‚Äô, ‚Äò ‚Äô, ‚Äò ‚Äô should not be too large ‚Äì values larger than a few megabytes are generally wasteful or (as in the gigabyte..exabyte case) downright counterproductive or error-inducing.\n\nTo process data with offset or size that is not a multiple of the I/O block size, you can use a numeric string that ends in the letter ‚Äò ‚Äô. For example, the following shell commands copy data in 1 MiB blocks between a flash drive and a tape, but do not save or restore a 512-byte area at the start of the flash drive:\n\nFor failing storage devices, other tools come with a great variety of extra functionality to ease the saving of as much data as possible before the device finally dies, e.g. GNU . However, in some cases such a tool is not available or the administrator feels more comfortable with the handling of . As a simple rescue method, call as shown in the following example: the operand ‚Äò ‚Äô is used to continue after read errors and to pad out bad reads with NULs, while ‚Äò ‚Äô caters for short reads (which traditionally never occur on flash or similar devices):\n\nSending an ‚Äò ‚Äô signal (or ‚Äò ‚Äô signal where that is unavailable) to a running process makes it print I/O statistics to standard error and then resume copying. In the example below, is run in the background to copy 5GB of data. The command makes it output intermediate I/O statistics, and when completes normally or is killed by the signal, it outputs the final statistics.\n\nThe above script will output in the following format:\n\nThe ‚Äò ‚Äô operand periodically updates the last line of the transfer statistics above.\n\nOn systems lacking the ‚Äò ‚Äô signal responds to the ‚Äò ‚Äô signal instead, unless the environment variable is set.\n\nAn exit status of zero indicates success, and a nonzero value indicates failure."
    },
    {
        "link": "https://man7.org/linux/man-pages/man1/dd.1.html",
        "document": "Pages that refer to this page: pipesz(1), truncate(1), xfs(5), fdisk(8), sfdisk(8), swapon(8), xfs_copy(8), xfs_repair(8)"
    },
    {
        "link": "https://wiki.archlinux.org/title/Dd",
        "document": "dd is a core utility whose primary purpose is to copy a file and optionally convert it during the copy process.\n\nSimilarly to cp, by default dd makes a bit-to-bit copy of the file, but with lower-level I/O flow control features.\n\nFor more information, see dd(1) or the full documentation.\n\nTip: By default, dd outputs nothing until the task has finished. To monitor the progress of the operation, add the option to the command.\n\nWarning: One should be extremely cautious using dd, as with any command of this kind it can destroy data irreversibly.\n\ndd is part of the GNU coreutils. For other utilities in the package, please refer to Core utilities.\n\nThe dd command is a simple, yet versatile and powerful tool. It can be used to copy from source to destination, block-by-block, regardless of their filesystem types or operating systems. A convenient method is to use dd from a live environment, as in a Live CD.\n\nWarning: As with any command of this type, you should be very cautious when using it; it can destroy data. Remember the order of input file ( ) and output file ( ) and do not reverse them! Always ensure that the destination drive or partition ( ) is of equal or greater size than the source ( ).\n\nNote: Be careful that if the output partition ( in the example) does not exist, dd will create a file with this name and will start filling up your root file system.\n\nThis will clone the entire drive, including the partition table, bootloader, all partitions, UUIDs, and data.\n‚Ä¢ sets the block size. Defaults to 512 bytes, which is the \"classic\" block size for hard drives since the early 1980s, but is not the most convenient. Use a bigger value, 64K or 128K. Also, please read the note below, because there is more to this than just \"block sizes\" ‚Äî it also influences how read errors propagate. See [1] and [2] for details and to figure out the best bs value for your use case.\n‚Ä¢ instructs dd to continue operation, ignoring all read errors. Default behavior for dd is to halt at any error.\n‚Ä¢ fills input blocks with zeroes at the end of the block if there were any read errors somewhere in the block, so data offsets stay in sync (see below for detailed explanation of read error behavior with sync if you are suspecting possible read errors).\n‚Ä¢ shows periodic transfer statistics which can be used to estimate when the operation may be complete.\n\nThe dd utility technically has an \"input block size\" (IBS) and an \"output block size\" (OBS). When you set , you effectively set both IBS and OBS. Normally, if your block size is, say, 1 MiB, dd will read 1024√ó1024 bytes and write as many bytes. But if a read error occurs, things will go wrong. Many people seem to think that dd will \"fill up read errors with zeroes\" if you use the options, but this is not what happens. dd will, according to documentation, fill up the OBS to IBS size after completing its read, which means adding zeroes at the end of the block. This means, for a disk, that effectively the whole 1 MiB would become messed up because of a single 512 byte read error in the beginning of the read: 12ERROR89 would become 128900000 instead of 120000089.\n\nIf you are positive that your disk does not contain any errors, you could proceed using a larger block size, which will increase the speed of your copying several fold. For example, changing bs from 512 to 64K changed copying speed from 35 MB/s to 120 MB/s on a simple Celeron 2.7 GHz system. But keep in mind that read errors on the source disk will end up as block errors on the destination disk, i.e. a single 512-byte read error will mess up the whole 64 KiB output block.\n\nSee fdisk#Backup and restore partition table or gdisk#Backup and restore partition table.\n\nBoot from a live medium and make sure no partitions are mounted from the source hard drive.\n\nThen mount the external hard drive and backup the drive:\n\nIf necessary (e.g. when the resulting files will be stored on a FAT32 file system), split the disk image into multiple parts (see also split(1)):\n\nIf there is not enough disk space locally, you may send the image through ssh:\n\nFinally, save extra information about the drive geometry necessary in order to interpret the partition table stored within the image. The most important of which is the sector size.\n\nWhen the image has been split, use the following instead:\n\nBefore making changes to a disk, you may want to backup the partition table and partition scheme of the drive. You can also use a backup to copy the same partition layout to numerous drives.\n\nThe MBR is stored in the first 512 bytes of the disk. It consists of 4 parts:\n‚Ä¢ The first 440 bytes contain the bootstrap code (boot loader).\n‚Ä¢ The next 6 bytes contain the disk signature.\n‚Ä¢ The next 64 bytes contain the partition table (4 entries of 16 bytes each, one entry for each primary partition).\n‚Ä¢ The last 2 bytes contain a boot signature.\n\nTo save the MBR as :\n\nYou can also extract the MBR from a full dd disk image:\n\nTo restore (be careful, this destroys the existing partition table and with it access to all data on the disk):\n\nIf you only want to restore the boot loader, but not the primary partition table entries, just restore the first 440 bytes of the MBR:\n\nTo restore only the partition table, one must use:\n\nTo erase the MBR bootstrap code (may be useful if you have to do a full reinstall of another operating system), only the first 440 bytes need to be zeroed:\n\nAs some readers might have already realised, the dd(1) core utility has a different command-line syntax compared to other utilities. Moreover, while supporting some unique features not found in other commodity utilities, several default behaviours it has are either less-ideal or potentially error-prone if applied to specific scenarios. For that reason, users may want to use some alternatives that are better in some aspects in lieu of the dd core utility.\n\nThat said, it is still worth to note that since dd is a core utility, which is installed by default on Arch and many other systems, it is preferable to some alternatives or more specialised utilities if it is inconvenient to install a new package on your system.\n\nTo cover the two aspects that are addressed above, this section is dedicated to summarising the features of the dd(1) core utility that are rarely found in other commodity utilities ‚Äî in a form that resembles the pacman/Rosetta article but with the quantity of examples being cut down to examine the features of dd (as denoted by i.e. or To-clause in \"Tip:\" box under subsection), either in practice or pseudocode.\n\nIt is not an uncommon practice to use dd as a feature-limited binary file patcher in an automated shell script as it supports:\n‚Ä¢ ing the output file by a given offset before writing.\n‚Ä¢ writing to an output file (without truncating the size of the output file by adding the option).\n\nHere is an example to modify the timestamp part of the first member in a cpio(5) ¬ß Portable ASCII Format archive, which starts at the 49th byte of the file (or with an offset of if you prefer hex notation):\n\nTo read the filesystem volume label of an VFAT image file, which should be in total length of 11 bytes that padded by ASCII spaces, with an offset of :\n\nIn the following example, to avoid unnecessary long-lasting TCP connection on input end if the output end blocks longer than expected, one may put a dd between two commands with an output block size certainly larger than input while still reasonably smaller than available memory:\n\nIt is a general practice to use dd in a data streaming shell script for limiting total length of data that a piped command may consume. For example, to inspect an ustar header block (tar(5) ¬ß POSIX ustar Archives) using a shell script function in a streaming manner:\n\nSee USB flash installation medium#Using basic command line utilities for examples of commodity utilities include the potential least adapted dd for that case.\n\nFiles created with dd can end up with a smaller size than requested if a full input block is not available for the moment, as per documentation:\n\nOn Linux, the underlying read(2) system call may returns early (i.e. partial read) when reading from a pipe(7), or when reading a device file like and (e.g. due to hardcoded limitation of underlying kernel device driver) Which make the total size of copied data smaller than expected when in conjunction of option is used, where limited the maximum number of (potential partial) input block(s) to copy to output.\n\nIt is possible, but not guaranteed, that dd will warn you about such kind of issue:\n\nThe solution is to do as the warning says, add option in addition to the input file option to the dd command. For example, to create a new file filled up with random data in total length of 40 mebibytes:\n\nWhen reading from a pipe, an alternative to is to limit to the constant value as defined in linux/limits.h to make the pipe(7) I/O atomic. For example, to prepare a text file filled up will random alphanumeric string in total length of 5 mebibytes:\n\nSince the output file is not a pipe, one may prefer to use and options to set block size separately for the (input) pipe and the (output) on-disk file. For example, to set a more efficient block size for output file:\n\nTip: In some circumstances, merely keeping the output block size the same the value as the input block size with a value defined by the constant may already be optimal.\n\nThe total transferred bytes count readout may be greater than actual if an error is encountered on writing to output (i.e. partial write, caused by e.g. SIGPIPE, faulty medium, or accidentally disconnected the target network block device), like in following proof of concept where the second dd obviously will not read more than 512200 bytes, but the first dd instance still report an inaccurate bytes count 512400 bytes:\n\nWhen resuming an interrupted transfer like the above PoC, it is recommended to only rely on the readout of number of whole output blocks already copied, as denoted by the number before \"+\" sign."
    },
    {
        "link": "https://blog.kubesimplify.com/the-complete-guide-to-the-dd-command-in-linux",
        "document": "The dd command is an extremely powerful Linux utility. It is commonly referred to as the \"disk destroyer\", ‚Äúdata definition‚Äù, ‚Äúdisk dump‚Äù, or \"disk duplicator\" due to its immense power and ability to directly interact with block devices. In this beginner's guide, we will explore the dd command, its syntax, and various use cases, highlighting its role in file copying, disk partition backup, and restoration, and creating bootable USB drives.\n\nThe syntax of the dd command is simple. It reads from standard input and writes to standard output by default. Here is the basic syntax of the dd command:\n\nIt's worth noting that dd deviates from the standard convention of using the or syntax for options, distinguishing it from most Linux shell commands.\n\nThe dd command accepts several options to customize its behavior and achieve specific tasks. Here are some of the most commonly used options:\n\nNow, let's explore some practical examples of using the dd command in various scenarios.\n\nHow to copy files in Linux\n\nTo make a simple copy of a file, you can use the dd command with the and options. For example, to copy a file named to a new file named , run the following command:\n\nThis command reads the contents of and writes them to .\n\nWhen using the dd command, if there is already a file with the same name at the destination, it will be replaced by default. This means that the existing file will be overwritten. Use the option to prevent overwriting an existing file while using the dd command. This option ensures that the destination file is not truncated during the write process. For example:\n\nIn addition to avoiding overwriting, you can also append data to an existing file by using the option. Let's consider an example where we want to append the contents of to :\n\nWith this command, the dd command reads the data from and appends it to the end of .\n\nThe dd command can also be used to perform text conversions. For instance, to convert all the text in a file from lowercase to uppercase, use the option with the and conversion parameters. Consider the following example:\n\nThis command reads the contents of , converts all lowercase characters to uppercase, and saves the result in .\n\nSimilarly, you can convert text from uppercase to lowercase using the option with the and conversion parameters. Here's an example:\n\nOne of the powerful use cases of the dd command is creating backups of disk partitions. This can be particularly useful for system administrators or users who want to preserve the state of their disk partitions. To back up a disk partition, you need to identify the block device associated with the partition, usually represented by a device file in the directory.\n\nFor example, to back up the first partition of the disk located at , you would use the following command:\n\nThis command reads the content of , the first partition of the disk, and saves it to a file named .\n\nOnce you have a backup of a disk partition, you can use the dd command to restore it when needed. To restore a disk partition, you would reverse the input and output files in the command. Here's an example:\n\nThis command reads the content from the file and writes it to the partition, effectively restoring the partition to its previous state.\n\nIn addition to backing up individual partitions, you can use the dd command to create a backup of the entire Linux hard drive. This allows you to capture the complete state of the disk, including all partitions, boot records, and file systems.\n\nTo back up the entire hard drive, you would specify the hard drive's block device as the input file. For instance, to back up the hard drive located at , run the following command:\n\nThis command reads the entire content of and saves it to a file named .\n\nSimilarly, you can use the dd command to restore a previously created backup of the entire Linux hard drive. This can be extremely useful in situations where you need to recover the whole system from a backup.\n\nTo restore the hard drive, you would reverse the input and output files in the command. For example:\n\nThis command reads the content from the file and writes it back to the hard drive, effectively restoring the entire system.\n\nThe Master Boot Record (MBR) is a crucial component of a disk that contains the boot loader and partition table. By using the dd command, you can create a backup of the MBR, ensuring that you can recover the boot sector if it gets corrupted or overwritten.\n\nTo back up the MBR, you can use the dd command to copy the first 512 bytes of the disk. Here's an example:\n\nIn this command, specifies the disk from which to read the MBR, specifies the output file to save the backup, sets the block size to 512 bytes (the size of the MBR), and specifies that only one block should be copied.\n\nIf you need to restore the MBR from a backup, you can use the dd command to write the contents of the backup file back to the disk. Here's an example:\n\nThis command reads the content from the file and writes it back to the disk, effectively restoring the MBR.\n\nThe dd command can also be used to create a bit-by-bit copy of a CD or DVD. This can be useful when you want to create an exact replica of the disc, including its file system and bootable properties.\n\nTo copy the contents of a CD/DVD drive, you would specify the CD/DVD drive as the input file ( ) and an output file to save the copy. Here's an example:\n\nIn this command, represents the CD/DVD drive, and is the output file where the copied data will be saved.\n\nAs mentioned earlier, one common use of the dd command is disk cloning. By copying block devices byte by byte, dd creates an exact replica of a disk. When cloning a disk to a file, we can enhance the result and reduce the file size by piping the data read by dd through compression utilities like gzip. For example, to create a clone of the entire block device, we can execute the following command:\n\nIn this example, we specify that dd should read from the device and adjust the block size to 1M for improved performance. We then pipe the data to the gzip program, utilizing the option to output to stdout and the option for maximum compression. Finally, we redirect the output to the \" \" file.\n\nSkipping Bytes or Characters When Reading the Input File\n\nThe dd command provides the option, which allows you to skip a specific number of bytes or characters while reading the input file. This can be useful when you need to exclude certain parts of the file. Here's an example:\n\nIn this command, the dd command skips the first 100 bytes of data in and writes the remaining content to .\n\nAnother valuable use case for dd is wiping a device. There are various situations where such an operation becomes necessary, such as preparing a disk for sale to ensure the previous data has been completely erased for privacy reasons or wiping data before setting up encryption. In the former case, overwriting the disk with zeros is sufficient:\n\nWith this command, dd reads from the device, which provides null characters, and writes them to the target device until it is completely filled.\n\nWhen setting up an encryption layer on our system, it is advisable to fill the disk with random data instead. This step renders the sectors that will contain data indistinguishable from the empty ones, thus preventing potential metadata leaks. In this scenario, we can read data from either the or devices:\n\nBoth commands will require a significant amount of time to complete, depending on the size and type of the block device and the source of random data used. It's worth noting that /dev/random is slower as it blocks until it gathers sufficient environmental noise, but it produces higher-quality random data compared to\n\nThe dd command is widely used for creating bootable USB drives from ISO images. This is particularly useful when installing or booting operating systems or live distributions from a USB device.\n\nTo create a bootable USB drive, you would specify the ISO file as the input file ( ) and the USB drive as the output file ( ). Here's an example:\n\nIn this command, represents the ISO image of the Linux distribution, is the USB drive (replace with the appropriate drive letter), sets the block size to 4 megabytes for faster copying, and displays the progress of the dd command.\n\nBy using the option with the dd command, you can display a progress bar that indicates the completion percentage of the ongoing operation. This can be helpful, especially when dealing with large files or lengthy processes.\n\nFor example, to copy a file and show the progress bar, use the following command:\n\nThis command reads the content from the and writes it to the , while displaying a progress bar.\n\nIn this tutorial, we learned how to use the dd command. We also covered some practical use cases, such as creating backups and bootable USB sticks, Because dd is a very powerful utility, it must be used with extreme caution: simply switching the input and output targets can, in some cases, destroy data on a disk.\n\nRemember to refer to the official documentation and additional resources to further expand your knowledge and explore advanced usage scenarios.\n\nBe sure to follow us on Twitter and Instagram.\n\nFollow Kubesimplify on Hashnode, Twitter, and LinkedIn. Join our Discord server to learn with us."
    },
    {
        "link": "https://reddit.com/r/archlinux/comments/17hc23b/full_disk_cloning_using_dd_best_practices_and",
        "document": "I would like to clone my entire system. Planning to use dd to do this. I am looking for guidance before attempting incorrectly and losing all data. Would be devastating if I mess this up.\n\nIs dd the best method to achieve a full clone that I can boot back into if and when my system breaks? I will be copying from drives of the exact same brand, size, model and age. The nvme drives I have are WD_BLACK SN850X NVMe 4TB SSDs (https://www.westerndigital.com/products/internal-drives/wd-black-sn850x-nvme-ssd?sku=WDS400T2X0E)\n\nThe target drive already has data on it from another arch system build which I no longer use (other then to chroot into my daily driver after encountering system issues.) I plan to write over it using dd. Is it best to wipe the target drive before proceeding? or does it make no difference?\n\nAs per arch wiki I should have no issue with cloning a fully encrypted btrfs:\"It can be used to copy from source to destination, block-by-block, regardless of their filesystem types or operating systems.\" (https://wiki.archlinux.org/title/Dd#Cloning_an_entire_hard_disk) However, since I have zero experience using dd I thought Id ask here for the consensus viewpoint first.\n\nI have read a bit on block size (bs) settings. Definitely seems I should specify at least bs=64K. From what I understand the higher block size you specify faster and more ram load, so you want to find a sweet spot given your hardware configuration. For ram I have 128GB ddr5 running at 4800mt/s (might be 5200 even, Id have to check bios xmp profile) with CL32 latency. Im considering setting bs=512K since I have tons of ram and read here (http://blog.tdg5.com/tuning-dd-block-size/) that it gives 30% transfer speeds over 64K\n\nAnyone experienced in this department know of anything I should be aware of before proceeding? Is there really much risk if I am increasing block size? it appears this setting is simply the rate at which the copy is being made and has no impact on the data once the process is done?\n\nAlso can I be using the system built on the source disk to proceed with this operation? or should this be done with another system?\n\nMany thanks in advance."
    },
    {
        "link": "https://serverfault.com/questions/4906/using-dd-for-disk-cloning",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://reddit.com/r/linuxquestions/comments/17hcq5i/any_suggestions_and_precautions_for_cloning",
        "document": "I would like to clone my entire arch system. Planning to use dd to do this. I am looking for guidance before attempting incorrectly and losing all data. Would be devastating if I mess this up.\n\nIs dd the best method to achieve a full clone that I can boot back into if and when my system breaks? I will be copying from drives of the exact same brand, size, model and age. The nvme drives I have are WD_BLACK SN850X NVMe 4TB SSDs (https://www.westerndigital.com/products/internal-drives/wd-black-sn850x-nvme-ssd?sku=WDS400T2X0E)\n\nThe target drive already has data on it from another arch system build which I no longer use (other then to chroot into my daily driver after encountering system issues.) I plan to write over it using dd. Is it best to wipe the target drive before proceeding? or does it make no difference?\n\nAs per arch wiki I should have no issue with cloning a fully encrypted btrfs: \"It can be used to copy from source to destination, block-by-block, regardless of their filesystem types or operating systems.\" (https://wiki.archlinux.org/title/Dd#Cloning_an_entire_hard_disk) However, since I have zero experience using dd I thought Id ask here for the consensus viewpoint first.\n\nI have read a bit on block size (bs) settings. Definitely seems I should specify at least bs=64K. From what I understand the higher block size you specify faster and more ram load, so you want to find a sweet spot given your hardware configuration. For ram I have 128GB ddr5 running at 4800mt/s (might be 5200 even, Id have to check bios xmp profile) with CL32 latency. Im considering setting bs=512K or perhaps even higher since I have tons of ram and read here (http://blog.tdg5.com/tuning-dd-block-size/) that it gives 30% transfer speeds over 64K\n\nAnyone experienced in this department know of anything I should be aware of before proceeding? Is there really much risk if I am increasing block size? it appears this setting is simply the rate at which the copy is being made and has no impact on the data once the process is done?\n\nAlso can I be using the system built on the source disk to proceed with this operation? or should this be done with another system?\n\nMany thanks in advance."
    },
    {
        "link": "https://unix.stackexchange.com/questions/670216/dd-data-disk-dump-copy-and-convert-best-practices-for-backups-in-local-extern",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://akashrajpurohit.com/blog/mastering-disk-imaging-and-cloning-with-linuxs-dd-command",
        "document": "As a Linux user, you may need to create backups of your data or migrate to a new hard drive. The command can help you accomplish these tasks by creating exact copies of disks or partitions.\n\nDisk imaging involves copying the entire contents of a disk or partition to an image file, which can be used to restore the disk or partition in case of data loss or system failure.\n\nIn this post, we‚Äôll cover the basics of using the Linux command for various disk imaging and cloning tasks.\n\nThe basic syntax for the command is as follows:\n\nwhere specifies the input file, specifies the output file, and are various options that modify the behavior of the command.\n\nHere are a few examples of how to use the command:\n\nTo create a disk image, use the command with the input file as the source disk or partition and the output file as the image file.\n\nFor example, to create an image of the first partition of the first hard drive ( ) and save it to a file called in the home directory, use the following command:\n\nTo clone a disk, use the command with the input file as the source disk and the output file as the target disk.\n\nFor example, to clone the contents of the first hard drive ( ) to a second hard drive ( ), use the following command:\n\nNote that this command will overwrite all data on the target disk, so make sure to use it with caution.\n\nThe Master Boot Record (MBR) is a special type of boot sector that contains information about how to boot the system. It is located at the beginning of the disk and is used by the BIOS to load the operating system.\n\nTo backup the MBR, use the command with the input file as the source disk and the output file as the MBR backup file.\n\nFor example, to backup the MBR of the first hard drive ( ) to a file called in the home directory, use the following command:\n\nTo restore the MBR, use the command with the input file as the MBR backup file and the output file as the source disk.\n\nFor example, to restore the MBR of the first hard drive (/dev/sda) from the file ‚Äúmbr_backup.img‚Äù in the home directory, use the following command:\n\nThis ensures you can recover the MBR in case it gets corrupted or overwritten.\n\nGenerate a file filled with random data, often useful for testing purposes.\n\nFor example, to create a file called ‚Äúrandom_data.img‚Äù in the home directory with 1GB of random data, use the following command:\n\nThis command will create a file with 1GB of random data, which can be useful for testing purposes. Adjust the value of to change the size of the file.\n\nNeed to wipe out data on a disk securely? can help by overwriting the disk with zeros.\n\nFor example, to erase all data on the first hard drive (/dev/sda), use the following command:\n\nThis command writes zeros to the entire disk, effectively erasing any existing data.\n\nIn this post, we covered the basics of using the command for various disk imaging and cloning tasks. I hope you found this post helpful and that it will help you get started with using the command on your Linux system.\n\nSee you in another post! üëã"
    }
]