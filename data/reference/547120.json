[
    {
        "link": "https://doc.qt.io/qt-5/qvector.html",
        "document": "The QVector class is a template class that provides a dynamic array. More...\n\nNote: All functions in this class are reentrant.\n\nNote that the operating system may impose further limits on applications holding a lot of allocated memory, especially large, contiguous blocks. Such considerations, the configuration of such behavior or any mitigation are outside the scope of the Qt API.\n\nIn case memory allocation fails, QVector will use the Q_CHECK_PTR macro, which will throw a std::bad_alloc exception if the application is being compiled with exception support. If exceptions are disabled, then running out of memory is undefined behavior.\n\nThe current version of QVector is limited to just under 2 GB (2^31 bytes) in size. The exact value is architecture-dependent, since it depends on the overhead required for managing the data block, but is no more than 32 bytes. The number of elements that can be stored in a QVector is that size divided by the size of each element.\n\nFor a detailed discussion comparing Qt containers with each other and with STL containers, see Understand the Qt Containers .\n\nQVector does not support inserting, prepending, appending or replacing with references to its own values. Doing so will cause your application to abort with an error message.\n\nIn addition to QVector, Qt also provides QVarLengthArray , a very low-level class with little functionality that is optimized for speed.\n\nLike the other container classes, QVector provides Java-style iterators ( QVectorIterator and QMutableVectorIterator ) and STL-style iterators ( QVector::const_iterator and QVector::iterator ). In practice, these are rarely used, because you can use indexes into the QVector.\n\nQVector's value type must be an assignable data type . This covers most data types that are commonly used, but the compiler won't let you, for example, store a QWidget as a value; instead, store a QWidget *. A few functions have additional requirements; for example, indexOf () and lastIndexOf () expect the value type to support operator==() . These requirements are documented on a per-function basis.\n\nNote that using non-const operators and functions can cause QVector to do a deep copy of the data. This is due to implicit sharing .\n\nIf you know in advance approximately how many items the QVector will contain, you can call reserve (), asking QVector to preallocate a certain amount of memory. You can also call capacity () to find out how much memory QVector actually allocated.\n\nUnlike plain C++ arrays, QVectors can be resized at any time by calling resize (). If the new size is larger than the old size, QVector might need to reallocate the whole vector. QVector tries to reduce the number of reallocations by preallocating up to twice as much memory as the actual data needs.\n\nQVector provides these basic functions to add, move, and remove items: insert (), replace (), remove (), prepend (), append (). With the exception of append () and replace (), these functions can be slow ( linear time ) for large vectors, because they require moving many items in the vector by one position in memory. If you want a container class that provides fast insertion/removal in the middle, use QList or QLinkedList instead.\n\nIf you simply want to check whether a vector contains a particular value, use contains (). If you want to find out how many times a particular value occurs in the vector, use count ().\n\n\"First occurrence of Harumi is at position \"\n\nIf you want to find all occurrences of a particular value in a vector, use indexOf () or lastIndexOf (). The former searches forward starting from a given index position, the latter searches backward. Both return the index of the matching item if they found one; otherwise, they return -1. For example:\n\nAnother way to access the data stored in a QVector is to call data (). The function returns a pointer to the first item in the vector. You can use the pointer to directly access and modify the elements stored in the vector. The pointer is also useful if you need to pass a QVector to a function that accepts a plain C++ array.\n\nat () can be faster than operator[](), because it never causes a deep copy to occur.\n\nFor read-only access, an alternative syntax is to use at ():\n\nQVector uses 0-based indexes, just like C++ arrays. To access the item at a particular index position, you can use operator[](). On non-const vectors, operator[]() returns a reference to the item that can be used on the left side of an assignment:\n\nYou can also call fill () at any time to fill the vector with a value.\n\nThe elements are automatically initialized with a default-constructed value . If you want to initialize the vector with a different value, pass that value as the second argument to the constructor:\n\nQVector stores its items in a vector (array). Typically, vectors are created with an initial size. For example, the following code constructs a QVector with 200 elements:\n\nHere's an example of a QVector that stores integers and a QVector that stores QString values:\n\nNote: Iterators into a QLinkedList and references into heap-allocating QLists remain valid as long as the referenced items remain in the container. This is not true for iterators and references into a QVector and non-heap-allocating QLists.\n\nNote: QVector and QVarLengthArray both guarantee C-compatible array layout. QList does not. This might be important if your application must interface with a C API.\n\nQList <T>, QLinkedList<T>, QVector<T>, and QVarLengthArray <T> provide similar APIs and functionality. They are often interchangeable, but there are performance consequences. Here is an overview of use cases:\n\nQVector<T> is one of Qt's generic container classes . It stores its items in adjacent memory locations and provides fast index-based access.\n\nSee also QVectorIterator, QMutableVectorIterator, QList, and QLinkedList.\n\nSee also QVector::rbegin (), QVector::rend (), QVector::const_reverse_iterator , and QVector::iterator .\n\nThis typedef was introduced in Qt 5.6.\n\nWarning: Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read Implicit sharing iterator problem .\n\nIt is simply a typedef for std::reverse_iterator<T*> .\n\nThe QVector::reverse_iterator typedef provides an STL-style non-const reverse iterator for QVector .\n\nSee also QVector::begin (), QVector::end (), QVector::const_iterator , and QMutableVectorIterator .\n\nWarning: Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read Implicit sharing iterator problem .\n\nQVector provides both STL-style iterators and Java-style iterators . The STL-style non-const iterator is simply a typedef for \"T *\" (pointer to T).\n\nThe QVector::iterator typedef provides an STL-style non-const iterator for QVector and QStack .\n\nSee also QVector::rbegin (), QVector::rend (), QVector::reverse_iterator , and QVector::const_iterator .\n\nThis typedef was introduced in Qt 5.6.\n\nWarning: Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read Implicit sharing iterator problem .\n\nIt is simply a typedef for std::reverse_iterator<const T*> .\n\nThe QVector::const_reverse_iterator typedef provides an STL-style const reverse iterator for QVector .\n\nSee also QVector::constBegin (), QVector::constEnd (), QVector::iterator , and QVectorIterator .\n\nWarning: Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read Implicit sharing iterator problem .\n\nQVector provides both STL-style iterators and Java-style iterators . The STL-style const iterator is simply a typedef for \"const T *\" (pointer to const T).\n\nThe QVector::const_iterator typedef provides an STL-style const iterator for QVector and QStack .\n\nThis function is provided for STL compatibility. It is equivalent to prepend(value).\n\nThis is an overloaded function.\n\nInserts value in front of the item pointed to by the iterator before. Returns an iterator pointing at the inserted item.\n\nInserts value at index position i in the vector. If i is 0, the value is prepended to the vector. If i is size(), the value is appended to the vector.\n\nFor large vectors, this operation can be slow (linear time), because it requires moving all the items at indexes i and above by one position further in memory. If you want a container class that provides a fast insert() function, use QLinkedList instead.\n\nSee also append(), prepend(), and remove().\n\nInserts value at the beginning of the vector.\n\nThis is the same as vector.insert(0, value).\n\nFor large vectors, this operation can be slow (linear time), because it requires moving all the items in the vector by one position further in memory. If you want a container class that provides a fast prepend() function, use QList or QLinkedList instead.\n\nSee also append() and insert().\n\nConstructs a vector with the contents in the iterator range [first, last).\n\nThe value type of must be convertible to .\n\nThis function was introduced in Qt 5.14.\n\nConstructs a vector from the std::initializer_list given by args.\n\nThis constructor is only enabled if the compiler supports C++11 initializer lists.\n\nThis function was introduced in Qt 4.8.\n\nMove-constructs a QVector instance, making it point at the same object that other was pointing to.\n\nThis function was introduced in Qt 5.2.\n\nThis operation takes constant time, because QVector is implicitly shared. This makes returning a QVector from a function very fast. If a shared instance is modified, it will be copied (copy-on-write), and that takes linear time.\n\nConstructs a vector with an initial size of size elements. Each element is initialized with value.\n\nSee also resize() and fill().\n\nConstructs a vector with an initial size of size elements.\n\nThe elements are initialized with a default-constructed value.\n\nMove-assigns other to this QVector instance.\n\nThis function was introduced in Qt 5.2.\n\nAssigns other to this vector and returns a reference to this vector.\n\nInserts value at the end of the vector.\n\nThis is the same as calling resize(size() + 1) and assigning value to the new last element in the vector.\n\nThis operation is relatively fast, because QVector typically allocates more memory than necessary, so it can grow without reallocating the entire vector each time.\n\nSee also operator<<(), prepend(), and insert().\n\nThis is an overloaded function.\n\nThis function was introduced in Qt 5.6.\n\nThis is an overloaded function.\n\nAppends the items of the value vector to this vector.\n\nThis function was introduced in Qt 5.5.\n\nSee also operator<<() and operator+=().\n\nReturns the item at index position i in the vector.\n\ni must be a valid index position in the vector (i.e., 0 <= i < size()).\n\nSee also value() and operator[]().\n\nThis function is provided for STL compatibility. It is equivalent to last().\n\nThis is an overloaded function.\n\nReturns an STL-style iterator pointing to the first item in the vector.\n\nSee also constBegin() and end().\n\nThis is an overloaded function.\n\nReturns the maximum number of items that can be stored in the vector without forcing a reallocation.\n\nThe sole purpose of this function is to provide a means of fine tuning QVector's memory usage. In general, you will rarely ever need to call this function. If you want to know how many items are in the vector, call size().\n\nSee also reserve() and squeeze().\n\nReturns a const STL-style iterator pointing to the first item in the vector.\n\nThis function was introduced in Qt 5.0.\n\nSee also begin() and cend().\n\nReturns a const STL-style iterator pointing to the imaginary item after the last item in the vector.\n\nThis function was introduced in Qt 5.0.\n\nSee also cbegin() and end().\n\nRemoves all the elements from the vector.\n\nReturns a const STL-style iterator pointing to the first item in the vector.\n\nSee also begin() and constEnd().\n\nReturns a const pointer to the data stored in the vector. The pointer can be used to access the items in the vector. The pointer remains valid as long as the vector isn't reallocated.\n\nThis function is mostly useful to pass a vector to a function that accepts a plain C++ array.\n\nSee also data() and operator[]().\n\nReturns a const STL-style iterator pointing to the imaginary item after the last item in the vector.\n\nSee also constBegin() and end().\n\nReturns a const reference to the first item in the vector. This function assumes that the vector isn't empty.\n\nThis function was introduced in Qt 5.6.\n\nSee also constLast(), isEmpty(), and first().\n\nReturns a const reference to the last item in the vector. This function assumes that the vector isn't empty.\n\nThis function was introduced in Qt 5.6.\n\nSee also constFirst(), isEmpty(), and last().\n\nReturns if the vector contains an occurrence of value; otherwise returns .\n\nThis function requires the value type to have an implementation of .\n\nSee also indexOf() and count().\n\nReturns the number of occurrences of value in the vector.\n\nThis function requires the value type to have an implementation of .\n\nSee also contains() and indexOf().\n\nThis is an overloaded function.\n\nReturns a const STL-style reverse iterator pointing to the first item in the vector, in reverse order.\n\nThis function was introduced in Qt 5.6.\n\nSee also begin(), rbegin(), and rend().\n\nReturns a const STL-style reverse iterator pointing to one past the last item in the vector, in reverse order.\n\nThis function was introduced in Qt 5.6.\n\nSee also end(), rend(), and rbegin().\n\nReturns a pointer to the data stored in the vector. The pointer can be used to access and modify the items in the vector.\n\nThe pointer remains valid as long as the vector isn't reallocated.\n\nThis function is mostly useful to pass a vector to a function that accepts a plain C++ array.\n\nSee also constData() and operator[]().\n\nThis is an overloaded function.\n\nThis function is provided for STL compatibility. It is equivalent to isEmpty(), returning if the vector is empty; otherwise returns .\n\nReturns an STL-style iterator pointing to the imaginary item after the last item in the vector.\n\nSee also begin() and constEnd().\n\nThis is an overloaded function.\n\nReturns if this vector is not empty and its last item is equal to value; otherwise returns .\n\nThis function was introduced in Qt 4.5.\n\nSee also isEmpty() and last().\n\nRemoves the item pointed to by the iterator pos from the vector, and returns an iterator to the next item in the vector (which may be end()).\n\nSee also insert() and remove().\n\nThis is an overloaded function.\n\nRemoves all the items from begin up to (but not including) end. Returns an iterator to the same item that end referred to before the call.\n\nAssigns value to all items in the vector. If size is different from -1 (the default), the vector is resized to size size beforehand.\n\nReturns a reference to the first item in the vector. This function assumes that the vector isn't empty.\n\nSee also last(), isEmpty(), and constFirst().\n\nThis is an overloaded function.\n\nReturns a QVector object with the data contained in list.\n\nSee also toList() and QList::toVector().\n\nReturns a QVector object with the data contained in vector. The order of the elements in the QVector is the same as in vector.\n\nSee also toStdVector() and QList::fromStdList().\n\nThis function is provided for STL compatibility. It is equivalent to first().\n\nThis is an overloaded function.\n\nReturns the index position of the first occurrence of value in the vector, searching forward from index position from. Returns -1 if no item matched.\n\nThis function requires the value type to have an implementation of .\n\nSee also lastIndexOf() and contains().\n\nThis is an overloaded function.\n\nInserts count copies of value at index position i in the vector.\n\nInserts count copies of value in front of the item pointed to by the iterator before. Returns an iterator pointing at the first of the inserted items.\n\nReturns if the vector has size 0; otherwise returns .\n\nSee also size() and resize().\n\nReturns a reference to the last item in the vector. This function assumes that the vector isn't empty.\n\nSee also first(), isEmpty(), and constLast().\n\nThis is an overloaded function.\n\nReturns the index position of the last occurrence of the value value in the vector, searching backward from index position from. If from is -1 (the default), the search starts at the last item. Returns -1 if no item matched.\n\nThis function requires the value type to have an implementation of .\n\nSame as size() and count().\n\nThis function was introduced in Qt 5.2.\n\nSee also size(), count(), and QList::length().\n\nReturns a sub-vector which contains elements from this vector, starting at position pos. If length is -1 (the default), all elements after pos are included; otherwise length elements (or all remaining elements if there are less than length elements) are included.\n\nMoves the item at index position from to index position to.\n\nThis function was introduced in Qt 5.6.\n\nThis function is provided for STL compatibility. It is equivalent to removeLast().\n\nThis function is provided for STL compatibility. It is equivalent to removeFirst().\n\nThis function is provided for STL compatibility. It is equivalent to append(value).\n\nThis is an overloaded function.\n\nThis function was introduced in Qt 5.6.\n\nReturns a STL-style reverse iterator pointing to the first item in the vector, in reverse order.\n\nThis function was introduced in Qt 5.6.\n\nSee also begin(), crbegin(), and rend().\n\nThis is an overloaded function.\n\nThis function was introduced in Qt 5.6.\n\nThis is an overloaded function.\n\nSee also insert(), replace(), and fill().\n\nThis is an overloaded function.\n\nRemoves count elements from the middle of the vector, starting at index position i.\n\nSee also insert(), replace(), and fill().\n\nRemoves all elements that compare equal to t from the vector. Returns the number of elements removed, if any.\n\nThis function was introduced in Qt 5.4.\n\nSee also removeOne() and QList::removeAll().\n\nRemoves the element at index position i. Equivalent to\n\nThis function was introduced in Qt 5.2.\n\nSee also remove() and QList::removeAt().\n\nRemoves the first item in the vector. Calling this function is equivalent to calling remove(0). The vector must not be empty. If the vector can be empty, call isEmpty() before calling this function.\n\nThis function was introduced in Qt 5.1.\n\nSee also remove(), takeFirst(), and isEmpty().\n\nRemoves the last item in the vector. Calling this function is equivalent to calling remove(size() - 1). The vector must not be empty. If the vector can be empty, call isEmpty() before calling this function.\n\nThis function was introduced in Qt 5.1.\n\nSee also remove(), takeLast(), removeFirst(), and isEmpty().\n\nRemoves the first element that compares equal to t from the vector. Returns whether an element was, in fact, removed.\n\nThis function was introduced in Qt 5.4.\n\nSee also removeAll() and QList::removeOne().\n\nReturns a STL-style reverse iterator pointing to one past the last item in the vector, in reverse order.\n\nThis function was introduced in Qt 5.6.\n\nSee also end(), crend(), and rbegin().\n\nThis is an overloaded function.\n\nThis function was introduced in Qt 5.6.\n\nReplaces the item at index position i with value.\n\ni must be a valid index position in the vector (i.e., 0 <= i < size()).\n\nSee also operator[]() and remove().\n\nAttempts to allocate memory for at least size elements. If you know in advance how large the vector will be, you should call this function to prevent reallocations and memory fragmentation.\n\nIf size is an underestimate, the worst that will happen is that the QVector will be a bit slower. If size is an overestimate, you may have used more memory than the normal QVector growth strategy would have allocatedâ€”or you may have used less.\n\nAn alternative to reserve() is calling resize(). Whether or not that is faster than reserve() depends on the element type, because resize() default-constructs all elements, and requires assignment to existing entries rather than calling append(), which copy- or move-constructs. For simple types, like or , resize() is typically faster, but for anything more complex, you should prefer reserve().\n\nSee also squeeze() and capacity().\n\nSets the size of the vector to size. If size is greater than the current size, elements are added to the end; the new elements are initialized with a default-constructed value. If size is less than the current size, elements are removed from the end.\n\nSince Qt 5.6, resize() doesn't shrink the capacity anymore. To shed excess capacity, use squeeze().\n\nThis function is provided for STL compatibility. It is equivalent to squeeze().\n\nThis function was introduced in Qt 5.10.\n\nReturns the number of items in the vector.\n\nSee also isEmpty() and resize().\n\nReleases any memory not required to store the items.\n\nThe sole purpose of this function is to provide a means of fine tuning QVector's memory usage. In general, you will rarely ever need to call this function.\n\nSee also reserve() and capacity().\n\nReturns if this vector is not empty and its first item is equal to value; otherwise returns .\n\nThis function was introduced in Qt 4.5.\n\nSee also isEmpty() and first().\n\nSwaps vector other with this vector. This operation is very fast and never fails.\n\nThis function was introduced in Qt 4.8.\n\nExchange the item at index position i with the item at index position j. This function assumes that both i and j are at least 0 but less than size(). To avoid failure, test that both i and j are at least 0 and less than size().\n\nThis function was introduced in Qt 5.14.\n\nRemoves the element at index position i and returns it.\n\nThis function was introduced in Qt 5.2.\n\nSee also takeFirst(), takeLast(), and QList::takeAt().\n\nRemoves the first item in the vector and returns it. This function assumes the vector is not empty. To avoid failure, call isEmpty() before calling this function.\n\nThis function was introduced in Qt 5.1.\n\nSee also takeLast() and removeFirst().\n\nRemoves the last item in the list and returns it. This function assumes the vector is not empty. To avoid failure, call isEmpty() before calling this function.\n\nIf you don't use the return value, removeLast() is more efficient.\n\nThis function was introduced in Qt 5.1.\n\nSee also takeFirst() and removeLast().\n\nReturns a QList object with the data contained in this QVector.\n\nSee also fromList() and QList::fromVector().\n\nReturns a std::vector object with the data contained in this QVector. Example:\n\nSee also fromStdVector() and QList::toStdList().\n\nReturns the value at index position i in the vector.\n\nIf the index i is out of bounds, the function returns a default-constructed value. If you are certain that i is within bounds, you can use at() instead, which is slightly faster.\n\nSee also at() and operator[]().\n\nThis is an overloaded function.\n\nIf the index i is out of bounds, the function returns defaultValue.\n\nReturns if other is not equal to this vector; otherwise returns .\n\nTwo vectors are considered equal if they contain the same values in the same order.\n\nThis function requires the value type to have an implementation of .\n\nReturns a vector that contains all the items in this vector followed by all the items in the other vector.\n\nAppends the items of the other vector to this vector and returns a reference to this vector.\n\nSee also operator+() and append().\n\nThis is an overloaded function.\n\nAppends value to the vector.\n\nSee also append() and operator<<().\n\nThis is an overloaded function.\n\nThis function was introduced in Qt 5.11.\n\nSee also append() and operator<<().\n\nAppends value to the vector and returns a reference to this vector.\n\nSee also append() and operator+=().\n\nAppends other to the vector and returns a reference to the vector.\n\nThis is an overloaded function.\n\nThis function was introduced in Qt 5.11.\n\nSee also append() and operator+=().\n\nAssigns the collection of values in args to this QVector instance.\n\nThis operator is only enabled if the compiler supports C++11 initializer lists.\n\nThis function was introduced in Qt 5.14.\n\nReturns if other is equal to this vector; otherwise returns .\n\nTwo vectors are considered equal if they contain the same values in the same order.\n\nThis function requires the value type to have an implementation of .\n\nReturns the item at index position i as a modifiable reference.\n\ni must be a valid index position in the vector (i.e., 0 <= i < size()).\n\nNote that using non-const operators can cause QVector to do a deep copy.\n\nSee also at() and value().\n\nThis is an overloaded function."
    },
    {
        "link": "https://ftp.nmr.mgh.harvard.edu/pub/dist/freesurfer/tutorial_versions/freesurfer/lib/qt/qt_doc/html/qvector.html",
        "document": "The QVector class is a template class that provides a dynamic array. More...\n\nNote: All functions in this class are reentrant.\n\nQVector does not support inserting, prepending, appending or replacing with references to its own values. Doing so will cause your application to abort with an error message.\n\nIn addition to QVector, Qt also provides QVarLengthArray , a very low-level class with little functionality that is optimized for speed.\n\nLike the other container classes, QVector provides Java-style iterators ( QVectorIterator and QMutableVectorIterator ) and STL-style iterators ( QVector::const_iterator and QVector::iterator ). In practice, these are rarely used, because you can use indexes into the QVector.\n\nQVector's value type must be an assignable data type . This covers most data types that are commonly used, but the compiler won't let you, for example, store a QWidget as a value; instead, store a QWidget *. A few functions have additional requirements; for example, indexOf () and lastIndexOf () expect the value type to support operator==() . These requirements are documented on a per-function basis.\n\nNote that using non-const operators and functions can cause QVector to do a deep copy of the data. This is due to implicit sharing .\n\nIf you know in advance approximately how many items the QVector will contain, you can call reserve (), asking QVector to preallocate a certain amount of memory. You can also call capacity () to find out how much memory QVector actually allocated.\n\nUnlike plain C++ arrays, QVectors can be resized at any time by calling resize (). If the new size is larger than the old size, QVector might need to reallocate the whole vector. QVector tries to reduce the number of reallocations by preallocating up to twice as much memory as the actual data needs.\n\nQVector provides these basic functions to add, move, and remove items: insert (), replace (), remove (), prepend (), append (). With the exception of append () and replace (), these functions can be slow ( linear time ) for large vectors, because they require moving many items in the vector by one position in memory. If you want a container class that provides fast insertion/removal in the middle, use QList or QLinkedList instead.\n\nIf you simply want to check whether a vector contains a particular value, use contains (). If you want to find out how many times a particular value occurs in the vector, use count ().\n\nIf you want to find all occurrences of a particular value in a vector, use indexOf () or lastIndexOf (). The former searches forward starting from a given index position, the latter searches backward. Both return the index of the matching item if they found one; otherwise, they return -1. For example:\n\nAnother way to access the data stored in a QVector is to call data (). The function returns a pointer to the first item in the vector. You can use the pointer to directly access and modify the elements stored in the vector. The pointer is also useful if you need to pass a QVector to a function that accepts a plain C++ array.\n\nat () can be faster than operator[](), because it never causes a deep copy to occur.\n\nFor read-only access, an alternative syntax is to use at ():\n\nQVector uses 0-based indexes, just like C++ arrays. To access the item at a particular index position, you can use operator[](). On non-const vectors, operator[]() returns a reference to the item that can be used on the left side of an assignment:\n\nYou can also call fill () at any time to fill the vector with a value.\n\nThe elements are automatically initialized with a default-constructed value . If you want to initialize the vector with a different value, pass that value as the second argument to the constructor:\n\nQVector stores a vector (or array) of items. Typically, vectors are created with an initial size. For example, the following code constructs a QVector with 200 elements:\n\nHere's an example of a QVector that stores integers and a QVector that stores QString values:\n\nQVector<T> is one of Qt's generic container classes . It stores its items in adjacent memory locations and provides fast index-based access.\n\nThe QVector class is a template class that provides a dynamic array.\n\nSee also QVectorIterator, QMutableVectorIterator, QList, and QLinkedList.\n\nSee also QVector::begin (), QVector::end (), QVector::const_iterator , and QMutableVectorIterator .\n\nQVector provides both STL-style iterators and Java-style iterators . The STL-style non-const iterator is simply a typedef for \"T *\" (pointer to T).\n\nThe QVector::iterator typedef provides an STL-style non-const iterator for QVector and QStack .\n\nSee also QVector::constBegin (), QVector::constEnd (), QVector::iterator , and QVectorIterator .\n\nQVector provides both STL-style iterators and Java-style iterators . The STL-style const iterator is simply a typedef for \"const T *\" (pointer to const T).\n\nThe QVector::const_iterator typedef provides an STL-style const iterator for QVector and QStack .\n\nConstructs a vector with an initial size of size elements.\n\nThe elements are initialized with a default-constructed value.\n\nConstructs a vector with an initial size of size elements. Each element is initialized with value.\n\nSee also resize() and fill().\n\nThis operation takes constant time, because QVector is implicitly shared. This makes returning a QVector from a function very fast. If a shared instance is modified, it will be copied (copy-on-write), and that takes linear time.\n\nInserts value at the end of the vector.\n\nThis is the same as calling resize(size() + 1) and assigning value to the new last element in the vector.\n\nThis operation is relatively fast, because QVector typically allocates more memory than necessary, so it can grow without reallocating the entire vector each time.\n\nSee also operator<<(), prepend(), and insert().\n\nReturns the item at index position i in the vector.\n\ni must be a valid index position in the vector (i.e., 0 <= i < size()).\n\nSee also value() and operator[]().\n\nThis function is provided for STL compatibility. It is equivalent to last().\n\nThis is an overloaded function.\n\nReturns an STL-style iterator pointing to the first item in the vector.\n\nSee also constBegin() and end().\n\nThis is an overloaded function.\n\nReturns the maximum number of items that can be stored in the vector without forcing a reallocation.\n\nThe sole purpose of this function is to provide a means of fine tuning QVector's memory usage. In general, you will rarely ever need to call this function. If you want to know how many items are in the vector, call size().\n\nSee also reserve() and squeeze().\n\nRemoves all the elements from the vector and releases the memory used by the vector.\n\nReturns a const STL-style iterator pointing to the first item in the vector.\n\nSee also begin() and constEnd().\n\nReturns a const pointer to the data stored in the vector. The pointer can be used to access the items in the vector. The pointer remains valid as long as the vector isn't reallocated.\n\nThis function is mostly useful to pass a vector to a function that accepts a plain C++ array.\n\nSee also data() and operator[]().\n\nReturns a const STL-style iterator pointing to the imaginary item after the last item in the vector.\n\nSee also constBegin() and end().\n\nReturns true if the vector contains an occurrence of value; otherwise returns false.\n\nThis function requires the value type to have an implementation of .\n\nSee also indexOf() and count().\n\nReturns the number of occurrences of value in the vector.\n\nThis function requires the value type to have an implementation of .\n\nSee also contains() and indexOf().\n\nThis is an overloaded function.\n\nReturns a pointer to the data stored in the vector. The pointer can be used to access and modify the items in the vector.\n\nThe pointer remains valid as long as the vector isn't reallocated.\n\nThis function is mostly useful to pass a vector to a function that accepts a plain C++ array.\n\nSee also constData() and operator[]().\n\nThis is an overloaded function.\n\nThis function is provided for STL compatibility. It is equivalent to isEmpty(), returning true if the vector is empty; otherwise returns false.\n\nReturns an STL-style iterator pointing to the imaginary item after the last item in the vector.\n\nSee also begin() and constEnd().\n\nThis is an overloaded function.\n\nReturns true if this vector is not empty and its last item is equal to value; otherwise returns false.\n\nThis function was introduced in Qt 4.5.\n\nSee also isEmpty() and last().\n\nRemoves the item pointed to by the iterator pos from the vector, and returns an iterator to the next item in the vector (which may be end()).\n\nSee also insert() and remove().\n\nThis is an overloaded function.\n\nRemoves all the items from begin up to (but not including) end. Returns an iterator to the same item that end referred to before the call.\n\nAssigns value to all items in the vector. If size is different from -1 (the default), the vector is resized to size size beforehand.\n\nReturns a reference to the first item in the vector. This function assumes that the vector isn't empty.\n\nSee also last() and isEmpty().\n\nThis is an overloaded function.\n\nReturns a QVector object with the data contained in list.\n\nSee also toList() and QList::toVector().\n\nReturns a QVector object with the data contained in vector. The order of the elements in the QVector is the same as in vector.\n\nSee also toStdVector() and QList::fromStdList().\n\nThis function is provided for STL compatibility. It is equivalent to first().\n\nThis is an overloaded function.\n\nReturns the index position of the first occurrence of value in the vector, searching forward from index position from. Returns -1 if no item matched.\n\nThis function requires the value type to have an implementation of .\n\nSee also lastIndexOf() and contains().\n\nInserts value at index position i in the vector. If i is 0, the value is prepended to the vector. If i is size(), the value is appended to the vector.\n\nFor large vectors, this operation can be slow (linear time), because it requires moving all the items at indexes i and above by one position further in memory. If you want a container class that provides a fast insert() function, use QLinkedList instead.\n\nSee also append(), prepend(), and remove().\n\nInserts count copies of value in front of the item pointed to by the iterator before. Returns an iterator pointing at the first of the inserted items.\n\nThis is an overloaded function.\n\nInserts count copies of value at index position i in the vector.\n\nThis is an overloaded function.\n\nInserts value in front of the item pointed to by the iterator before. Returns an iterator pointing at the inserted item.\n\nReturns true if the vector has size 0; otherwise returns false.\n\nSee also size() and resize().\n\nReturns a reference to the last item in the vector. This function assumes that the vector isn't empty.\n\nSee also first() and isEmpty().\n\nThis is an overloaded function.\n\nReturns the index position of the last occurrence of the value value in the vector, searching backward from index position from. If from is -1 (the default), the search starts at the last item. Returns -1 if no item matched.\n\nThis function requires the value type to have an implementation of .\n\nReturns a vector whose elements are copied from this vector, starting at position pos. If length is -1 (the default), all elements after pos are copied; otherwise length elements (or all remaining elements if there are less than length elements) are copied.\n\nThis function is provided for STL compatibility. It is equivalent to erase(end() - 1).\n\nThis function is provided for STL compatibility. It is equivalent to erase(begin()).\n\nInserts value at the beginning of the vector.\n\nThis is the same as vector.insert(0, value).\n\nFor large vectors, this operation can be slow (linear time), because it requires moving all the items in the vector by one position further in memory. If you want a container class that provides a fast prepend() function, use QList or QLinkedList instead.\n\nSee also append() and insert().\n\nThis function is provided for STL compatibility. It is equivalent to append(value).\n\nThis function is provided for STL compatibility. It is equivalent to prepend(value).\n\nThis is an overloaded function.\n\nSee also insert(), replace(), and fill().\n\nThis is an overloaded function.\n\nRemoves count elements from the middle of the vector, starting at index position i.\n\nSee also insert(), replace(), and fill().\n\nReplaces the item at index position i with value.\n\ni must be a valid index position in the vector (i.e., 0 <= i < size()).\n\nSee also operator[]() and remove().\n\nAttempts to allocate memory for at least size elements. If you know in advance how large the vector will be, you can call this function, and if you call resize() often you are likely to get better performance. If size is an underestimate, the worst that will happen is that the QVector will be a bit slower.\n\nThe sole purpose of this function is to provide a means of fine tuning QVector's memory usage. In general, you will rarely ever need to call this function. If you want to change the size of the vector, call resize().\n\nSee also squeeze() and capacity().\n\nSets the size of the vector to size. If size is greater than the current size, elements are added to the end; the new elements are initialized with a default-constructed value. If size is less than the current size, elements are removed from the end.\n\nReturns the number of items in the vector.\n\nSee also isEmpty() and resize().\n\nReleases any memory not required to store the items.\n\nThe sole purpose of this function is to provide a means of fine tuning QVector's memory usage. In general, you will rarely ever need to call this function.\n\nSee also reserve() and capacity().\n\nReturns true if this vector is not empty and its first item is equal to value; otherwise returns false.\n\nThis function was introduced in Qt 4.5.\n\nSee also isEmpty() and first().\n\nReturns a QList object with the data contained in this QVector.\n\nSee also fromList() and QList::fromVector().\n\nReturns a std::vector object with the data contained in this QVector. Example:\n\nSee also fromStdVector() and QList::toStdList().\n\nReturns the value at index position i in the vector.\n\nIf the index i is out of bounds, the function returns a default-constructed value. If you are certain that i is within bounds, you can use at() instead, which is slightly faster.\n\nSee also at() and operator[]().\n\nThis is an overloaded function.\n\nIf the index i is out of bounds, the function returns defaultValue.\n\nReturns true if other is not equal to this vector; otherwise returns false.\n\nTwo vectors are considered equal if they contain the same values in the same order.\n\nThis function requires the value type to have an implementation of .\n\nReturns a vector that contains all the items in this vector followed by all the items in the other vector.\n\nAppends the items of the other vector to this vector and returns a reference to this vector.\n\nSee also operator+() and append().\n\nThis is an overloaded function.\n\nAppends value to the vector.\n\nSee also append() and operator<<().\n\nAppends value to the vector and returns a reference to this vector.\n\nSee also append() and operator+=().\n\nAppends other to the vector and returns a reference to the vector.\n\nAssigns other to this vector and returns a reference to this vector.\n\nReturns true if other is equal to this vector; otherwise returns false.\n\nTwo vectors are considered equal if they contain the same values in the same order.\n\nThis function requires the value type to have an implementation of .\n\nReturns the item at index position i as a modifiable reference.\n\ni must be a valid index position in the vector (i.e., 0 <= i < size()).\n\nNote that using non-const operators can cause QVector to do a deep copy.\n\nSee also at() and value().\n\nThis is an overloaded function."
    },
    {
        "link": "https://stuff.mit.edu/afs/athena/software/texmaker_v5.0.2/qt57/doc/qtcore/qvector.html",
        "document": "The QVector class is a template class that provides a dynamic array. More...\n\nNote: All functions in this class are reentrant.\n\nFor a detailed discussion comparing Qt containers with each other and with STL containers, see Understand the Qt Containers .\n\nQVector does not support inserting, prepending, appending or replacing with references to its own values. Doing so will cause your application to abort with an error message.\n\nIn addition to QVector , Qt also provides QVarLengthArray , a very low-level class with little functionality that is optimized for speed.\n\nLike the other container classes, QVector provides Java-style iterators ( QVectorIterator and QMutableVectorIterator ) and STL-style iterators ( QVector::const_iterator and QVector::iterator ). In practice, these are rarely used, because you can use indexes into the QVector .\n\nQVector 's value type must be an assignable data type . This covers most data types that are commonly used, but the compiler won't let you, for example, store a QWidget as a value; instead, store a QWidget *. A few functions have additional requirements; for example, indexOf () and lastIndexOf () expect the value type to support operator==() . These requirements are documented on a per-function basis.\n\nNote that using non-const operators and functions can cause QVector to do a deep copy of the data. This is due to implicit sharing .\n\nIf you know in advance approximately how many items the QVector will contain, you can call reserve (), asking QVector to preallocate a certain amount of memory. You can also call capacity () to find out how much memory QVector actually allocated.\n\nUnlike plain C++ arrays, QVectors can be resized at any time by calling resize (). If the new size is larger than the old size, QVector might need to reallocate the whole vector. QVector tries to reduce the number of reallocations by preallocating up to twice as much memory as the actual data needs.\n\nQVector provides these basic functions to add, move, and remove items: insert (), replace (), remove (), prepend (), append (). With the exception of append () and replace (), these functions can be slow ( linear time ) for large vectors, because they require moving many items in the vector by one position in memory. If you want a container class that provides fast insertion/removal in the middle, use QList or QLinkedList instead.\n\nIf you simply want to check whether a vector contains a particular value, use contains (). If you want to find out how many times a particular value occurs in the vector, use count ().\n\n\"First occurrence of Harumi is at position \"\n\nIf you want to find all occurrences of a particular value in a vector, use indexOf () or lastIndexOf (). The former searches forward starting from a given index position, the latter searches backward. Both return the index of the matching item if they found one; otherwise, they return -1. For example:\n\nAnother way to access the data stored in a QVector is to call data (). The function returns a pointer to the first item in the vector. You can use the pointer to directly access and modify the elements stored in the vector. The pointer is also useful if you need to pass a QVector to a function that accepts a plain C++ array.\n\nat () can be faster than operator[](), because it never causes a deep copy to occur.\n\nFor read-only access, an alternative syntax is to use at ():\n\nQVector uses 0-based indexes, just like C++ arrays. To access the item at a particular index position, you can use operator[](). On non-const vectors, operator[]() returns a reference to the item that can be used on the left side of an assignment:\n\nYou can also call fill () at any time to fill the vector with a value.\n\nThe elements are automatically initialized with a default-constructed value . If you want to initialize the vector with a different value, pass that value as the second argument to the constructor:\n\nQVector stores its items in a vector (array). Typically, vectors are created with an initial size. For example, the following code constructs a QVector with 200 elements:\n\nHere's an example of a QVector that stores integers and a QVector that stores QString values:\n\nNote: Iterators into a QLinkedList and references into heap-allocating QLists remain valid as long as the referenced items remain in the container. This is not true for iterators and references into a QVector and non-heap-allocating QLists.\n\nNote: QVector and QVarLengthArray both guarantee C-compatible array layout. QList does not. This might be important if your application must interface with a C API.\n\nQList <T>, QLinkedList <T>, QVector <T>, and QVarLengthArray <T> provide similar APIs and functionality. They are often interchangeable, but there are performance consequences. Here is an overview of use cases:\n\nQVector <T> is one of Qt's generic container classes . It stores its items in adjacent memory locations and provides fast index-based access.\n\nThe QVector class is a template class that provides a dynamic array.\n\nSee also QVectorIterator, QMutableVectorIterator, QList, and QLinkedList.\n\nSee also QVector::rbegin (), QVector::rend (), QVector::const_reverse_iterator , and QVector::iterator .\n\nThis typedef was introduced in Qt 5.6.\n\nWarning: Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read Implicit sharing iterator problem .\n\nIt is simply a typedef for std::reverse_iterator<T*> .\n\nThe QVector::reverse_iterator typedef provides an STL-style non-const reverse iterator for QVector .\n\nSee also QVector::begin (), QVector::end (), QVector::const_iterator , and QMutableVectorIterator .\n\nWarning: Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read Implicit sharing iterator problem .\n\nQVector provides both STL-style iterators and Java-style iterators . The STL-style non-const iterator is simply a typedef for \"T *\" (pointer to T).\n\nThe QVector::iterator typedef provides an STL-style non-const iterator for QVector and QStack .\n\nSee also QVector::rbegin (), QVector::rend (), QVector::reverse_iterator , and QVector::const_iterator .\n\nThis typedef was introduced in Qt 5.6.\n\nWarning: Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read Implicit sharing iterator problem .\n\nIt is simply a typedef for std::reverse_iterator<const T*> .\n\nThe QVector::const_reverse_iterator typedef provides an STL-style const reverse iterator for QVector .\n\nSee also QVector::constBegin (), QVector::constEnd (), QVector::iterator , and QVectorIterator .\n\nWarning: Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read Implicit sharing iterator problem .\n\nQVector provides both STL-style iterators and Java-style iterators . The STL-style const iterator is simply a typedef for \"const T *\" (pointer to const T).\n\nThe QVector::const_iterator typedef provides an STL-style const iterator for QVector and QStack .\n\nConstructs a vector with an initial size of size elements.\n\nThe elements are initialized with a default-constructed value.\n\nConstructs a vector with an initial size of size elements. Each element is initialized with value.\n\nSee also resize() and fill().\n\nThis operation takes constant time, because QVector is implicitly shared. This makes returning a QVector from a function very fast. If a shared instance is modified, it will be copied (copy-on-write), and that takes linear time.\n\nMove-constructs a QVector instance, making it point at the same object that other was pointing to.\n\nThis function was introduced in Qt 5.2.\n\nConstructs a vector from the std::initializer_list given by args.\n\nThis constructor is only enabled if the compiler supports C++11 initializer lists.\n\nThis function was introduced in Qt 4.8.\n\nInserts value at the end of the vector.\n\nThis is the same as calling resize(size() + 1) and assigning value to the new last element in the vector.\n\nThis operation is relatively fast, because QVector typically allocates more memory than necessary, so it can grow without reallocating the entire vector each time.\n\nSee also operator<<(), prepend(), and insert().\n\nThis is an overloaded function.\n\nThis function was introduced in Qt 5.6.\n\nThis is an overloaded function.\n\nAppends the items of the value vector to this vector.\n\nThis function was introduced in Qt 5.5.\n\nSee also operator<<() and operator+=().\n\nReturns the item at index position i in the vector.\n\ni must be a valid index position in the vector (i.e., 0 <= i < size()).\n\nSee also value() and operator[]().\n\nThis function is provided for STL compatibility. It is equivalent to last().\n\nThis is an overloaded function.\n\nReturns an STL-style iterator pointing to the first item in the vector.\n\nSee also constBegin() and end().\n\nThis is an overloaded function.\n\nReturns the maximum number of items that can be stored in the vector without forcing a reallocation.\n\nThe sole purpose of this function is to provide a means of fine tuning QVector's memory usage. In general, you will rarely ever need to call this function. If you want to know how many items are in the vector, call size().\n\nSee also reserve() and squeeze().\n\nReturns a const STL-style iterator pointing to the first item in the vector.\n\nThis function was introduced in Qt 5.0.\n\nSee also begin() and cend().\n\nReturns a const STL-style iterator pointing to the imaginary item after the last item in the vector.\n\nThis function was introduced in Qt 5.0.\n\nSee also cbegin() and end().\n\nRemoves all the elements from the vector.\n\nNote: Until Qt 5.6, this also released the memory used by the vector. From Qt 5.7, the capacity is preserved. To shed all capacity, swap with a default-constructed vector:\n\nReturns a const STL-style iterator pointing to the first item in the vector.\n\nSee also begin() and constEnd().\n\nReturns a const pointer to the data stored in the vector. The pointer can be used to access the items in the vector. The pointer remains valid as long as the vector isn't reallocated.\n\nThis function is mostly useful to pass a vector to a function that accepts a plain C++ array.\n\nSee also data() and operator[]().\n\nReturns a const STL-style iterator pointing to the imaginary item after the last item in the vector.\n\nSee also constBegin() and end().\n\nReturns a const reference to the first item in the vector. This function assumes that the vector isn't empty.\n\nThis function was introduced in Qt 5.6.\n\nSee also constLast(), isEmpty(), and first().\n\nReturns a const reference to the last item in the vector. This function assumes that the vector isn't empty.\n\nThis function was introduced in Qt 5.6.\n\nSee also constFirst(), isEmpty(), and last().\n\nReturns if the vector contains an occurrence of value; otherwise returns .\n\nThis function requires the value type to have an implementation of .\n\nSee also indexOf() and count().\n\nReturns the number of occurrences of value in the vector.\n\nThis function requires the value type to have an implementation of .\n\nSee also contains() and indexOf().\n\nThis is an overloaded function.\n\nReturns a const STL-style reverse iterator pointing to the first item in the vector, in reverse order.\n\nThis function was introduced in Qt 5.6.\n\nSee also begin(), rbegin(), and rend().\n\nReturns a const STL-style reverse iterator pointing to one past the last item in the vector, in reverse order.\n\nThis function was introduced in Qt 5.6.\n\nSee also end(), rend(), and rbegin().\n\nReturns a pointer to the data stored in the vector. The pointer can be used to access and modify the items in the vector.\n\nThe pointer remains valid as long as the vector isn't reallocated.\n\nThis function is mostly useful to pass a vector to a function that accepts a plain C++ array.\n\nSee also constData() and operator[]().\n\nThis is an overloaded function.\n\nThis function is provided for STL compatibility. It is equivalent to isEmpty(), returning if the vector is empty; otherwise returns .\n\nReturns an STL-style iterator pointing to the imaginary item after the last item in the vector.\n\nSee also begin() and constEnd().\n\nThis is an overloaded function.\n\nReturns if this vector is not empty and its last item is equal to value; otherwise returns .\n\nThis function was introduced in Qt 4.5.\n\nSee also isEmpty() and last().\n\nRemoves the item pointed to by the iterator pos from the vector, and returns an iterator to the next item in the vector (which may be end()).\n\nSee also insert() and remove().\n\nThis is an overloaded function.\n\nRemoves all the items from begin up to (but not including) end. Returns an iterator to the same item that end referred to before the call.\n\nAssigns value to all items in the vector. If size is different from -1 (the default), the vector is resized to size size beforehand.\n\nReturns a reference to the first item in the vector. This function assumes that the vector isn't empty.\n\nSee also last(), isEmpty(), and constFirst().\n\nThis is an overloaded function.\n\nReturns a QVector object with the data contained in list.\n\nSee also toList() and QList::toVector().\n\nReturns a QVector object with the data contained in vector. The order of the elements in the QVector is the same as in vector.\n\nSee also toStdVector() and QList::fromStdList().\n\nThis function is provided for STL compatibility. It is equivalent to first().\n\nThis is an overloaded function.\n\nReturns the index position of the first occurrence of value in the vector, searching forward from index position from. Returns -1 if no item matched.\n\nThis function requires the value type to have an implementation of .\n\nSee also lastIndexOf() and contains().\n\nInserts value at index position i in the vector. If i is 0, the value is prepended to the vector. If i is size(), the value is appended to the vector.\n\nFor large vectors, this operation can be slow (linear time), because it requires moving all the items at indexes i and above by one position further in memory. If you want a container class that provides a fast insert() function, use QLinkedList instead.\n\nSee also append(), prepend(), and remove().\n\nThis is an overloaded function.\n\nInserts count copies of value at index position i in the vector.\n\nInserts count copies of value in front of the item pointed to by the iterator before. Returns an iterator pointing at the first of the inserted items.\n\nThis is an overloaded function.\n\nInserts value in front of the item pointed to by the iterator before. Returns an iterator pointing at the inserted item.\n\nReturns if the vector has size 0; otherwise returns .\n\nSee also size() and resize().\n\nReturns a reference to the last item in the vector. This function assumes that the vector isn't empty.\n\nSee also first(), isEmpty(), and constLast().\n\nThis is an overloaded function.\n\nReturns the index position of the last occurrence of the value value in the vector, searching backward from index position from. If from is -1 (the default), the search starts at the last item. Returns -1 if no item matched.\n\nThis function requires the value type to have an implementation of .\n\nSame as size() and count().\n\nThis function was introduced in Qt 5.2.\n\nSee also size(), count(), and QList::length().\n\nReturns a sub-vector which contains elements from this vector, starting at position pos. If length is -1 (the default), all elements after pos are included; otherwise length elements (or all remaining elements if there are less than length elements) are included.\n\nMoves the item at index position from to index position to.\n\nThis function was introduced in Qt 5.6.\n\nThis function is provided for STL compatibility. It is equivalent to removeLast().\n\nThis function is provided for STL compatibility. It is equivalent to removeFirst().\n\nInserts value at the beginning of the vector.\n\nThis is the same as vector.insert(0, value).\n\nFor large vectors, this operation can be slow (linear time), because it requires moving all the items in the vector by one position further in memory. If you want a container class that provides a fast prepend() function, use QList or QLinkedList instead.\n\nSee also append() and insert().\n\nThis function is provided for STL compatibility. It is equivalent to append(value).\n\nThis is an overloaded function.\n\nThis function was introduced in Qt 5.6.\n\nThis function is provided for STL compatibility. It is equivalent to prepend(value).\n\nReturns a STL-style reverse iterator pointing to the first item in the vector, in reverse order.\n\nThis function was introduced in Qt 5.6.\n\nSee also begin(), crbegin(), and rend().\n\nThis is an overloaded function.\n\nThis function was introduced in Qt 5.6.\n\nThis is an overloaded function.\n\nSee also insert(), replace(), and fill().\n\nThis is an overloaded function.\n\nRemoves count elements from the middle of the vector, starting at index position i.\n\nSee also insert(), replace(), and fill().\n\nRemoves all elements that compare equal to t from the vector. Returns the number of elements removed, if any.\n\nThis function was introduced in Qt 5.4.\n\nSee also removeOne() and QList::removeAll().\n\nRemoves the element at index position i. Equivalent to\n\nThis function was introduced in Qt 5.2.\n\nSee also remove() and QList::removeAt().\n\nRemoves the first item in the vector. Calling this function is equivalent to calling remove(0). The vector must not be empty. If the vector can be empty, call isEmpty() before calling this function.\n\nThis function was introduced in Qt 5.1.\n\nSee also remove(), takeFirst(), and isEmpty().\n\nRemoves the last item in the vector. Calling this function is equivalent to calling remove(size() - 1). The vector must not be empty. If the vector can be empty, call isEmpty() before calling this function.\n\nThis function was introduced in Qt 5.1.\n\nSee also remove(), takeLast(), removeFirst(), and isEmpty().\n\nRemoves the first element that compares equal to t from the vector. Returns whether an element was, in fact, removed.\n\nThis function was introduced in Qt 5.4.\n\nSee also removeAll() and QList::removeOne().\n\nReturns a STL-style reverse iterator pointing to one past the last item in the vector, in reverse order.\n\nThis function was introduced in Qt 5.6.\n\nSee also end(), crend(), and rbegin().\n\nThis is an overloaded function.\n\nThis function was introduced in Qt 5.6.\n\nReplaces the item at index position i with value.\n\ni must be a valid index position in the vector (i.e., 0 <= i < size()).\n\nSee also operator[]() and remove().\n\nAttempts to allocate memory for at least size elements. If you know in advance how large the vector will be, you should call this function to prevent reallocations and memory fragmentation.\n\nIf size is an underestimate, the worst that will happen is that the QVector will be a bit slower. If size is an overestimate, you may have used more memory than the normal QVector growth strategy would have allocatedâ€”or you may have used less.\n\nAn alternative to reserve() is calling resize(). Whether or not that is faster than reserve() depends on the element type, because resize() default-constructs all elements, and requires assignment to existing entries rather than calling append(), which copy- or move-constructs. For simple types, like or , resize() is typically faster, but for anything more complex, you should prefer reserve().\n\nWarning: If the size passed to resize() was underestimated, you run out of allocated space and into undefined behavior. This problem does not exist with reserve(), because it treats the size as just a hint.\n\nSee also squeeze() and capacity().\n\nSets the size of the vector to size. If size is greater than the current size, elements are added to the end; the new elements are initialized with a default-constructed value. If size is less than the current size, elements are removed from the end.\n\nSince Qt 5.6, resize() doesn't shrink the capacity anymore. To shed excess capacity, use squeeze().\n\nReturns the number of items in the vector.\n\nSee also isEmpty() and resize().\n\nReleases any memory not required to store the items.\n\nThe sole purpose of this function is to provide a means of fine tuning QVector's memory usage. In general, you will rarely ever need to call this function.\n\nSee also reserve() and capacity().\n\nReturns if this vector is not empty and its first item is equal to value; otherwise returns .\n\nThis function was introduced in Qt 4.5.\n\nSee also isEmpty() and first().\n\nSwaps vector other with this vector. This operation is very fast and never fails.\n\nThis function was introduced in Qt 4.8.\n\nRemoves the element at index position i and returns it.\n\nThis function was introduced in Qt 5.2.\n\nSee also takeFirst(), takeLast(), and QList::takeAt().\n\nRemoves the first item in the vector and returns it. This function assumes the vector is not empty. To avoid failure, call isEmpty() before calling this function.\n\nThis function was introduced in Qt 5.1.\n\nSee also takeLast() and removeFirst().\n\nRemoves the last item in the list and returns it. This function assumes the vector is not empty. To avoid failure, call isEmpty() before calling this function.\n\nIf you don't use the return value, removeLast() is more efficient.\n\nThis function was introduced in Qt 5.1.\n\nSee also takeFirst() and removeLast().\n\nReturns a QList object with the data contained in this QVector.\n\nSee also fromList() and QList::fromVector().\n\nReturns a std::vector object with the data contained in this QVector. Example:\n\nSee also fromStdVector() and QList::toStdList().\n\nReturns the value at index position i in the vector.\n\nIf the index i is out of bounds, the function returns a default-constructed value. If you are certain that i is within bounds, you can use at() instead, which is slightly faster.\n\nSee also at() and operator[]().\n\nThis is an overloaded function.\n\nIf the index i is out of bounds, the function returns defaultValue.\n\nReturns if other is not equal to this vector; otherwise returns .\n\nTwo vectors are considered equal if they contain the same values in the same order.\n\nThis function requires the value type to have an implementation of .\n\nReturns a vector that contains all the items in this vector followed by all the items in the other vector.\n\nAppends the items of the other vector to this vector and returns a reference to this vector.\n\nSee also operator+() and append().\n\nThis is an overloaded function.\n\nAppends value to the vector.\n\nSee also append() and operator<<().\n\nAppends value to the vector and returns a reference to this vector.\n\nSee also append() and operator+=().\n\nAppends other to the vector and returns a reference to the vector.\n\nAssigns other to this vector and returns a reference to this vector.\n\nMove-assigns other to this QVector instance.\n\nThis function was introduced in Qt 5.2.\n\nReturns if other is equal to this vector; otherwise returns .\n\nTwo vectors are considered equal if they contain the same values in the same order.\n\nThis function requires the value type to have an implementation of .\n\nReturns the item at index position i as a modifiable reference.\n\ni must be a valid index position in the vector (i.e., 0 <= i < size()).\n\nNote that using non-const operators can cause QVector to do a deep copy.\n\nSee also at() and value().\n\nThis is an overloaded function."
    },
    {
        "link": "https://radekp.github.io/qtmoko/api/qvector.html",
        "document": "The QVector class is a template class that provides a dynamic array. More...\n\nNote: All the functions in this class are reentrant.\n\nThe QVector class is a template class that provides a dynamic array.\n\nQVector<T> is one of Qt's generic container classes. It stores its items in adjacent memory locations and provides fast index-based access.\nâ€¢ For most purposes, QList is the right class to use. Operations like prepend() and insert() are usually faster than with QVector because of the way QList stores its items in memory (see Algorithmic Complexity for details), and its index-based API is more convenient than QLinkedList's iterator-based API. It also expands to less code in your executable.\nâ€¢ If you need a real linked list, with guarantees of constant time insertions in the middle of the list and iterators to items rather than indexes, use QLinkedList.\nâ€¢ If you want the items to occupy adjacent memory positions, or if your items are larger than a pointer and you want to avoid the overhead of allocating them on the heap individually at insertion time, then use QVector.\nâ€¢ If you want a low-level variable-size array, QVarLengthArray may be sufficient.\n\nHere's an example of a QVector that stores integers and a QVector that stores QString values:\n\nQVector stores a vector (or array) of items. Typically, vectors are created with an initial size. For example, the following code constructs a QVector with 200 elements:\n\nThe elements are automatically initialized with a default-constructed value. If you want to initialize the vector with a different value, pass that value as the second argument to the constructor:\n\nYou can also call fill() at any time to fill the vector with a value.\n\nQVector uses 0-based indexes, just like C++ arrays. To access the item at a particular index position, you can use operator[](). On non-const vectors, operator[]() returns a reference to the item that can be used on the left side of an assignment:\n\nFor read-only access, an alternative syntax is to use at():\n\nat() can be faster than operator[](), because it never causes a deep copy to occur.\n\nAnother way to access the data stored in a QVector is to call data(). The function returns a pointer to the first item in the vector. You can use the pointer to directly access and modify the elements stored in the vector. The pointer is also useful if you need to pass a QVector to a function that accepts a plain C++ array.\n\nIf you want to find all occurrences of a particular value in a vector, use indexOf() or lastIndexOf(). The former searches forward starting from a given index position, the latter searches backward. Both return the index of the matching item if they found one; otherwise, they return -1. For example:\n\nIf you simply want to check whether a vector contains a particular value, use contains(). If you want to find out how many times a particular value occurs in the vector, use count().\n\nQVector provides these basic functions to add, move, and remove items: insert(), replace(), remove(), prepend(), append(). With the exception of append() and replace(), these functions can be slow (linear time) for large vectors, because they require moving many items in the vector by one position in memory. If you want a container class that provides fast insertion/removal in the middle, use QList or QLinkedList instead.\n\nUnlike plain C++ arrays, QVectors can be resized at any time by calling resize(). If the new size is larger than the old size, QVector might need to reallocate the whole vector. QVector tries to reduce the number of reallocations by preallocating up to twice as much memory as the actual data needs.\n\nIf you know in advance approximately how many items the QVector will contain, you can call reserve(), asking QVector to preallocate a certain amount of memory. You can also call capacity() to find out how much memory QVector actually allocated.\n\nNote that using non-const operators and functions can cause QVector to do a deep copy of the data. This is due to implicit sharing.\n\nQVector's value type must be an assignable data type. This covers most data types that are commonly used, but the compiler won't let you, for example, store a QWidget as a value; instead, store a QWidget *. A few functions have additional requirements; for example, indexOf() and lastIndexOf() expect the value type to support . These requirements are documented on a per-function basis.\n\nLike the other container classes, QVector provides Java-style iterators (QVectorIterator and QMutableVectorIterator) and STL-style iterators (QVector::const_iterator and QVector::iterator). In practice, these are rarely used, because you can use indexes into the QVector.\n\nIn addition to QVector, Qt also provides QVarLengthArray, a very low-level class with little functionality that is optimized for speed.\n\nQVector does not support inserting, prepending, appending or replacing with references to its own values. Doing so will cause your application to abort with an error message.\n\nSee also QVectorIterator, QMutableVectorIterator, QList, and QLinkedList.\n\nThe QVector::const_iterator typedef provides an STL-style const iterator for QVector and QStack.\n\nQVector provides both STL-style iterators and Java-style iterators. The STL-style const iterator is simply a typedef for \"const T *\" (pointer to const T).\n\nSee also QVector::constBegin(), QVector::constEnd(), QVector::iterator, and QVectorIterator.\n\nThe QVector::iterator typedef provides an STL-style non-const iterator for QVector and QStack.\n\nQVector provides both STL-style iterators and Java-style iterators. The STL-style non-const iterator is simply a typedef for \"T *\" (pointer to T).\n\nSee also QVector::begin(), QVector::end(), QVector::const_iterator, and QMutableVectorIterator.\n\nConstructs a vector with an initial size of size elements.\n\nThe elements are initialized with a default-constructed value.\n\nConstructs a vector with an initial size of size elements. Each element is initialized with value.\n\nSee also resize() and fill().\n\nThis operation takes constant time, because QVector is implicitly shared. This makes returning a QVector from a function very fast. If a shared instance is modified, it will be copied (copy-on-write), and that takes linear time.\n\nInserts value at the end of the vector.\n\nThis is the same as calling resize(size() + 1) and assigning value to the new last element in the vector.\n\nThis operation is relatively fast, because QVector typically allocates more memory than necessary, so it can grow without reallocating the entire vector each time.\n\nSee also operator<<(), prepend(), and insert().\n\nReturns the item at index position i in the vector.\n\ni must be a valid index position in the vector (i.e., 0 <= i < size()).\n\nSee also value() and operator[]().\n\nThis function is provided for STL compatibility. It is equivalent to last().\n\nThis is an overloaded member function, provided for convenience.\n\nReturns an STL-style iterator pointing to the first item in the vector.\n\nSee also constBegin() and end().\n\nThis is an overloaded member function, provided for convenience.\n\nReturns the maximum number of items that can be stored in the vector without forcing a reallocation.\n\nThe sole purpose of this function is to provide a means of fine tuning QVector's memory usage. In general, you will rarely ever need to call this function. If you want to know how many items are in the vector, call size().\n\nSee also reserve() and squeeze().\n\nRemoves all the elements from the vector.\n\nReturns a const STL-style iterator pointing to the first item in the vector.\n\nSee also begin() and constEnd().\n\nReturns a const pointer to the data stored in the vector. The pointer can be used to access the items in the vector. The pointer remains valid as long as the vector isn't reallocated.\n\nThis function is mostly useful to pass a vector to a function that accepts a plain C++ array.\n\nSee also data() and operator[]().\n\nReturns a const STL-style iterator pointing to the imaginary item after the last item in the vector.\n\nSee also constBegin() and end().\n\nReturns true if the vector contains an occurrence of value; otherwise returns false.\n\nThis function requires the value type to have an implementation of .\n\nSee also indexOf() and count().\n\nReturns the number of occurrences of value in the vector.\n\nThis function requires the value type to have an implementation of .\n\nSee also contains() and indexOf().\n\nThis is an overloaded member function, provided for convenience.\n\nReturns a pointer to the data stored in the vector. The pointer can be used to access and modify the items in the vector.\n\nThe pointer remains valid as long as the vector isn't reallocated.\n\nThis function is mostly useful to pass a vector to a function that accepts a plain C++ array.\n\nSee also constData() and operator[]().\n\nThis is an overloaded member function, provided for convenience.\n\nThis function is provided for STL compatibility. It is equivalent to isEmpty(), returning true if the vector is empty; otherwise returns false.\n\nReturns an STL-style iterator pointing to the imaginary item after the last item in the vector.\n\nSee also begin() and constEnd().\n\nThis is an overloaded member function, provided for convenience.\n\nRemoves the item pointed to by the iterator pos from the vector, and returns an iterator to the next item in the vector (which may be end()).\n\nSee also insert() and remove().\n\nThis is an overloaded member function, provided for convenience.\n\nRemoves all the items from begin up to (but not including) end. Returns an iterator to the same item that end referred to before the call.\n\nAssigns value to all items in the vector. If size is different from -1 (the default), the vector is resized to size size beforehand.\n\nReturns a reference to the first item in the vector. This function assumes that the vector isn't empty.\n\nSee also last() and isEmpty().\n\nThis is an overloaded member function, provided for convenience.\n\nReturns a QVector object with the data contained in list.\n\nSee also toList() and QList::toVector().\n\nReturns a QVector object with the data contained in vector. The order of the elements in the QVector is the same as in vector.\n\nSee also toStdVector() and QList::fromStdList().\n\nThis function is provided for STL compatibility. It is equivalent to first().\n\nThis is an overloaded member function, provided for convenience.\n\nReturns the index position of the first occurrence of value in the vector, searching forward from index position from. Returns -1 if no item matched.\n\nThis function requires the value type to have an implementation of .\n\nSee also lastIndexOf() and contains().\n\nInserts value at index position i in the vector. If i is 0, the value is prepended to the vector. If i is size(), the value is appended to the vector.\n\nFor large vectors, this operation can be slow (linear time), because it requires moving all the items at indexes i and above by one position further in memory. If you want a container class that provides a fast insert() function, use QLinkedList instead.\n\nSee also append(), prepend(), and remove().\n\nThis is an overloaded member function, provided for convenience.\n\nInserts count copies of value in front of the item pointed to by the iterator before. Returns an iterator pointing at the first of the inserted items.\n\nThis is an overloaded member function, provided for convenience.\n\nInserts count copies of value at index position i in the vector.\n\nThis is an overloaded member function, provided for convenience.\n\nInserts value in front of the item pointed to by the iterator before. Returns an iterator pointing at the inserted item.\n\nReturns true if the vector has size 0; otherwise returns false.\n\nSee also size() and resize().\n\nReturns a reference to the last item in the vector. This function assumes that the vector isn't empty.\n\nSee also first() and isEmpty().\n\nThis is an overloaded member function, provided for convenience.\n\nReturns the index position of the last occurrence of the value value in the vector, searching backward from index position from. If from is -1 (the default), the search starts at the last item. Returns -1 if no item matched.\n\nThis function requires the value type to have an implementation of .\n\nReturns a vector whose elements are copied from this vector, starting at position pos. If length is -1 (the default), all elements after pos are copied; otherwise length elements (or all remaining elements if there are less than length elements) are copied.\n\nThis function is provided for STL compatibility. It is equivalent to erase(end() - 1).\n\nThis function is provided for STL compatibility. It is equivalent to erase(begin()).\n\nInserts value at the beginning of the vector.\n\nThis is the same as vector.insert(0, value).\n\nFor large vectors, this operation can be slow (linear time), because it requires moving all the items in the vector by one position further in memory. If you want a container class that provides a fast prepend() function, use QList or QLinkedList instead.\n\nSee also append() and insert().\n\nThis function is provided for STL compatibility. It is equivalent to append(value).\n\nThis function is provided for STL compatibility. It is equivalent to prepend(value).\n\nSee also insert(), replace(), and fill().\n\nThis is an overloaded member function, provided for convenience.\n\nRemoves count elements from the middle of the vector, starting at index position i.\n\nSee also insert(), replace(), and fill().\n\nReplaces the item at index position i with value.\n\ni must be a valid index position in the vector (i.e., 0 <= i < size()).\n\nSee also operator[]() and remove().\n\nAttempts to allocate memory for at least size elements. If you know in advance how large the vector will be, you can call this function, and if you call resize() often you are likely to get better performance. If size is an underestimate, the worst that will happen is that the QVector will be a bit slower.\n\nThe sole purpose of this function is to provide a means of fine tuning QVector's memory usage. In general, you will rarely ever need to call this function. If you want to change the size of the vector, call resize().\n\nSee also squeeze() and capacity().\n\nSets the size of the vector to size. If size is greater than the current size, elements are added to the end; the new elements are initialized with a default-constructed value. If size is less than the current size, elements are removed from the end.\n\nReturns the number of items in the vector.\n\nSee also isEmpty() and resize().\n\nReleases any memory not required to store the items.\n\nThe sole purpose of this function is to provide a means of fine tuning QVector's memory usage. In general, you will rarely ever need to call this function.\n\nSee also reserve() and capacity().\n\nReturns a QList object with the data contained in this QVector.\n\nSee also fromList() and QList::fromVector().\n\nReturns a std::vector object with the data contained in this QVector. Example:\n\nSee also fromStdVector() and QList::toStdList().\n\nReturns the value at index position i in the vector.\n\nIf the index i is out of bounds, the function returns a default-constructed value. If you are certain that i is within bounds, you can use at() instead, which is slightly faster.\n\nSee also at() and operator[]().\n\nThis is an overloaded member function, provided for convenience.\n\nIf the index i is out of bounds, the function returns defaultValue.\n\nReturns true if other is not equal to this vector; otherwise returns false.\n\nTwo vectors are considered equal if they contain the same values in the same order.\n\nThis function requires the value type to have an implementation of .\n\nReturns a vector that contains all the items in this vector followed by all the items in the other vector.\n\nAppends the items of the other vector to this vector and returns a reference to this vector.\n\nSee also operator+() and append().\n\nThis is an overloaded member function, provided for convenience.\n\nAppends value to the vector.\n\nSee also append() and operator<<().\n\nAppends value to the vector and returns a reference to this vector.\n\nSee also append() and operator+=().\n\nThis is an overloaded member function, provided for convenience.\n\nAppends other to the vector and returns a reference to the vector.\n\nAssigns other to this vector and returns a reference to this vector.\n\nReturns true if other is equal to this vector; otherwise returns false.\n\nTwo vectors are considered equal if they contain the same values in the same order.\n\nThis function requires the value type to have an implementation of .\n\nReturns the item at index position i as a modifiable reference.\n\ni must be a valid index position in the vector (i.e., 0 <= i < size()).\n\nNote that using non-const operators can cause QVector to do a deep copy.\n\nSee also at() and value().\n\nThis is an overloaded member function, provided for convenience.\n\nThis is an overloaded member function, provided for convenience.\n\nWrites the vector vector to stream out.\n\nThis function requires the value type to implement .\n\nSee also Format of the QDataStream operators.\n\nThis is an overloaded member function, provided for convenience.\n\nReads a vector from stream in into vector.\n\nThis function requires the value type to implement .\n\nSee also Format of the QDataStream operators."
    },
    {
        "link": "https://stackoverflow.com/questions/33609406/qlist-vs-qvector-revisited",
        "document": "Qt advertises as the \"jack of all trades\", but the other half of that saying is \"master of none\". I'd say is a good candidate if you plan on appending to both ends of the list, and those are no larger than than a pointer, as reserves space before and after. That's about it, I mean as far as good reasons to use are concerned.\n\nwill automatically store \"large\" objects as pointer and allocate the objects on the heap, which may be considered a good thing if you are a baby, which doesn't know how to declare a and use dynamic allocation. This is not necessarily a good thing, and in some cases it will only bloat the memory usage and add extra indirection. IMO it is always a good idea to be explicit about what you want, whether it is pointers or instances. Even if you do want heap allocation, it is always better to allocate it yourself and simply add the pointer to the list than construct the object once, then have have copy construct that on the heap.\n\nQt will return you a in a lot of places where it comes with overhead, for example when getting a 's children or you search for children. In this case it doesn't make sense to use a container that allocates space before the first element, as it is a list of objects which are already there, not something you are likely to prepend to. I also don't much like the absence of a method.\n\nImagine a situation where you have an object with size of 9 bytes and byte alignment on a 64 bit system. It is \"far too much\" for so instead it will use 8 byte pointer + CPU overhead for the slow heap allocation + memory overhead for the heap allocation. It will use twice the memory and with an extra indirection for access it will hardly offer performance advantages as advertised.\n\nAs of why cannot suddenly become the \"default\" container - you don't change horses mid-race - it is a legacy thing, Qt being such an old framework, and even though a lot of stuff has been deprecated, making changes to widely used defaults is not always possible, not without breaking a lot of code, or producing undesired behavior. Good or bad, will likely continue being the default all the way throughout Qt 5, and likely in the next major release as well. The same reason Qt will continue using \"dumb\" pointers, for years after smart pointers have become a must and everybody is crying about how bad plain pointers are and how they should not be used ever.\n\nThat being said, nobody is forcing you to use in your design. There is no reason why should not be your default container. I myself don't use anywhere, and in the Qt functions which return a I merely use as a temporary to move stuff into a .\n\nFurthermore, and this is only my personal opinion, but I do find a lot of design decisions in Qt that don't necessary make sense, be that performance or memory use efficiency or ease of use wise, and overall there are a a lot of frameworks and languages which like promoting their ways of doing things, not because it is the best way to do it, but because it is their way to do it.\n\nLast but not least:\n\nIt really boils down to how you understand this. IMO in this context, \"the right\" does not stand for \"the best\" or \"the optimal\", but for \"good enough\" as in \"it will do, even if not the best\". Especially if you know nothing about different container classes and how they work.\nâ€¢ you intend to prepend objects no larger than the size of a pointer, since it reserves some space in the front\nâ€¢ you intend to insert in the middle of the list objects (substantially) larger than a pointer (and I am being generous here, since you can easily use with explicit pointers to achieve the same and cheaper - no extra copy), since when resizing the list, no objects will be moved, only pointers\nâ€¢ doesn't have a method, is a subtle trap, since it will not increase the valid list size, even if index access works it falls in the UB category, also you will not be able to iterate that list\nâ€¢ does an extra copy and heap allocating when object is larger than a pointer, which might also be an issue if object identity matters\nâ€¢ uses extra indirection to access objects larger than a pointer\nâ€¢ has CPU time and memory usage overheads due to the last two, also less cache friendly\nâ€¢ comes with additional overhead when used as a \"search\" return value, since you are not likely to prepend or even append to that\nâ€¢ only makes sense if index access is a must, for optimal prepend and insert performance a linked list might be a better option.\n\nThe CON's marginally outweigh the PROs, meaning that while in \"casual\" use might be acceptable, you definitely don't want to use it in situations where CPU time and/or memory usage are a critical factor. All in all, is best suited for lazy and careless use, when you don't want to make the consideration of optimal storage container for the use case, which would typically be a , a or a (and I exclude \"STL\" containers, since we are talking Qt here, Qt containers are just as portable, sometimes faster, and most certainly easier and cleaner to use, whereas containers are needlessly verbose)."
    },
    {
        "link": "https://stackoverflow.com/questions/21511073/how-to-use-the-qvector-with-multiple-object",
        "document": "I'm trying to use the class from to work (for me :P). What I want to do is to put multiple instances of the object in a .\n\nI went on multiple forums, but they're all too complicated for me as I am a beginner. This one post was perfect but I did not find a way to resolve my problem.\n\nSo I'm turning to you to help me!\n\nHere's the function that I want to work :\n\nThe part that create the bundle/ the vector\n\nWhat i expect to do here is to put the selected number of the object in a . After that i can pass it to another class. From there i should be able to extract the text from them( and )."
    },
    {
        "link": "https://forum.qt.io/topic/107848/how-to-insert-different-arrays-into-a-qvector",
        "document": "\nâ€¢ How do you insert the values into your QVector? With ? If you need array \"a\" and \"b\" in one container as such, try a 2D-Vector or Vector of Vectors. You can access them by using If debugging is the process of removing software bugs, then programming must be the process of putting them in.\nâ€¢ Use of for indexes is wrong! And will indeed only print out first 2 elements of the arrays in the 2-element vector. You want more like (untested) This is only pushing element from each / array into the vector. I you're wanting to push whole arrays, like ? In which case declaration will be wrong....?\nâ€¢ @Shankar-B\n\n well, yes, you're mixing and matching at will. I would suggest not to use pure c arrays, use the vector container for it. If you need to pass the raw array around later on, you can get that by calling of the container Be aware of the Qt Code of Conduct, when posting : https://forum.qt.io/topic/113070/qt-code-of-conduct Q: What's that?\n\n A: It's blue light.\n\n Q: What does it do?\n\n A: It turns blue."
    },
    {
        "link": "https://stackoverflow.com/questions/60717011/using-qvector-and-implement-a-subset-of-qvector-in-good-practice",
        "document": "Hello and good morning together, I have two questions concerning QVector and its usage. I have an own custom class. It is necessary to use or does it suffice to directly add instances to like . I read that already uses a shared pointer internally contrary std vector. It is bad practice to append instance pointer directly?\n\nNext, I want to have a subset of with selected elements. What is good practice to do that using QVector>?"
    },
    {
        "link": "https://doc.qt.io/qt-5/qvector.html",
        "document": "The QVector class is a template class that provides a dynamic array. More...\n\nNote: All functions in this class are reentrant.\n\nNote that the operating system may impose further limits on applications holding a lot of allocated memory, especially large, contiguous blocks. Such considerations, the configuration of such behavior or any mitigation are outside the scope of the Qt API.\n\nIn case memory allocation fails, QVector will use the Q_CHECK_PTR macro, which will throw a std::bad_alloc exception if the application is being compiled with exception support. If exceptions are disabled, then running out of memory is undefined behavior.\n\nThe current version of QVector is limited to just under 2 GB (2^31 bytes) in size. The exact value is architecture-dependent, since it depends on the overhead required for managing the data block, but is no more than 32 bytes. The number of elements that can be stored in a QVector is that size divided by the size of each element.\n\nFor a detailed discussion comparing Qt containers with each other and with STL containers, see Understand the Qt Containers .\n\nQVector does not support inserting, prepending, appending or replacing with references to its own values. Doing so will cause your application to abort with an error message.\n\nIn addition to QVector, Qt also provides QVarLengthArray , a very low-level class with little functionality that is optimized for speed.\n\nLike the other container classes, QVector provides Java-style iterators ( QVectorIterator and QMutableVectorIterator ) and STL-style iterators ( QVector::const_iterator and QVector::iterator ). In practice, these are rarely used, because you can use indexes into the QVector.\n\nQVector's value type must be an assignable data type . This covers most data types that are commonly used, but the compiler won't let you, for example, store a QWidget as a value; instead, store a QWidget *. A few functions have additional requirements; for example, indexOf () and lastIndexOf () expect the value type to support operator==() . These requirements are documented on a per-function basis.\n\nNote that using non-const operators and functions can cause QVector to do a deep copy of the data. This is due to implicit sharing .\n\nIf you know in advance approximately how many items the QVector will contain, you can call reserve (), asking QVector to preallocate a certain amount of memory. You can also call capacity () to find out how much memory QVector actually allocated.\n\nUnlike plain C++ arrays, QVectors can be resized at any time by calling resize (). If the new size is larger than the old size, QVector might need to reallocate the whole vector. QVector tries to reduce the number of reallocations by preallocating up to twice as much memory as the actual data needs.\n\nQVector provides these basic functions to add, move, and remove items: insert (), replace (), remove (), prepend (), append (). With the exception of append () and replace (), these functions can be slow ( linear time ) for large vectors, because they require moving many items in the vector by one position in memory. If you want a container class that provides fast insertion/removal in the middle, use QList or QLinkedList instead.\n\nIf you simply want to check whether a vector contains a particular value, use contains (). If you want to find out how many times a particular value occurs in the vector, use count ().\n\n\"First occurrence of Harumi is at position \"\n\nIf you want to find all occurrences of a particular value in a vector, use indexOf () or lastIndexOf (). The former searches forward starting from a given index position, the latter searches backward. Both return the index of the matching item if they found one; otherwise, they return -1. For example:\n\nAnother way to access the data stored in a QVector is to call data (). The function returns a pointer to the first item in the vector. You can use the pointer to directly access and modify the elements stored in the vector. The pointer is also useful if you need to pass a QVector to a function that accepts a plain C++ array.\n\nat () can be faster than operator[](), because it never causes a deep copy to occur.\n\nFor read-only access, an alternative syntax is to use at ():\n\nQVector uses 0-based indexes, just like C++ arrays. To access the item at a particular index position, you can use operator[](). On non-const vectors, operator[]() returns a reference to the item that can be used on the left side of an assignment:\n\nYou can also call fill () at any time to fill the vector with a value.\n\nThe elements are automatically initialized with a default-constructed value . If you want to initialize the vector with a different value, pass that value as the second argument to the constructor:\n\nQVector stores its items in a vector (array). Typically, vectors are created with an initial size. For example, the following code constructs a QVector with 200 elements:\n\nHere's an example of a QVector that stores integers and a QVector that stores QString values:\n\nNote: Iterators into a QLinkedList and references into heap-allocating QLists remain valid as long as the referenced items remain in the container. This is not true for iterators and references into a QVector and non-heap-allocating QLists.\n\nNote: QVector and QVarLengthArray both guarantee C-compatible array layout. QList does not. This might be important if your application must interface with a C API.\n\nQList <T>, QLinkedList<T>, QVector<T>, and QVarLengthArray <T> provide similar APIs and functionality. They are often interchangeable, but there are performance consequences. Here is an overview of use cases:\n\nQVector<T> is one of Qt's generic container classes . It stores its items in adjacent memory locations and provides fast index-based access.\n\nSee also QVectorIterator, QMutableVectorIterator, QList, and QLinkedList.\n\nSee also QVector::rbegin (), QVector::rend (), QVector::const_reverse_iterator , and QVector::iterator .\n\nThis typedef was introduced in Qt 5.6.\n\nWarning: Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read Implicit sharing iterator problem .\n\nIt is simply a typedef for std::reverse_iterator<T*> .\n\nThe QVector::reverse_iterator typedef provides an STL-style non-const reverse iterator for QVector .\n\nSee also QVector::begin (), QVector::end (), QVector::const_iterator , and QMutableVectorIterator .\n\nWarning: Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read Implicit sharing iterator problem .\n\nQVector provides both STL-style iterators and Java-style iterators . The STL-style non-const iterator is simply a typedef for \"T *\" (pointer to T).\n\nThe QVector::iterator typedef provides an STL-style non-const iterator for QVector and QStack .\n\nSee also QVector::rbegin (), QVector::rend (), QVector::reverse_iterator , and QVector::const_iterator .\n\nThis typedef was introduced in Qt 5.6.\n\nWarning: Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read Implicit sharing iterator problem .\n\nIt is simply a typedef for std::reverse_iterator<const T*> .\n\nThe QVector::const_reverse_iterator typedef provides an STL-style const reverse iterator for QVector .\n\nSee also QVector::constBegin (), QVector::constEnd (), QVector::iterator , and QVectorIterator .\n\nWarning: Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read Implicit sharing iterator problem .\n\nQVector provides both STL-style iterators and Java-style iterators . The STL-style const iterator is simply a typedef for \"const T *\" (pointer to const T).\n\nThe QVector::const_iterator typedef provides an STL-style const iterator for QVector and QStack .\n\nThis function is provided for STL compatibility. It is equivalent to prepend(value).\n\nThis is an overloaded function.\n\nInserts value in front of the item pointed to by the iterator before. Returns an iterator pointing at the inserted item.\n\nInserts value at index position i in the vector. If i is 0, the value is prepended to the vector. If i is size(), the value is appended to the vector.\n\nFor large vectors, this operation can be slow (linear time), because it requires moving all the items at indexes i and above by one position further in memory. If you want a container class that provides a fast insert() function, use QLinkedList instead.\n\nSee also append(), prepend(), and remove().\n\nInserts value at the beginning of the vector.\n\nThis is the same as vector.insert(0, value).\n\nFor large vectors, this operation can be slow (linear time), because it requires moving all the items in the vector by one position further in memory. If you want a container class that provides a fast prepend() function, use QList or QLinkedList instead.\n\nSee also append() and insert().\n\nConstructs a vector with the contents in the iterator range [first, last).\n\nThe value type of must be convertible to .\n\nThis function was introduced in Qt 5.14.\n\nConstructs a vector from the std::initializer_list given by args.\n\nThis constructor is only enabled if the compiler supports C++11 initializer lists.\n\nThis function was introduced in Qt 4.8.\n\nMove-constructs a QVector instance, making it point at the same object that other was pointing to.\n\nThis function was introduced in Qt 5.2.\n\nThis operation takes constant time, because QVector is implicitly shared. This makes returning a QVector from a function very fast. If a shared instance is modified, it will be copied (copy-on-write), and that takes linear time.\n\nConstructs a vector with an initial size of size elements. Each element is initialized with value.\n\nSee also resize() and fill().\n\nConstructs a vector with an initial size of size elements.\n\nThe elements are initialized with a default-constructed value.\n\nMove-assigns other to this QVector instance.\n\nThis function was introduced in Qt 5.2.\n\nAssigns other to this vector and returns a reference to this vector.\n\nInserts value at the end of the vector.\n\nThis is the same as calling resize(size() + 1) and assigning value to the new last element in the vector.\n\nThis operation is relatively fast, because QVector typically allocates more memory than necessary, so it can grow without reallocating the entire vector each time.\n\nSee also operator<<(), prepend(), and insert().\n\nThis is an overloaded function.\n\nThis function was introduced in Qt 5.6.\n\nThis is an overloaded function.\n\nAppends the items of the value vector to this vector.\n\nThis function was introduced in Qt 5.5.\n\nSee also operator<<() and operator+=().\n\nReturns the item at index position i in the vector.\n\ni must be a valid index position in the vector (i.e., 0 <= i < size()).\n\nSee also value() and operator[]().\n\nThis function is provided for STL compatibility. It is equivalent to last().\n\nThis is an overloaded function.\n\nReturns an STL-style iterator pointing to the first item in the vector.\n\nSee also constBegin() and end().\n\nThis is an overloaded function.\n\nReturns the maximum number of items that can be stored in the vector without forcing a reallocation.\n\nThe sole purpose of this function is to provide a means of fine tuning QVector's memory usage. In general, you will rarely ever need to call this function. If you want to know how many items are in the vector, call size().\n\nSee also reserve() and squeeze().\n\nReturns a const STL-style iterator pointing to the first item in the vector.\n\nThis function was introduced in Qt 5.0.\n\nSee also begin() and cend().\n\nReturns a const STL-style iterator pointing to the imaginary item after the last item in the vector.\n\nThis function was introduced in Qt 5.0.\n\nSee also cbegin() and end().\n\nRemoves all the elements from the vector.\n\nReturns a const STL-style iterator pointing to the first item in the vector.\n\nSee also begin() and constEnd().\n\nReturns a const pointer to the data stored in the vector. The pointer can be used to access the items in the vector. The pointer remains valid as long as the vector isn't reallocated.\n\nThis function is mostly useful to pass a vector to a function that accepts a plain C++ array.\n\nSee also data() and operator[]().\n\nReturns a const STL-style iterator pointing to the imaginary item after the last item in the vector.\n\nSee also constBegin() and end().\n\nReturns a const reference to the first item in the vector. This function assumes that the vector isn't empty.\n\nThis function was introduced in Qt 5.6.\n\nSee also constLast(), isEmpty(), and first().\n\nReturns a const reference to the last item in the vector. This function assumes that the vector isn't empty.\n\nThis function was introduced in Qt 5.6.\n\nSee also constFirst(), isEmpty(), and last().\n\nReturns if the vector contains an occurrence of value; otherwise returns .\n\nThis function requires the value type to have an implementation of .\n\nSee also indexOf() and count().\n\nReturns the number of occurrences of value in the vector.\n\nThis function requires the value type to have an implementation of .\n\nSee also contains() and indexOf().\n\nThis is an overloaded function.\n\nReturns a const STL-style reverse iterator pointing to the first item in the vector, in reverse order.\n\nThis function was introduced in Qt 5.6.\n\nSee also begin(), rbegin(), and rend().\n\nReturns a const STL-style reverse iterator pointing to one past the last item in the vector, in reverse order.\n\nThis function was introduced in Qt 5.6.\n\nSee also end(), rend(), and rbegin().\n\nReturns a pointer to the data stored in the vector. The pointer can be used to access and modify the items in the vector.\n\nThe pointer remains valid as long as the vector isn't reallocated.\n\nThis function is mostly useful to pass a vector to a function that accepts a plain C++ array.\n\nSee also constData() and operator[]().\n\nThis is an overloaded function.\n\nThis function is provided for STL compatibility. It is equivalent to isEmpty(), returning if the vector is empty; otherwise returns .\n\nReturns an STL-style iterator pointing to the imaginary item after the last item in the vector.\n\nSee also begin() and constEnd().\n\nThis is an overloaded function.\n\nReturns if this vector is not empty and its last item is equal to value; otherwise returns .\n\nThis function was introduced in Qt 4.5.\n\nSee also isEmpty() and last().\n\nRemoves the item pointed to by the iterator pos from the vector, and returns an iterator to the next item in the vector (which may be end()).\n\nSee also insert() and remove().\n\nThis is an overloaded function.\n\nRemoves all the items from begin up to (but not including) end. Returns an iterator to the same item that end referred to before the call.\n\nAssigns value to all items in the vector. If size is different from -1 (the default), the vector is resized to size size beforehand.\n\nReturns a reference to the first item in the vector. This function assumes that the vector isn't empty.\n\nSee also last(), isEmpty(), and constFirst().\n\nThis is an overloaded function.\n\nReturns a QVector object with the data contained in list.\n\nSee also toList() and QList::toVector().\n\nReturns a QVector object with the data contained in vector. The order of the elements in the QVector is the same as in vector.\n\nSee also toStdVector() and QList::fromStdList().\n\nThis function is provided for STL compatibility. It is equivalent to first().\n\nThis is an overloaded function.\n\nReturns the index position of the first occurrence of value in the vector, searching forward from index position from. Returns -1 if no item matched.\n\nThis function requires the value type to have an implementation of .\n\nSee also lastIndexOf() and contains().\n\nThis is an overloaded function.\n\nInserts count copies of value at index position i in the vector.\n\nInserts count copies of value in front of the item pointed to by the iterator before. Returns an iterator pointing at the first of the inserted items.\n\nReturns if the vector has size 0; otherwise returns .\n\nSee also size() and resize().\n\nReturns a reference to the last item in the vector. This function assumes that the vector isn't empty.\n\nSee also first(), isEmpty(), and constLast().\n\nThis is an overloaded function.\n\nReturns the index position of the last occurrence of the value value in the vector, searching backward from index position from. If from is -1 (the default), the search starts at the last item. Returns -1 if no item matched.\n\nThis function requires the value type to have an implementation of .\n\nSame as size() and count().\n\nThis function was introduced in Qt 5.2.\n\nSee also size(), count(), and QList::length().\n\nReturns a sub-vector which contains elements from this vector, starting at position pos. If length is -1 (the default), all elements after pos are included; otherwise length elements (or all remaining elements if there are less than length elements) are included.\n\nMoves the item at index position from to index position to.\n\nThis function was introduced in Qt 5.6.\n\nThis function is provided for STL compatibility. It is equivalent to removeLast().\n\nThis function is provided for STL compatibility. It is equivalent to removeFirst().\n\nThis function is provided for STL compatibility. It is equivalent to append(value).\n\nThis is an overloaded function.\n\nThis function was introduced in Qt 5.6.\n\nReturns a STL-style reverse iterator pointing to the first item in the vector, in reverse order.\n\nThis function was introduced in Qt 5.6.\n\nSee also begin(), crbegin(), and rend().\n\nThis is an overloaded function.\n\nThis function was introduced in Qt 5.6.\n\nThis is an overloaded function.\n\nSee also insert(), replace(), and fill().\n\nThis is an overloaded function.\n\nRemoves count elements from the middle of the vector, starting at index position i.\n\nSee also insert(), replace(), and fill().\n\nRemoves all elements that compare equal to t from the vector. Returns the number of elements removed, if any.\n\nThis function was introduced in Qt 5.4.\n\nSee also removeOne() and QList::removeAll().\n\nRemoves the element at index position i. Equivalent to\n\nThis function was introduced in Qt 5.2.\n\nSee also remove() and QList::removeAt().\n\nRemoves the first item in the vector. Calling this function is equivalent to calling remove(0). The vector must not be empty. If the vector can be empty, call isEmpty() before calling this function.\n\nThis function was introduced in Qt 5.1.\n\nSee also remove(), takeFirst(), and isEmpty().\n\nRemoves the last item in the vector. Calling this function is equivalent to calling remove(size() - 1). The vector must not be empty. If the vector can be empty, call isEmpty() before calling this function.\n\nThis function was introduced in Qt 5.1.\n\nSee also remove(), takeLast(), removeFirst(), and isEmpty().\n\nRemoves the first element that compares equal to t from the vector. Returns whether an element was, in fact, removed.\n\nThis function was introduced in Qt 5.4.\n\nSee also removeAll() and QList::removeOne().\n\nReturns a STL-style reverse iterator pointing to one past the last item in the vector, in reverse order.\n\nThis function was introduced in Qt 5.6.\n\nSee also end(), crend(), and rbegin().\n\nThis is an overloaded function.\n\nThis function was introduced in Qt 5.6.\n\nReplaces the item at index position i with value.\n\ni must be a valid index position in the vector (i.e., 0 <= i < size()).\n\nSee also operator[]() and remove().\n\nAttempts to allocate memory for at least size elements. If you know in advance how large the vector will be, you should call this function to prevent reallocations and memory fragmentation.\n\nIf size is an underestimate, the worst that will happen is that the QVector will be a bit slower. If size is an overestimate, you may have used more memory than the normal QVector growth strategy would have allocatedâ€”or you may have used less.\n\nAn alternative to reserve() is calling resize(). Whether or not that is faster than reserve() depends on the element type, because resize() default-constructs all elements, and requires assignment to existing entries rather than calling append(), which copy- or move-constructs. For simple types, like or , resize() is typically faster, but for anything more complex, you should prefer reserve().\n\nSee also squeeze() and capacity().\n\nSets the size of the vector to size. If size is greater than the current size, elements are added to the end; the new elements are initialized with a default-constructed value. If size is less than the current size, elements are removed from the end.\n\nSince Qt 5.6, resize() doesn't shrink the capacity anymore. To shed excess capacity, use squeeze().\n\nThis function is provided for STL compatibility. It is equivalent to squeeze().\n\nThis function was introduced in Qt 5.10.\n\nReturns the number of items in the vector.\n\nSee also isEmpty() and resize().\n\nReleases any memory not required to store the items.\n\nThe sole purpose of this function is to provide a means of fine tuning QVector's memory usage. In general, you will rarely ever need to call this function.\n\nSee also reserve() and capacity().\n\nReturns if this vector is not empty and its first item is equal to value; otherwise returns .\n\nThis function was introduced in Qt 4.5.\n\nSee also isEmpty() and first().\n\nSwaps vector other with this vector. This operation is very fast and never fails.\n\nThis function was introduced in Qt 4.8.\n\nExchange the item at index position i with the item at index position j. This function assumes that both i and j are at least 0 but less than size(). To avoid failure, test that both i and j are at least 0 and less than size().\n\nThis function was introduced in Qt 5.14.\n\nRemoves the element at index position i and returns it.\n\nThis function was introduced in Qt 5.2.\n\nSee also takeFirst(), takeLast(), and QList::takeAt().\n\nRemoves the first item in the vector and returns it. This function assumes the vector is not empty. To avoid failure, call isEmpty() before calling this function.\n\nThis function was introduced in Qt 5.1.\n\nSee also takeLast() and removeFirst().\n\nRemoves the last item in the list and returns it. This function assumes the vector is not empty. To avoid failure, call isEmpty() before calling this function.\n\nIf you don't use the return value, removeLast() is more efficient.\n\nThis function was introduced in Qt 5.1.\n\nSee also takeFirst() and removeLast().\n\nReturns a QList object with the data contained in this QVector.\n\nSee also fromList() and QList::fromVector().\n\nReturns a std::vector object with the data contained in this QVector. Example:\n\nSee also fromStdVector() and QList::toStdList().\n\nReturns the value at index position i in the vector.\n\nIf the index i is out of bounds, the function returns a default-constructed value. If you are certain that i is within bounds, you can use at() instead, which is slightly faster.\n\nSee also at() and operator[]().\n\nThis is an overloaded function.\n\nIf the index i is out of bounds, the function returns defaultValue.\n\nReturns if other is not equal to this vector; otherwise returns .\n\nTwo vectors are considered equal if they contain the same values in the same order.\n\nThis function requires the value type to have an implementation of .\n\nReturns a vector that contains all the items in this vector followed by all the items in the other vector.\n\nAppends the items of the other vector to this vector and returns a reference to this vector.\n\nSee also operator+() and append().\n\nThis is an overloaded function.\n\nAppends value to the vector.\n\nSee also append() and operator<<().\n\nThis is an overloaded function.\n\nThis function was introduced in Qt 5.11.\n\nSee also append() and operator<<().\n\nAppends value to the vector and returns a reference to this vector.\n\nSee also append() and operator+=().\n\nAppends other to the vector and returns a reference to the vector.\n\nThis is an overloaded function.\n\nThis function was introduced in Qt 5.11.\n\nSee also append() and operator+=().\n\nAssigns the collection of values in args to this QVector instance.\n\nThis operator is only enabled if the compiler supports C++11 initializer lists.\n\nThis function was introduced in Qt 5.14.\n\nReturns if other is equal to this vector; otherwise returns .\n\nTwo vectors are considered equal if they contain the same values in the same order.\n\nThis function requires the value type to have an implementation of .\n\nReturns the item at index position i as a modifiable reference.\n\ni must be a valid index position in the vector (i.e., 0 <= i < size()).\n\nNote that using non-const operators can cause QVector to do a deep copy.\n\nSee also at() and value().\n\nThis is an overloaded function."
    },
    {
        "link": "https://ftp.nmr.mgh.harvard.edu/pub/dist/freesurfer/tutorial_versions/freesurfer/lib/qt/qt_doc/html/containers.html",
        "document": "The Qt library provides a set of general purpose template-based container classes. These classes can be used to store items of a specified type. For example, if you need a resizable array of QStrings, use QVector<QString>.\n\nThese container classes are designed to be lighter, safer, and easier to use than the STL containers. If you are unfamiliar with the STL, or prefer to do things the \"Qt way\", you can use these classes instead of the STL classes.\n\nThe container classes are implicitly shared, they are reentrant, and they are optimized for speed, low memory consumption, and minimal inline code expansion, resulting in smaller executables. In addition, they are thread-safe in situations where they are used as read-only containers by all threads used to access them.\n\nFor traversing the items stored in a container, you can use one of two types of iterators: Java-style iterators and STL-style iterators. The Java-style iterators are easier to use and provide high-level functionality, whereas the STL-style iterators are slightly more efficient and can be used together with Qt's and STL's generic algorithms.\n\nQt also offers a foreach keyword that make it very easy to iterate over all the items stored in a container.\n\nQt provides the following sequential containers: QList, QLinkedList, QVector, QStack, and QQueue. For most applications, QList is the best type to use. Although it is implemented as an array-list, it provides very fast prepends and appends. If you really need a linked-list, use QLinkedList; if you want your items to occupy consecutive memory locations, use QVector. QStack and QQueue are convenience classes that provide LIFO and FIFO semantics.\n\nQt also provides these associative containers: QMap, QMultiMap, QHash, QMultiHash, and QSet. The \"Multi\" containers conveniently support multiple values associated with a single key. The \"Hash\" containers provide faster lookup by using a hash function instead of a binary search on a sorted set.\n\nAs special cases, the QCache and QContiguousCache classes provide efficient hash-lookup of objects in a limited cache storage.\n\nThis is by far the most commonly used container class. It stores a list of values of a given type (T) that can be accessed by index. Internally, the QList is implemented using an array, ensuring that index-based access is very fast. Items can be added at either end of the list using QList::append() and QList::prepend(), or they can be inserted in the middle using QList::insert(). More than any other container class, QList is highly optimized to expand to as little code as possible in the executable. QStringList inherits from QList<QString>. This is similar to QList, except that it uses iterators rather than integer indexes to access items. It also provides better performance than QList when inserting in the middle of a huge list, and it has nicer iterator semantics. (Iterators pointing to an item in a QLinkedList remain valid as long as the item exists, whereas iterators to a QList can become invalid after any insertion or removal.) This stores an array of values of a given type at adjacent positions in memory. Inserting at the front or in the middle of a vector can be quite slow, because it can lead to large numbers of items having to be moved by one position in memory. This is a convenience subclass of QVector that provides \"last in, first out\" (LIFO) semantics. It adds the following functions to those already present in QVector: push(), pop(), and top(). This is a convenience subclass of QList that provides \"first in, first out\" (FIFO) semantics. It adds the following functions to those already present in QList: enqueue(), dequeue(), and head(). This provides a single-valued mathematical set with fast lookups. This provides a dictionary (associative array) that maps keys of type Key to values of type T. Normally each key is associated with a single value. QMap stores its data in Key order; if order doesn't matter QHash is a faster alternative. This is a convenience subclass of QMap that provides a nice interface for multi-valued maps, i.e. maps where one key can be associated with multiple values. This has almost the same API as QMap, but provides significantly faster lookups. QHash stores its data in an arbitrary order. This is a convenience subclass of QHash that provides a nice interface for multi-valued hashes.\n\nContainers can be nested. For example, it is perfectly possible to use a QMap<QString, QList<int> >, where the key type is QString and the value type QList<int>. The only pitfall is that you must insert a space between the closing angle brackets (>); otherwise the C++ compiler will misinterpret the two >'s as a right-shift operator (>>) and report a syntax error.\n\nThe containers are defined in individual header files with the same name as the container (e.g., ). For convenience, the containers are forward declared in .\n\nThe values stored in the various containers can be of any assignable data type. To qualify, a type must provide a default constructor, a copy constructor, and an assignment operator. This covers most data types you are likely to want to store in a container, including basic types such as and , pointer types, and Qt data types such as QString, QDate, and QTime, but it doesn't cover QObject or any QObject subclass (QWidget, QDialog, QTimer, etc.). If you attempt to instantiate a QList<QWidget>, the compiler will complain that QWidget's copy constructor and assignment operators are disabled. If you want to store these kinds of objects in a container, store them as pointers, for example as QList<QWidget *>.\n\nHere's an example custom data type that meets the requirement of an assignable data type:\n\nIf we don't provide a copy constructor or an assignment operator, C++ provides a default implementation that performs a member-by-member copy. In the example above, that would have been sufficient. Also, if you don't provide any constructors, C++ provides a default constructor that initializes its member using default constructors. Although it doesn't provide any explicit constructors or assignment operator, the following data type can be stored in a container:\n\nSome containers have additional requirements for the data types they can store. For example, the Key type of a QMap<Key, T> must provide . Such special requirements are documented in a class's detailed description. In some cases, specific functions have special requirements; these are described on a per-function basis. The compiler will always emit an error if a requirement isn't met.\n\nQt's containers provide operator<<() and operator>>() so that they can easily be read and written using a QDataStream. This means that the data types stored in the container must also support operator<<() and operator>>(). Providing such support is straightforward; here's how we could do it for the Movie struct above:\n\nThe documentation of certain container class functions refer to default-constructed values; for example, QVector automatically initializes its items with default-constructed values, and QMap::value() returns a default-constructed value if the specified key isn't in the map. For most value types, this simply means that a value is created using the default constructor (e.g. an empty string for QString). But for primitive types like and , as well as for pointer types, the C++ language doesn't specify any initialization; in those cases, Qt's containers automatically initialize the value to 0.\n\nIterators provide a uniform means to access items in a container. Qt's container classes provide two types of iterators: Java-style iterators and STL-style iterators. Iterators of both types are invalidated when the data in the container is modified or detached from implicitly shared copies due to a call to a non-const member function.\n\nThe Java-style iterators are new in Qt 4 and are the standard ones used in Qt applications. They are more convenient to use than the STL-style iterators, at the price of being slightly less efficient. Their API is modelled on Java's iterator classes.\n\nFor each container class, there are two Java-style iterator data types: one that provides read-only access and one that provides read-write access.\n\nIn this discussion, we will concentrate on QList and QMap. The iterator types for QLinkedList, QVector, and QSet have exactly the same interface as QList's iterators; similarly, the iterator types for QHash have the same interface as QMap's iterators.\n\nUnlike STL-style iterators (covered below), Java-style iterators point between items rather than directly at items. For this reason, they are either pointing to the very beginning of the container (before the first item), at the very end of the container (after the last item), or between two items. The diagram below shows the valid iterator positions as red arrows for a list containing four items:\n\nHere's a typical loop for iterating through all the elements of a QList<QString> in order and printing them to the console:\n\nIt works as follows: The QList to iterate over is passed to the QListIterator constructor. At that point, the iterator is located just in front of the first item in the list (before item \"A\"). Then we call hasNext() to check whether there is an item after the iterator. If there is, we call next() to jump over that item. The next() function returns the item that it jumps over. For a QList<QString>, that item is of type QString.\n\nHere's how to iterate backward in a QList:\n\nThe code is symmetric with iterating forward, except that we start by calling toBack() to move the iterator after the last item in the list.\n\nThe diagram below illustrates the effect of calling next() and previous() on an iterator:\n\nThe following table summarizes the QListIterator API:\n\nQListIterator provides no functions to insert or remove items from the list as we iterate. To accomplish this, you must use QMutableListIterator. Here's an example where we remove all odd numbers from a QList<int> using QMutableListIterator:\n\nThe next() call in the loop is made every time. It jumps over the next item in the list. The remove() function removes the last item that we jumped over from the list. The call to remove() does not invalidate the iterator, so it is safe to continue using it. This works just as well when iterating backward:\n\nIf we just want to modify the value of an existing item, we can use setValue(). In the code below, we replace any value larger than 128 with 128:\n\nJust like remove(), setValue() operates on the last item that we jumped over. If we iterate forward, this is the item just before the iterator; if we iterate backward, this is the item just after the iterator.\n\nThe next() function returns a non-const reference to the item in the list. For simple operations, we don't even need setValue():\n\nAs mentioned above, QLinkedList's, QVector's, and QSet's iterator classes have exactly the same API as QList's. We will now turn to QMapIterator, which is somewhat different because it iterates on (key, value) pairs.\n\nLike QListIterator, QMapIterator provides toFront(), toBack(), hasNext(), next(), peekNext(), hasPrevious(), previous(), and peekPrevious(). The key and value components are extracted by calling key() and value() on the object returned by next(), peekNext(), previous(), or peekPrevious().\n\nThe following example removes all (capital, country) pairs where the capital's name ends with \"City\":\n\nQMapIterator also provides a key() and a value() function that operate directly on the iterator and that return the key and value of the last item that the iterator jumped above. For example, the following code copies the contents of a QMap into a QHash:\n\nIf we want to iterate through all the items with the same value, we can use findNext() or findPrevious(). Here's an example where we remove all the items with a particular value:\n\nSTL-style iterators have been available since the release of Qt 2.0. They are compatible with Qt's and STL's generic algorithms and are optimized for speed.\n\nFor each container class, there are two STL-style iterator types: one that provides read-only access and one that provides read-write access. Read-only iterators should be used wherever possible because they are faster than read-write iterators.\n\nThe API of the STL iterators is modelled on pointers in an array. For example, the operator advances the iterator to the next item, and the operator returns the item that the iterator points to. In fact, for QVector and QStack, which store their items at adjacent memory positions, the iterator type is just a typedef for , and the const_iterator type is just a typedef for .\n\nIn this discussion, we will concentrate on QList and QMap. The iterator types for QLinkedList, QVector, and QSet have exactly the same interface as QList's iterators; similarly, the iterator types for QHash have the same interface as QMap's iterators.\n\nHere's a typical loop for iterating through all the elements of a QList<QString> in order and converting them to lowercase:\n\nUnlike Java-style iterators, STL-style iterators point directly at items. The begin() function of a container returns an iterator that points to the first item in the container. The end() function of a container returns an iterator to the imaginary item one position past the last item in the container. end() marks an invalid position; it must never be dereferenced. It is typically used in a loop's break condition. If the list is empty, begin() equals end(), so we never execute the loop.\n\nThe diagram below shows the valid iterator positions as red arrows for a vector containing four items:\n\nIterating backward with an STL-style iterator requires us to decrement the iterator before we access the item. This requires a loop:\n\nIn the code snippets so far, we used the unary operator to retrieve the item (of type QString) stored at a certain iterator position, and we then called QString::toLower() on it. Most C++ compilers also allow us to write , but some don't.\n\nFor read-only access, you can use const_iterator, constBegin(), and constEnd(). For example:\n\nThe following table summarizes the STL-style iterators' API:\n\nThe and operators are available both as prefix ( , ) and postfix ( , ) operators. The prefix versions modify the iterators and return a reference to the modified iterator; the postfix versions take a copy of the iterator before they modify it, and return that copy. In expressions where the return value is ignored, we recommend that you use the prefix operators ( , ), as these are slightly faster.\n\nFor non-const iterator types, the return value of the unary operator can be used on the left side of the assignment operator.\n\nFor QMap and QHash, the operator returns the value component of an item. If you want to retrieve the key, call key() on the iterator. For symmetry, the iterator types also provide a value() function to retrieve the value. For example, here's how we would print all items in a QMap to the console:\n\nThanks to implicit sharing, it is very inexpensive for a function to return a container per value. The Qt API contains dozens of functions that return a QList or QStringList per value (e.g., QSplitter::sizes()). If you want to iterate over these using an STL iterator, you should always take a copy of the container and iterate over the copy. For example:\n\nThis problem doesn't occur with functions that return a const or non-const reference to a container.\n\nImplicit sharing has another consequence on STL-style iterators: You must not take a copy of a container while non-const iterators are active on that container. Java-style iterators don't suffer from that limitation.\n\nIf you just want to iterate over all the items in a container in order, you can use Qt's keyword. The keyword is a Qt-specific addition to the C++ language, and is implemented using the preprocessor.\n\nIts syntax is: (variable, container) statement. For example, here's how to use to iterate over a QLinkedList<QString>:\n\nThe code is significantly shorter than the equivalent code that uses iterators:\n\nUnless the data type contains a comma (e.g., ), the variable used for iteration can be defined within the statement:\n\nAnd like any other C++ loop construct, you can use braces around the body of a loop, and you can use to leave the loop:\n\nWith QMap and QHash, accesses the value component of the (key, value) pairs. If you want to iterate over both the keys and the values, you can use iterators (which are fastest), or you can write code like this:\n\nQt automatically takes a copy of the container when it enters a loop. If you modify the container as you are iterating, that won't affect the loop. (If you do not modify the container, the copy still takes place, but thanks to implicit sharing copying a container is very fast.)\n\nSince foreach creates a copy of the container, using a non-const reference for the variable does not allow you to modify the original container. It only affects the copy, which is probably not what you want.\n\nIn addition to , Qt also provides a pseudo-keyword for infinite loops:\n\nIf you're worried about namespace pollution, you can disable these macros by adding the following line to your file:\n\nQt includes three template classes that resemble containers in some respects. These classes don't provide iterators and cannot be used with the keyword.\nâ€¢ QVarLengthArray<T, Prealloc> provides a low-level variable-length array. It can be used instead of QVector in places where speed is particularly important.\nâ€¢ QCache<Key, T> provides a cache to store objects of a certain type T associated with keys of type Key.\nâ€¢ QContiguousCache<T> provides an efficient way of caching data that is typically accessed in a contiguous way.\n\nAdditional non-template types that compete with Qt's template containers are QBitArray, QByteArray, QString, and QStringList.\n\nAlgorithmic complexity is concerned about how fast (or slow) each function is as the number of items in the container grow. For example, inserting an item in the middle of a QLinkedList is an extremely fast operation, irrespective of the number of items stored in the QLinkedList. On the other hand, inserting an item in the middle of a QVector is potentially very expensive if the QVector contains many items, since half of the items must be moved one position in memory.\n\nTo describe algorithmic complexity, we use the following terminology, based on the \"big Oh\" notation:\nâ€¢ Constant time: O(1). A function is said to run in constant time if it requires the same amount of time no matter how many items are present in the container. One example is QLinkedList::insert().\nâ€¢ Logarithmic time: O(log n). A function that runs in logarithmic time is a function whose running time is proportional to the logarithm of the number of items in the container. One example is qBinaryFind().\nâ€¢ Linear time: O(n). A function that runs in linear time will execute in a time directly proportional to the number of items stored in the container. One example is QVector::insert().\nâ€¢ Linear-logarithmic time: O(n log n). A function that runs in linear-logarithmic time is asymptotically slower than a linear-time function, but faster than a quadratic-time function.\nâ€¢ Quadratic time: O(nÂ²). A quadratic-time function executes in a time that is proportional to the square of the number of items stored in the container.\n\nThe following table summarizes the algorithmic complexity of Qt's sequential container classes:\n\nIn the table, \"Amort.\" stands for \"amortized behavior\". For example, \"Amort. O(1)\" means that if you call the function only once, you might get O(n) behavior, but if you call it multiple times (e.g., n times), the average behavior will be O(1).\n\nThe following table summarizes the algorithmic complexity of Qt's associative containers and sets:\n\nWith QVector, QHash, and QSet, the performance of appending items is amortized O(log n). It can be brought down to O(1) by calling QVector::reserve(), QHash::reserve(), or QSet::reserve() with the expected number of items before you insert the items. The next section discusses this topic in more depth.\n\nQVector<T>, QString, and QByteArray store their items contiguously in memory; QList<T> maintains an array of pointers to the items it stores to provide fast index-based access (unless T is a pointer type or a basic type of the size of a pointer, in which case the value itself is stored in the array); QHash<Key, T> keeps a hash table whose size is proportional to the number of items in the hash. To avoid reallocating the data every single time an item is added at the end of the container, these classes typically allocate more memory than necessary.\n\nConsider the following code, which builds a QString from another QString:\n\nWe build the string dynamically by appending one character to it at a time. Let's assume that we append 15000 characters to the QString string. Then the following 18 reallocations (out of a possible 15000) occur when QString runs out of space: 4, 8, 12, 16, 20, 52, 116, 244, 500, 1012, 2036, 4084, 6132, 8180, 10228, 12276, 14324, 16372. At the end, the QString has 16372 Unicode characters allocated, 15000 of which are occupied.\n\nThe values above may seem a bit strange, but here are the guiding principles:\nâ€¢ QString allocates 4 characters at a time until it reaches size 20.\nâ€¢ From 20 to 4084, it advances by doubling the size each time. More precisely, it advances to the next power of two, minus 12. (Some memory allocators perform worst when requested exact powers of two, because they use a few bytes per block for book-keeping.)\nâ€¢ From 4084 on, it advances by blocks of 2048 characters (4096 bytes). This makes sense because modern operating systems don't copy the entire data when reallocating a buffer; the physical memory pages are simply reordered, and only the data on the first and last pages actually needs to be copied.\n\nQByteArray and QList<T> use more or less the same algorithm as QString.\n\nQVector<T> also uses that algorithm for data types that can be moved around in memory using memcpy() (including the basic C++ types, the pointer types, and Qt's shared classes) but uses a different algorithm for data types that can only be moved by calling the copy constructor and a destructor. Since the cost of reallocating is higher in that case, QVector<T> reduces the number of reallocations by always doubling the memory when running out of space.\n\nQHash<Key, T> is a totally different case. QHash's internal hash table grows by powers of two, and each time it grows, the items are relocated in a new bucket, computed as qHash(key) % QHash::capacity() (the number of buckets). This remark applies to QSet<T> and QCache<Key, T> as well.\n\nFor most applications, the default growing algorithm provided by Qt does the trick. If you need more control, QVector<T>, QHash<Key, T>, QSet<T>, QString, and QByteArray provide a trio of functions that allow you to check and specify how much memory to use to store the items:\nâ€¢ capacity() returns the number of items for which memory is allocated (for QHash and QSet, the number of buckets in the hash table).\nâ€¢ squeeze() frees any memory not required to store the items.\n\nIf you know approximately how many items you will store in a container, you can start by calling reserve(), and when you are done populating the container, you can call squeeze() to release the extra preallocated memory."
    }
]