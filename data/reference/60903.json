[
    {
        "link": "https://en.cppreference.com/w/cpp/container/priority_queue",
        "document": "The priority queue is a container adaptor that provides constant time lookup of the largest (by default) element, at the expense of logarithmic insertion and extraction.\n\nA user-provided can be supplied to change the ordering, e.g. using std::greater<T> would cause the smallest element to appear as the top().\n\nWorking with a is similar to managing a heap in some random access container, with the benefit of not being able to accidentally invalidate the heap.\n\nAll member functions of are constexpr: it is possible to create and use objects in the evaluation of a constant expression. However, objects generally cannot be constexpr, because any dynamically allocated storage must be released in the same evaluation of constant expression.\n\nThe type of the stored elements. The program is ill-formed if is not the same type as . The type of the underlying container to use to store the elements. The container must satisfy the requirements of , and its iterators must satisfy the requirements of . Additionally, it must provide the following functions with the usual semantics: The standard containers std::vector (not including ) and std::deque satisfy these requirements. A type providing a strict weak ordering. Note that the Compare parameter is defined such that it returns true if its first argument comes before its second argument in a weak ordering. But because the priority queue outputs largest elements first, the elements that \"come before\" are actually output last. That is, the front of the queue contains the \"last\" element according to the weak ordering imposed by Compare.\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://geeksforgeeks.org/priority-queue-in-cpp-stl",
        "document": "In C++, priority queue is a type of queue in which there is some priority assigned to the elements. According to this priority, elements are removed from the queue. By default, the value of the element being inserted is considered as priority. Higher its value, higher its priority. But this can be changed to any desired priority scheme as per requirement.\n\nExplanation: In the above program, we created a priority queue of integers that contains the elements 9, 10 and 6. The top element, which is the largest value in the queue, is then printed.\n‚Ä¢ pq: Name assigned to the priority queue.\n‚Ä¢ comp : It is a binary predicate function that tells priority queue how to compare two elements. It is used to set the custom priority parameter and scheme. It is optional and if not provided, maximum value gets maximum priority.\n\nPriority queue container provides the built-in implementation of a binary heap data structure. There can be two types of heaps,\n‚Ä¢ None Max-heap in which the priority is given to the largest element. (Default)\n‚Ä¢ None Min-heap in which the priority is given to the smallest element.\n\nPriority queue is a container adaptor generally built over vector container. We can implement both of these heaps in priority queue.\n\nPriority queue can be declared and initialized in multiple ways as shown in the below example:\n\nExplanation: In the above program, two priority queues are initialized in the following ways:\n‚Ä¢ priority_queue<int> pq1 creates an empty priority queue of integers. Elements are later inserted.\n‚Ä¢ priority_queue<int> pq2(v.begin(), v.end()) creates a priority queue and initializes it with the same elements as those in the vector v. We can use any other container too.\n\nBoth priority queues will have the largest element at the top.\n\nHere are the basic operations that can be performed on a priority queue:\n\nElements can be inserted in the priority queue using push() method. After insertion, priority queue reorganize itself in such a way that the highest priority element is always at the top.\n\nExplanation: In the above program, elements 9, 8 and 6 are inserted into the priority queue using push() method one by one. After insertion, the largest element 9 is at the top.\n\nOnly the top element of the priority queue can be accessed using top() method. It is the element with the highest priority in priority queue.\n\nIn priority queue, deletion can only be done from the top of the priority queue using pop()method. It means that we can only remove the element with highest priority in one move. After deletion, the priority queue rearranges itself such that the next greatest priority element becomes the top element.\n\nExplanation: In this example, we deleted the top element using pop() method, which is 9. This shifts the next greatest element 8 to the top.\n\nIn priority queue, we can only access top element of the priority queue, so we cannot directly traverse it. However, we can create a copy of the priority queue, access and delete the top element and repeat this process until the copied priority queue is empty. In this way, we can effectively traverse all the elements of the priority queue.\n\nAll the above operations are demonstrated on a priority queue implementing max heap. This can be changed by using a custom comparator in which you define the priority parameter and how to compare them.\n\nIf you only want to assign highest priority to the smallest element (min-heap), then inbuilt greater<type> functional object can be used.\n\nExplanation: In the above program, even though vector is default container, we still have to pass it because the comparator is third template argument. So, we have to pass all the arguments before it.\n\nThe below table lists the time complexity of the above operations on priority queue:\n\nThe following are some more operations on priority queue that will help you become more familiarize with this container:\n\nFollowing is the primary differences between priority queue and queue in C++:\n‚Ä¢ None follows the First in First Out (FIFO) principle, where the first element inserted is the first element to be removed.\n‚Ä¢ None A priority queue stores elements in order of priority, where the highest priority element is always at the top no matter when it is inserted.\n\nFollowing is the list of all member functions of std::priority_queue class in C++:"
    },
    {
        "link": "https://learn.microsoft.com/en-us/cpp/standard-library/priority-queue-class?view=msvc-170",
        "document": "A template container adaptor class that provides a restriction of functionality limiting access to the top element of some underlying container type, which is always the largest or of the highest priority. New elements can be added to the and the top element of the can be inspected or removed.\n\n\n\n The element data type to be stored in the .\n\n\n\n The type of the underlying container used to implement the .\n\n\n\n The type that provides a function object that can compare two element values as sort keys to determine their relative order in the . This argument is optional and the binary predicate is the default value.\n\nThe elements of class stipulated in the first template parameter of a queue object are synonymous with and must match the type of element in the underlying container class stipulated by the second template parameter. The must be assignable, so that it's possible to copy objects of that type and to assign values to variables of that type.\n\nThe orders the sequence it controls by calling a stored function object of class . In general, the elements need be merely less than comparable to establish this order: so that, given any two elements, it may be determined either that they're equivalent (in the sense that neither is less than the other) or that one is less than the other. This results in an ordering between the nonequivalent elements. On a more technical note, the comparison function is a binary predicate that induces a strict weak ordering in the standard mathematical sense.\n\nSuitable underlying container classes for include Class and the default Class or any other sequence container that supports the operations of , , and and a random-access iterator. The underlying container class is encapsulated within the container adaptor, which exposes only the limited set of the sequence container member functions as a public interface.\n\nAdding elements to and removing elements from a both have logarithmic complexity. Accessing elements in a has constant complexity.\n\nThere are three types of container adaptors defined by the C++ Standard Library: , , and . Each restricts the functionality of some underlying container class to provide a precisely controlled interface to a standard data structure.\n‚Ä¢ None The Class supports a last-in, first-out (LIFO) data structure. A good analogue to keep in mind would be a stack of plates. Elements (plates) may be inserted, inspected, or removed only from the top of the stack, which is the last element at the end of the base container. The restriction to accessing only the top element is the reason for using the class.\n‚Ä¢ None The Class supports a first-in, first-out (FIFO) data structure. A good analogue to keep in mind would be people lining up for a bank teller. Elements (people) may be added to the back of the line and are removed from the front of the line. Both the front and the back of a line may be inspected. The restriction to accessing only the front and back elements in this way is the reason for using the class.\n‚Ä¢ None The class orders its elements so that the largest element is always at the top position. It supports insertion of an element and the inspection and removal of the top element. A good analogue to keep in mind would be people lining up where they're arranged by age, height, or some other criterion.\n\nA type that provides the base container to be adapted.\n\nThe type is a synonym for the template parameter . The C++ Standard Library sequence container class and the default class meet the requirements to be used as the base container for a object. User-defined types satisfying the requirements may also be used.\n\nFor more information on , see the Remarks section of the Class topic.\n\nSee the example for for an example of how to declare and use .\n\nif the is empty; if the is nonempty.\n\nRemoves the largest element of the from the top position.\n\nThe must be nonempty to apply the member function. The top of the is always occupied by the largest element in the container.\n\nConstructs a that is empty or that is a copy of a range of a base container object or of another .\n\n\n\n The comparison function of type used to order the elements in the , which defaults to compare function of the base container.\n\n\n\n The base container of which the constructed is to be a copy.\n\n\n\n The of which the constructed set is to be a copy.\n\n\n\n The position of the first element in the range of elements to be copied.\n\n\n\n The position of the first element beyond the range of elements to be copied.\n\nEach of the first three constructors specifies an empty initial , the second also specifying the type of comparison function ( ) to be used in establishing the order of the elements and the third explicitly specifying the ( ) to be used. The keyword suppresses certain kinds of automatic type conversion.\n\nThe fourth constructor specifies a copy of the .\n\nThe last three constructors copy the range of some container and use the values to initialize a with increasing explicitness in specifying the type of comparison function of class and .\n\nAdds an element to the priority queue based on the priority of the element from .\n\n\n\n The element added to the top of the .\n\nThe top of the is the position occupied by the largest element in the container.\n\nReturns the number of elements in the .\n\nThe current length of the .\n\nAn unsigned integer type that can represent the number of elements in a .\n\nThe type is a synonym for the of the base container adapted by the .\n\nSee the example for for an example of how to declare and use .\n\nReturns a const reference to the largest element at the top of the .\n\nA reference to the largest element, as determined by the function, object of the .\n\nThe must be nonempty to apply the member function.\n\nA type that represents the type of object stored as an element in a .\n\nThe type is a synonym for the of the base container adapted by the .\n\nThread Safety in the C++ Standard Library\n\n C++ Standard Library Reference"
    },
    {
        "link": "https://cplusplus.com/reference/queue/priority_queue",
        "document": "usually the same as"
    },
    {
        "link": "https://medium.com/@ryan_forrester_/c-priority-queue-practical-guide-cf5291bc1fcd",
        "document": "A Note From The Author That You‚Äôll Actually Want to Read\n\nHey there, I‚Äôm Ryan üëã . I hope you‚Äôre finding this article useful!\n\nI just wanted to tell you about something I built after one too many late-night debugging sessions.\n\nHere‚Äôs the truth: I was tired of spending hours hunting down bugs, scrolling through endless Stack Overflow threads, and getting generic AI responses that didn‚Äôt actually solve my problems.\n\nSo I built SolvePro (https://solvepro.co/ai/), and it turned out to be the tool I wish I‚Äôd had years ago.\n\nRemember that feeling when you finally understand a concept, and everything just clicks?\n\nThat‚Äôs what I wanted to create ‚Äî not just another AI tool, but an actual learning companion that helps those ‚Äúaha!‚Äù moments happen more often.\n\nWhat sets SolvePro apart from other AI‚Äôs is how it guides your learning journey. Based on your coding questions and style, it suggests quizzes and real projects that match your needs.\n\nMy Promise to You\n\nAs an educator and developer, I stand behind SolvePro‚Äôs quality. We‚Äôre constantly improving based on user feedback, and I personally read every suggestion. If it doesn‚Äôt help you become a better programmer, I want to know why.\n\nI believe everyone deserves access to quality programming education. That‚Äôs why you can get instant access to SolvePro at https://solvepro.co/ai/\n\n‚ÄúIt‚Äôs like having a really patient senior dev who actually wants to help you understand the problem.‚Äù\n\n‚ÄúThis helped me finally make sense of async programming. The personalized exercises made all the difference.‚Äù\n\nI built this because I believe coding should be less frustrating and more rewarding. If you try SolvePro and it doesn‚Äôt help, email me directly at help@solvepro.co, I want to know why so we can make it better."
    },
    {
        "link": "https://geeksforgeeks.org/insertion-and-deletion-in-heaps",
        "document": "The standard deletion operation on Heap is to delete the element present at the root node of the Heap. That is if it is a Max Heap, the standard deletion operation will delete the maximum element and if it is a Min heap, it will delete the minimum element.\n\nProcess of Deletion: \n\nSince deleting an element at any intermediary position in the heap can be costly, so we can simply replace the element to be deleted by the last element and delete the last element of the Heap.\n‚Ä¢ None Replace the root or element to be deleted by the last element.\n‚Ä¢ None Delete the last element from the Heap.\n‚Ä¢ None Since, the last element is now placed at the position of the root node. So, it may not follow the heap property. Therefore, heapify the last node placed at the position of root.\n\nTime complexity: O(logn) where n is no of elements in the heap\n\nAuxiliary Space: O(n)\n\nThe insertion operation is also similar to that of the deletion process.\n\nProcess of Insertion: Elements can be inserted to the heap following a similar approach as discussed above for deletion. The idea is to:\n‚Ä¢ None First increase the heap size by 1, so that it can store the new element.\n‚Ä¢ None Insert the new element at the end of the Heap.\n‚Ä¢ None This newly inserted element may distort the properties of Heap for its parents. So, in order to keep the properties of Heap, heapify\n\nTime Complexity: O(log(n)) (where n is no of elements in the heap)\n\nAuxiliary Space: O(n)"
    },
    {
        "link": "https://geeksforgeeks.org/implement-heap-in-c",
        "document": "A heap is a type of tree data structure where each node is either greater than or equal to or less than or equal to the values of its children. Based on this property, heaps are classified into two types:\n‚Ä¢ Min Heap: Each node is less than or equal to the values of its children.\n‚Ä¢ Max Heap: Each node is greater than or equal to the values of its children.\n\nAdditionally, a heap is a complete binary tree, meaning all levels are fully filled except possibly the last level, which is filled from left to right.\n\nIn this article, we will learn how to implement the heap data structure in C++ using classes. We will focus on a binary heap. For a k-ary heap, refer to this article ‚Äì K-ary Heap Data Structure.\n\nImplementation of Heap in C++\n\nIn C++, heaps are often stored in arrays for faster access and modification. Due to the complete binary tree property, the index of the child and parent nodes can be easily computed:\n\nIn C++, we can create a class with an vector and a size variable to represent the heap. We can implement the required functions as the member functions of this class\n\nThere are several essential operations used with heaps:\n‚Ä¢ Insert : Adds a new element to the heap while maintaining the heap property (either min or max heap ordering).\n‚Ä¢ Extract Min/Max: Removes and returns the minimum/maximum element from the heap.\n‚Ä¢ Peek : Returns the minimum/maximum element without removing it.\n‚Ä¢ Heapify : Reorganizes a subtree for a given node to ensure the heap property holds.\n‚Ä¢ Increase/Decrease Key : Changes the value of an existing element in the heap.\n‚Ä¢ Build Heap : Converts an array into a proper min or max heap.\n\nThe heapify function is implemented with the function signature: void Heap::heapify(int i) where i is the index on which heapify is called.\n\nThe insert function is implemented with the function signature: void Heap::insert(int key).\n\nThe extractMax function is implemented with the function signature: int Heap::extractMax().\n\nGet Max Implementation in C++\n\nThe getMax function is implemented with the function signature: int Heap::getMax() const.\n\nThe deleteKey function is implemented with the function signature: void Heap::deleteKey(int i).\n\nThe increaseKey function is implemented with the function signature: void Heap::increaseKey(int i, int newValue).\n\nThe printHeap function is implemented with the function signature: void Heap::printHeap() const.\n\nThe min heap can be easily implemented using the same algorithms by changing the comparison operator to less than ( )."
    },
    {
        "link": "https://hackerearth.com/practice/notes/heaps-and-priority-queues",
        "document": ""
    },
    {
        "link": "https://medium.com/@RobuRishabh/heap-data-structure-and-priority-queue-in-c-d2fe7a569c86",
        "document": "A Heap is a special tree-based data structure in which the tree is a complete binary tree. Heap is not necessarily a Binary Search Tree (BST).\n\nIt can be of 2 types:\n‚Ä¢ Max-Heap: The value of each node is greater than or equal to the values of its children. The largest element is at the root.\n‚Ä¢ Min-Heap: The value of each node is less than or equal to the values of its children. The smallest element is at the root.\n\nHeaps are commonly used to implement priority queues because they efficiently support operations like insertion and extraction of the maximum or minimum element.\n\nComplete Binary Tree: A heap is always a complete binary tree, meaning all levels are completely filled except possibly the last, which is filled from left to right.\n\nRepresentation: Heaps are typically implemented using arrays for simplicity. For a node at index :\n\nHeap Sort: It uses a heap to sort an array in O(nlogn) time:\n‚Ä¢ Extract the maximum element and place it at the end of the array.\n‚Ä¢ Restore the heap property and repeat for the remaining elements.\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// Function to maintain the heap property for a subtree rooted at index 'i'\n\n// 'n' is the size of the heap\n\nvoid heapify(vector<int> &arr, int n, int i){\n\n int largest = i;\n\n int left = 2 * i + 1; // Left child index\n\n int right = 2 * 1 + 2; // Right child index\n\n // Check if the left child exists and is larger than the current largest\n\n if(left < n && arr[left] > arr[largest])\n\n largest = left;\n\n // Check if the right child exist and is larger than the current largest\n\n if(right < n && arr[right] > arr[largest])\n\n largest = right;\n\n // If the largest is not the current node, swap and heapify the affected subtree\n\n if(largest != i){\n\n swap(arr[i], arr[largest]); // Swap the current node with the largest\n\n heapify(arr, n, largest); // Recursively heapify the affected subtree\n\n }\n\n}\n\n\n\n// Main function to perform heap sort\n\nvoid heapSort(vector<int> &arr){\n\n int n = arr.size();\n\n // Step.1 : Build a max-heap from the input array\n\n for(int i = n/2 - 1; i >= 0; i--) // Start from the last non-leaf node\n\n heapify(arr, n, i);\n\n\n\n // Step.2 Extract elements from the heap one by one\n\n for(int i = n-1; i>0; i--){\n\n swap(arr[0], arr[i]); // Move the root (largest element) to the end\n\n heapify(arr, i, 0); // Restore the heap property for the reduced heap\n\n }\n\n}\n\n\n\nint main(){\n\n vector<int> arr = {10, 5, 20, 2, 15}; // Input array\n\n heapSort(arr); // Perform heap sort\n\n cout << \"Sorted Array: \";\n\n for(int val : arr) cout << val << \" \";\n\n cout << endl;\n\n return 0;\n\n}\n\nA priority queue is an abstract data structure that allows elements to be retrieved based on their priority. In C++, the priority_queue container implements this functionality using a heap.\n\nA priority_queue in C++ by default acts as a max-heap, where the largest element is always at the top.\n\nTo implement a min-heap, you need to specify as the comparator:\n\nYou are part of a university admissions office and need to keep track of the highest test score from applicants in real-time. This helps to determine cut-off marks for interviews and admissions dynamically as new applicants submit their scores.\n\nYou are tasked to implement a class which, for a given integer , maintains a stream of test scores and continuously returns the th highest test score after a new score has been submitted. More specifically, we are looking for the th highest score in the sorted list of all scores.\n‚Ä¢ Initializes the object with the integer and the stream of test scores .\n‚Ä¢ Adds a new test score to the stream and returns the element representing the largest element in the pool of test scores so far.\n‚Ä¢ The smallest element in the heap is the kth largest element when the heap has size .\n‚Ä¢ Add numbers from the initial list into the heap.\n‚Ä¢ Keep the heap size limited to . Remove the smallest elements if the heap grows larger than .\n‚Ä¢ Add the new value to the heap.\n‚Ä¢ If the heap exceeds size , remove the smallest element.\n‚Ä¢ Return the smallest element of the heap ( in your code), which is the kth largest element.\n\nYou are given an array of integers where is the weight of the stone.\n\nWe are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights and with . The result of this smash is:\n‚Ä¢ If , both stones are destroyed, and\n‚Ä¢ If , the stone of weight is destroyed, and the stone of weight has new weight .\n\nAt the end of the game, there is at most one stone left.\n\nReturn the weight of the last remaining stone. If there are no stones left, return .\n‚Ä¢ Build a max-heap, where the largest value is always at the top. This helps us efficiently extract the heaviest stones.\n‚Ä¢ While the heap has more than one stones:\n‚Ä¢ If their weights are equal, destroy both.\n‚Ä¢ If their weights differ, calculate the difference and add the remaining weight back to the heap.\n\n3. When the loop ends, if the heap is empty, return 0. If there is only 1 stone left, return its weight.\n\nGiven an integer array and an integer , return the largest element in the array.\n\nNote that it is the largest element in the sorted order, not the distinct element.\n\nCan you solve it without sorting?\n‚Ä¢ Use a Min-heap to find the K-th largest element in the array without fully sorting it.\n‚Ä¢ Traverse through all the elements of the array\n‚Ä¢ Push each element into the Min-Heap.\n‚Ä¢ If the size of Min-Heap exceeds ‚Äúk‚Äù, remove the smallest element (top of the Min-Heap).\n‚Ä¢ At the end of the iteration, top of the Min-Heap contains the ‚Äúk-th‚Äù largest element."
    },
    {
        "link": "https://stackoverflow.com/questions/45675985/deleting-ith-index-in-minimum-heap",
        "document": "Can someone please explain the concept for deleting the i-th element in the min-heap that is represented by an array and maintain the heap property after deletion operation.\n\nThat's how I tried, but this doesn't handles all the conditions properly:"
    }
]