[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API",
        "document": "The WebSocket API makes it possible to open a two-way interactive communication session between the user's browser and a server. With this API, you can send messages to a server and receive responses without having to poll the server for a reply.\n\nThe WebSocket API provides two alternative mechanisms for creating and using web socket connections: the interface and the interface.\nâ€¢ The interface is stable and has good browser and server support. However it doesn't support backpressure. As a result, when messages arrive faster than the application can process them it will either fill up the device's memory by buffering those messages, become unresponsive due to 100% CPU usage, or both.\nâ€¢ The interface is a -based alternative to . It uses the Streams API to handle receiving and sending messages, meaning that socket connections can take advantage of stream backpressure automatically, regulating the speed of reading or writing to avoid bottlenecks in the application. However, is non-standard and currently only supported in one rendering engine.\n\nAdditionally, the WebTransport API is expected to replace the WebSocket API for many applications. WebTransport is a versatile, low-level API that provides backpressure and many other features not supported by either or , such as unidirectional streams, out-of-order delivery, and unreliable data transmission via datagrams. WebTransport is more complex to use than WebSockets and its cross-browser support is not as wide, but it enables the implementation of sophisticated solutions. If standard WebSocket connections are a good fit for your use case and you need wide browser compatibility, you should employ the WebSockets API to get up and running quickly. However, if your application requires a non-standard custom solution, then you should use the WebTransport API."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_client_applications",
        "document": "In order to communicate using the WebSocket protocol, you need to create a object; this will automatically attempt to open the connection to the server. The WebSocket constructor accepts one required and one optional parameter: The URL to which to connect; this should be the URL to which the WebSocket server will respond. This should use the URL scheme , although some software may allow you to use the insecure for a local connection. Relative URL values and and schemes are also allowed in most recent browser versions. Either a single protocol string or an array of protocol strings. These strings are used to indicate sub-protocols, so that a single server can implement multiple WebSocket sub-protocols (for example, you might want one server to be able to handle different types of interactions depending on the specified ). If you don't specify a protocol string, an empty string is assumed. The constructor will throw a if the destination doesn't allow access. This may happen if you attempt to use an insecure connection (most user agents now require a secure link for all WebSocket connections unless they're on the same device or possibly on the same network).\n\nIf an error occurs while attempting to connect, an event is first sent to the object (thereby invoking any handlers), followed by a event that indicates the reason for the connection's closing. The browser may also output to its console a more descriptive error message as well as a closing code as defined in RFC 6455, Section 7.4 through the .\n\nThis simple example creates a new WebSocket, connecting to the server at . A custom protocol of \"protocolOne\" is named in the request for the socket in this example, though this can be omitted. On return, is . The will become once the connection is ready to transfer data. If you want to open a connection and are flexible about the protocols you support, you can specify an array of protocols: Once the connection is established (that is, is ), will tell you which protocol the server selected. Establishing a WebSocket relies on the HTTP Upgrade mechanism, so the request for the protocol upgrade is implicit when we address the web server as or .\n\nOnce you've opened your connection, you can begin transmitting data to the server. To do this, call the object's method for each message you want to send: exampleSocket.send(\"Here's some text that the server is urgently awaiting!\"); You can send data as a string, , or . As establishing a connection is asynchronous and prone to failure there is no guarantee that calling the method immediately after creating a WebSocket object will be successful. We can at least be sure that attempting to send data only takes place once a connection is established by defining an event handler to do the work: exampleSocket.onopen = (event) => { exampleSocket.send(\"Here's some text that the server is urgently awaiting!\"); };\n\nLet's consider the chat client application first alluded to in Using JSON to transmit objects. There are assorted types of data packets the client might receive, such as: The code that interprets these incoming messages might look like this: exampleSocket.onmessage = (event) => { const f = document.getElementById(\"chat-box\").contentDocument; let text = \"\"; const msg = JSON.parse(event.data); const time = new Date(msg.date); const timeStr = time.toLocaleTimeString(); switch (msg.type) { case \"id\": clientID = msg.id; setUsername(); break; case \"username\": text = `User <em>${msg.name}</em> signed in at ${timeStr}<br>`; break; case \"message\": text = `(${timeStr}) ${msg.name} : ${msg.text} <br>`; break; case \"reject-username\": text = `Your username has been set to <em>${msg.name}</em> because the name you chose is in use.<br>`; break; case \"user-list\": document.getElementById(\"user-list-box\").innerText = msg.users.join(\"\n\n\"); break; } if (text.length) { f.write(text); document.getElementById(\"chat-box\").contentWindow.scrollByPages(1); } }; Here we use to convert the JSON object back into the original object, then examine and act upon its contents."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/WebSocket",
        "document": "This feature is well established and works across many devices and browser versions. Itâ€™s been available across browsers since July 2015 .\n\n* Some parts of this feature may have varying levels of support."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers",
        "document": "A WebSocket server is nothing more than an application listening on any port of a TCP server that follows a specific protocol. Creating a custom server can seem overwhelming if you have never done it before. It can actually be quite straightforward to implement a basic WebSocket server on your platform of choice, though. A WebSocket server can be written in any server-side programming language that is capable of Berkeley sockets, such as C(++), Python, PHP, or server-side JavaScript. This is not a tutorial in any specific language, but serves as a guide to facilitate writing your own server. This article assumes you're already familiar with how HTTP works, and that you have a moderate level of programming experience. Depending on language support, knowledge of TCP sockets may be required. The scope of this guide is to present the minimum knowledge you need to write a WebSocket server. Note: Read the latest official WebSockets specification, RFC 6455. Sections 1 and 4-7 are especially interesting to server implementors. Section 10 discusses security and you should definitely peruse it before exposing your server. A WebSocket server is explained on a very low level here. WebSocket servers are often separate and specialized servers (for load-balancing or other practical reasons), so you will often use a reverse proxy (such as a regular HTTP server) to detect WebSocket handshakes, pre-process them, and send those clients to a real WebSocket server. This means that you don't have to bloat your server code with cookie and authentication handlers (for example).\n\nFirst, the server must listen for incoming socket connections using a standard TCP socket. Depending on your platform, this may be handled for you automatically. For example, let's assume that your server is listening on , port 8000, and your socket server responds to requests at . Warning: The server may listen on any port it chooses, but if it chooses any port other than 80 or 443, it may have problems with firewalls and/or proxies. Browsers generally require a secure connection for WebSockets, although they may offer an exception for local devices. The handshake is the \"Web\" in WebSockets. It's the bridge from HTTP to WebSockets. In the handshake, details of the connection are negotiated, and either party can back out before completion if the terms are unfavorable. The server must be careful to understand everything the client asks for, otherwise security issues can occur. Note: The request-uri ( here) has no defined meaning in the spec. So, many people use it to let one server handle multiple WebSocket applications. For example, could invoke a multiuser chat app, while on the same server might invoke a multiplayer game.\n\nEven though you're building a server, a client still has to start the WebSocket handshake process by contacting the server and requesting a WebSocket connection. So, you must know how to interpret the client's request. The client will send a pretty standard HTTP request with headers that looks like this (the HTTP version must be 1.1 or greater, and the method must be ): The client can solicit extensions and/or subprotocols here; see Miscellaneous for details. Also, common headers like , , , or authentication headers might be there as well. Do whatever you want with those; they don't directly pertain to the WebSocket. It's also safe to ignore them. In many common setups, a reverse proxy has already dealt with them. Note: All browsers send an header. You can use this header for security (checking for same origin, automatically allowing or denying, etc.) and send a 403 Forbidden if you don't like what you see. This is effective against Cross Site WebSocket Hijacking (CSWH). However, be warned that non-browser agents can send a faked . Most applications reject requests without this header. If any header is not understood or has an incorrect value, the server should send a (\"Bad Request\") response and immediately close the socket. As usual, it may also give the reason why the handshake failed in the HTTP response body, but the message may never be displayed (browsers do not display it). If the server doesn't understand that version of WebSockets, it should send a header back that contains the version(s) it does understand. In the example above, it indicates version 13 of the WebSocket protocol. The most interesting header here is . Let's look at that next. Note: Regular HTTP status codes can be used only before the handshake. After the handshake succeeds, you have to use a different set of codes (defined in section 7.4 of the spec).\n\nWhen the server receives the handshake request, it should send back a special response that indicates that the protocol will be changing from HTTP to WebSocket. That header looks something like the following (remember each header line ends with and put an extra after the last one to indicate the end of the header): Additionally, the server can decide on extension/subprotocol requests here; see Miscellaneous for details. The header is important in that the server must derive it from the that the client sent to it. To get it, concatenate the client's and the string together (it's a \"magic string\"), take the SHA-1 hash of the result, and return the base64 encoding of that hash. Note: This seemingly overcomplicated process exists so that it's obvious to the client whether the server supports WebSockets. This is important because security issues might arise if the server accepts a WebSockets connection but interprets the data as a HTTP request. So if the Key was , the header's value is . Once the server sends these headers, the handshake is complete and you can start swapping data! Note: The server can send other headers like , or ask for authentication or redirects via other status codes, before sending the reply handshake.\n\nIf the MASK bit was set (and it should be, for client-to-server messages), read the next 4 octets (32 bits); this is the masking key. Once the payload length and masking key is decoded, you can read that number of bytes from the socket. Let's call the data , and the key . To get , loop through the octets of and XOR the octet with the (i modulo 4)th octet of . Using JavaScript as an example: // The function receives the frame as a Uint8Array. // firstIndexAfterPayloadLength is the index of the first byte // after the payload length, so it can be 2, 4, or 10. function getPayloadDecoded(frame, firstIndexAfterPayloadLength) { const mask = frame.slice( firstIndexAfterPayloadLength, firstIndexAfterPayloadLength + 4, ); const encodedPayload = frame.slice(firstIndexAfterPayloadLength + 4); // XOR each 4-byte sequence in the payload with the bitmask const decodedPayload = encodedPayload.map((byte, i) => byte ^ mask[i % 4]); return decodedPayload; } const frame = Uint8Array.from([ // FIN=1, RSV1-3=0, opcode=0x1 (text) 0b10000001, // MASK=1, payload length=5 0b10000101, // 4-byte mask 1, 2, 3, 4, // 5-byte payload 105, 103, 111, 104, 110, ]); // Assume you got the number 2 from properly decoding the payload length const decoded = getPayloadDecoded(frame, 2); Now you can figure out what means depending on your application. For example, you can decode it as UTF-8 if it's a text message. Masking is a security measure to avoid malicious parties from predicting the data that is sent to the server. The client will generate a cryptographically random masking key for each message.\n\nThe FIN and opcode fields work together to send a message split up into separate frames. This is called message fragmentation. Fragmentation is only available on opcodes to . Recall that the opcode tells what a frame is meant to do. If it's , the payload is text. If it's , the payload is binary data. However, if it's , the frame is a continuation frame; this means the server should concatenate the frame's payload to the last frame it received from that client. Here is a rough sketch, in which a server reacts to a client sending text messages. The first message is sent in a single frame, while the second message is sent across three frames. FIN and opcode details are shown only for the client: Client: FIN=1, opcode=0x1, msg=\"hello\" Server: (process complete message immediately) Hi. Client: FIN=0, opcode=0x1, msg=\"and a\" Server: (listening, new message containing text started) Client: FIN=0, opcode=0x0, msg=\"happy new\" Server: (listening, payload concatenated to previous message) Client: FIN=1, opcode=0x0, msg=\"year!\" Server: (process complete message) Happy new year to you too! Notice the first frame contains an entire message (has and ), so the server can process or respond as it sees fit. The second frame sent by the client has a text payload ( ), but the entire message has not arrived yet ( ). All remaining parts of that message are sent with continuation frames ( ), and the final frame of the message is marked by . Section 5.4 of the spec describes message fragmentation.\n\nPings and Pongs: The Heartbeat of WebSockets At any point after the handshake, either the client or the server can choose to send a ping to the other party. When the ping is received, the recipient must send back a pong as soon as possible. You can use this to make sure that the client is still connected, for example. A ping or pong is just a regular frame, but it's a control frame. Pings have an opcode of , and pongs have an opcode of . When you get a ping, send back a pong with the exact same Payload Data as the ping (for pings and pongs, the max payload length is 125). You might also get a pong without ever sending a ping; ignore this if it happens. Note: If you have gotten more than one ping before you get the chance to send a pong, you only send one pong.\n\nThink of a subprotocol as a custom XML schema or doctype declaration. You're still using XML and its syntax, but you're additionally restricted by a structure you agreed on. WebSocket subprotocols are just like that. They do not introduce anything fancy, they just establish structure. Like a doctype or schema, both parties must agree on the subprotocol; unlike a doctype or schema, the subprotocol is implemented on the server and cannot be externally referred to by the client. Note: Subprotocols are explained in sections 1.9, 4.2, 11.3.4, and 11.5 of the spec. A client has to ask for a specific subprotocol. To do so, it will send something like this as part of the original handshake: Now the server must pick one of the protocols that the client suggested and it supports. If there is more than one, send the first one the client sent. Imagine our server can use both and . Then, in the response handshake, it sends: Warning: The server can't send more than one header. If the server doesn't want to use any subprotocol, it shouldn't send any header. Sending a blank header is incorrect. The client may close the connection if it doesn't get the subprotocol it wants. If you want your server to obey certain subprotocols, then naturally you'll need extra code on the server. Let's imagine we're using a subprotocol . In this subprotocol, all data is passed as JSON. If the client solicits this protocol and the server wants to use it, the server needs to have a JSON parser. Practically speaking, this will be part of a library, but the server needs to pass the data around. Note: To avoid name conflict, it's recommended to make your subprotocol name part of a domain string. If you are building a custom chat app that uses a proprietary format exclusive to Example Inc., then you might use this: . Note that this isn't required, it's just an optional convention, and you can use any string you wish."
    },
    {
        "link": "https://geeksforgeeks.org/how-to-create-a-websocket-connection-in-javascript",
        "document": "How to Create a WebSocket Connection in JavaScript ?\n\nWebSocket is a powerful communication protocol enabling real-time data exchange between clients and servers. In this guide, we'll explore how to establish a WebSocket connection using JavaScript. Below are the steps outlined for implementation:\n\n\"To establish a WebSocket connection in JavaScript, we need to configure a WebSocket server on the backend and WebSocket clients on the front end. The server listens for incoming WebSocket connections, while the client initiates a WebSocket handshake and communicates with the server using JavaScript's WebSocket API.\n\nFor the backend, we'll use Node.js and the ws library to create a WebSocket server. The ws library facilitates WebSocket connection management, message handling, and broadcasting to connected clients.\n\nOn the front end, we'll instantiate a WebSocket object using the WebSocket constructor. We'll utilize the onopen, onmessage, and onclose events to manage various operations, and employ the send() method to transmit messages to the server.\"\n\nStep 1: Create a NodeJS application using the following command:\n\nThe updated dependencies in package.json file will look like:\n\nExample: The Below example is demonstrating the use of WebSocket.\n\nWebSocket Client WebSocket Example Send Message to Server: Send // and connect to the server // Alert the user that they are 'You are Connected to WebSocket Server' // is received from the server // Event listener for when the\n\nTo launch the application, execute the following command in your terminal:\n\nThen, open the `index.html` file in your web browser.\""
    },
    {
        "link": "https://medium.com/@edhalliwell/chat-app-driven-by-websockets-using-socket-io-and-typescript-ed49611d6077",
        "document": "How to use WebSockets and Socket.IO to build a chat application in Typescript and React\n\nIn my last article, I got some experience with WebSockets, building a simple chat app using the library. This time I wanted to go deeper and spend a bit more time expanding my knowledge and practical experience with WebSockets.\n\nAt the end of that project, I identified a few areas that I wanted to cover next time, so my goals this time were to:\nâ€¢ Build a more complex chat app with users and rooms\nâ€¢ Use instead of\n\nAll the code can be found on GitHub so letâ€™s dive in.\n\nBefore I could get going with Socket.IO and implementing WebSockets, I needed to build out a much more extensive CRUD application. As in the previous project, I used the library for my PostgreSQL database and to create my API.\n\nI made 4 tables â€” , , and . A user can create (own) multiple rooms, and can join multiple rooms (that they donâ€™t necessarily own). A room can have many messages, and each message is created by a user. Joining a room will insert a row in the table and leaving that room will remove the row.\n\nI made routes for users to create themselves (register) and login. The passwords are encrypted using and stored as hashed values. I manage the user tokens using - signing the tokens on login and verifying them where necessary. Itâ€™s probably not the most secure but itâ€™s sufficient for the project - I may look at security and password management in a future project ðŸ¤”.\n\nThe routes for creating rooms and messages and joining or leaving rooms are all protected by auth middleware in express. The auth middleware grabs the token from the headers and checks that it is valid â€” if not, itâ€™ll bounce the user out to the login page.\n\nThe front end uses React and some custom styled components â€” in retrospect, it may have been easier to use a design library like chakra, radix or tailwind.\n\nItâ€™s all in a monorepo using yarn workspaces â€” I started using this pattern with my last WebSockets project and I love it. For a small, full stack app like this, it is great to be able to run both the server and client at the same time with one command and move between the package folders without having to change windows.\n\nThis time, I found that I had types that I wanted to use in both the front and back end â€” like and . Instead of duplicating them in the client and server, I pulled them into a package so that they could be accessed from both and so I only had to maintain one set of types.\n\nThe trickiest part in the front end was getting the authenticated context right. I havenâ€™t built this from scratch in a while and it took longer than it should have to get this working properly ðŸ˜«\n\nI started (as ever) with the documentation which has a very handy tutorial for beginners and getting set up was pretty straight forward. Similar to the previous project with , the server will broadcast a new chat message to all connected clients.\n\nWhat is different, or more complicated, this time is that there is a separate socket â€˜channelâ€™ for each chat room. Without this filtering, the broadcasted message will go to every client whichever room they are in â€” a big problem for a chat app!\n\nLast time, I had the client send each message to the server over the WebSocket. Then the server would store the message and then broadcast out to the connected clients.\n\nI learned afterwards that this was a slightly strange approach and a more conventional one would be to have the client send a message via a simple POST call and then have the server save the message and distribute it to connected clients via WebSockets.\n\nThe server uses the package which is imported into my file in the package.\n\nThe express is passed into a method imported from the package, and then that server is passed into the call imported from the package:\n\nIâ€™ll build up the the WebSocket functionality as we go through the article. Initially, we just listen for the default and events:\n\nThe server makes a event on creation of each message. This is done from inside the create message handler, just after the message is successfully added to the database.\n\nThe emit event uses the method to scope the broadcast to only clients connected to the correct room ID. Then, the emit method sends the event name and the message object. Note that thereâ€™s no need to the message (and then parse it on the client) as Socket.IO is able to handle sending the full object.\n\nWeâ€™ll listen for the event called on the front end so we can capture messages sent via the WebSocket and display them to the user.\n\nFirstly, itâ€™s a case of adding this code to my file:\n\nNext, in the Room component, we can setup the listener for the events coming from the server:\n\nThe is imported from the file then, on an event with the name , the new message is spread into the messages state (which is shown in a list to the user).\n\nOne of the key things to get right with this project was separating the messages by room so that users receive the correct messages via the WebSocket for the room they are in.\n\nTo achieve this, it was necessary to have a user â€˜joinâ€™ and â€˜leaveâ€™ a room and thus subscribe / unsubscribe to a particular â€˜roomâ€™ (Socket.IO also call them â€˜roomsâ€™).\n\nIn the client, we fire a event from the â€˜createâ€™ and â€˜joinâ€™ handler functions and a event from the â€˜leaveâ€™ room handler function.\n\nThen on the server side, I added event listeners for those join and leave events and call the join and leave methods on the socket, passing in the room ID (which we used in the method on broadcasting the chat messages above):\n\nOne of the things I wanted to add to this project compared to the previous one was some kind of message confirmation - as well as retry logic when message sending fails. This functionality needed to be built out manually in but Socket.IO has some of this functionality built in.\n\nWe can also implement retries for the messages that are sent â€” both from server to client and from client to server.\n\nSocket.IO events can have an optional callback added that will fire when the message is received on the other side. The below diagram shows that for events sent from the client (like joining or leaving a room), we can get a confirmation from the server. And for events sent from the server (like chat messages), we can get a confirmation from the client on receipt.\n\nFor the join and leave room events, we can make a couple of changes to add in the logic. On the client side in , we can add (the time between retries) and the number of retries to the config on instantiation.\n\nYou donâ€™t have to use the built in retries, and itâ€™s possible to build out your own logic as shown in the tutorial documentation.\n\nOn the server side in , we need to add in callback functions and return something to the front end - Iâ€™ve chosen to send status message here but it could be anything.\n\nFor sending events from the server, it was necessary to create the retry logically manually with this function:\n\nThen I replaced the old emit event with a call to the new function:\n\nFinally, we need to look for that acknowledgement function on the front end and send back a response after weâ€™ve received the message:\n\nSocket.IO has useful built-in state recovery tooling which temporarily stores all the events that are sent by the server and will try to restore the state of a client when it reconnects â€” restoring its rooms and sending any missed events. Itâ€™s enabled on the server side in the config:\n\nItâ€™s not enabled by default as it doesnâ€™t always work (e.g. the client state might not be saved in the case of an abrupt crash or restart) and it does not scale well.\n\nSocket.IOâ€™s tutorial goes through the steps to synchronise the state of the client upon reconnection by having the client keep track of the last event it has processed and the server sends the missing pieces (another option is for the server to send the whole state).\n\nHowever, in my project, the room component will fetch all the messages when the page is loaded, so there was no need to send through all the messages via the WebSocket.\n\nThis project took much longer than the previous one but I found working with Socket.IO much easier. Their library is much more extensive and the documentation is pretty easy to follow, with a few more handy built in capabilities.\n\nAs always, there is always more that could have doneâ€¦ Socket.IOâ€™s tutorial has documentation on horizontal scaling to handle sending messages to clients connected across multiple servers. Also, itâ€™s all hard coded to localhost at the moment and will only work locally, so Iâ€™d love to look into deploying the code too."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_client_applications",
        "document": "In order to communicate using the WebSocket protocol, you need to create a object; this will automatically attempt to open the connection to the server. The WebSocket constructor accepts one required and one optional parameter: The URL to which to connect; this should be the URL to which the WebSocket server will respond. This should use the URL scheme , although some software may allow you to use the insecure for a local connection. Relative URL values and and schemes are also allowed in most recent browser versions. Either a single protocol string or an array of protocol strings. These strings are used to indicate sub-protocols, so that a single server can implement multiple WebSocket sub-protocols (for example, you might want one server to be able to handle different types of interactions depending on the specified ). If you don't specify a protocol string, an empty string is assumed. The constructor will throw a if the destination doesn't allow access. This may happen if you attempt to use an insecure connection (most user agents now require a secure link for all WebSocket connections unless they're on the same device or possibly on the same network).\n\nIf an error occurs while attempting to connect, an event is first sent to the object (thereby invoking any handlers), followed by a event that indicates the reason for the connection's closing. The browser may also output to its console a more descriptive error message as well as a closing code as defined in RFC 6455, Section 7.4 through the .\n\nThis simple example creates a new WebSocket, connecting to the server at . A custom protocol of \"protocolOne\" is named in the request for the socket in this example, though this can be omitted. On return, is . The will become once the connection is ready to transfer data. If you want to open a connection and are flexible about the protocols you support, you can specify an array of protocols: Once the connection is established (that is, is ), will tell you which protocol the server selected. Establishing a WebSocket relies on the HTTP Upgrade mechanism, so the request for the protocol upgrade is implicit when we address the web server as or .\n\nOnce you've opened your connection, you can begin transmitting data to the server. To do this, call the object's method for each message you want to send: exampleSocket.send(\"Here's some text that the server is urgently awaiting!\"); You can send data as a string, , or . As establishing a connection is asynchronous and prone to failure there is no guarantee that calling the method immediately after creating a WebSocket object will be successful. We can at least be sure that attempting to send data only takes place once a connection is established by defining an event handler to do the work: exampleSocket.onopen = (event) => { exampleSocket.send(\"Here's some text that the server is urgently awaiting!\"); };\n\nLet's consider the chat client application first alluded to in Using JSON to transmit objects. There are assorted types of data packets the client might receive, such as: The code that interprets these incoming messages might look like this: exampleSocket.onmessage = (event) => { const f = document.getElementById(\"chat-box\").contentDocument; let text = \"\"; const msg = JSON.parse(event.data); const time = new Date(msg.date); const timeStr = time.toLocaleTimeString(); switch (msg.type) { case \"id\": clientID = msg.id; setUsername(); break; case \"username\": text = `User <em>${msg.name}</em> signed in at ${timeStr}<br>`; break; case \"message\": text = `(${timeStr}) ${msg.name} : ${msg.text} <br>`; break; case \"reject-username\": text = `Your username has been set to <em>${msg.name}</em> because the name you chose is in use.<br>`; break; case \"user-list\": document.getElementById(\"user-list-box\").innerText = msg.users.join(\"\n\n\"); break; } if (text.length) { f.write(text); document.getElementById(\"chat-box\").contentWindow.scrollByPages(1); } }; Here we use to convert the JSON object back into the original object, then examine and act upon its contents."
    },
    {
        "link": "https://stackoverflow.com/questions/32816618/websocket-best-practice-for-groups-chat-one-websocket-for-all-groups-or-one-we",
        "document": "I have to implement a chat application using websocket, users will chat via groups, there can be thousands of groups and a user can be in multiple groups. I'm thinking about 2 solutions:\n\n[1] for each group chat, I create a websocket endpoint (using camel-atmosphere-websocket), users in the same group can subscribe to the group endpoint and send/receive message over that endpoint. it means there can be thousands of websocket endpoints. Client side (let's say iPhone) has to subscribes to multiple wbesocket endpoints. is this a good practice?\n\n[2] I just create one websocket endpoint for all groups. Client side just subscribes to this endpoint and I manage the messages distribution myself on server: get group members, pick the websocket of each member from list of connected websockets then write the message to each member via websocket.\n\nWhich solution is better in term of performance and easy to implement on both client and server?\n\nI chose the second approach and did a test with jetty websocket client, I use camel atmosphere websocket on server side. On client side, I create websocket connections to server in threads. There was a problem with jetty that I can just create around 160 websocket connections (it means around 160 threads). The result is that I almost see no difference when the number of clients increases from 1 to 160.\n\nYes, 160 is not a big number, but I think I will do more test when I actually see the performance problem, for now, I'm ok with second approach.\n\nIf you are interested in the test code, here it is: http://www.eclipse.org/jetty/documentation/current/jetty-websocket-client-api.html#d0e22545"
    },
    {
        "link": "https://medium.com/@dragonblade9x/making-a-multiplayer-web-game-with-websocket-that-can-be-scalable-to-millions-of-users-923cc8bd4d3b",
        "document": "First of all, we need a service to store temporary game states, with every move we make, the game state will change and using redis as a pubsub service as well as game state storage is just perfect. Redis is extremely fast in both read and write speed, sometimes it can be as fast as millions of requests per second. Granted that the data will not be persistent in redis but for a web game, the game state is just temporary information, we donâ€™t have to store it permanently.\n\nExecution: When the game is created, the server will create the game_state and store it in the game_id key in redis. This game state will be used when handling game logic after the player makes a move, then update it accordingly. Since this is a web game, there are a lot of reads and writes happening every move, so redis is perfect for this, also since this is a turn base web game (ban/pick) there shouldnâ€™t be too much move to worry about redis failing since it likely not reach redis limit.\n\nHere is the GitHub link to the websocket server code: https://github.com/emilebui/GBP_BE_WS\n\nIâ€™m using Go for this project, Go is fast and with goroutines, you can easily handle the websocket connection and redis pubsub connection simultaneously.\n\nThis is the hard part as I have little experience in front-end. Luckily for me, there is a project that I can use to build upon, which is: https://github.com/Pustur/genshin-impact-team-randomizer\n\nThis web app is somewhat similar to what I want to do so I only have to modify it a bit. It was built using SolidJs â€” a very interesting front-end framework that I wanted to try. However, it is currently a SPA (Single Page Application) so I donâ€™t want that. I modified the project using Solid-Start (meta-framework) instead for faster initial load time. After adding the websocket, adding game logic, and changing the UI here and there then Voila, I have finished creating the front-end: https://github.com/emilebui/GPB_FE_SolidJS\n\nThe experience I have with Solid is great, I used to have some experience with React and Angular and it was not fun (probably the reason why Iâ€™m a backend engineer). However, with Solid, it was different, especially with state management, Solid nailed it! I couldnâ€™t have done it without Solid. I recommend everyone to try it out: https://www.solidjs.com/\n\nHere is the overall architecture\nâ€¢ FE: Solid-Start server to render html and js for client\n\nEvery component here can be scalable, even the websocket server which can be scaled up to millions of instance to be able to serve billions of users (if there is enough resource)\n\nHere is the deployment project using Kubernetes: https://github.com/emilebui/GBP_Deploy\n\nNow that the development part is done, there is still a long way to make this game a finished product. I need to find someplace to host it, buy a domain, creating SSL, â€¦ There are a lot of processes I had been missing out as I said earlier. Luckily, I got everything sorted out.\n\nAs scalable as this architecture may seem, it is somewhat sad that I can only deploy this entire project on AWS free-tier account with t2.micro EC2 instance. However, I wonâ€™t ever regret making it scalable. Itâ€™s been fun working on this game. The deployment was very smooth and easy since I dockerized everything, I just run one command and it just works. Remember, always docker your app. It makes the deployment way easier.\n\nThere is a trick so you can get cheap domains, most of the domain shops offer very cheaply for the first year but an enormous amount in the following year. What you can do is buy the 1st year from a domain store, and after the first year, go to the next store and do the same so you can get a very cheap price.\n\nWell, I have to thank Cloudflare for providing SSL for free. You only need to register, no credit card is required. The only problem I have when using Cloudflare is that the Minify JS feature broke my game, so I had to turn it off. Other than that, it was perfect, everything is secured, even the websocket connection.\n\nHere is the link to my web game, go check it out: https://genshinbanpick.top/\n\nThank you so much for reading my blog, I hope this little document can be somewhat helpful to you."
    },
    {
        "link": "https://deadsimplechat.com/blog/websockets-and-nodejs-real-time-chat-app",
        "document": "Websockets are a communication protocol that provides a full-duplex communication channels over a single, long-held TCP connection.\n\nUsing web sockets you can create a persistent, two way interaction between a client and a server.\n\nIn this article we are going to learn the following, you can click on a click to move to that particular section of the article\nâ€¢ Why NodeJs is the recommended platform for using WebSockets?\nâ€¢ Step by Step Tutorial Building a real time Chat App with WebSockets and Node JS\nâ€¢ Step 5: Creating the UI of the Chat App\nâ€¢ Step 6: Implementing the websocket on the client side\n\nas explained above, Websockets are a communication protocol that provides a full-duplex communication channels over a single, long-held TCP connection.\n\nHere is how the websockets work\n\nTo establish a websocket connection, a handshake between the client and server happens.\n\nThis handshake is initiated by the client and includes a special kind of HTTP header called and ' Upgrade' header\n\nWhich signifies that client wants to establish a websocket connection\n\nIf the server supports the websocket connection then it replies with 'Upgrade' header in its response which signifies and confirms that the connection is swiched from HTTP to websocket\n\nOnce the handshake is complete the connection is swicthed from HTTP to websocket connection.\n\nwhich is a persistent two way communication channel where each party in the connection that is the client as well as the server can send data to each other any time\n\nHTTP is a stateless protocol, what it means is that it operates in a request response model\n\nEach request from the client requires a seprate HTTP request and the server responses to that request and the connection is closed\n\nfor example: client request data to load a page, server response with the data and the connection is closed\n\nIn HTTP the connection is unidirectional, client sends a request and the server recieves the request then responses to that request. This makes it less efficent in use cases where there is need for contineous exchange of data\n\nEach HTTP request contains headers and other meta data which makes a HTTP request heavy as compared to a websocket connection\n\nWebsockets allow for full duplex communication, which means that the data can go through any direction that allows for real time interaction\n\nWebsockets do not contain additional meta data like HTTP headers which reduces data overload and improves performance especially over slow networks and allows for smooth flow of data\n\nUnlike HTTP, the websocket protocol is stateful, which means the server and client knows that they are connected to each other and the connection remains open until it is closed\n\nHere are some of the real world applications and advantages of WebSockets.\nâ€¢ Chat Application: Real time chat app can be easily created using websockets\nâ€¢ Gaming: Online gaming where fast bi directional data transfer is required to play games. Especially fast paced games\nâ€¢ Financial trading platforms: Financial trading platforms where real time fast data transfers is required such as stock prices and fat execution of trades\nâ€¢ Live Sports Updates: Sporting events are good and drives real time data transfer is neessory for the viewer to be engaged in sports\nâ€¢ Collaboration Tools: Real time collaboration tools such as whiteboard and document sharing require websockets to function\nâ€¢ Notification Services: Instant notification and alerts can be made using websockets\n\nWhat is Node Js and why NodeJs is the recommended platform for using WebSockets?\n\nNode JS is an open source cross platform JavaScript runtime environment, using which you can run JavaScript on the server side.\n\nNode JS is built on the V8 runtime environment of Chrome that allows developers to use JavaScript outiside the browser\nâ€¢ JavaScript everywhere: NodeJS extends javascript to the server as well. Before javascript was only used inside the browser\nâ€¢ Event-Driven architecture: Node JS has an event driven architecture and non blocking I/O based model that makes it lightweight for your applications\nâ€¢ NPM Node Version Manager: Node Js comes with an enourmous library of packages that are managed through NPM. NPM makes it easy to incorporate various tools and packages into your application\nâ€¢ Async and Non Blocking: Node JS is Async and non blocking by nature, which means it can continue to process other requests while waiting for the completion of tasks like reading a file etc\nâ€¢ Scalable: Node Js has a lightweight arhitecture and can scale to thousands of connections\n\nWhy Node Js is preferred to be used with WebSockets\n\nIn this section we are going to build a real time chat application in a step by step format\nâ€¢ Creating the server with NodeJs and WebSockets\n\nCreate a new project directory in your machine and and name it and into it like so\n\nthen initalize the node js project with to create a file\n\nnext step is to install the dependencies for our project. We will be needing the express js and the websocket library to set up the server for our real time chat application\n\nCreate a file in your project then write the below code to setup an express js server\n\nThis is a simple express js server which listens on the and returns the of the endpoint\n\nnext step is to add the library to the file and setup the websocket server running independently on some other port\n\nAdd the below code to the index.js file:\n\nWhat are we doing in this code\nâ€¢ We are importing the websocket library\nâ€¢ we are running the websocket server on . This server is running independently of the HTTP expressjs server which means that it does not share the same port or connection as the HTTP server\nâ€¢ We are handling the websocket connections\n\nhere we are listning for new websocket connections. When a client connects to the server via websockets the callback method is triggered\n\nthe parameter here represents the connected websocket client.\n\n4. Then inside the callback function we are setting up another listener that listens to any messages that the client is sending to the server. Whenever a message is recieved we are logging that message to the console for now. Later we can send this message back to the client or do whatever we want to do with the message\n\n5. Lastly, we are sending a sample message back to the client.\n\nNow that we have created our simple express js and websocket servers. We can test them.\n\nIt is quite easy to test these servers, we are going to use third party tools such as Postman to do this.\n\npaste the localhost:300 and send a GET request to the expressjs server and you will get a response\n\nto create a websocket request on the postman sidebar click new and then click on websocket\n\nthen paste the websocket server url and create a connection\n\nclick on the connect button to connect to the websocket server and type a message in the message section and click on the send button to send the message\n\nYou can see the connection established in the postman response section also the message that was sent from the websocket server.\n\nAlso, you can see the message logged to the server on the server console log\n\nHere is how the complete back-end code looks like\n\nNow we have created a simple server and tested the basic functionality. Our server doesn't do much except send a basic message back to the client.\n\nWe want the server to take the messages from a single client and send it back again to the sender client.\n\nLet us edit the server code to add that functionality.\n\nWhat are we doing here\nâ€¢ we have edited the express code to send files from the public directory. We are going to build the front-end of our chat app and send the html and js files for the front end from the public directory\nâ€¢ In the websocket we are sending the message that we are recieving back to the client\nâ€¢ We can also broadcast the message to all the client connected to the websocket server. We are going to do this later on in the article as a bonus content\n\nNext we are going to be building the front end of our real time chat application.\n\nIn the root folder of your application create a new directory called the directory\n\nthere create two new files\nâ€¢ : Here we will write the UI of the chat app\nâ€¢ : Here we will write the front end logic of the chat app\n\nStep 5 : Create the UI of the chat app\n\nOpen the file and paste the following code in it.\n\nthis is basically creating a chat interface and styling it with tailwind css. You can open the file in the browser and it looks something like this\n\nNext we are going to create a javascript file and name it on the client side\n\nThis file handles the connection on the client side, receiving messages and sending messages clearing the message box updating the HTML interface.\n\nIf you go to the Localhost://3000 you can see the chat interface and if you send the message you can see it in the chat box\n\nNeed JavaScript Chat API for your website or app\nâ€¢ Add Scalable Chat to your app in minutes\n\nBonus: Sending chat message to all the connected clients\n\nIn this section we are going to change the server code to send the message to all the connected clients instead of just the sender.\n\nfor this first we need to create an arry to store all the clients that are currently connected to the websocket server\n\nthen edit the websocket code to\nâ€¢ add a client to the array whenever a new client is connected\nâ€¢ Broadcast the message to all the connected clients\nâ€¢ when the connection closes remove the client from the clients Array\n\nhere is how the complete server code looks like:\nâ€¢ Global Geo-Location targeting: Automatically directs traffic to the nearest servers, for lowest possible latency and highest quality performance. less than 50 ms latency anywhere around the world\nâ€¢ Servers in 12 Regions of the world: Toronto, Miami, San Francisco, Amsterdam, London, Frankfurt, Bangalore, Singapore,Sydney (Coming Soon: South Korea, Japan and Oman)\nâ€¢ Low Latency: less than 50 ms latency, anywhere across the world.\nâ€¢ Cost-Effective: pay-as-you-go pricing with bandwidth and volume discounts available.\nâ€¢ Easy Administration: Get usage logs, emails when accounts reach threshold limits, billing records and email and phone support.\nâ€¢ Standards Compliant: Conforms to RFCs 5389, 5769, 5780, 5766, 6062, 6156, 5245, 5768, 6336, 6544, 5928 over UDP, TCP, TLS, and DTLS.\nâ€¢ Multiâ€‘Tenancy: Create multiple credentials and separate the usage by customer, or different apps. Get Usage logs, billing records and threshold alerts.\nâ€¢ Enterprise Scale: With no limit on concurrent traffic or total traffic. Metered TURN Servers provide Enterprise Scalability\nâ€¢ 50 GB/mo Free: Get 50 GB every month free TURN server usage with the Free Plan\nâ€¢ Support TURNS + SSL to allow connections through deep packet inspection firewalls."
    }
]