[
    {
        "link": "https://docs.python.org/3/library/asyncio-eventloop.html",
        "document": "The event loop is the core of every asyncio application. Event loops run asynchronous tasks and callbacks, perform network IO operations, and run subprocesses.\n\nApplication developers should typically use the high-level asyncio functions, such as , and should rarely need to reference the loop object or call its methods. This section is intended mostly for authors of lower-level code, libraries, and frameworks, who need finer control over the event loop behavior.\n\nThe following low-level functions can be used to get, set, or create an event loop:\n\nNote that the behaviour of , , and functions can be altered by setting a custom event loop policy.\n\nThis documentation page contains the following sections:\n‚Ä¢ None The Event Loop Methods section is the reference documentation of the event loop APIs;\n‚Ä¢ None The Callback Handles section documents the and instances which are returned from scheduling methods such as and ;\n‚Ä¢ None The Server Objects section documents types returned from event loop methods like ;\n‚Ä¢ None The Event Loop Implementations section documents the and classes;\n‚Ä¢ None The Examples section showcases how to work with some event loop APIs.\n\nServer objects are created by , , , and functions. Do not instantiate the class directly. Server objects are asynchronous context managers. When used in an statement, it‚Äôs guaranteed that the Server object is closed and not accepting new connections when the statement is completed: # At this point, srv is closed and no longer accepts new connections. Changed in version 3.7: Server object is an asynchronous context manager since Python 3.7. Changed in version 3.11: This class was exposed publicly as in Python 3.9.11, 3.10.3 and 3.11. Stop serving: close listening sockets and set the attribute to . The sockets that represent existing incoming client connections are left open. The server is closed asynchronously; use the coroutine to wait until the server is closed (and no more connections are active). Calls on all associated transports. should be called before when closing the server to avoid races with new clients connecting. Close all existing incoming client connections immediately, without waiting for pending operations to complete. Calls on all associated transports. should be called before when closing the server to avoid races with new clients connecting. Return the event loop associated with the server object. This method is idempotent, so it can be called when the server is already serving. The start_serving keyword-only parameter to and allows creating a Server object that is not accepting connections initially. In this case , or can be used to make the Server start accepting connections. Start accepting connections until the coroutine is cancelled. Cancellation of task causes the server to be closed. This method can be called if the server is already accepting connections. Only one task can exist per one Server object. # Communicate with the client with Return if the server is accepting new connections. Wait until the method completes and all active connections have finished. List of socket-like objects, , which the server is listening on. Changed in version 3.7: Prior to Python 3.7 used to return an internal list of server sockets directly. In 3.7 a copy of that list is returned.\n\nNote that all examples in this section purposefully show how to use the low-level event loop APIs, such as and . Modern asyncio applications rarely need to be written this way; consider using the high-level functions like . An example using the method to schedule a callback. The callback displays and then stops the event loop: \"\"\"A callback to print 'Hello World' and stop the event loop\"\"\" A similar Hello World example created with a coroutine and the function. Wait until a file descriptor received some data using the method and then close the event loop: # We are done: unregister the file descriptor # Simulate the reception of data from the network # We are done. Close sockets and the event loop.\n‚Ä¢ None A similar example using transports, protocols, and the method.\n‚Ä¢ None Another similar example using the high-level function and streams. Register handlers for signals and using the method:"
    },
    {
        "link": "https://stackoverflow.com/questions/51642267/asyncio-how-do-you-use-run-forever",
        "document": "There are two possible approaches: you can run the event loop in the main thread or in a background thread. If you run it in the main thread, you need to (or or equivalent) as the very last step of the program initialization. In that case the main thread will \"block\", but that's ok because its event loop will be live and respond to outside events, allowing the program to function. A single \"blocking\" call to the event loop that dispatches coroutines and callbacks is how asyncio is designed to be run.\n\nIn cases where this is impractical, such as programs that contain a large body of synchronous code, or those that already communicate between several threads, it is often a better idea to create a dedicated thread and run the event loop in it. In that case you must be very careful not to communicate with the event loop other than with calls to and . For example, must be invoked using because it interacts with the tasks and the event loop. This applies to all interactions with the event loop - for example, calling from another thread is not allowed, it must be spelled as . Of course, calling loop functions from asyncio callbacks and coroutines is fine because those will always be run in the same thread the event loop runs in."
    },
    {
        "link": "https://tutorialedge.net/python/concurrency/asyncio-event-loops-tutorial",
        "document": "In this tutorial we are going to be covering Asyncio‚Äôs event loop. Some of the material for this tutorial was taken from my book: Learning Concurrency in Python.\n\nThe main component of any asyncio based Python program has to be the underlying event loop. Within this event loop we can (from the official documentation):\n‚Ä¢ Launch subprocesses and the associated transports for communication with an external program\n\nEssentially all an event loop does is wait for events to happen before matching each event to a function that we have explicitly matched with said type of event.\n\nA good example of this would be a simple web server, say we have an endpoint on our server that serves our website which features a multitude of different pages. Our event loop essentially listens for requests to be made and then matches each of these requests to its associated webpage.\n\nEach of the requests made to our web server in the above example would be considered a separate . These events are then matched to a set function that we have predefined whenever a said event is triggered.\n\nLet‚Äôs take a quick look at how you can define a very simple event loop. In order to instantiate an event loop we‚Äôll use , we‚Äôll then start a and within the body of our we‚Äôll specify that we want our newly instantiated event loop to run until it has completed our function.\n\nWe have a number of options for running our event loops, we can either call which will subsequently run our event loop until the function is called, or we can call and only run our event loop until whatever object we‚Äôve passed in has completed it‚Äôs execution.\n\nLet‚Äôs take a quick look at the function. In this example we‚Äôll define our coroutine which we will then pass into our function and subsequently we should see our event loop run until this coroutine is finished it‚Äôs execution.\n\nUpon running this you should then see the following output:\n\nThe alternative way of starting up your event loop is to call the method which will subsequently start your asyncio based event loop and have it run indefinitely until the program comes to an end or the method is called. It should be noted that calling this causes our main thread to block indefinitely.\n\nLet‚Äôs take a look at a quick example which showcases the use of this method. We‚Äôll first define our coroutine which will feature a while loop that will run indefinitely and simply print out in 1 second intervals.\n\nIf you wanted to run multiple coroutines indefinitely in parallel then you can do that by creating your number of coroutines and have them run a while loop each. You would then call in order to enqueue them onto the loop and they would run indefinitely after that point.\n\nThis should output the following indefinitely:\n\nIf you found this tutorial useful or you require more assistance then please feel free to leave a comment in the comments section below!"
    },
    {
        "link": "https://stackoverflow.com/questions/40143289/why-do-most-asyncio-examples-use-loop-run-until-complete",
        "document": "is used to run a future until it's finished. It will block the execution of code following it. It does, however, cause the event loop to run. Any futures that have been scheduled will run until the future passed to is done.\n\nGiven this example:\n\nwill run. After it's complete, will run. Your output will be:\n\nIf you schedule with the event loop before running , control will switch from to when the former awaits.\n\nThis will get you the output of:\n\nThis is because was scheduled before . There are a lot of different ways to get the same output, but which one makes sense really depends on what your application actually does. So I'll leave that as an exercise to the reader."
    },
    {
        "link": "https://bbc.github.io/cloudfit-public-docs/asyncio/asyncio-part-2.html",
        "document": "Having already covered the basic concepts in Python Asyncio Part 1 ‚Äì Basic Concepts and Patterns, in this part of the series I will be going into more depth on the actual syntax used when employing this library in Python code. Many of the examples used here are based on code we have actually used as part of BBC R&D‚Äôs cloudfit project.\n\nThe most basic tool in the tool kit of an asynchronous programmer in Python is the new keyword , which is used to declare an asynchronous coroutine function in the same way that is used to define a normal synchronous function.\n\nSo for example:\n\nIn the above example we define a coroutine function and an ordinary function . The code block that forms the body of the definition is slightly different in the two cases. The code block for is ordinary synchronous Python, whilst the code-block for is asynchronous Python.\n\nA declaration of a coroutine function using looks deceptively similar to the declaration of an ordinary function using . Most of the time writing one is pretty similar, however there are some key differences, which are very important for asynchronous programming:\n‚Ä¢ The Python keyword creates a callable object with a name, when the object is called the code block of the function is run. Eg. means that is now a callable object which takes three parameters. When you invoke it like so: this causes the function code to be run immediately as a subroutine call, and its return value to be assigned to .\n‚Ä¢ The Python keyword creates a callable object with a name, when the object is called the code block of the function is not run. Eg. means that is now a callable object which takes three parameters. When you invoke it like so: this does not cause the function code block to be run. Instead an object of class is created, and is assigned to . To make the code block actually run you need to make use of one of the facilities that asyncio provides for running a coroutine. Most commonly this is the keyword. The function is used in an example below. Other examples can be found in the python docs. See for example .\n\nOne of the new keywords added to the language to support asyncio is . This keyword is, in many ways, the very core of asynchronous code. It can only be used inside asynchronous code blocks (ie. in the code block of an statement defining a coroutine function), and it is used as an expression which takes a single parameter and returns a value.\n\nis a valid Python statement which will perform the action on the object and return a value which will be assigned to . Exactly what will happen when this statement is executed will depend upon what the object is.\n\nA coroutine object is ‚Äúawaitable‚Äù (it can be used in an statement). Recall that when you are executing asynchronous code you are always doing so in the context of a ‚ÄúTask‚Äù, which is an object maintained by the Event Loop, and that each Task has its own call stack. The first time a Coroutine object is awaited the code block inside its definition is executed in the current Task, with its new code context added to the top of the call stack for this Task, just like a normal function call. When the code block reaches its end (or otherwise returns) then execution moves back to the await statement that called it. The return value of the statement is the value returned by the code block. If a Coroutine object is awaited a second time this raises an exception. In this way you can think of awaiting a Coroutine object as being very much like calling a function, with the notable difference that the Coroutine object‚Äôs code block can contain asynchronous code, and so can pause the current task during running, which a function‚Äôs code block cannot.\n\nIn fact there are three types of objects that are awaitable:\n‚Ä¢ A Coroutine object. When awaited it will execute the code-block of the coroutine in the current Task. The statement will return the value returned by the code block.\n‚Ä¢ Any object of class which when awaited causes the current Task to be paused until a specific condition occurs (see next section).\n‚Ä¢ An object which implements the magic method , in which case what happens when it is awaited is defined by that method.\n\nThat last one is there so that writers of libraries can create their own new classes of objects which are awaitable and do something special when awaited. It‚Äôs usually a good idea to make your custom awaitable objects either behave like a Coroutine object or like a Future object, and document which in the class‚Äôs doc strings. Making custom awaitable classes like this is a somewhat more advanced topic, though one that may come up when writing asyncio wrappers for synchronous io libraries, for example.\n\nOne of the most important points to get across is that the currently executing Task cannot be paused by any means other than awaiting a future (or a custom awaitable object that behaves like one). And that is something which can only happen inside asynchronous code. So any statement might cause your current task to pause, but is not guaranteed to. Conversely any statement which is not an statement (or an or under certain circumstances which will be explained in the next post) cannot cause your current Task to be paused.\n\nThis means that the traditional multithreaded code problems of data races where different threads of execution both alter the same value are severely reduced in asynchronous code, but not entirely eliminated. In particular for the purposes of data shared between Tasks on the same event loop all synchronous code can be considered ‚Äúatomic‚Äù. To illustrate what this means consider the following code:\n\nthen even though both and access the global variable they do so in two tasks that are running in the same event loop. For this reason it is not possible for the print statement in to run unless is currently asleep waiting for io. This means that it is not possible for the length of to be printed whilst the loop is only part-way through running. So if the always returns 10 values at a time (for example) then the printed length of will always be a multiple of ten. It is simply not possible for the print statement to execute at a time when has a non-multiple of ten length.\n\nOn the other hand if there was an statement inside the loop this would no longer be guaranteed.\n\nA object is a type of awaitable. Unlike a coroutine object when a future is awaited it does not cause a block of code to be executed. Instead a future object can be thought of as representing some process that is ongoing elsewhere and which may or may not yet be finished.\n\nWhen you await a future the following happens:\n‚Ä¢ If the process the future represents has finished and returned a value then the await statement immediately returns that value.\n‚Ä¢ If the process the future represents has finished and raised an exception then the await statement immediately raises that exception.\n‚Ä¢ If the process the future represents has not yet finished then the current Task is paused until the process has finished. Once it is finished it behaves as described in the first two bullet points here.\n\nAll Future objects have the following synchronous interface in addition to being awaitable:\n‚Ä¢ returns if the process the future represents has finished.\n‚Ä¢ raises an exception if the process has not yet finished. If the process has finished it returns the exception it raised, or if it terminated without raising.\n‚Ä¢ raises an exception if the process has not yet finished. If the process has finished it raises the exception it raised, or returns the value it returned if it finished without raising.\n\nIt‚Äôs important to note that there is no way for a future that is done to ever change back into one that is not yet done. A future becoming done is a one-time occurrence.\n\nYou probably won‚Äôt create your own futures very often unless you are implementing new libraries that extend asyncio. However you will find that library functions often return futures. If you do need to create your own future directly you can do it with a call to\n\nOn the other hand you will probably find that you use a related method, quite often ‚Ä¶\n\nAs described in the previous article each event loop contains a number of tasks, and every coroutine that is executing is doing so inside a task. So the question of how to create a task seems like an important one.\n\nCreating a task is a simple matter, and can be done entirely in synchronous code:\n\nThe method takes a coroutine object as a parameter and returns a object, which inherits from . The call creates the task inside the event loop for the current thread, and starts the task executing at the beginning of the coroutine‚Äôs code-block. The returned future will be marked as only when the task has finished execution. As you might expect the return value of the coroutine‚Äôs code block is the which will be stored in the future object when it is finished (and if it raises then the exception will be caught and stored in the future).\n\nCreating a task to wrap a coroutine is a synchronous call, so it can be done anywhere, including inside synchronous or asynchronous code. If you do it in asynchronous code then the event loop is already running (since it is currently executing your asynchronous code), and when it next gets the opportunity (ie. next time your current task pauses) it might make the new task active.\n\nWhen you do it in synchronous code, however, chances are that the event loop is not yet running. Manualy manipulating event loops is discouranged by the python documentation. Unless you are developing libraries extending functionality, you should probably avoid trying to create a task from synchronous code.\n\nIf you do need to call a single piece of async code in an otherwise synchronous script, you can use .\n\nWith the introduction of in Python 3.7, and the removal of the parameter from many asyncio function in Python 3.10, managing event loops is something that you are unlikely to come across, unless you are developing an async library. The event loop objects are still there and accessible. There is a whole page in the docs discussing them. If you are working in Python 3.7 or greater, rejoice and give thanks for .\n\nwill run , and return the result. It will always start a new event loop, and it cannot be called when the event loop is already running. This leads to a couple of obvious ways to run your async code.\n\nThe first is to have everything in async coroutines, and have a very simple entry function:\n\nThe second is to wrap each coroutine call in a separate command. Note that this forgoes all of the benefits of asyncio. Still, there might be the odd script where this is the right thing to do.\n\nNote that these simple examples don‚Äôt make use of the ability of async code to work on multiple tasks concurrently. A more sensible example is given at the end. As you work with in python, you‚Äôll learn about more sophisticated ways to manage your work, but this is enough to get you started.\n\nIf you‚Äôre using Python 3.6, and you need to run coroutines from ordinary sync code (which you probably will, if you want to start something.) then you will need to start the event loop. There are two methods for doing this:\n\nwill cause the event loop to run forever (or until explicitly killed). This isn‚Äôt usually particularly useful. Much more useful is:\n\nwhich takes a single parameter. If the parameter is a future (such as a task) then the loop will be run until the future is done, returning its result or raising its exception. So putting it together:\n\nwill create a new task which executes inside the event loop until it finishes, and then return the result.\n\nIn fact this can be simplified further since if you pass a coroutine object as the parameter to then it automatically calls for you.\n\nThere is no simple command for yielding control to the event loop so that other tasks can run. In most cases in an asyncio program this is not something you will want to do explicitly, preferring to allow control to be yielded automatically when you await a future returned by some underlying library that handles some type of IO.\n\nHowever occasionally you do need to, and in particular it‚Äôs quite useful during testing and debugging. As a result there is a recognised idiom for doing this if you need to. The statement:\n\nwill pause the current task and allow other tasks to be executed. The way this works is by using the function which is provided by the library. This function takes a single parameter which is a number of seconds, and returns a future which is not marked done yet but which will be when the specified number of seconds have passed.\n\nSpecifying a count of zero seconds works to interrupt the current task if other tasks are pending, but otherwise doesn‚Äôt do anything since the sleep time is zero.\n\nThe implementation of in the standard library has been optimised to make this an efficient operation.\n\nWhen using with a non-zero parameter it‚Äôs worth noting that just because the future will become done when the number of seconds has passed does not mean that your task will always wake back up at that time. In fact it may wake back up at any point after that time, since it can only awaken when there‚Äôs no other task being run on the event loop.\n‚Ä¢ You can only use the keywords , and inside asynchronous code.\n‚Ä¢ Asynchronous code must be contained inside an declaration (or one other place we‚Äôll cover in the next article), but the declaration can go anywhere is allowed.\n‚Ä¢ When you call you must call it on one of the following:\n‚Ä¢ A coroutine object, which is the return value of a coroutine function defined using .\n‚Ä¢ The coroutine‚Äôs code will only be executed when it is awaited or wrapped in a task.\n‚Ä¢ A future object, which represents a process ongoing somewhere else which may have finished.\n‚Ä¢ Awaiting a future will not cause code to be executed, but might pause your current task until another process has completed.\n‚Ä¢ An object which implements the magic method\n‚Ä¢ What happens then could be anything, check the documentation for the object in question.\n‚Ä¢ You can wrap a coroutine in a task to make it execute and return a future you can use to monitor the results.\n\nSo that concludes our run down of the basic syntax for writing asynchronous code. With just this you can already create a perfectly good async program which can instantiate multiple tasks and allow them to be swapped in and out. The following example is a fully working Python program using only the things included in this post:\n\nThis program will run four tasks which print the numbers from 0 to 99, and after printing each task will yield control to allow other tasks to take over. It neatly demonstrates that asyncio allows multiple things to be done interleaved.\n\nTo actually do anything useful you‚Äôll need to make use of one of the libraries that implement io, such as aiohttp, and when you do you might well find that there are a few things in their interfaces which I haven‚Äôt covered in this post. Specifically you‚Äôll probably find that the interface makes use of and possibly also . So those will be the subject of the next post in this series: Python Asyncio Part 3 ‚Äì Asynchronous Context Managers and Asynchronous Iterators"
    },
    {
        "link": "https://uvicorn.org/deployment",
        "document": ""
    },
    {
        "link": "https://uvicorn.org",
        "document": ""
    },
    {
        "link": "https://fastapi.xiniushu.com/az/deployment/manually",
        "document": "The main thing you need to run a FastAPI application in a remote server machine is an ASGI server program like Uvicorn.\n‚Ä¢ Hypercorn: an ASGI server compatible with HTTP/2 and Trio among other features.\n\nThere's a small detail about names to have in mind. üí°\n\nThe word \"server\" is commonly used to refer to both the remote/cloud computer (the physical or virtual machine) and also the program that is running on that machine (e.g. Uvicorn).\n\nJust have that in mind when you read \"server\" in general, it could refer to one of those two things.\n\nWhen referring to the remote machine, it's common to call it server, but also machine, VM (virtual machine), node. Those all refer to some type of remote machine, normally running Linux, where you run programs.\n\nYou can install an ASGI compatible server with:\n\nYou can then run your application the same way you have done in the tutorials, but without the option, e.g.:\n\nRemember to remove the option if you were using it. The option consumes much more resources, is more unstable, etc. It helps a lot during development, but you shouldn't use it in production.\n\nStarlette and FastAPI are based on AnyIO, which makes them compatible with both Python's standard library asyncio and Trio.\n\nNevertheless, Uvicorn is currently only compatible with asyncio, and it normally uses , the high-performance drop-in replacement for .\n\nBut if you want to directly use Trio, then you can use Hypercorn as it supports it. ‚ú®\n\nFirst you need to install Hypercorn with Trio support:\n\nThen you can pass the command line option with the value :\n\nAnd that will start Hypercorn with your app using Trio as the backend.\n\nNow you can use Trio internally in your app. Or even better, you can use AnyIO, to keep your code compatible with both Trio and asyncio. üéâ\n\nThese examples run the server program (e.g Uvicorn), starting a single process, listening on all the IPs ( ) on a predefined port (e.g. ).\n\nThis is the basic idea. But you will probably want to take care of some additional things, like:\n\nI'll tell you more about each of these concepts, how to think about them, and some concrete examples with strategies to handle them in the next chapters. üöÄ"
    },
    {
        "link": "https://leapcell.medium.com/exploring-asgi-pythons-async-protocol-for-web-apps-867914a69d14",
        "document": "Leapcell: The Best Serverless Platform for Python Web Hosting, Async Tasks, and Redis\n\nWhen developing with FastAPI, we need to use the Uvicorn server. Beginners may wonder why. Today, we‚Äôll answer this question.\n\nThe field contains binary strings, so we need a conversion function . Let's analyze it briefly. Information related to the request path and method is in . Since supports more than just HTTP, we need to use to determine the type of the current protocol. Then, we use the function to receive the request body. Next, we create a response body using and encode it with . Finally, we send the request headers and the request body.\n\nHere, we send the data twice. This design meets the requirements of asynchronous programming and enhances the processing ability for different application scenarios (streaming response). With an understanding of real ‚Äî world projects, we can now understand ASGI from a theoretical basis.\n\nThe Asynchronous Server Gateway Interface (ASGI) is a Python protocol for building asynchronous web applications.\n‚Ä¢ Multi ‚Äî protocol Support: Supports protocols like WebSocket and long ‚Äî polling, which means it supports http/https/websocket.\n‚Ä¢ Communication: Applications and servers, as well as different parts of an application, interact by sending and receiving messages.\n‚Ä¢ The ASGI application interface defines how an application interacts with an ASGI server. An ASGI application is a callable object, usually an asynchronous function, that accepts two parameters: and , and returns a asynchronous generator.\n‚Ä¢ scope: A dictionary containing information about the request, such as the request type (HTTP or WebSocket), path, query string, server information, etc.\n‚Ä¢ receive: An asynchronous call used to receive events from the ASGI server.\n‚Ä¢ send: An asynchronous generator used to send events back to the ASGI server.\n‚Ä¢ The main responsibilities of the server interface include:\n‚Ä¢ Invoking the and methods of the application to pass events.\n‚Ä¢ The event loop interface is an implicit part of the ASGI protocol. It is managed by the ASGI server rather than being directly defined by the ASGI protocol.\n‚Ä¢ The event loop is responsible for scheduling and executing asynchronous tasks, which is the core of asynchronous programming. Its main functions include:\n\nIn ASGI, the event loop is usually provided by the following Python libraries:\n‚Ä¢ asyncio: An asynchronous I/O framework in the Python standard library.\n‚Ä¢ uvloop: An asynchronous event loop based on , often used with the Uvicorn server.\n\nASGI servers and applications rely on the event loop to perform asynchronous operations, enabling them to efficiently handle a large number of concurrent connections.\n\nThe ASGI event ‚Äî driven model handles lifecycle management (startup and shutdown), HTTP request handling, and WebSocket connection management. Through different types of events, developers can precisely control connections and data flow to achieve asynchronous and concurrent processing.\n\nLifespan events are related to the startup and shutdown cycles of an ASGI application. They are typically used to perform initialization and cleanup tasks.\n\nASGI‚Äôs handling of HTTP requests is divided into multiple events, allowing for the management of the details of each HTTP request.\n\nThe ASGI application lifecycle refers to the stages the application goes through during startup and shutdown. It is managed by the lifespan event channel.\n\nThe ASGI lifecycle is divided into two parts: the startup and shutdown of the application, and the establishment, processing, response, and shutdown of requests.\n\nAs mentioned before, Uvicorn implements the ASGI server layer. However, it is not very user ‚Äî friendly at the application layer as it is too low ‚Äî level. Thus, many higher ‚Äî level frameworks have emerged:\n‚Ä¢ Starlette: A lightweight ASGI framework/toolkit for building high ‚Äî performance web services. It is a basic component of FastAPI and can also be used independently to create simple web applications.\n‚Ä¢ FastAPI: A modern, fast (high ‚Äî performance) web framework for building APIs, used with Python 3.6+ type hints. It is based on Starlette and standard Python type hints, and provides automatic data validation and serialization, as well as interactive API documentation generation.\n\nThere‚Äôs no need to elaborate on other aspects here; too much information may be overwhelming. Uvicorn requires an , so for these two frameworks, the instantiated object is . Then, we use the Uvicorn CLI to start the application:\n\nThis article mainly explores the Python web ASGI protocol through Uvicorn. ASGI is Python‚Äôs asynchronous server gateway interface, integrating the asynchronous, concurrent, and multi ‚Äî protocol capabilities of modern Python web programs.\n\nLeapcell: The Best Serverless Platform for Python Web Hosting, Async Tasks, and Redis\n\nFinally, I recommend a platform that is most suitable for deploying Python projects: Leapcell\n‚Ä¢ Develop with JavaScript, Python, Go, or Rust.\n‚Ä¢ Pay only for usage ‚Äî no requests, no charges.\n‚Ä¢ Pay ‚Äî as ‚Äî you ‚Äî go with no idle charges.\n‚Ä¢ Zero operational overhead ‚Äî just focus on building.\n\nExplore more in the documentation!"
    },
    {
        "link": "https://fastapi.tiangolo.com/deployment/manually",
        "document": "In short, use to serve your FastAPI application:\n\nThat would work for most of the cases. üòé\n\nYou could use that command for example to start your FastAPI app in a container, in a server, etc.\n\nLet's go a little deeper into the details.\n\nFastAPI uses a standard for building Python web frameworks and servers called . FastAPI is an ASGI web framework.\n\nThe main thing you need to run a FastAPI application (or any other ASGI application) in a remote server machine is an ASGI server program like Uvicorn, this is the one that comes by default in the command.\n\nThere are several alternatives, including:\n‚Ä¢ Hypercorn: an ASGI server compatible with HTTP/2 and Trio among other features.\n\nThere's a small detail about names to keep in mind. üí°\n\nThe word \"server\" is commonly used to refer to both the remote/cloud computer (the physical or virtual machine) and also the program that is running on that machine (e.g. Uvicorn).\n\nJust keep in mind that when you read \"server\" in general, it could refer to one of those two things.\n\nWhen referring to the remote machine, it's common to call it server, but also machine, VM (virtual machine), node. Those all refer to some type of remote machine, normally running Linux, where you run programs.\n\nWhen you install FastAPI, it comes with a production server, Uvicorn, and you can start it with the command.\n\nBut you can also install an ASGI server manually.\n\nMake sure you create a virtual environment, activate it, and then you can install the server application.\n\nFor example, to install Uvicorn:\n\nA similar process would apply to any other ASGI server program.\n\nBy adding the , Uvicorn will install and use some recommended extra dependencies. That including , the high-performance drop-in replacement for , that provides the big concurrency performance boost. When you install FastAPI with something like you already get as well.\n\nIf you installed an ASGI server manually, you would normally need to pass an import string in a special format for it to import your FastAPI application:\n\nEach alternative ASGI server program would have a similar command, you can read more in their respective documentation.\n\nThese examples run the server program (e.g Uvicorn), starting a single process, listening on all the IPs ( ) on a predefined port (e.g. ).\n\nThis is the basic idea. But you will probably want to take care of some additional things, like:\n\nI'll tell you more about each of these concepts, how to think about them, and some concrete examples with strategies to handle them in the next chapters. üöÄ"
    }
]