[
    {
        "link": "https://spacelift.io/blog/yaml",
        "document": "\nâ€¢ Maps/Dictionaries node is an unordered set of , with the restriction that each of the keys is unique. YAML places no further restrictions on the nodes.\nâ€¢ Arrays/Lists node is an ordered series of zero or more nodes. In particular, a sequence may contain the same node more than once. It could even contain itself.\nâ€¢ Literals node is an opaque datum that can be presented as a series of zero or more Let us try to identify where these appear in the sample YAML file we saw earlier. # key: value is an array [sequence] A YAML file relies on whitespace and indentation to indicate nesting. Notice the hierarchy and nesting is visible through a Python-like indentation style. It is critical to note that tab characters cannot be used for indentation in YAML files; only spaces can be used. The number of spaces used for indentation doesnâ€™t matter as long as they are consistent. Mappings are used to associate key/value pairs that are unordered. Maps in YAML files can be nested by increasing the indentation, or new maps can be created at the same level by resolving the previous one. Sequences in YAML are represented by using the hyphen (-) and space. They are ordered and can be embedded inside a map using indentation. Tip: Remember that the order matters with sequences but not with mappings. String literals in YAML do not need to be quoted. It is only important to quote them when they contain a value that can be mistaken for a special character. Here is an example where the string has to be quoted as & is a special character. # Works as the string is quoted Strings can also be written in blocks and be interpreted without the new line characters using the fold operator (greater than). The above YAML snippet is interpreted as in the output below. \"even though it looks like this is a multiline message,it is actually not\" Strings can be interpreted as blocks using the block (pipe) character. This is interpreted with the new lines (\n\n) as below. Multiline strings may end with whitespaces. Preserve chomp(+) and strip chomp operators can be used either to preserve or strip the whitespaces. They can be used with block and pipe characters. This block line Will be interpreted as a single line with a newline character at the end The above snippet is interpreted as below in JSON \"This block line Will be interpreted as a single line with a newline character at the end\n\n\" This block line Will be interpreted as a single line without the newline character at the end The above snippet is interpreted as below in JSON. \"This block line Will be interpreted as a single line without the newline character at the end\" Unlike JSON, the YAML file supports comments, which start with #. To learn more, see â€“ how to add comments in YAML. # Comments inside a YAML file can be added followed by the '#' character\nâ€¢ None Top Most Useful CI/CD Tools for DevOps\nâ€¢ Why Generic CI/CD Tools Will Not Deliver Successful IaC\n\nNow that we know all the basics, letâ€™s look at more advanced YAML syntax features. The above YAML snippet is called a document. A single YAML file can have more than one document. Each document can be interpreted as a separate YAML file which means multiple documents can contain the same or duplicate keys which are not allowed in the same document. The beginning of a document is denoted by three hyphens â€”. A YAML file with multiple documents would look like this, where each new document is indicated by . Triple dots are used to end a YAML document without starting a new one Before we learn more about YAML, this is a good time to practice writing your own YAML file. They can be validated here. Now that we have seen an online YAML parser in action, itâ€™s time we learn about schemas and tags. Letâ€™s take a moment to consider how YAML will interpret the given document. Is the sequenceâ€™s first literal a string or a boolean? You are correct if you answer that the first item on the list is a boolean, and you are also correct if you answer that it is a string. The way it is resolved is determined by the YAML schema that the parser has implemented. Schemas can be thought of as the way a parser resolves or understands nodes (values) present in a YAML file. There are primarily three default schemas in YAML:\nâ€¢ None understands only maps, sequences, and strings and is guaranteed to work with any YAML file.\nâ€¢ None understands all types supported within JSON, including boolean, null, int, and float, as well as those in the FailSafe schema.\nâ€¢ None is an extension of the JSON schema, making it more human-readable supporting the same types but in multiple forms.\n\n For example: 1. null | Null | NULL will all be resolved to the same type null, and true | True | TRUE will all be resolved to the same boolean value.\n\n Note: It is also possible to create your own custom schemas based on the above default schema. Coming back to the original question, if the parser supports only the basic schema (FailSafe Schema), the first item will be evaluated as a string. Otherwise, it will be evaluated as a boolean. Read more about YAML schemas here. What if we explicitly want a value to be parsed in a specific way? Letâ€™s say from the same example that we want the first true value to be parsed as a string instead of a boolean, even when the parser uses the JSON or the core schema. This is where tags come into the picture. Tags can be thought of as types in YAML. Even though we explicitly didnâ€™t mention the tags/types in any of the YAML snippets we saw so far, they are inferred automatically by the YAML parser. For instance, the maps have the tag/type as tag:yaml.org,2002:map, sequences are tag:yaml.org,2002:seq and strings are tag:yaml.org,2002:str The snippet below works perfectly fine, even when we specify the tags. It can be validated here. We can use these tags to explicitly specify a type. For our example, all we have to do is specify the type as a string, and the YAML parser will parse it as a string. With a lot of configuration, configuration files can become quite large. Anchors (&) and aliases (*) are used to avoid duplication in YAML files. When writing large configurations in YAML, it is common for a specific configuration to be repeated. For example, the vars config is repeated for all three services in the following YAML snippet. As more and more things are repeated for large configuration files, this becomes tedious. Anchors and aliases allow us to rewrite the same snippet without repeating any configuration. Anchors (&) are used to define a chunk of configuration, and aliases refer to that chunk at a different part of the configuration. Anchors and aliases here helped us cut down the repeated configuration. But practically, configurations wonâ€™t be completely identical they would vary here and there. For instance, what if all the above services are running on different versions? Does this mean we have to rewrite and repeat the whole config? This is where overrides (<<:) come to the rescue. We can still use aliases and make the changes that we need. If special characters are a part of the data/value, they can be escaped using entities, Unicode, or quotes.\nâ€¢ None Double quote in a single quote: â€˜YAML is the â€œbestâ€ configuration languageâ€™\nâ€¢ None Single quote in a double quote: â€œ Yes, the â€˜bestâ€™ â€œ\n\nHow is YAML different from JSON? While both YAML and JSON are data serialization formats, YAML offers greater readability, support for complex data types, and the ability to include comments, making it more suitable for configuration files and human-readable data representation. JSON, on the other hand, is simpler and more widely used for data exchange in web applications and APIs due to its native support in JavaScript and smaller file size. The below code snippet of Kubernetes configuration is written in JSON. Donâ€™t pay attention to what it does; just observe the file. \"APIService represents a server for a particular GroupVersion. Name must be \\\"version.group\\\".\" \"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\" \"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\" \"Spec contains information for locating and communicating with a server\" \"Status contains derived information about an API server\" Doesnâ€™t it look like a pure JSON file? Letâ€™s see if we can validate it in our YAML parser. Itâ€™s odd that the YAML parser didnâ€™t report the file as invalid. Does this imply that JSON is also YAML? YAML is, in fact, a superset of JSON. All JSON files are valid YAML files, but not the other way around. Can we combine JSON and YAML? Is it still a valid YAML file? Letâ€™s put this hypothesis to the test. Let us change some of the above snippets to make it look more like the YAML we are familiar with ðŸ˜‰ \"APIService represents a server for a particular GroupVersion. Name must be \\\"version.group\\\".\" \"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\" \"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\" \"Spec contains information for locating and communicating with a server\" \"Status contains derived information about an API server\" Notice that there isnâ€™t a root JSON wrapper {} anymore; there are just maps at the root level, but most of it is still JSON. Validate the file once more in a YAML parser. It is a valid YAML file, but when we try to validate it in a JSON parser, it says it is invalid. Thatâ€™s because the file is no longer JSON but rather YAML. This demonstrates that YAML is, in fact, the superset of JSON.\n\nExamples: How to use YAML files? We learned a lot about YAML and saw that it works great as a configuration language. Let us see it in action with some of the most famous tools. Ansible playbooks are used to automate repeated tasks that execute actions automatically. Playbooks are expressed in YAML format and perform any action defined in plays. To learn more about Ansible playbooks, see our article: Working with Ansible Playbooks â€“ Tips & Tricks with Examples. Here is a simple Ansible playbook that installs Nginx, applies the specified template to replace the existing default Nginx landing page, and finally enables TCP access on port 80. Allow all access to tcp port 80 Kubernetes, also known as K8s, is an open-source system for automating the deployment, scaling, and management of containerized applications. Kubernetes works based on a state model where it tries to reach the desired state from the current state in a declarative way. Kubernetes uses YAML files to define the Kubernetes object, which is applied to the cluster to create resources like pods, services, and deployments. Here is a YAML file that describes a deployment that runs Nginx."
    },
    {
        "link": "https://developers.redhat.com/blog/2020/11/25/how-to-configure-yaml-schema-to-make-editing-files-easier",
        "document": "YAML is a friendly data serialization standard that works with all programming languages. While configuration files are often defined in YAML, it can even be used as a programming language, like the workflow language at Google, or Apache Camel K.\n\nIt has the advantage of not having any braces, making it lightweight visually. One of the drawbacks is that editing YAML files may not always be easy. For instance, writing a tag at the wrong indentation level can be hard to detect. To help with editing, it is possible to provide a YAML schema that can be leveraged by a large set of integrated development environments (IDEs). Unfortunately, this practice is not widespread. Consequently, users waste time searching for a missing or extra space and browsing documentation.\n\nIn this article, you will discover the benefits of providing a YAML schema and how to make it consumable for all your users, making it easier to edit YAML files.\n\nProviding a schema describing the structure of a YAML file type is possible. You might not find the specification easily because it relies on the JSON Schema specifications. YAML schemas allow several IDEs and editors to provide code completion, documentation on hover, and validation of the file, including Eclipse Desktop IDE, Eclipse Che, VS Code, IntelliJ, Emacs, and vim.\n\nFor instance, see the code completion example in VS Code for an Apache Camel K integration file in Figure 1.\n\nFigure 2 shows an example of file validation.\n\nFigure 3 shows an example of documentation on hover.\n\nI recommend that you register the schema in the JSON Schema store which is, as far as I know, the largest registry of JSON and YAML schemas. The JSON Schema store is used directly or through the YAML Language Server in several IDEs. It allows an automatic binding of YAML files with their corresponding schema. The biggest advantage is that it is completely transparent for the end user.\n\nTo benefit from the JSON Schema store and the built-in integration offered by IDEs, the YAML schema writer needs to set a file name pattern for the YAML files and the schema's users need to respect that pattern. For instance, you can use this kind of file pattern *.myId.yaml. Take care to avoid collision with the existing file name pattern. Colliding with the existing file name patterns will complicate things for your users.\n\nIf you do not want to impose a file name pattern, two possibilities remain that benefit from the schema association. Using one of these other methods will add extra effort either for the user or during your tooling maintenance.\n\nMost IDEs provide ways to associate a schema to a specific file via preferences. In this case, the burden is on your user.\n\nIt is also possible to write a specific extension to auto-associate the schema. The drawback is that specific IDE extensions must be written for each IDE that you want to support. Hopefully, for some of them, there is a specific API to do it. For instance, vscode-yaml is one way you could accomplish this.\n\nIt is possible to use inline metadata to specify the schema corresponding to the file. The following modeline-like format must be used:\n\nThe main drawback is that this option places a burden on your users. This annotation is also specific to yaml-language-server and not part of the specifications. If you think it would be nice to have it directly inside the YAML specification, please cast your vote here.\n\nThe main advantage is that it is available under the hood with all recent IDEs by using the YAML Language Server.\n\nProviding a YAML schema provides a tremendous benefit to your users. Now you know multiple ways to make your YAML schema easily accessible to all of your users, and make editing these YAML files easier. From here, I hope to see a huge increase in registered schemas on the Schema store!"
    },
    {
        "link": "https://marketplace.visualstudio.com/items?itemName=redhat.vscode-yaml",
        "document": "Provides comprehensive YAML Language support to Visual Studio Code, via the yaml-language-server, with built-in Kubernetes syntax support.\nâ€¢ YAML validation:\nâ€¢ Detects whether the entire file is valid yaml\nâ€¢ Document Outlining (Ctrl + Shift + O):\nâ€¢ Provides the document outlining of all completed nodes in the file\nâ€¢ Auto completion (Ctrl + Space):\nâ€¢ Scalar nodes autocomplete to schema's defaults if they exist\nâ€¢ Hover support:\nâ€¢ Hovering over a node shows description if provided by schema\nâ€¢ Formatter:\nâ€¢ Allows for formatting the current file Auto completion and hover support are provided by the schema. Please refer to Language Server Settings to setup a schema Starting from the extension uses eemeli/yaml as the new YAML parser, which strictly enforces the specified YAML spec version. Default YAML spec version is , it can be changed with setting. The following settings are supported:\nâ€¢ : Use single quotes instead of double quotes\nâ€¢ : Always: wrap prose if it exceeds the print width, Never: never wrap the prose, Preserve: wrap prose as-is\nâ€¢ : Specify the line length that the printer will wrap on\nâ€¢ : Helps you associate schemas with files in a glob pattern\nâ€¢ : When set to true, the YAML language server will pull in all available schemas from JSON Schema Store\nâ€¢ : URL of a schema store catalog to use when downloading schemas.\nâ€¢ : Array of custom tags that the parser will validate against. It has two ways to be used. Either an item in the array is a custom tag such as \"!Ref\" and it will automatically map !Ref to a scalar, or you can specify the type of the object !Ref should be, e.g. \"!Ref sequence\". The type of object can be either scalar (for strings and booleans), sequence (for arrays), mapping (for objects).\nâ€¢ : The maximum number of outline symbols and folding regions computed (limited for performance reasons).\nâ€¢ : Disable adding not required properties with default values into completion text (default is false).\nâ€¢ : If true, the user must select some parent skeleton first before autocompletion starts to suggest the rest of the properties. When the YAML object is not empty, autocompletion ignores this setting and returns all properties and skeletons.\nâ€¢ : VSCode-YAML adds default configuration for all YAML files. More specifically, it converts tabs to spaces to ensure valid YAML, sets the tab size, allows live typing autocompletion and formatting, and also allows code lens. These settings can be modified via the corresponding settings inside the section in the settings:\nâ€¢ : The URL of the proxy server that will be used when attempting to download a schema. If it is not set or it is undefined no proxy server will be used.\nâ€¢ : If true the proxy server certificate should be verified against the list of supplied CAs. Default is false.\nâ€¢ : Enforces alphabetical ordering of keys in mappings when set to . Default is To use the custom tags in your YAML file, you need to first specify the custom tags in the setting of your code editor. For example, you can have the following custom tags: The !Scalar-example would map to a scalar custom tag, the !Seq-example would map to a sequence custom tag, the !Mapping-example would map to a mapping custom tag. You can then use the newly defined custom tags inside the YAML file: YAML Language support uses JSON Schemas to understand the shape of a YAML file, including its value sets, defaults and descriptions. The schema support is shipped with JSON Schema Draft 7. We support schemas provided through JSON Schema Store. However, schemas can also be defined in a workspace. The association of a YAML file to a schema can be done either in the YAML file itself using a modeline or in the User or Workspace settings under the property . It is possible to specify a yaml schema using a modeline. Schema url can be a relative path. If a relative path is specified, it is calculated from yaml file path, not from workspace root path applies a schema to a file. In other words, the schema (placed on the left) is applied to the glob pattern on the right. Your schema can be local or online. Your schema must be a relative path and not an absolute path. The entrance point for is a location in user and workspace settings When associating a schema it should follow the format below Since YAML Schemas can be used for validation: A schema can be associated with multiple globs using a json array, e.g. You can also use relative paths when working with multi-root workspaces. Suppose you have a multi-root workspace that is laid out like: You must then associate schemas relative to the root of the multi root workspace project. allows you to specify JSON schemas that you want to validate against the YAML you write. Kubernetes is a reserved keyword field. It does not require a URL, as the language server will provide that. You need the keyword and a glob pattern.\nâ€¢ Supports point, which allows you to contribute a schema for a specific type of YAML file (Similar to jsonValidation) e.g. If you discover an issue please file a bug and we will fix it as soon as possible. MIT, See LICENSE for more information. The extension collects anonymous usage data and sends it to Red Hat servers to help improve our products and services. Read our privacy statement to learn more. This extension respects the setting, which you can learn more about at https://github.com/redhat-developer/vscode-redhat-telemetry#how-to-disable-telemetry-reporting The instructions are available in the contribution guide."
    },
    {
        "link": "https://home-assistant.io/docs/configuration/yaml",
        "document": "Home Assistant uses the YAML syntax for configuration. While most integrations can be configured through the UI, some integrations require you to edit your file to specify its settings.\n\nThis page gives a high-level introduction to the YAML syntax used in Home Assistant. For a more detailed description and more examples, refer to the YAML Style Guide for Home Assistant developers.\n\nThe following YAML example entry assumes that you would like to set up the notify integration with the pushbullet platform.\nâ€¢ An integration provides the core logic for some functionality (like provides sending notifications).\nâ€¢ A platform makes the connection to a specific software or hardware platform (like works with the service from pushbullet.com).\n\nThe basics of YAML syntax are block collections and mappings containing key-value pairs. Each item in a collection starts with a while mappings have the format . This is somewhat similar to a Hash table or more specifically a dictionary in Python. These can be nested as well. Beware that if you specify duplicate keys, the last value for a key is used.\n\nIn YAML, indentation is important for specifying relationships. Indented lines are nested inside lines that are one level higher. In the above example, is a property of (nested inside) the integration.\n\nGetting the right indentation can be tricky if youâ€™re not using an editor with a fixed-width font. Tabs are not allowed to be used for indentation. The convention is to use 2 spaces for each level of indentation.\n\nStrings of text following a are comments. They are ignored by the system. Comments explain in plain language what a particular code block is supposed to do. For future-you or someone else looking at the file.\n\nExample with comment and nesting\n\nThe next example shows an input_select integration that uses a block collection for the values of options. The other properties (like ) are specified using mappings. Note that the second line just has with no value on the same line. Here, is the name of the input_select. The values for it are everything nested below it.\n\nThe following example shows nesting a collection of mappings in a mapping. In Home Assistant, this would create two sensors that each use the MQTT platform but have different values for their (one of the properties used for MQTT sensors).\n\nOn Home Assistant CoreHome Assistant Core is the heart of Home Assistant itself. It is a Python program that powers every installation type, but can be installed standalone. [Learn more] installations, you can include values from your systemâ€™s environment variables with . Note that this will only work for Home Assistant CoreHome Assistant Core is the heart of Home Assistant itself. It is a Python program that powers every installation type, but can be installed standalone. [Learn more] installations, in a scenario where it is possible to specify these. Regular Home Assistant users are recommended to use statements instead.\n\nIf an environment variable is not set, you can fall back to a default value.\n\nTo improve readability, you can source out certain domains from your main configuration file with the -syntax.\n\nMore information about this feature can also be found at splitting configuration.\n\nIf you see the following message:\n\nThis means that youâ€™ve mistakenly entered a tab character, instead of spaces.\n\nHome Assistant is case sensitive, a state of is not the same as or . Similarly an entity of is not the same as .\n\nIf youâ€™re having trouble, check the case that Home Assistant is reporting in the dev-state menu, under Developer tools.\n\nYAML treats , , , all as and , , , as . This means that if you want to set the state of an entity to you must quote it as otherwise it will be translated as setting the state to true. The same applies to .\n\nNot quoting the value may generate an error such as:\n\nWith all these indents and rules, it is easy to make a mistake. The best way to check if your YAML syntax is correct (validate) depends on the editor you use. We canâ€™t list them all here.\nâ€¢ If you edit the files directly in Home Assistant, refer to the section: Validating the configuration"
    },
    {
        "link": "https://docs.readthedocs.com/dev/latest/design/yaml-file.html",
        "document": "The current YAML configuration file is in beta state. There are many options and features that it doesnâ€™t support yet. This document will serve as a design document for discuss how to implement the missing features.\n\nNo all the RTD settings are applicable to the YAML file, others are applicable for each build (or version), and others for the global project. Those settings canâ€™t be on the YAML file because: may depend for the initial project setup, are planned to be removed, security and privacy reasons.\nâ€¢ None Privacy level (this feature is planned to be removed )\nâ€¢ None Project description (this feature is planned to be removed ) To keep consistency with the per-version settings and avoid confusion, this settings will not be stored in the YAML file and will be stored in the database only. Those configurations will be read from the YAML file in the current version that is being built. Several settings are already implemented and documented on https://docs.readthedocs.io/en/latest/yaml-config.html. So, they arenâ€™t covered with much detail here.\n\nThe file format is based on the YAML spec 1.2 (latest version on the time of this writing). The file must be on the root directory of the repository, and must be named as: The spec of the configuration file must use this conventions.\nâ€¢ None Use to indicate an empty list\nâ€¢ None Use to indicate a null value\nâ€¢ None Use (internal string keyword) to indicate that all options are included on a list with predetermined choices.\nâ€¢ None Use and as only options on boolean fields The current spec is documented on https://docs.readthedocs.io/en/latest/yaml-config.html. It will be used as base for the future spec. The spec will be written using a validation schema such as https://json-schema-everywhere.github.io/yaml.\n\nThe version of the spec that the user wants to use will be specified on the YAML file. The spec only will have mayor versions (1.0, not 1.2) . For keeping compatibility with older projects using a configuration file without a version, the latest compatible version will be used (1.0).\n\nWhen a user creates a new project or itâ€™s on the settings page, we could suggest her/him an example of a functional configuration file with a minimal setup. And making clear where to put global configurations. For users that already have a project, we can suggest him/her a configuration file on each build based on the current settings.\n\nThe settings used in the build from the configuration file (and other metadata) needs to be stored in the database, this is for later usage only, not to populate existing fields."
    },
    {
        "link": "https://spigotmc.org/threads/the-best-way-of-internationalizing.43971",
        "document": ""
    },
    {
        "link": "https://spigotmc.org/resources/internationalization.80984",
        "document": ""
    },
    {
        "link": "https://lingoport.com/blog/resource-files-best-practices-for-i18n-localization",
        "document": "Resource files are a crucial component of software localization. If youâ€™re a developer or work in localization, youâ€™ve probably heard of them. But for those who havenâ€™t, donâ€™t worry â€“ weâ€™ll break it down\n\nA resource file stores all the user-facing text in an app or website. Instead of hardcoding phrases like â€œClick hereâ€ or â€œWelcomeâ€ directly into your code, you put them in a separate file. This file is basically a list of labels and their corresponding text in different languages.\n\nThen, for other languages, you create similar files with the same labels but translated text:\n\nThese files come in different formats depending on what programming language or framework youâ€™re using. Java uses .properties files, .NET uses .resx, and web apps often use JSON.\n\nYou might be wondering why youâ€™d go through the trouble of setting up these files. Well, there are a few good reasons:\nâ€¢ It keeps your code clean. Developers can focus on functionality without worrying about text.\nâ€¢ Translators can work directly with these files without touching your code.\nâ€¢ Adding new languages is much easier â€“ just create a new resource file.\nâ€¢ You can update text across your entire app by changing one file.\nâ€¢ It helps maintain consistency in your translations.\n\nBy using resource files, youâ€™re setting yourself up for success when it comes to making your app available in multiple languages. Although it may seem like extra work initially, the benefits are significant over time.\n\nAs we already mentioned, different programming languages handle resource files in their own formats. How to denote locales, how to pass locales in the application execution path, and how to fall back on the default locale when a given locale resource is not found.\n\nHere are some common examples:\nâ€¢ Java: standard resource files end in .properties and are named based on the target locales, such as resources.properties for the source locale and resources_fr.properties for the French file.\nâ€¢ JavaScript: Often uses JSON files to store localized content.\nâ€¢ Android: end in xml (e.g. strings.xml) and are located under directories named â€œres/valuesâ€ for the source locale, and â€œvalues-frâ€ for the French version of the files under that directory.\n\nFollowing these standard file formats, will help developers streamline the internationalization (i18n) process and make it easier to manage localization (l10n).\n\nWhile standard formats simplify localization, some developers use non-standard methods to store resource files. Here are some real-life examples:\n\nUsing JSON files with locale as the root key\n\nIn this case, JSON files are named with locales, which means the filename itself indicates the language or region (e.g., en.json for English). However, inside the file, the locale is used as the root key. This means that all strings or data in the file are nested under the locale identifier within the file structure.\n\nThis structure can make it harder to manage if there are multiple locales in one file, as it requires additional handling when extracting translations.\n\nAt build time the file is split into multiple YAML files, each representing a specific locale. These files are then converted into CSV format and sent for translation. Once the translations are complete, the CSV files are returned, reprocessed back into their respective formats (YAML), and then pushed into a database to update the localized content.\n\nThis method allows the central management of multiple locales but adds complexity during the translation and build process.\n\nDuring the build time, these YAML files are combined into a single read-only JSON file that contains all the localesâ€™ data. This can cause the following problems:\nâ€¢ Loss of Flexibility: A single read-only file makes it harder to update or modify individual locale data without re-generating the entire file.\nâ€¢ Size and Performance Issues: Large JSON files containing all locales may slow down load times or increase memory usage, especially for large-scale applications.\nâ€¢ Error Handling: If thereâ€™s an error with one locale, the entire file may become unusable, making debugging more complex.\n\nInstead of placing the resource files directly in a directory tied to the locale (e.g., for English), they are stored in a more complex directory structure, located â€œsomewhere below,â€ such as .\n\nThis approach complicates the organization and retrieval of localization files, making it harder to manage and track them, as the directory structure is unnecessarily deep or non-standard.\n\nMisuse of YAML by formatting it like XML\n\nInstead of following proper YAML syntax it is formatted like XML. This incorrect approach adds unnecessary complexity.\n\nThe correct approach simplifies it by using direct key-value pairs:\n\nUsing the same naming for resource files\n\nMultiple files, which are meant to store different types of content or resources, all share the same filename, like â€œen.jsonâ€ for English content. This causes confusion and difficulty in managing these files because itâ€™s hard to distinguish between them without looking at the directory path. Best practices recommend giving each file a unique, descriptive name (e.g., or ) to improve clarity and organization.\n\nThese â€œcreativeâ€ approaches in resource file management can lead to additional work for both developers and localization teams. It may require creating custom scripts, managing complex directory structures, and developing specialized workflows for translation and file validation. This can increase the risk of errors and slow down the localization process and as a consequence, the development cycle.\n\nTo make the i18n and l10n processes smoother, follow these best practices:\nâ€¢ Use Programming Framework-Recommended File Formats: Stick to the standard file formats for your programming environment (e.g., .resx for .NET, JSON for JavaScript, or .properties for Java). This simplifies both development and localization workflows.\nâ€¢ One File per Locale: Ensure each locale has its own dedicated resource file. This makes it easier to add or remove languages without affecting other locales.\nâ€¢ Follow ISO Naming Conventions: Use standard naming conventions such as ISO 639 for languages (e.g., en_US for U.S. English or fr_FR for French). This ensures consistency and helps both developers and localization teams quickly identify and work with the correct locale files.\nâ€¢ Simplify the Process: Donâ€™t overcomplicate things. If your source code is written in JSON, use JSON for translations instead of creating unnecessary conversions. Keeping the same format from development to localization avoids complexity and errors.\nâ€¢ Unique File Naming: Ensure each file has a unique, descriptive name to avoid confusion. Avoid having 200 files named â€œen.jsonâ€ scattered across directories. This improves file organization and tracking.\nâ€¢ Consistent Locale Naming: Use the same locale structure across all resource files in your repository. For example, always follow the pattern language/country/variant (optional) for all files to prevent inconsistency and confusion.\n\nLingoport offers solutions that can help automate and streamline your i18n and l10n processes, ensuring your software is ready for global markets. If you need any support contact us. We can help you go global at the speed of development."
    },
    {
        "link": "https://middlemanapp.com/advanced/localization",
        "document": "The extension provides a way to localize your site. Activate it in your :\n\nBy default this will search the folder in the root of your project for YAML files representing each locale you want to support. The YAML file is a set of keys and values for each string you need to localize in your site. The keys, which is how you will refer to these strings in your templates, must be the same in each locale, but the values will change. Here are two example YAML files.\n\nLocalizable templates live in the folder by default (see below on how to change this option).\n\nEach template in that folder will have access to the helper. Using this helper, you can refer to keys from your YAML files and inject the language-specific values into your template. Here's a simple template:\n\nThis would output two files:\n\nYou can use as a shortcut for in your templates:\n\nEach individual language is accessible in its own namespaced path. By default, the first language lives at the root of the site (see below to change this option). The default path is to simply use the language name (the name of the YAML file) in the path:\n\nYou can change this with the option, but remember: the URL will always include the name of the YAML file:\n\nNow the paths would be:\n\nIf you are unhappy using the YAML file names as part of your path, you can remap them to different values.\n\nNow the paths would be:\n\nIn some cases you may want to localize the name of the file in addition to its contents. You can use the special key in your language YAML files to rename URLs to be language-specific.\n\nLet's say we have a file . By default, this will output as:\n\nIf we want to rename that file to for Spanish only, we can use the key in :\n\nNow, the files would be output as:\n\nTo localize directories, you have to split up the paths. For example, to localize to , you could use the following structure in :\n\nBy default, the contents of will be built in multiple languages while the rest of your templates will continue to work normally. The name of this folder can be changed with the option:\n\nIf you'd prefer specify a list of supported languages rather than automatically discovering files in , you can use the option:\n\nBy default, the first language (either specified by or discovered in your folder) will be the \"default\" language and will be mounted at the root of your site. Given our two languages, files localized to will be at the root:\n\nYou can change the default or disable mounting a specific language at the root entirely using the option:\n\nIt can be inefficient to put translations of large blocks of text into the locale YAML files. To help with this, Middleman offers a way to localize entire templates. For example, if you had , you could create two templates, and . When the site is built, you'll get:\n\nTo use this localization method, be sure to put your files inside the folder."
    },
    {
        "link": "https://stackoverflow.com/questions/9062753/yaml-internationalization",
        "document": "OK,I have no answers.\n\n I will describe here my solutions for localization\n\nFor a common translations I used Yaml format.\n\n (Data has this format):\n\n\n\n Filename:common.en_US.yaml\n\nHow to use it:\n\n\n\nFor the javaScript translations,I used the same yaml format.\n\n\n\n How to use it:\n\n For the large dynamic data, I used l10n localization standart.\n\n Where localization table has a prefix _l10n"
    }
]