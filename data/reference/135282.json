[
    {
        "link": "https://developer.android.com/training/data-storage/sqlite",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nSaving data to a database is ideal for repeating or structured data, such as contact information. This page assumes that you are familiar with SQL databases in general and helps you get started with SQLite databases on Android. The APIs you'll need to use a database on Android are available in the package.\n\nCaution: Although these APIs are powerful, they are fairly low-level and require a great deal of time and effort to use:\nâ€¢ There is no compile-time verification of raw SQL queries. As your data graph changes, you need to update the affected SQL queries manually. This process can be time consuming and error prone.\nâ€¢ You need to use lots of boilerplate code to convert between SQL queries and data objects. For these reasons, we highly recommended using the Room Persistence Library as an abstraction layer for accessing information in your app's SQLite databases.\n\nOne of the main principles of SQL databases is the schema: a formal declaration of how the database is organized. The schema is reflected in the SQL statements that you use to create your database. You may find it helpful to create a companion class, known as a contract class, which explicitly specifies the layout of your schema in a systematic and self-documenting way.\n\nA contract class is a container for constants that define names for URIs, tables, and columns. The contract class allows you to use the same constants across all the other classes in the same package. This lets you change a column name in one place and have it propagate throughout your code.\n\nA good way to organize a contract class is to put definitions that are global to your whole database in the root level of the class. Then create an inner class for each table. Each inner class enumerates the corresponding table's columns.\n\nNote: By implementing the interface, your inner class can inherit a primary key field called that some Android classes such as expect it to have. It's not required, but this can help your database work harmoniously with the Android framework.\n\nFor example, the following contract defines the table name and column names for a single table representing an RSS feed:\n\nOnce you have defined how your database looks, you should implement methods that create and maintain the database and tables. Here are some typical statements that create and delete a table:\n\nJust like files that you save on the device's internal storage, Android stores your database in your app's private folder. Your data is secure, because by default this area is not accessible to other apps or the user.\n\nThe class contains a useful set of APIs for managing your database. When you use this class to obtain references to your database, the system performs the potentially long-running operations of creating and updating the database only when needed and not during app startup. All you need to do is call or .\n\nNote: Because they can be long-running, be sure that you call or in a background thread. See Threading on Android for more information.\n\nTo use , create a subclass that overrides the and callback methods. You may also want to implement the or methods, but they are not required.\n\nFor example, here's an implementation of that uses some of the commands shown above:\n\nTo access your database, instantiate your subclass of :\n\nInsert data into the database by passing a object to the method:\n\nThe first argument for is simply the table name.\n\nThe second argument tells the framework what to do in the event that the is empty (i.e., you did not any values). If you specify the name of a column, the framework inserts a row and sets the value of that column to null. If you specify , like in this code sample, the framework does not insert a row when there are no values.\n\nThe methods returns the ID for the newly created row, or it will return -1 if there was an error inserting the data. This can happen if you have a conflict with pre-existing data in the database.\n\nTo read from a database, use the method, passing it your selection criteria and desired columns. The method combines elements of and , except the column list defines the data you want to fetch (the \"projection\"), rather than the data to insert. The results of the query are returned to you in a object.\n\nThe third and fourth arguments ( and ) are combined to create a WHERE clause. Because the arguments are provided separately from the selection query, they are escaped before being combined. This makes your selection statements immune to SQL injection. For more detail about all arguments, see the reference.\n\nTo look at a row in the cursor, use one of the move methods, which you must always call before you begin reading values. Since the cursor starts at position -1, calling places the \"read position\" on the first entry in the results and returns whether or not the cursor is already past the last entry in the result set. For each row, you can read a column's value by calling one of the get methods, such as or . For each of the get methods, you must pass the index position of the column you desire, which you can get by calling or . When finished iterating through results, call on the cursor to release its resources. For example, the following shows how to get all the item IDs stored in a cursor and add them to a list:\n\nTo delete rows from a table, you need to provide selection criteria that identify the rows to the method. The mechanism works the same as the selection arguments to the method. It divides the selection specification into a selection clause and selection arguments. The clause defines the columns to look at, and also allows you to combine column tests. The arguments are values to test against that are bound into the clause. Because the result isn't handled the same as a regular SQL statement, it is immune to SQL injection.\n\nThe return value for the method indicates the number of rows that were deleted from the database.\n\nWhen you need to modify a subset of your database values, use the method.\n\nUpdating the table combines the syntax of with the syntax of .\n\nThe return value of the method is the number of rows affected in the database.\n\nSince and are expensive to call when the database is closed, you should leave your database connection open for as long as you possibly need to access it. Typically, it is optimal to close the database in the of the calling Activity.\n\nThe Android SDK includes a shell tool that allows you to browse table contents, run SQL commands, and perform other useful functions on SQLite databases. For more information, see how to how to issue shell commands."
    },
    {
        "link": "https://developer.android.com/reference/android/database/sqlite/SQLiteDatabase",
        "document": "SQLiteDatabase has methods to create, delete, execute SQL commands, and perform other common database management tasks.\n\nSee the Notepad sample application in the SDK for an example of creating and managing a database.\n\nDatabase names must be unique within an application, not across all applications.\n\nIn addition to SQLite's default collator, Android supplies two more, , which changes with the system's current locale, and , which is the Unicode Collation Algorithm and not tailored to the current locale.\n\nBegins a transaction in DEFERRED mode, with the android-specific constraint that the transaction is read-only. Convenience method for deleting rows in the database. Deletes a database including its journal file and other auxiliary files that may have been created by the database engine. This method disables the features enabled by . This method enables parallel execution of queries from multiple threads on the same database. Execute the given SQL statement on all connections to this database. Execute a single SQL statement that is NOT a SELECT or any other SQL statement that returns data. Execute a single SQL statement that is NOT a SELECT/INSERT/UPDATE/DELETE. Finds the name of the first table, which is editable. Returns list of full pathnames of all attached databases including the main database by executing 'pragma database_list' on the database. Return the number of database rows that were inserted, updated, or deleted by the most recent SQL statement within the current transaction. Return the \"rowid\" of the last row to be inserted on the current connection. Returns the maximum size the database may grow to. Gets the path to the database file. This method was deprecated in API level 15. This method no longer serves any useful purpose and has been deprecated. Return the total number of database rows that have been inserted, updated, or deleted on the current connection since it was created. Returns true if the current thread has a transaction pending. Convenience method for inserting a row into the database. Convenience method for inserting a row into the database. General method for inserting a row into the database. Runs 'pragma integrity_check' on the given database (and all the attached databases) and returns true if the given database (and all its attached databases) pass integrity_check, false otherwise. Returns true if the current thread is holding an active connection to the database. This method was deprecated in API level 16. Always returns false. Do not use this method. Returns true if the database is currently open. Returns true if the database is opened as read only. Returns true if write-ahead logging has been enabled for this database. This method was deprecated in API level 15. This method no longer serves any useful purpose and has been deprecated. This method was deprecated in API level 15. This method no longer serves any useful purpose and has been deprecated. Returns true if the new version code is greater than the current database version. Open the database according to the flags and/or . Open the database according to the specified Open the database according to the flags and/or . Query the given URL, returning a over the result set. Query the given table, returning a over the result set. Query the given URL, returning a over the result set. Query the given table, returning a over the result set. Query the given URL, returning a over the result set. Query the given URL, returning a over the result set. Runs the provided SQL and returns a over the result set. Runs the provided SQL and returns a over the result set. Runs the provided SQL and returns a cursor over the result set. Runs the provided SQL and returns a cursor over the result set. Attempts to release memory that SQLite holds but does not require to operate properly. Convenience method for replacing a row in the database. Convenience method for replacing a row in the database. Register a custom aggregate function that can be called from SQL expressions. Register a custom scalar function that can be called from SQL expressions. Sets whether foreign key constraints are enabled for the database. Sets the locale for this database. This method was deprecated in API level 16. This method now does nothing. Do not use. Sets the maximum size of the prepared-statement cache for this database. Sets the maximum size the database will grow to. Convenience method for updating rows in the database. Convenience method for updating rows in the database. Verifies that a SQL SELECT statement is valid by compiling it. This method was deprecated in API level 15. if the db is locked more than once (because of nested transactions) then the lock will not be yielded. Use yieldIfContendedSafely instead. Temporarily end the transaction to let other threads run. Temporarily end the transaction to let other threads run.\n\n[[[\"Easy to understand\",\"easyToUnderstand\",\"thumb-up\"],[\"Solved my problem\",\"solvedMyProblem\",\"thumb-up\"],[\"Other\",\"otherUp\",\"thumb-up\"]],[[\"Missing the information I need\",\"missingTheInformationINeed\",\"thumb-down\"],[\"Too complicated / too many steps\",\"tooComplicatedTooManySteps\",\"thumb-down\"],[\"Out of date\",\"outOfDate\",\"thumb-down\"],[\"Samples / code issue\",\"samplesCodeIssue\",\"thumb-down\"],[\"Other\",\"otherDown\",\"thumb-down\"]],[\"Last updated 2025-02-10 UTC.\"],[],[]]"
    },
    {
        "link": "https://sqlite.org/android",
        "document": "The SQLite library is a core part of the Android environment. Java applications and content providers access SQLite using the interface in the android.database.sqlite namespace.\n\nFor most applications, this is convenient and works well. However, it means that applications must be content with the SQLite version and build installed on the target device as part of the operating system. If your application happens to require a newer version of SQLite, or a build with a custom extension or VFS installed, you're out of luck.\n\nOne solution is to bundle the SQLite library directly into the application, bypassing the version built-in to Android. This project, the SQLite Android bindings, provides an easy way to do just that. This allows an application to use a custom build or version of SQLite, regardless of the Android version to which it is deployed, while continuing to use the standard Android interface.\nâ€¢ Installation Guide - this page describes the various ways the SQLite Android bindings may be integrated with an application.\nâ€¢ Application Programming - this page describes the very minor code modifications required to use the SQLite Android bindings instead of Android's built-in SQLite support.\nâ€¢ Using the Simple Encryption Extension (SEE) - extra notes regarding the use of the proprietary encryption extension SEE."
    },
    {
        "link": "https://sqlite.org/docs.html",
        "document": ""
    },
    {
        "link": "https://quora.com/Can-you-use-SQLite-from-an-Android-app-written-in-Java-without-learning-SQLite-directly",
        "document": "Something went wrong. Wait a moment and try again."
    },
    {
        "link": "https://developer.android.com/training/data-storage/shared-preferences",
        "document": "If you have a relatively small collection of key-values that you'd like to save, you can use the APIs. A object points to a file containing key-value pairs and provides simple methods to read and write them. Each file is managed by the framework and can be private or shared.\n\nThis page shows you how to use the APIs to store and retrieve simple values.\n\nCaution: is a modern data storage solution that you should use instead of . It builds on Kotlin coroutines and Flow, and overcomes many of the drawbacks of . is a modern data storage solution that you should use instead of. It builds on Kotlin coroutines and Flow, and overcomes many of the drawbacks of Read the DataStore guide for more information.\n\nYou can create a new shared preference file or access an existing one by calling one of these methods:\nâ€¢ : Use this if you need multiple shared preference files identified by name, which you specify with the first parameter. You can call this from any in your app.\nâ€¢ : Use this from an if you need to use only one shared preference file for the activity. Because this retrieves a default shared preference file that belongs to the activity, you don't need to supply a name.\n\nFor example, the following code accesses the shared preferences file that's identified by the resource string and opens it using the private mode so the file is accessible by only your app:\n\nWhen naming your shared preference files, you should use a name that's uniquely identifiable to your app. A good way to do this is prefix the file name with your application ID. For example:\n\nAlternatively, if you need just one shared preference file for your activity, you can use the method:\n\nIf you're using the API to save app settings, you should instead use to get the default shared preference file for your entire app. For more information, see the Settings developer guide.\n\nTo write to a shared preferences file, create a by calling on your .\n\nPass the keys and values you want to write with methods such as: and . Then call or to save the changes. For example:\n\nchanges the in-memory object immediately but writes the updates to disk asynchronously. Alternatively, you can use to write the data to disk synchronously. But because is synchronous, you should avoid calling it from your main thread because it could pause your UI rendering.\n\nTo retrieve values from a shared preferences file, call methods such as and , providing the key for the value you want, and optionally a default value to return if the key isn't present. For example:"
    },
    {
        "link": "https://mobterest.medium.com/exploring-data-persistence-a-comprehensive-guide-c7e9b4a8bfd4",
        "document": "Data persistence is a crucial aspect of modern application development. It refers to the ability of an application to store and retrieve data even after the application is closed or the device is restarted. Data persistence ensures that valuable user information, settings, and application state are preserved, providing a seamless user experience across sessions. In this article, we will delve into the concept of data persistence and explore various approaches and examples in Android, Swift (iOS), and Flutter (cross-platform) development.\n\nData persistence involves the storing and retrieval of data in a way that allows it to be accessed beyond the current session. There are several common scenarios where data persistence is essential:\n\nStoring and retrieving user-specific preferences, such as theme selection, language preferences, or notification settings.\n\nPreserving the state of the application, such as the current screen, progress in a game, or unsaved data in a form.\n\nCaching data from remote servers, enabling offline access and improved performance. This is particularly important for applications with dynamic content like news readers or social media apps.\n\nStoring structured data locally, such as user profiles, product catalogs, or chat history.\n\nNow letâ€™s explore examples of data persistence in Android, Swift, and Flutter.\n\nAndroid provides several mechanisms for data persistence:\n\nThis mechanism allows storing key-value pairs in a private XML file. It is suitable for storing small amounts of data, such as user preferences. The SharedPreferences API in Android simplifies the process of reading and writing values.\n\nAndroid includes SQLite, a powerful and lightweight relational database. It allows developers to create, read, update, and delete structured data. SQLite is well-suited for applications that require complex data structures and querying capabilities.\n\nRoom is an abstraction layer over SQLite that simplifies database access in Android. It provides an object-relational mapping (ORM) approach, enabling developers to work with strongly-typed entities and perform database operations using intuitive annotations.\n\nWhen developing iOS applications using Swift, there are several options for data persistence:\n\nSimilar to Androidâ€™s Shared Preferences, User Defaults provides an interface to store small amounts of user-specific data. It uses the UserDefaults class to store key-value pairs persistently.\n\nCore Data is a powerful framework that allows developers to manage object graphs and persist data in iOS applications. It provides a high-level API for storing, querying, and managing data in a SQLite database or other persistent storage formats.\n\nRealm is an alternative to Core Data that offers a more straightforward and modern approach to data persistence. It provides a cross-platform, object-oriented database that can be used with Swift and other languages. Realm simplifies database operations and offers real-time synchronization across devices.\n\nFlutter, being a cross-platform framework, leverages the native persistence mechanisms of the underlying platforms. Here are a few common options:\n\nFlutter provides plugins that allow developers to access the platform-specific shared preferences mechanism. These plugins offer a unified API to store and retrieve small amounts of data.\n\nFlutter provides plugins for SQLite that allow developers to create and interact with a local SQLite database. These plugins provide a convenient way to manage structured data in Flutter applications.\n\nIsar is a high-performance, NoSQL database built specifically for Flutter. It offers a simple and efficient way to store and retrieve data in Flutter applications. Isar is designed to be fast, scalable, and easy to use, making it a suitable choice for various use cases.\n\nData persistence is a critical aspect of application development, ensuring that important user information and application state are preserved across sessions. How do you persist data?\n\nSee you on next article ðŸ‘‹"
    },
    {
        "link": "https://stackoverflow.com/questions/8855069/android-sharedpreferences-best-practices",
        "document": "In an application I have been building we rely on SharedPreferences quite a bit, this got me thinking about what is best practice when it comes to accessing SharedPreferences. For instance many people say the appropriate way to access it is via this call:\n\nHowever it seems like this could be dangerous. If you have a large application that is relying on SharedPreferences you could have key duplication, especially in the case of using some third party library that relies on SharedPreferences as well. It seems to me that the better call to use would be:\n\nThis way if you have a class that heavily relies on SharedPreferences you can create a preference file that is used only by your class. You could use the fully qualified name of the class to ensure that the file will most likely not be duplicated by someone else.\n\nAlso based on this SO question: Should accessing SharedPreferences be done off the UI Thread?, it seems that accesses SharedPreferences should be done off the UI thread which makes sense.\n\nAre there any other best practices Android developers should be aware of when using SharedPreferences in their applications?"
    },
    {
        "link": "https://jointaro.com/interview-insights/meta/how-would-you-persist-data-between-sessions-in-android-considering-different-storage-options-and-their-trade-offs",
        "document": "When building Android applications, persisting data between sessions is crucial for providing a seamless user experience. This ensures that user data is retained even when the app is closed or the device is restarted. Several methods can be employed, each with its own trade-offs. Let's explore these strategies in the context of a simple note-taking app.\n\nShared Preferences is a simple and convenient way to store small amounts of primitive data, such as user preferences or app settings. It stores data in key-value pairs within an XML file.\n\nTo use Shared Preferences, you can use the following code:\n\nTo retrieve the data, you can use:\n\nShared Preferences are not suitable for storing large datasets or complex data structures. It is best used for simple data like boolean flags, integer values, or short strings. For more complex data, other storage options should be considered.\n\nInternal storage allows you to save files directly on the device's internal memory. These files are private to your application and are not accessible by other apps.\n\nTo manage file organization, create directories within the app's internal storage. For data security, internal storage is generally secure as files are private to the app. However, consider encrypting sensitive data for added protection.\n\nExternal storage refers to the device's SD card or external memory. It is typically used for storing large files or data that needs to be shared between apps. However, it comes with certain considerations.\n\nTo access external storage, you need to request the permission in your file. Additionally, since external storage is user-accessible, there's a risk of data removal by the user or other apps. Therefore, it's essential to handle data carefully and consider using encryption for sensitive information.\n\nFor structured data, such as a list of notes with titles, content, and timestamps, an SQLite database is an excellent choice. It allows you to store data in tables and perform CRUD operations.\nâ€¢ public class NoteDataSource { private SQLiteDatabase database; private NoteDatabaseHelper dbHelper; private String[] allColumns = {NoteDatabaseHelper.COLUMN_ID, NoteDatabaseHelper.COLUMN_TITLE, NoteDatabaseHelper.COLUMN_CONTENT, NoteDatabaseHelper.COLUMN_TIMESTAMP}; public NoteDataSource(Context context) { dbHelper = new NoteDatabaseHelper(context); } public void open() throws SQLException { database = dbHelper.getWritableDatabase(); } public void close() { dbHelper.close(); } public Note createNote(String title, String content) { ContentValues values = new ContentValues(); values.put(NoteDatabaseHelper.COLUMN_TITLE, title); values.put(NoteDatabaseHelper.COLUMN_CONTENT, content); values.put(NoteDatabaseHelper.COLUMN_TIMESTAMP, System.currentTimeMillis()); long insertId = database.insert(NoteDatabaseHelper.TABLE_NOTES, null, values); Cursor cursor = database.query(NoteDatabaseHelper.TABLE_NOTES, allColumns, NoteDatabaseHelper.COLUMN_ID + \" = \" + insertId, null, null, null, null); cursor.moveToFirst(); Note newNote = cursorToNote(cursor); cursor.close(); return newNote; } public void deleteNote(Note note) { long id = note.getId(); database.delete(NoteDatabaseHelper.TABLE_NOTES, NoteDatabaseHelper.COLUMN_ID + \" = \" + id, null); } public List<Note> getAllNotes() { List<Note> notes = new ArrayList<>(); Cursor cursor = database.query(NoteDatabaseHelper.TABLE_NOTES, allColumns, null, null, null, null, null); cursor.moveToFirst(); while (!cursor.isAfterLast()) { Note note = cursorToNote(cursor); notes.add(note); cursor.moveToNext(); } cursor.close(); return notes; } private Note cursorToNote(Cursor cursor) { Note note = new Note(); note.setId(cursor.getLong(0)); note.setTitle(cursor.getString(1)); note.setContent(cursor.getString(2)); note.setTimestamp(cursor.getLong(3)); return note; } }\n\nFor user data that needs to be accessible across multiple devices, network storage using a cloud-based solution like Firebase or a custom API is necessary.\nâ€¢ \nâ€¢ Set up a Firebase project and add the Firebase SDK to your Android app.\nâ€¢ Use Firebase APIs to read and write data to the Realtime Database.\nâ€¢ \nâ€¢ Create a REST API using a backend framework like Node.js, Django, or Spring Boot.\nâ€¢ Use Retrofit or Volley in your Android app to communicate with the API.\nâ€¢ Security: Secure your API with authentication and authorization mechanisms.\nâ€¢ Offline Access: Use local caching or offline storage to allow users to access data even when they are not connected to the internet.\n\nThe choice of data persistence method depends on several factors:\nâ€¢ Data Complexity: Simple data can be stored in Shared Preferences, while complex and structured data requires an SQLite database or network storage.\nâ€¢ Data Size: For large files or multimedia content, internal or external storage is suitable.\nâ€¢ Data Sharing: If data needs to be shared between apps or devices, external storage or network storage is necessary.\nâ€¢ Security: Sensitive data should be encrypted and stored securely, either in internal storage, SQLite database, or a secure cloud storage solution.\nâ€¢ Offline Access: If the app needs to work offline, data should be cached locally.\n\nBy carefully considering these factors, you can choose the most appropriate data persistence method for your Android application."
    },
    {
        "link": "https://geeksforgeeks.org/shared-preferences-in-android-with-examples",
        "document": "One of the most Interesting Data Storage options Android provides its users is Shared Preferences. Shared Preferences is the way in which one can store and retrieve small amounts of primitive data as key/value pairs to a file on the device storage such as String, int, float, Boolean that make up your preferences in an XML file inside the app on the device storage. Shared Preferences can be thought of as a dictionary or a key/value pair. For example, you might have a key being â€œusernameâ€ and for the value, you might store the userâ€™s username. And then you could retrieve that by its key (here username). You can have a simple shared preference API that you can use to store preferences and pull them back as and when needed. The shared Preferences class provides APIs for reading, writing, and managing this data. A sample GIF is given below to get an idea about what we are going to do in this article.\n\nShared Preferences are suitable for different situations. For example, when the userâ€™s settings need to be saved or to store data that can be used in different activities within the app. As you know, onPause() will always be called before your activity is placed in the background or destroyed, So for the data to be saved persistently, itâ€™s preferred to save it in onPause(), which could be restored in onCreate() of the activity. The data stored using shared preferences are kept private within the scope of the application. However, shared preferences are different from that activityâ€™s instance state.\n\nHow are Shared Preferences different from Saved Instance State?\n\nThe first thing we need to do is to create one shared preferences file per app. So name it with the package name of your app- unique and easy to associate with the app. When you want to get the values, call the getSharedPreferences() method. Shared Preferences provide modes of storing the data (private mode and public mode). It is for backward compatibility- use only MODE_PRIVATE to be secure.\nâ€¢ SharedPreferences.Editor : Interface used to write(edit) data in the SP file. Once editing has been done, one must commit() apply() the changes made to the file.\nâ€¢ SharedPreferences.OnSharedPreferenceChangeListener() : Called when a shared preference is changed, added, or removed. This may be called even if a preference is set to its existing value. This callback will be run on your main thread.\nâ€¢ contains(String key) : This method is used to check whether the preferences contain a preference.\nâ€¢ edit() : This method is used to create a new Editor for these preferences, through which you can make modifications to the data in the preferences and atomically commit those changes back to the SharedPreferences object.\nâ€¢ getAll() : This method is used to retrieve all values from the preferences.\nâ€¢ getBoolean(String key, boolean defValue) : This method is used to retrieve a boolean value from the preferences.\nâ€¢ getFloat(String key, float defValue) : This method is used to retrieve a float value from the preferences.\nâ€¢ getInt(String key, int defValue) : This method is used to retrieve an int value from the preferences.\nâ€¢ getLong(String key, long defValue) : This method is used to retrieve a long value from the preferences.\nâ€¢ getString(String key, String defValue) : This method is used to retrieve a String value from the preferences.\nâ€¢ getStringSet(String key, Set defValues) : This method is used to retrieve a set of String values from the preferences.\nâ€¢ registerOnSharedPreferencechangeListener(SharedPreferences.OnSharedPreferencechangeListener listener) : This method is used to register a callback to be invoked when a change happens to a preference.\nâ€¢ unregisterOnSharedPreferencechangeListener(SharedPreferences.OnSharedPreferencechangeListener listener) : This method is used to unregister a previous callback.\n\nIf you donâ€™t know how to create a new project in Android Studio then you can refer to How to Create/Start a New Project in Android Studio?\n\nBelow is the small demo for Shared Preferences. In this particular demo, there are two EditTexts, which save and retain the data entered earlier in them. This type of feature can be seen in applications with forms. Using Shared Preferences, the user will not have to fill in details again and again. Invoke the following code inside the activity_main.xml file to implement the UI.\n\nThis file will be used to handle the two of the EditText to save the data entered by the user inside the SharedPreferences. Below is the code for the MainActivity file. Comments are added inside the code to understand the code in more detail."
    },
    {
        "link": "https://medium.com/@mustafamalik1310/creating-a-login-register-page-using-android-studio-e1b32e5354e9",
        "document": "The frontend part of both the Login and the Register Page will be created using XML.So first we go on with creating the Login Page.\n\nFor creating the Login Page go to res/layout then right-click on layout and then New/Activity/Empty Activity.\nâ€¢ The first step is to change the layout to a linear layout. This is done as follows:\n\n2. Download the required png file which has to be used as an image and copy the image in res/drawable. Save the file and use the following code:\n\n3. Now we have to create a text field to take the Email-Id as input:\n\n4. Similarly, we create another text field to take the password as the input as follows:\n\n5. After creating the fields for the inputs we go for creating the buttons. There are three buttons being used in the login page which are:\n\nThe given image shows the user interface of the Login Page:\n\nNow we are completed with the Login Page and we move forward with creating the UI of the Signup Page.\n\nFor creating the signup page go to res/layout then right-click on layout and then New/Activity/Empty Activity.\nâ€¢ The first step is to change the layout to a linear layout:\n\n2. The text fields to take the inputs are created as follows:\n\n3. The next step is to create the radio buttons to take the gender as the input:\n\n4. The final step is to create the register button and the design is completed.\n\nThe Signup Page looks like this:"
    },
    {
        "link": "https://stackoverflow.com/questions/9867142/design-login-and-register-page-using-android-tabs",
        "document": "I would use the Android API Support Library and the sample located at http://developer.android.com/resources/samples/Support4Demos/src/com/example/android/supportv4/app/FragmentTabsPager.html\n\nYou would have two tabs, corresponding to two that you could name RegisterFragment and LoginFragment.\n\nBasically you would remove the lines\n\nand replace them with\n\nThen you implement those Fragments and integrate this code into your Activity. You'll also need to integrate the fragment_tabs_pager.xml layout into your layout."
    },
    {
        "link": "https://developer.android.com/studio/write/layout-editor",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nThe Layout Editor enables you to quickly build -based layouts by dragging UI elements into a visual design editor instead of writing layout XML. The design editor can preview your layout on different Android devices and versions, and you can dynamically resize the layout to be sure it works properly on different screen sizes.\n\nThe Layout Editor is especially powerful when building a layout with .\n\nThis page provides an overview of the Layout Editor. To learn more about layout fundamentals, see Layouts.\n\nThe Layout Editor appears when you open an XML layout file.\nâ€¢ Palette: contains various views and view groups that you can drag into your layout.\nâ€¢ Component Tree: shows the hierarchy of components in your layout.\nâ€¢ Toolbar: has buttons that configure your layout appearance in the editor and change layout attributes.\nâ€¢ Design editor: lets you edit your layout in Design view, Blueprint view, or both.\nâ€¢ Attributes: has controls for the selected view's attributes.\nâ€¢ View mode: lets you view your layout in either Code , Split , or Design modes. Split mode shows the Code and Design windows at the same time.\nâ€¢ Zoom and pan controls: control the preview size and position within the editor.\n\nWhen you open an XML layout file, the design editor opens by default, as shown in figure 1. To edit the layout XML in the text editor, click the Code button in the top-right corner of the window. Note that the Palette, Component Tree, and Attributes panels are not available while editing your layout in Code view.\n\nTip: To switch between design and text editors, press ( on macOS) plus and the right or left arrow key.\n\nThe buttons in the top row of the design editor let you configure the appearance of your layout in the editor.\nâ€¢ Design and Blueprint: Select how you want to view your layout in the editor. You can also press to cycle through these view types.\nâ€¢ Choose Design to see a rendered preview of your layout.\nâ€¢ Choose Blueprint to see only outlines for each view.\nâ€¢ Choose Design + Blueprint to see both views side by side.\nâ€¢ Screen orientation and layout variants: Choose between landscape or portrait screen orientation or choose other screen modes that your app provides alternative layouts for, such as night mode. This menu also contains commands for creating a new layout variant, as described in a section on this page. You can also press the letter on your keyboard to change orientation.\nâ€¢ None System UI Mode: If you've enabled dynamic color in your app, switch wallpapers and see how your layouts react to different users chosen wallpaper. Note that you must first change the theme to a Material dynamic color theme, then change the wallpaper.\nâ€¢ None Device type and size: Select the device type (phone/tablet, Android TV, or Wear OS) and screen configuration (size and density). You can select from several pre-configured device types and your own AVD definitions, and you can create a new AVD by selecting Add Device Definition from the list, as shown in figure 3.\nâ€¢ To resize the device, drag the bottom-right corner of the layout.\nâ€¢ Press to cycle through the device list. Testing your layout against the Reference Devices in this menu helps your app scale well to layout states on real devices.\nâ€¢ None API version: Select the version of Android to preview your layout. The list of available Android versions depends on which SDK platform versions you have installed using SDK Manager.\nâ€¢ None App theme: Select which UI theme to apply to the preview. This works only for supported layout styles, so many themes in this list result in an error.\nâ€¢ None Language: Select the language to show for your UI strings. This list displays only the languages available in your string resources. If you'd like to edit your translations, click Edit Translations from the menu. For more information on working with translations, see Localize the UI with Translations Editor.\n\nWhen adding a new layout for your app, first create a default layout file in your project's default directory so that it applies to all device configurations. Once you have a default layout, you can create layout variations, as described in a section on this page, for specific device configurations, such as for large screens.\n\nYou can create a new layout in one of the following ways:\nâ€¢ In the Project window, click the module you want to add a layout to.\nâ€¢ In the main menu, select File > New > XML > Layout XML File.\nâ€¢ In the dialog that appears, provide the filename, the root layout tag, and the source set where the layout belongs.\nâ€¢ Choose the Project view from within the Project window.\nâ€¢ Right-click the layout directory where you'd like to add the layout.\nâ€¢ In the context menu that appears, click New > Layout Resource File.\nâ€¢ Choose the Android view from within the Project window.\nâ€¢ In the context menu that appears, select New > Layout Resource File.\nâ€¢ In the Resource Manager, select the Layout tab.\nâ€¢ Click the button, and then click Layout Resource File.\n\nUse layout variants to optimize for different screens\n\nA layout variant is an alternative version of an existing layout that is optimized for a certain screen size or orientation.\n\nAndroid Studio includes common layout variants that you can use in your project. To use a suggested layout variant, do the following:\nâ€¢ Click the Design icon in the top-right corner of the window.\nâ€¢ The name of the layout file appears in the Action to switch and create qualifiers for layout files drop-down. Select the drop-down.\nâ€¢ In the drop-down list, select a variant such as Create Landscape Qualifier or Create Tablet Qualifier.\n\nIf you'd like to create your own layout variant, do the following:\nâ€¢ Click the Design icon in the top-right corner of the window.\nâ€¢ The name of the layout file appears in the Action to switch and create qualifiers for layout files drop-down. Select the drop-down.\nâ€¢ None In the drop-down list, select Add Resource Qualifier. (See figure 4 above.)\nâ€¢ None In the Select Resource Directory dialog, define the resource qualifiers for the variant:\nâ€¢ Select a qualifier from the Available qualifiers list.\nâ€¢ Repeat these steps to add other qualifiers.\nâ€¢ None Once you've added all of your qualifiers, click OK.\n\nWhen you have multiple variations of the same layout, you can switch between them by selecting a variant from the Action to switch and create qualifiers for layout files drop-down.\n\nFor more information about how to create layouts for different displays, see Support different display sizes.\n\nYou can convert a view to another kind of view, and you can convert a layout to another kind of layout:\nâ€¢ Click the Design button in the top-right corner of the editor window.\nâ€¢ In the Component Tree, right-click the view or layout, and then click Convert view.\nâ€¢ In the dialog that appears, choose the new type of view or layout, and then click Apply.\n\nFor improved layout performance, convert older layouts to . uses a constraint-based layout system that lets you build most layouts without any nested view groups.\n\nTo convert an existing layout to a , do the following:\nâ€¢ Click the Design icon in the top-right corner of the editor window.\nâ€¢ In the Component Tree, right-click the layout, and then click Convert to ConstraintLayout.\n\nTo learn more about , see Build a Responsive UI with ConstraintLayout.\n\nTo search for a view or view group by name in the Palette, click the Search button at the top of the palette. Alternatively, you can type the name of the item whenever the Palette window has focus.\n\nIn the Palette, you can find frequently used items in the Common category. To add an item to this category, right-click a view or view group in the Palette and then click Favorite in the context menu.\n\nTo open the Android Developers reference documentation for a view or view group, select the UI element in the Palette and press + .\n\nTo view Material Guidelines documentation for a view or view group, right-click the UI element in the Palette and select Material Guidelines from the context menu. If no specific entry exists for the item, then the command opens the homepage of the Material Guidelines documentation.\n\nTo start building your layout, drag views and view groups from the Palette into the design editor. As you place a view in the layout, the editor displays information about the view's relationship with the rest of the layout.\n\nIf you are using , you can automatically create constraints using the Infer Constraints and Autoconnect features.\n\nYou can edit view attributes from the Attributes panel in the Layout Editor. This window is available only when the design editor is open, so view your layout in either Design or Split mode to use it.\n\nWhen you select a view, whether by clicking the view in the Component Tree or in the design editor, the Attributes panel shows the following, as indicated in figure 5:\nâ€¢ Declared Attributes: Lists attributes specified in the layout file. To add an attribute, click the Add button at the top of the section.\nâ€¢ Layout: Contains controls for the width and height of the view. If the view is in a , this section also shows constraint bias and lists the constraints that the view uses. For more information on controlling the size of views with , see Adjust the view size.\nâ€¢ Common Attributes: Lists common attributes for the selected view. To see all available attributes, expand the All Attributes section at the bottom of the window.\nâ€¢ None The icons to the right of each attribute value indicate whether the attribute values are resource references. These indicators are solid when the value is a resource reference and empty when the value is hardcoded to help you recognize hardcoded values at a glance. Click indicators in either state to open the Resources dialog, where you can select a resource reference for the corresponding attribute.\nâ€¢ None A red highlight around an attribute value indicates an error with the value. For example, an error might indicate an invalid entry for a layout-defining attribute. An orange highlight indicates a warning for the value. For example, a warning might appear when you use a hardcoded value where a resource reference is expected.\n\nBecause many Android layouts rely on runtime data, it can be difficult to visualize the look and feel of a layout while designing your app. You can add sample preview data to a , an , or a from within the Layout Editor.\n\nTo display the Design-time View Attributes window, right-click one of these view types and choose Set Sample Data, as shown in figure 6.\n\nFor a , you can choose between different sample text categories. When using sample text, Android Studio populates the attribute of the with your chosen sample data. Note that you can choose sample text via the Design-time View Attributes window only if the attribute is empty.\n\nFor an , you can choose between different sample images. When you choose a sample image, Android Studio populates the attribute of the (or if using AndroidX).\n\nFor a , you can choose from a set of templates that contain sample images and texts. When using these templates, Android Studio adds a file to your directory, , that contains the layout for the sample data. Android Studio also adds metadata to the to properly display the sample data.\n\nThe Layout Editor notifies you of any layout issues next to the corresponding view in the Component Tree by using a red circle exclamation icon for errors or an orange triangle exclamation icon for warnings. Click the icon to see more details.\n\nTo see all known issues in a window below the editor, click Show Warnings and Errors ( or ) in the toolbar.\n\nDownload fonts and apply them to text\n\nWhen using Android 8.0 (API level 26) or the Jetpack Core library, you can select from hundreds of fonts by following these steps:\nâ€¢ In the Layout Editor, click the Design icon to view your layout in the design editor.\nâ€¢ In the Attributes panel, expand textAppearance, and then expand the fontFamily box.\nâ€¢ Scroll to the bottom of the list and click More Fonts to open the Resources dialog.\nâ€¢ In the Resources dialog, to select a font, browse the list or type into the search bar at the top. If you select a font under Downloadable, then you can either click Create downloadable font to load the font at runtime as a downloadable font or click Add font to project to package the TTF font file in your APK. The fonts listed under Android are provided by the Android system, so they don't need to be downloaded or bundled in your APK.\n\nLayout Validation is a visual tool for simultaneously previewing layouts for different devices and display configurations, helping you catch problems in your layouts earlier in the process. To access this feature, click the Layout Validation tab in the top-right corner of the IDE window:\n\nTo switch between the available configuration sets, select one of the following from the Reference Devices drop-down at the top of the Layout Validation window:\n\nReference devices are a set of devices that we recommend you test against. They include phone, foldable, tablet, and desktop interfaces. You should preview how your layout appears on this set of reference devices:\n\nTo customize a display configuration to preview, choose from a variety of settings including language, device, or screen orientation:\n\nTo help make your app more accessible for users who are color blind, validate your layout with simulations of common types of color blindness:\n\nValidate your layouts at various font sizes, and improve your app's accessibility for visually impaired users by testing your layouts with larger fonts:"
    },
    {
        "link": "https://geeksforgeeks.org/user-registration-in-android-using-back4app",
        "document": "Prerequisite: How to Connect Android App with Back4App?\n\nWe have seen adding Back4App in our Android App. In this article, we will take a look at adding a User Registration form in Android App so that users can register themselves in the app.\n\nWhat we are going to build in this article?\n\nWe will be building a simple application in which we will be adding a simple user registration form so that users can register themselves with their username and password. Below is the video in which we will get to see what we are going to build in this article.\n\nThis article is the continuation of How to Connect Android App with Back4App.\n\nNavigate to the app > res > layout > activity_main.xml and add the below code to that file. Below is the code for the activity_main.xml file.\n\nStep 2: Creating a new activity to redirect our user after registration\n\nNavigate to the app > java > your appâ€™s package name > Right-click on it > New > Empty Activity and name it as HomeActivity. or you may also refer to this article How to Create New Activity in Android Studio?\n\nNavigate to the app > res > layout > activity_home.xml file and add the below code to it.\n\nNavigate to the app > java > your appâ€™s package name > HomeActivity.java file and add the below code to it. Comments are added inside the code to understand the code in more detail.\n\nGo to the MainActivity.java file and refer to the following code. Below is the code for the MainActivity.java file. Comments are added inside the code to understand the code in more detail.\n\nNow run your app and see the output of the app.\n\nCheck out the project on the below link: https://github.com/ChaitanyaMunje/GFG-Back4App/tree/RegisterUser"
    },
    {
        "link": "https://medium.com/@rake_code/how-to-create-a-simple-login-and-registration-app-in-android-studio-that-displays-username-using-674f21a0c208",
        "document": "Firebase was created by google to simplify processes that involved databases. Instead of writing SQL codes, developers could use firebase to simplify their processes. Firebase can be used for authentication and data storage. In this tutorial we will focus on authentication that involves user email and password. Though other forms exist, like google, facebook and twitter login amongst others. We will stick with the email and password for now. You can check my timeline for the other tutorials. For complete beginners donâ€™t worry I have uploaded the source code on github and have riddled my code with comments to help you better understand. Before commencing this tutorial make sure you have hooked up your project to firebase.\n\nFirst we will create a welcome page in xml. The page will consist of two buttons. A login and signup button. I used a constraint layout as the default layout. The code is below with comments. The comments are marked by a â€œ//â€ in front. You might notice that the buttons have a background. We will be creating a background button for the signup and login. For the login button we will create an xml file under the drawable folder and name it get.\n\nFor the signup button we follow the steps we used to create the get.xml file and input the following code. we will call the xml file transaprent\n\nIn our activity.main input the following code.\n\nIn the MainActivity. Java we type in the following\n\nwe will create a new activity and call it login. In the login.xml we type in the following\n\nIn the login.java we will type in the following.\n\npackage com.example.logintask;\n\n\n\n\n\n\n\nimport android.content.Intent;\n\n\n\nimport android.support.annotation.NonNull;\n\n\n\nimport android.support.v7.app.AppCompatActivity;\n\n\n\nimport android.os.Bundle;\n\n\n\nimport android.view.View;\n\n\n\nimport android.widget.Button;\n\n\n\nimport android.widget.EditText;\n\n\n\nimport android.widget.ProgressBar;\n\n\n\nimport android.widget.Toast;\n\n\n\n\n\n\n\nimport com.google.android.gms.tasks.OnCompleteListener;\n\n\n\nimport com.google.android.gms.tasks.Task;\n\n\n\nimport com.google.firebase.auth.AuthResult;\n\n\n\nimport com.google.firebase.auth.FirebaseAuth;\n\n\n\nimport com.google.firebase.auth.FirebaseUser;\n\n\n\n\n\n\n\npublic class login extends AppCompatActivity {\n\n\n\n\n\n\n\n FirebaseAuth firebaseAuth;\n\n\n\n EditText etmail;\n\n\n\n EditText etPassword;\n\n\n\n Button btnLogin;\n\n\n\n Button btnRegister;\n\n\n\n private FirebaseAuth.AuthStateListener authStateListener;\n\n\n\n ProgressBar progressBar;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n @Override\n\n\n\n protected void onCreate(Bundle savedInstanceState) {\n\n\n\n super.onCreate(savedInstanceState);\n\n\n\n setContentView(R.layout.activity_login);\n\n\n\n\n\n\n\n firebaseAuth = FirebaseAuth.getInstance();\n\n\n\n etmail = (EditText) findViewById(R.id.etemail);\n\n\n\n etPassword = (EditText) findViewById(R.id.etpassword);\n\n\n\n btnLogin = (Button) findViewById(R.id.btnlogin);\n\n\n\n btnRegister = (Button) findViewById(R.id.btnsignup);\n\n\n\n progressBar = (ProgressBar) findViewById(R.id.progressLog);\n\n\n\n // checks whether the user is logged in and executes the code\n\n\n\n authStateListener = new FirebaseAuth.AuthStateListener() {\n\n\n\n @Override\n\n\n\n public void onAuthStateChanged(@NonNull FirebaseAuth firebaseAuth) {\n\n\n\n FirebaseUser firebaseUser = firebaseAuth.getCurrentUser();\n\n\n\n if (firebaseUser != null){\n\n\n\n Toast.makeText(login.this, \"Login Successful\", Toast.LENGTH_SHORT).show();\n\n\n\n Intent home = new Intent(login.this, dashboard.class);\n\n\n\n startActivity(home);\n\n\n\n }\n\n\n\n else{\n\n\n\n Toast.makeText(login.this, \"Please Login\", Toast.LENGTH_SHORT).show();\n\n\n\n }\n\n\n\n }\n\n\n\n };\n\n\n\n\n\n\n\n btnLogin.setOnClickListener(new View.OnClickListener() {\n\n\n\n @Override\n\n\n\n public void onClick(View v){\n\n\n\n\n\n\n\n String email = etmail.getText().toString(); // gets the user email\n\n\n\n String password = etPassword.getText().toString();\n\n\n\n\n\n\n\n if (email.isEmpty()){\n\n\n\n etmail.setError(\"PLEASE ENTER EMAIL ADDRESS\");\n\n\n\n etmail.requestFocus();\n\n\n\n }\n\n\n\n else if (password.isEmpty()){\n\n\n\n etPassword.setError(\"PLEASE INPUT PASSWORD\");\n\n\n\n etPassword.requestFocus();\n\n\n\n }\n\n\n\n else if (email.isEmpty() && password.isEmpty()){\n\n\n\n Toast.makeText(login.this, \" BOTH FIELDS ARE EMPTY!!\", Toast.LENGTH_SHORT).show();\n\n\n\n }\n\n\n\n else if (!(email.isEmpty() && !password.isEmpty())){\n\n\n\n progressBar.setVisibility(View.VISIBLE);\n\n\n\n firebaseAuth.signInWithEmailAndPassword(email,password).addOnCompleteListener(login.this,\n\n\n\n new OnCompleteListener<AuthResult>() {\n\n\n\n @Override\n\n\n\n public void onComplete(@NonNull Task<AuthResult> task) {\n\n\n\n progressBar.setVisibility(View.GONE);\n\n\n\n if (!task.isSuccessful()){\n\n\n\n Toast.makeText(login.this, task.getException().getMessage(), Toast.LENGTH_SHORT).show();\n\n\n\n }\n\n\n\n else{\n\n\n\n Intent dashboard = new Intent(login.this, dashboard.class);\n\n\n\n startActivity(dashboard);\n\n\n\n }\n\n\n\n }\n\n\n\n });\n\n\n\n\n\n\n\n }\n\n\n\n else {\n\n\n\n Toast.makeText(login.this, \"Error Occured\",Toast.LENGTH_SHORT).show();\n\n\n\n }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n }\n\n\n\n });\n\n\n\n\n\n\n\n btnRegister.setOnClickListener(new View.OnClickListener() {\n\n\n\n @Override\n\n\n\n public void onClick(View v) {\n\n\n\n Intent signup = new Intent(login.this, signup.class);\n\n\n\n startActivity(signup);\n\n\n\n }\n\n\n\n });\n\n\n\n\n\n\n\n\n\n\n\n }\n\n\n\n @Override\n\n\n\n protected void onStart() {\n\n\n\n super.onStart(); // attach the firebase listener when the activity starts \n\n\n\n firebaseAuth.addAuthStateListener(authStateListener);\n\n\n\n }\n\n\n\n\n\n\n\n @Override\n\n\n\n protected void onStop() {\n\n\n\n super.onStop(); // remove the firebase listener when the activity stops\n\n\n\n if (authStateListener != null) {\n\n\n\n firebaseAuth.removeAuthStateListener(authStateListener);\n\n\n\n\n\n\n\n }\n\n\n\n }\n\n\n\n}\n\nCreate a new activity and call it signup. In the signup .xml . input the following code.\n\nIn the signup.java we input the following code.\n\nThis is the moment we create a dashboard that welcomes our user and displays our username and email. We create a dashboard activity and in the dashboard.xml we input the following code.\n\nIn the dashboard.java we input the following code"
    }
]