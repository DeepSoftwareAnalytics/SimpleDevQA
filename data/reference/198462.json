[
    {
        "link": "https://docs.python.org/3/library/random.html",
        "document": "This module implements pseudo-random number generators for various distributions.\n\nFor integers, there is uniform selection from a range. For sequences, there is uniform selection of a random element, a function to generate a random permutation of a list in-place, and a function for random sampling without replacement.\n\nOn the real line, there are functions to compute uniform, normal (Gaussian), lognormal, negative exponential, gamma, and beta distributions. For generating distributions of angles, the von Mises distribution is available.\n\nAlmost all module functions depend on the basic function , which generates a random float uniformly in the half-open range . Python uses the Mersenne Twister as the core generator. It produces 53-bit precision floats and has a period of 2**19937-1. The underlying implementation in C is both fast and threadsafe. The Mersenne Twister is one of the most extensively tested random number generators in existence. However, being completely deterministic, it is not suitable for all purposes, and is completely unsuitable for cryptographic purposes.\n\nThe functions supplied by this module are actually bound methods of a hidden instance of the class. You can instantiate your own instances of to get generators that don‚Äôt share state.\n\nClass can also be subclassed if you want to use a different basic generator of your own devising: see the documentation on that class for more details.\n\nThe module also provides the class which uses the system function to generate random numbers from sources provided by the operating system.\n\nReturn a random element from the non-empty sequence seq. If seq is empty, raises . Return a k sized list of elements chosen from the population with replacement. If the population is empty, raises . If a weights sequence is specified, selections are made according to the relative weights. Alternatively, if a cum_weights sequence is given, the selections are made according to the cumulative weights (perhaps computed using ). For example, the relative weights are equivalent to the cumulative weights . Internally, the relative weights are converted to cumulative weights before making selections, so supplying the cumulative weights saves work. If neither weights nor cum_weights are specified, selections are made with equal probability. If a weights sequence is supplied, it must be the same length as the population sequence. It is a to specify both weights and cum_weights. The weights or cum_weights can use any numeric type that interoperates with the values returned by (that includes integers, floats, and fractions but excludes decimals). Weights are assumed to be non-negative and finite. A is raised if all weights are zero. For a given seed, the function with equal weighting typically produces a different sequence than repeated calls to . The algorithm used by uses floating-point arithmetic for internal consistency and speed. The algorithm used by defaults to integer arithmetic with repeated selections to avoid small biases from round-off error. Changed in version 3.9: Raises a if all weights are zero. To shuffle an immutable sequence and return a new shuffled list, use instead. Note that even for small , the total number of permutations of x can quickly grow larger than the period of most random number generators. This implies that most permutations of a long sequence can never be generated. For example, a sequence of length 2080 is the largest that can fit within the period of the Mersenne Twister random number generator. Return a k length list of unique elements chosen from the population sequence. Used for random sampling without replacement. Returns a new list containing elements from the population while leaving the original population unchanged. The resulting list is in selection order so that all sub-slices will also be valid random samples. This allows raffle winners (the sample) to be partitioned into grand prize and second place winners (the subslices). Members of the population need not be hashable or unique. If the population contains repeats, then each occurrence is a possible selection in the sample. Repeated elements can be specified one at a time or with the optional keyword-only counts parameter. For example, is equivalent to . To choose a sample from a range of integers, use a object as an argument. This is especially fast and space efficient for sampling from a large population: . If the sample size is larger than the population size, a is raised. Changed in version 3.11: The population must be a sequence. Automatic conversion of sets to lists is no longer supported.\n\nThe following functions generate specific real-valued distributions. Function parameters are named after the corresponding variables in the distribution‚Äôs equation, as used in common mathematical practice; most of these equations can be found in any statistics text. Return the next random floating-point number in the range Return a random floating-point number N such that for and for . The end-point value may or may not be included in the range depending on floating-point rounding in the expression . Return a random floating-point number N such that and with the specified mode between those bounds. The low and high bounds default to zero and one. The mode argument defaults to the midpoint between the bounds, giving a symmetric distribution. Beta distribution. Conditions on the parameters are and . Returned values range between 0 and 1. Exponential distribution. lambd is 1.0 divided by the desired mean. It should be nonzero. (The parameter would be called ‚Äúlambda‚Äù, but that is a reserved word in Python.) Returned values range from 0 to positive infinity if lambd is positive, and from negative infinity to 0 if lambd is negative. Changed in version 3.12: Added the default value for . Gamma distribution. (Not the gamma function!) The shape and scale parameters, alpha and beta, must have positive values. (Calling conventions vary and some sources define ‚Äòbeta‚Äô as the inverse of the scale). Normal distribution, also called the Gaussian distribution. mu is the mean, and sigma is the standard deviation. This is slightly faster than the function defined below. Multithreading note: When two threads call this function simultaneously, it is possible that they will receive the same return value. This can be avoided in three ways. 1) Have each thread use a different instance of the random number generator. 2) Put locks around all calls. 3) Use the slower, but thread-safe function instead. Changed in version 3.11: mu and sigma now have default arguments. Log normal distribution. If you take the natural logarithm of this distribution, you‚Äôll get a normal distribution with mean mu and standard deviation sigma. mu can have any value, and sigma must be greater than zero. Normal distribution. mu is the mean, and sigma is the standard deviation. Changed in version 3.11: mu and sigma now have default arguments. mu is the mean angle, expressed in radians between 0 and 2*pi, and kappa is the concentration parameter, which must be greater than or equal to zero. If kappa is equal to zero, this distribution reduces to a uniform random angle over the range 0 to 2*pi. Weibull distribution. alpha is the scale parameter and beta is the shape parameter.\n\n# Even integer from 0 to 100 inclusive ['four', 'two', 'ace', 'three'] # of 52 playing cards, and determine the proportion of cards # Estimate the probability of getting 5 or more heads from 7 spins # of a biased coin that settles on heads 60% of the time. # Probability of the median of 5 samples being in middle two quartiles Example of statistical bootstrapping using resampling with replacement to estimate a confidence interval for the mean of a sample: Example of a resampling permutation test to determine the statistical significance or p-value of an observed difference between the effects of a drug versus a placebo: # Example from \"Statistics is Easy\" by Dennis Shasha and Manda Wilson 'at least as extreme as the observed difference of leads us to reject the null' 'hypothesis that there is no difference between the drug and the placebo.' Simulation of arrival times and service deliveries for a multiserver queue: # time when each server becomes available Statistics for Hackers a video tutorial by Jake Vanderplas on statistical analysis using just a few fundamental concepts including simulation, sampling, shuffling, and cross-validation. Economics Simulation a simulation of a marketplace by Peter Norvig that shows effective use of many of the tools and distributions provided by this module (gauss, uniform, sample, betavariate, choice, triangular, and randrange). A Concrete Introduction to Probability (using Python) a tutorial by Peter Norvig covering the basics of probability theory, how to write simulations, and how to perform data analysis using Python.\n\nThese recipes show how to efficiently make random selections from the combinatoric iterators in the module: \"Choose r elements with replacement. Order the result to match the iterable.\" # Result will be in set(itertools.combinations_with_replacement(iterable, r)). The default returns multiples of 2‚Åª‚Åµ¬≥ in the range 0.0 ‚â§ x < 1.0. All such numbers are evenly spaced and are exactly representable as Python floats. However, many other representable floats in that interval are not possible selections. For example, isn‚Äôt an integer multiple of 2‚Åª‚Åµ¬≥. The following recipe takes a different approach. All floats in the interval are possible selections. The mantissa comes from a uniform distribution of integers in the range 2‚Åµ¬≤ ‚â§ mantissa < 2‚Åµ¬≥. The exponent comes from a geometric distribution where exponents smaller than -53 occur half as often as the next larger exponent. All real valued distributions in the class will use the new method: The recipe is conceptually equivalent to an algorithm that chooses from all the multiples of 2‚Åª¬π‚Å∞‚Å∑‚Å¥ in the range 0.0 ‚â§ x < 1.0. All such numbers are evenly spaced, but most have to be rounded down to the nearest representable Python float. (The value 2‚Åª¬π‚Å∞‚Å∑‚Å¥ is the smallest positive unnormalized float and is equal to .) Generating Pseudo-random Floating-Point Values a paper by Allen B. Downey describing ways to generate more fine-grained floats than normally generated by ."
    },
    {
        "link": "https://w3schools.com/python/module_random.asp",
        "document": "Python has a built-in module that you can use to make random numbers.\n\nThe module has a set of methods:"
    },
    {
        "link": "https://geeksforgeeks.org/python-randint-function",
        "document": "randint() is an inbuilt function of the random module in Python3. The random module gives access to various useful functions one of them being able to generate random numbers, which is randint(). In this article, we will learn about randint in Python.\n\nIn this example, we are using the randint() method in Python to find a random number in a given range.\n\nIn this example, we are making multiple random.randint() method calls in Python.\n\nIn this example, we are seeing that if we passes the floating point values as parameters in the randint() function then a ValueError occurs.\n\nIn this example, we can see that if we pass string or character literals as parameters in the randint() function then a TypeError occurs.\n\nApplications : The randint() function can be used to simulate a lucky draw situation. Let‚Äôs say User has participated in a lucky draw competition. The user gets three chances to guess the number between 1 and 10. If guess is correct user wins, else loses the competition.\n\nWhat Does the\n\nWhat is the Difference Between the\n\nHow to Generate a Random Number from 1 to 10 in Python?\n\nWhat is the Use of the\n\nThe function is used to generate a random float number between 0.0 and 1.0. It‚Äôs useful when you need a random decimal value within this range, and it is commonly used in simulations, games, testing, and wherever random sampling is required. Because it generates a number up to but not including 1.0, it‚Äôs particularly useful when combined with other functions or scaled to fit a desired range. For example, multiplying the result by 100 would provide a random float from 0.0 to 100.0, not inclusive of 100."
    },
    {
        "link": "https://docs.python.org/2/library/random.html",
        "document": "This module implements pseudo-random number generators for various distributions.\n\nFor integers, uniform selection from a range. For sequences, uniform selection of a random element, a function to generate a random permutation of a list in-place, and a function for random sampling without replacement.\n\nOn the real line, there are functions to compute uniform, normal (Gaussian), lognormal, negative exponential, gamma, and beta distributions. For generating distributions of angles, the von Mises distribution is available.\n\nAlmost all module functions depend on the basic function , which generates a random float uniformly in the semi-open range [0.0, 1.0). Python uses the Mersenne Twister as the core generator. It produces 53-bit precision floats and has a period of 2**19937-1. The underlying implementation in C is both fast and threadsafe. The Mersenne Twister is one of the most extensively tested random number generators in existence. However, being completely deterministic, it is not suitable for all purposes, and is completely unsuitable for cryptographic purposes.\n\nThe functions supplied by this module are actually bound methods of a hidden instance of the class. You can instantiate your own instances of to get generators that don‚Äôt share state. This is especially useful for multi-threaded programs, creating a different instance of for each thread, and using the method to make it likely that the generated sequences seen by each thread don‚Äôt overlap.\n\nClass can also be subclassed if you want to use a different basic generator of your own devising: in that case, override the , , , and methods. Optionally, a new generator can supply a method ‚Äî this allows to produce selections over an arbitrarily large range.\n\nAs an example of subclassing, the module provides the class that implements an alternative generator in pure Python. The class provides a backward compatible way to reproduce results from earlier versions of Python, which used the Wichmann-Hill algorithm as the core generator. Note that this Wichmann-Hill generator can no longer be recommended: its period is too short by contemporary standards, and the sequence generated is known to fail some stringent randomness tests. See the references below for a recent variant that repairs these flaws.\n\nThe module also provides the class which uses the system function to generate random numbers from sources provided by the operating system.\n\nReturn a k length list of unique elements chosen from the population sequence. Used for random sampling without replacement. Returns a new list containing elements from the population while leaving the original population unchanged. The resulting list is in selection order so that all sub-slices will also be valid random samples. This allows raffle winners (the sample) to be partitioned into grand prize and second place winners (the subslices). Members of the population need not be hashable or unique. If the population contains repeats, then each occurrence is a possible selection in the sample. To choose a sample from a range of integers, use an object as an argument. This is especially fast and space efficient for sampling from a large population: .\n\nThe following functions generate specific real-valued distributions. Function parameters are named after the corresponding variables in the distribution‚Äôs equation, as used in common mathematical practice; most of these equations can be found in any statistics text."
    },
    {
        "link": "https://geeksforgeeks.org/python-random-module",
        "document": "Python Random module generates random numbers in Python. These are pseudo-random numbers means they are not truly random.\n\nThis module can be used to perform random actions such as generating random numbers, printing random a value for a list or string, etc. It is an in-built function in Python.\n\nList of all the functions Python Random Module\n\nThere are different random functions in the Random Module of Python. Look at the table below to learn more about these functions:\n\nLet‚Äôs discuss some common operations performed by Random module in Python.\n\nExample 1: Printing a random value from a list in Python.\n\nThis code uses the module to select a random element from the list using the function. It prints a random element from the list, demonstrating how to pick a random item from a sequence in Python.\n\nExample 2: Creating random numbers with Python seed() in Python.\n\nAs stated above random module creates pseudo-random numbers. Random numbers depend on the seeding value. For example, if the seeding value is 5 then the output of the below program will always be the same. Therefore, it must not be used for encryption.\n\nThe code sets the random number generator‚Äôs seed to 5 using , ensuring reproducibility. It then prints two random floating-point numbers between 0 and 1 using . The seed makes these numbers the same every time you run the code with a seed of 5, providing consistency in the generated random values.\n\nrandom.randint() method is used to generate random integers between the given range.\n\nThis code uses the ‚Äò module to generate random integers within specific ranges. It first generates a random integer between 5 and 15 (inclusive) and then between -10 and -2 (inclusive). The generated integers are printed with appropriate formatting.\n\nA random.random() method is used to generate random floats between 0.0 to 1.\n\nIn this code, we are using the function from the ‚Äò module in Python. It prints a random floating-point number between 0 and 1 when you call .\n\nRandom sampling from a list in Python (random.choice, and sample)\n\nExample 1: Python random.choice() function is used to return a random item from a list, tuple, or string.\n\nThe code uses the function from the module to randomly select elements from different data types. It demonstrates selecting a random element from a list, a string, and a tuple. The chosen elements will vary each time you run the code, making it useful for random selection from various data structures.\n\nExample 2: Python random.sample() function is used to return a random item from a list, tuple, or string.\n\nThis code utilizes the function from the ‚Äò module to obtain random samples from various data types. It selects three random elements without replacement from a list, a tuple, and a string, demonstrating its versatility in generating distinct random samples. With each execution, the selected elements will differ, providing random subsets from the input data structures.\n\nA random.shuffle() method is used to shuffle a sequence (list). Shuffling means changing the position of the elements of the sequence. Here, the shuffling operation is inplace.\n\nThis code uses the function from the ‚Äò module to shuffle the elements of a list named ‚Äò . It first prints the original order of the list, then shuffles it twice. The second shuffle creates a new random order, and the list‚Äôs content is displayed after each shuffle. This demonstrates how the elements are rearranged randomly in the list with each shuffle operation.\n\nIn this article we discussed about Python Random module, and also saw some examples of functions in random module in Python. Random module in Python is very important and contains very useful functions.\n\nHope this helps you in using Python Random module functions.\n\nWhat is a random module in Python?\n\nWhat is random vs Randint in Python?\n\nHow many functions are there in the random module?\n\nWhat is the syntax of the random function?\n\nWhat is the difference between the math module and the random module?"
    },
    {
        "link": "https://stackoverflow.com/questions/19834806/is-there-a-more-pythonic-way-to-prevent-adding-a-duplicate-to-a-list",
        "document": "Is there a more Pythonic (or succinct) way to prevent adding a duplicate to a list?\n\nOr is this in fact a cheap operation?"
    },
    {
        "link": "https://stackoverflow.com/questions/67733225/how-to-avoid-duplicates-in-list-python",
        "document": "So, i created a list of dictionaries with the following values :\n\nI also created a function as such:\n\nSo, what i wanted to do was that if the index is already in the list of dictionaries, it cannot add a new item with same index and will just break out from the loop. It works for the first index but doesn't work for the other indexes despite is the same as the one already in the list. It would still go to else block despite already existing in the list. There are no errors in the terminal but the function still is not working as i intended. I am trying to make the item index to be unique so that each dictionary will have different index no duplicates. Anyone that can help?\n\nEDIT : Thank you so much for those who helped me solve the problem! I appreciate your help :)"
    },
    {
        "link": "https://geeksforgeeks.org/python-ways-to-remove-duplicates-from-list",
        "document": "In this article, we‚Äôll learn several ways to remove duplicates from a list in Python. The simplest way to remove duplicates is by converting a list to a set.\n\nWe can use set() to remove duplicates from the list. However, this approach does not preserve the original order.\n\nNote: Using set() removes duplicates but does not guarantee the order of elements.\n\nLet‚Äôs explore other different ways to remove duplicates from list:\n\nTo remove duplicates while keeping the original order, we can use a loop (for loop) to add only unique items to a new list.\n\nNote: This method preserves the original order but may be slower for large lists due to repeated membership checks ( ‚Äòin‚Äô operator).\n\nList comprehension is another way to remove duplicates while preserving order. This method provides a cleaner and one-liner approach.\n\nNote: This method is concise but it is less efficient for large lists similar to the loop approach.\n\nDictionaries maintain the order of items and by using dict.fromkeys() we can create a dictionary with unique elements and then convert it back to a list.\n\nNote: This method is generally faster than the loop method for larger lists."
    },
    {
        "link": "https://medium.com/@kawsarlog/5-effective-ways-to-remove-duplicates-from-a-python-list-dac70b9e7851",
        "document": "In Python, lists are one of the most commonly used data structures, allowing for the storage of ordered collections of items. However, these collections often accumulate duplicate entries, which can lead to inefficiencies and increased memory usage. Understanding how to effectively remove these duplicates is crucial for maintaining optimal performance in Python applications.\n\nOne straightforward way to remove duplicates from a list in Python is by converting the list to a set. Since sets cannot contain duplicates, converting a list to a set automatically removes any duplicate elements. However, this method does not preserve the original order of elements, which might be necessary in certain applications.\n\nWhile this method is incredibly efficient, its major drawback is the loss of the original order of elements, making it unsuitable for all scenarios."
    },
    {
        "link": "https://switowski.com/blog/remove-duplicates",
        "document": "How do we remove duplicates from a list? One way is to go through the original list, pick up unique values, and append them to a new list.\n\n\"Writing Faster Python\" is a series of short articles discussing how to solve some common problems with different code structures. I run some benchmarks, discuss the difference between each code snippet, and finish with some personal recommendations. Are those recommendations going to make your code much faster? Not really.\n\n Is knowing those small differences going to make a slightly better Python programmer? Hopefully! You can read more about some assumptions I made, the benchmarking setup, and answers to some common questions in the Introduction article. And you can find most of the code examples in this repository.\n\nLet's prepare a simple test. I will use the randrange to generate 1 million random numbers between 0 and 99 (this will guarantee some duplicates):\n\nIf you are wondering what's this variable - that's a convention used in Python code when you need to declare a variable, but you are not planning to use it (a throwaway variable). In the above code, I want to call 1 million times. I can't omit the variable and just write - I would get a syntax error. Since I need to specify a variable, I name it to indicate that I won't use it. I could use any other name, but is a common convention. Keep in mind that in a Python REPL, actually stores the value of the last executed expression. Check out this StackOverflow answer for a more detailed explanation.\n\nWe have 1 million numbers. Now, let's remove duplicates using a \"for loop.\"\n\nSince we are operating on a list, you might be tempted to use list comprehension instead:\n\nIn general, this is not a good way to use a list comprehension because we use it only for the side effects. We don't do anything with the list that we get out of the comprehension. It looks like a nice one-liner (and I might use it in a throwaway code), but:\n‚Ä¢ It hides the intention of the code. List comprehension creates a list. But in our case, we actually hide a \"for loop\" inside!\n‚Ä¢ It's wasteful - we create a list (because list comprehension always creates a list) just to discard it immediately.\n\nI try to avoid using list comprehension just for the side effects. \"For loop\" is much more explicit about the intentions of my code.\n\nThere is a much simpler way to remove duplicates - by converting our list to a set. Set, by definition, is a \"collection of distinct (unique) items.\" Converting a list to a set automatically removes duplicates. Then you just need to convert this set back to a list:\n\nWhich one is faster?\n\nConverting our list to a set is over 50 times faster (634/11‚âà57.63) than using a \"for loop.\" And a hundred times cleaner and easier to read üòâ.\n\nThis above method of converting a list to a set only works if a list is hashable. So it's fine for strings, numbers, tuples, and any immutable objects. But it won't work for unhashable elements like lists, sets, or dictionaries. So if you have a list of nested lists, your only choice is to use that \"bad\" for loop. That's why \"bad\" is in quotes - it's not always bad. To learn more about the difference between hashable and unhashable objects in Python, check out this StackOverflow question: What does \"hashable\" mean in Python?\n\nThere is one problem with sets - they are unordered. When you convert a list to a set, there is no guarantee that it will keep the insertion order. If you need to preserve the original order, you can use this dictionary trick:\n\nHere is what the above code does:\n‚Ä¢ It creates a dictionary using fromkeys() method. Each element from is a key with a value of . Dictionaries in Python 3.6 and above are ordered, so the keys are created in the same order as they appeared on the list. Duplicated items from a list are ignored (since dictionaries can't have duplicated keys).\n‚Ä¢ Then it converts a dictionary to a list - this returns a list of keys. Again, we get those keys in the same order as we inserted into the dictionary in the previous step.\n\nWhat about the performance?\n\nIt's 62% slower than using a set (17.9/11‚âà1.627), but still over 30 times faster than the \"for loop\" (634/17.3‚âà35.419).\n\nThe above method only works with Python 3.6 and above. If you are using an older version of Python, replace with :\n\nIt's around 3 times as slow as a set (32.8/11‚âà2.982) and 83% slower than a dictionary (32.8/17.9‚âà1.832), but it's still much faster than a \"for loop\" (634/32.8‚âà19.329). And will work with Python 2.7 and any Python 3 version.\n\nWhen you need to remove duplicates from a collection of items, the best way to do this is to convert that collection to a set. By definition, the set contains unique items (among other features, like the constant membership testing time). This will make your code faster and more readable.\n\nDownsides? Sets are unordered, so if you need to make sure you don't lose the insertion order, you need to use something else. For example - a dictionary!"
    }
]