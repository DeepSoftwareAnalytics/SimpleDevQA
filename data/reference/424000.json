[
    {
        "link": "https://learn.microsoft.com/en-us/powershell",
        "document": "A place for the community to learn PowerShell and share insights"
    },
    {
        "link": "https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.management/new-item?view=powershell-7.5",
        "document": "The cmdlet creates a new item and sets its value. The types of items that can be created depend on the location of the item. For example, in the file system, creates files and folders. In the registry, creates registry keys and entries. can also set the value of the items that it creates. For example, when it creates a new file, can add initial content to the file.\n\nExample 1: Create a file in the current directory\n\nThis command creates a PowerShell profile in the path that is specified by the variable. You can use profiles to customize PowerShell. is an automatic (built-in) variable that stores the path and file name of the \"CurrentUser/CurrentHost\" profile. By default, the profile does not exist, even though PowerShell stores a path and file name for it. In this command, the variable represents the path of the file. ItemType parameter specifies that the command creates a file. The Force parameter lets you create a file in the profile path, even when the directories in the path do not exist. After you create a profile, you can enter aliases, functions, and scripts in the profile to customize your shell. For more information, see about_Automatic_Variables and about_Profiles.\n\nExample 4: Create a directory in a different directory\n\nExample 6: Use wildcards to create files in multiple directories\n\nThe cmdlet supports wildcards in the Path parameter. The following command creates a file in all of the directories specified by the wildcards in the Path parameter. Get-ChildItem -Path C:\\Temp\\ Directory: C:\\Temp Mode LastWriteTime Length Name ---- ------------- ------ ---- d----- 5/15/2019 6:45 AM 1 One d----- 5/15/2019 6:45 AM 1 Two d----- 5/15/2019 6:45 AM 1 Three New-Item -Path C:\\Temp\\* -Name temp.txt -ItemType File | Select-Object FullName FullName -------- C:\\Temp\\One\\temp.txt C:\\Temp\\Three\\temp.txt C:\\Temp\\Two\\temp.txt The cmdlet shows three directories under the directory. Using wildcards the cmdlet creates a file in all of the directories under the current directory. The cmdlet outputs the items you created, which is piped to to verify the paths of the newly created files.\n\nExample 7: Create a symbolic link to a file or folder\n\nThis example creates a symbolic link to the Notice.txt file in the current folder. In this example, Target is an alias for the Value parameter. The target of the symbolic link can be a relative path. Prior to PowerShell v6.2, the target must be a fully-qualified path. Beginning in PowerShell 7.1, you can now create to a SymbolicLink to a folder on Windows using a relative path.\n\nExample 8: Use the -Force parameter to attempt to recreate folders\n\nExample 9: Use the Force parameter to overwrite existing files\n\nThis example creates a file with a value and then recreates the file using the Force parameter. This overwrites the existing file, as you can see by the length property. PS> New-Item ./TestFile.txt -ItemType File -Value 'This is just a test file' Directory: C:\\Source\\Test Mode LastWriteTime Length Name ---- ------------- ------ ---- -a---- 5/1/2020 8:32 AM 24 TestFile.txt New-Item ./TestFile.txt -ItemType File -Force Directory: C:\\Source\\Test Mode LastWriteTime Length Name ---- ------------- ------ ---- -a---- 5/1/2020 8:32 AM 0 TestFile.txt When using with the Force parameter to create registry keys, the command behaves the same as when overwriting a file. If the registry key already exists, the key and all properties and values are overwritten with an empty registry key.\n\nSpecifies the path of the location of the new item. The default is the current location when Path is omitted. You can specify the name of the new item in Name, or include it in Path. Items names passed using the Name parameter are created relative to the value of the Path parameter. For this cmdlet, the Path parameter works like the LiteralPath parameter of other cmdlets. Wildcard characters are not interpreted. All characters are passed to the location's provider. The provider may not support all characters. For example, you can't create a filename that contains an asterisk ( ) character."
    },
    {
        "link": "https://isaac-the-man.dev/posts/smart-directory-navigation-with-powershell-script",
        "document": "Sometimes I find myself having to navigate between multiple projects. And since my main working laptop is on Windows, naturally I tried to customize my command line tool (I use PowerShell because WSL is just way too slow) to jump between directories faster. My folder organization looks something like this:\n\nMy goal is to be able to easily switch between project folders (in the terminal), no matter where my current directory points to. For example, I could be under , and want to switch to . Instead of scratching my head trying to type out the entire absolute or relative path, I thought I could use the help of some custom PowerShell script.\n\nThe plan is to create a custom command with tab auto-completion to change the directory to that project from anywhere. This is surprisingly easy with PowerShell.\n\nWe‚Äôll go through the script step by step.\n\nIn lines 1 ~ 12 we define the class . This class is a , which defines all the valid arguments to our custom command for auto-completion. In this case, it is just an exhaustive list of all the project names. At lines 5 ~ 9, we use a for-each loop to get all the project names under our base project folder and return them as a list of strings at line 10. See the official PowerShell docs for more info.\n\nFrom lines 15 ~ 27, we define the actual command functionality. I named the function to follow the PowerShell commands‚Äô naming convention. Line 18 we call the to declare this function as an advanced function to use our custom-defined arguments.\n\nLine 19 ~ 24 we load our validate set as the valid arguments for the command‚Äôs auto-completion.\n\nLines 25 ~ 26 are the body of the function. We first call , which is just the full name of the command, to change our current directory to the specified parameter . Next, we call (full name of ) to list out all the items under the destination project‚Äôs folder.\n\nFinally, at line 30, we create an alias ‚Äú ‚Äù for our function, because no one wants to type out the full name of the function.\n\nSave the file as and reopen your terminal so that the script is loaded. You can now type in in your terminal and press tab to go through your list of projects. Pressing enter will change your current directory to the project folder and list out all the items in it."
    },
    {
        "link": "https://github.com/MicrosoftDocs/PowerShell-Docs/blob/main/reference/docs-conceptual/install/Installing-PowerShell-on-Windows.md",
        "document": "There are multiple ways to install PowerShell in Windows. Each install method is designed to support different scenarios and workflows. Choose the method that best suits your needs.\n‚Ä¢ WinGet - Recommended way to install PowerShell on Windows clients\n‚Ä¢ MSI package - Best choice for Windows Servers and enterprise deployment scenarios\n‚Ä¢ ZIP package - Easiest way to \"side load\" or install multiple versions\n‚Ä¢ Use this method for Windows Nano Server, Windows IoT, and Arm-based systems\n‚Ä¢ .NET Global tool - A good choice for .NET developers that install and use other global tools\n‚Ä¢ Microsoft Store package - An easy way to install for casual users of PowerShell but has limitations\n\nWinGet, the Windows Package Manager, is a command-line tool enables users to discover, install, upgrade, remove, and configure applications on Windows client computers. This tool is the client interface to the Windows Package Manager service. The command-line tool is bundled with Windows 11 and modern versions of Windows 10 by default as the App Installer.\n\nThe following commands can be used to install PowerShell using the published packages:\n\nSearch for the latest version of PowerShell\n\nInstall PowerShell or PowerShell Preview using the parameter\n\nTo install PowerShell on Windows, use the following links to download the install package from GitHub.\n\nOnce downloaded, double-click the installer file and follow the prompts.\n\nThe installer creates a shortcut in the Windows Start Menu.\n‚Ä¢ By default the package is installed to\n‚Ä¢ You can launch PowerShell via the Start Menu or\n\nSupport for Microsoft Update in PowerShell 7.2 and newer\n\nPowerShell 7.2 and newer has support for Microsoft Update. When you enable this feature, you'll get the latest PowerShell 7 updates in your traditional Microsoft Update (MU) management flow, whether that's with Windows Update for Business, WSUS, Microsoft Endpoint Configuration Manager, or the interactive MU dialog in Settings.\n‚Ä¢ - This property has two possible values:\n‚Ä¢ (default) - Opts into updating through Microsoft Update, WSUS, or Configuration Manager\n‚Ä¢ - Don't opt into updating through Microsoft Update, WSUS, or Configuration Manager\n‚Ä¢ \n‚Ä¢ (default) - Opts into using Microsoft Update for Automatic Updates\n\nFor more information, see the PowerShell Microsoft Update FAQ.\n\nMSI packages can be installed from the command line allowing administrators to deploy packages without user interaction. The MSI package includes the following properties to control the installation options:\n‚Ä¢ - This property controls the option for adding the item to the context menu in Windows Explorer.\n‚Ä¢ - This property controls the option for adding the item to the context menu in Windows Explorer.\n‚Ä¢ - This property controls the option for enabling PowerShell remoting during installation.\n‚Ä¢ - This property controls the option for registering the Windows Event Logging manifest.\n‚Ä¢ - This property controls the option for adding PowerShell to the Windows PATH environment variable.\n‚Ä¢ - This property controls the option for disabling PowerShell's telemetry by setting the environment variable.\n‚Ä¢ - This property controls the installation directory. The default is . This is the location where the installer creates the versioned subfolder. You can't change the name of the versioned subfolder.\n‚Ä¢ For current releases, the versioned subfolder is\n‚Ä¢ For preview releases, the versioned subfolder is\n\nThe following example shows how to silently install PowerShell with all the install options enabled.\n\nFor a full list of command-line options for , see Command line options.\n\nPowerShell binary ZIP archives are provided to enable advanced deployment scenarios. Download one of the following ZIP archives from the current release page.\n\nDepending on how you download the file you may need to unblock the file using the cmdlet. Unzip the contents to the location of your choice and run from there. Unlike installing the MSI packages, installing the ZIP archive doesn't check for prerequisites. For remoting over WSMan to work properly, ensure that you've met the prerequisites.\n\nUse this method to install the ARM-based version of PowerShell on computers like the Microsoft Surface Pro X. For best results, install PowerShell to the to folder.\n\nIf you already have the .NET Core SDK installed, you can install PowerShell as a .NET Global tool.\n\nThe dotnet tool installer adds to your environment variable. However, the currently running shell doesn't have the updated . You can start PowerShell from a new shell by typing .\n\nPowerShell can be installed from the Microsoft Store. You can find the PowerShell release in the Microsoft Store site or in the Store application in Windows.\n‚Ä¢ Integrates with other software distribution mechanisms like Intune and Configuration Manager\n‚Ä¢ Can install on Windows systems using x86, x64, or Arm64 processors\n\nBy default, Windows Store packages run in an application sandbox that virtualizes access to some filesystem and registry locations. Changes to virtualized file and registry locations don't persist outside of the application sandbox.\n\nThis sandbox blocks all changes to the application's root folder. Any system-level configuration settings stored in can't be modified. This includes the WSMAN configuration. This prevents remote sessions from connecting to Store-based installs of PowerShell. User-level configurations and SSH remoting are supported.\n\nThe following commands need write to . These commands aren't supported in a Microsoft Store instance of PowerShell.\n\nFor more information, see Understanding how packaged desktop apps run on Windows.\n\nBeginning in PowerShell 7.2, the PowerShell package is now exempt from file and registry virtualization. Changes to virtualized file and registry locations now persist outside of the application sandbox. However, changes to the application's root folder are still blocked.\n\nPreview releases of PowerShell 7 install to so they can be run side-by-side with non-preview releases of PowerShell. PowerShell 7.4 is the next preview release.\n\nFor best results when upgrading, you should use the same install method you used when you first installed PowerShell. If you aren't sure how PowerShell was installed, you can check the value of the variable, which always points to the directory containing PowerShell that the current session is running.\n‚Ä¢ If the value is , PowerShell was installed with the .NET Global tool.\n‚Ä¢ If the value is , PowerShell was installed as an MSI package or with WinGet on a computer with an X86 or x64 processor.\n‚Ä¢ If the value starts with , PowerShell was installed as a Microsoft Store package or with WinGet on computer with an ARM processor.\n‚Ä¢ If the value is anything else, it's likely that PowerShell was installed as a ZIP package.\n\nIf you installed via the MSI package, that information also appears in the Programs and Features Control Panel.\n\nTo determine whether PowerShell may be upgraded with WinGet, run the following command:\n\nIf there is an available upgrade, the output indicates the latest available version. Use the following command to upgrade PowerShell using WinGet:\n\nWindows 10 IoT Enterprise comes with Windows PowerShell, which we can use to deploy PowerShell 7.\n\nReplace the placeholder information for the following variables: The download location is local to the device. There should be enough space for the zip file and the unzipped contents. Path WSMan:\\localhost\\Client\\TrustedHosts ComputerName Credential Administrator Copy the ZIP package to the device Destination ToSession Connect to the device and expand the archive u:\\users\\administrator\\Downloads .\\PowerShell . win arm64.zip .\\PowerShell . win arm64 Be sure to use the -PowerShellHome parameter otherwise it tries to create a new . PowerShellHome .\n\nWhen you set up PowerShell Remoting you get an error message and are disconnected from the device. PowerShell has to restart WinRM. Now you can connect to PowerShell 7 endpoint on device.\n\nWindows 10 IoT Core adds Windows PowerShell when you include IOT_POWERSHELL feature, which we can use to deploy PowerShell 7. The steps defined above for Windows 10 IoT Enterprise can be followed for IoT Core as well.\n\nFor adding the latest PowerShell in the shipping image, use Import-PSCoreRelease command to include the package in the workarea and add OPENSRC_POWERSHELL feature to your image.\n\nThese instructions assume that the Nano Server is a \"headless\" OS that has a version of PowerShell already running on it. For more information, see the Nano Server Image Builder documentation.\n\nPowerShell binaries can be deployed using two different methods.\n‚Ä¢ Offline - Mount the Nano Server VHD and unzip the contents of the zip file to your chosen location within the mounted image.\n‚Ä¢ Online - Transfer the zip file over a PowerShell Session and unzip it in your chosen location.\n\nIn both cases, you need the Windows x64 ZIP release package. Run the commands within an \"Administrator\" instance of PowerShell.\n‚Ä¢ Use your favorite zip utility to unzip the package to a directory within the mounted Nano Server image.\n‚Ä¢ Unmount the image and boot it.\n‚Ä¢ Connect to the built-in instance of Windows PowerShell.\n\nDeploy PowerShell to Nano Server using the following steps.\n\nPowerShell supports the PowerShell Remoting Protocol (PSRP) over both WSMan and SSH. For more information, see:\n\nYou can check the version that you are using by running .\n\nMicrosoft supports the installation methods in this document. There may be other third-party methods of installation available from other sources. While those tools and methods may work, Microsoft can't support those methods."
    },
    {
        "link": "https://code.visualstudio.com/docs/languages/powershell",
        "document": "PowerShell is a task-based command-line shell and scripting language built on .NET that provides a powerful toolset for administrators on any platform.\n\nThe Microsoft PowerShell extension for Visual Studio Code (VS Code) provides rich language support and capabilities such as syntax completions, definition tracking, and linting for PowerShell. The extension should work everywhere VS Code is supported using PowerShell 7+ currently supported versions.\n\nSupport for Windows PowerShell 5.1 is provided on a best effort basis. .NET Framework 4.8 or higher is required.\n\nVS Code Remote Development Environments, including GitHub Codespaces and VS Code Server are supported.\n\nWe actively test the following configurations:\n\nOn Windows, we also test with and without Constrained Language Mode enabled.\n\nThe PowerShell extension can be installed from the Visual Studio Code Marketplace by clicking the Install Button. You can also install the PowerShell extension from within VS Code by opening the Extensions view with keyboard shortcut ‚áß‚åòX (Windows, Linux Ctrl+Shift+X), typing PowerShell, and selecting the PowerShell extension:\n‚Ä¢ IntelliSense for cmdlets and more\n‚Ä¢ Go to Definition of cmdlets, variables, classes and more\n‚Ä¢ Find References of cmdlets, variables, classes and more\n‚Ä¢ Launch online help for the symbol under the cursor using\n‚Ä¢ An Extension Terminal that can interact with the debugger (try !)\n‚Ä¢ PowerShell ISE theme available in the theme picker\n‚Ä¢ Also try ISE mode using then search for \"Enable ISE Mode\"\n\nThe PowerShell extension uses the built-in debugging interface of VS Code to allow for debugging of PowerShell scripts and modules. For more information about debugging PowerShell, see Using VS Code.\n\nYou can configure the PowerShell extension to use any supported version of PowerShell installed on your machine by following these instructions.\n\nOr run the PowerShell: Show Session Menu command from the Command Palette (‚áß‚åòP (Windows, Linux Ctrl+Shift+P)).\n\nCodeLenses are a VS Code feature to provide actionable, contextual information that's displayed within the source code.\n‚Ä¢ CodeLens reference support shows the number of times a symbol is referenced within your code and allows you to jump to specific references.\n\nPSScriptAnalyzer is a PowerShell module that provides a static source code checker for modules and scripts. PSScriptAnalyzer has rules that verify the quality of PowerShell code. These rules are based on PowerShell best practices identified by the PowerShell Team and the community. PSScriptAnalyzer generates diagnostic records (errors and warnings) to inform users about potential code defects and suggests possible solutions for improvements.\n\nThe PowerShell extension includes PSScriptAnalyzer by default, and automatically performs analysis on PowerShell script files you edit in VS Code.\n\nPSScriptAnalyzer comes with a collection of built-in rules that check various aspects of PowerShell source code such as presence of uninitialized variables, usage of PSCredential type, usage of , and others. The module also allows you to include or exclude specific rules.\n\nTo disable PSScriptAnalyzer, open your settings (‚åò, (Windows, Linux Ctrl+,)), browse Extensions, select the PowerShell extension, and deselect the checkbox for Script Analysis: Enable ( ).\n\nPSScriptAnalyzer also provides code formatting. You can invoke automatic document formatting with the Format Document command or the (‚áß‚å•F (Windows Shift+Alt+F, Linux Ctrl+Shift+I)) keyboard shortcut.\n\nPester is a framework for running unit tests to execute and Windows PowerShell 5.1 comes with Pester 3.40 preinstalled. To update Pester or to install the latest version on other platforms, follow the Pester installation instructions.\n\nYou can customize VS Code settings from the File > Preferences > Settings menu item.\n\nYou can also select the gear icon located in the lower left corner of the Activity Bar.\n\nYou can also use the keyboard shortcut ‚åò, (Windows, Linux Ctrl+,) to open your settings. You can still open the file using Preferences: Open User Settings (JSON) command from the Command Palette (‚áß‚åòP (Windows, Linux Ctrl+Shift+P)) or by changing the default settings editor with the setting.\n\nGo to User and Workspace settings for more information on configuring VS Code settings.\n\nPowerShell files are used to extend the type system and define output formatting. For more information on these files, see the official PowerShell documentation on Types.ps1xml and Format.ps1xml. You can get IntelliSense features when authoring files by installing the XML extension by Red Hat. After installing, add this configuration to your user settings:\n\nThis configuration tells the XML extension to use the official XML schemas from the PowerShell repository for all files. Configuring these schemas enables the following features in files:\n\nExample scripts are included with the extension and can be found at the following path.\n\nTo open or view the examples in VS Code, run the following from your PowerShell command prompt:\n\nYou can also open the examples from the Command Palette (‚áß‚åòP (Windows, Linux Ctrl+Shift+P)) with the PowerShell: Open Examples Folder command.\n\nThere are more detailed articles in the PowerShell documentation. Start with Using VS Code.\n\nCheck out the troubleshooting guide for answers to common questions.\n\nFor more information on debugging, check out the Hey, Scripting Guy! two-part blog post series written by @keithHill on debugging with the PowerShell extension:\n\nWe would encourage you to try the pre-release version whenever possible. When a Pre-Release is available, it can be installed from the marketplace using the Switch to Pre-Release Version button. You can switch back to the stable version of the extension by using the Switch to Release Version button that will appear. You can also downgrade to other versions of the extension using the arrow next to the Uninstall button and choosing Install Another Version....\n\nIf you find a bug, open an issue and revert to the stable version while we fix it."
    },
    {
        "link": "https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.management/test-path?view=powershell-7.5",
        "document": "The cmdlet determines whether all elements of the path exist. It returns if all elements exist and if any are missing. It can also tell whether the path syntax is valid and whether the path leads to a container or a terminal or leaf element. If the Path is a whitespace or empty string, then the cmdlet returns . If the Path is , an array of or an empty array, the cmdlet returns a non-terminating error.\n\nExample 2: Test the path of a profile\n\nThese commands test the path of the PowerShell profile. The first command determines whether all elements in the path exist. The second command determines whether the syntax of the path is correct. In this case, the path is , but the syntax is correct . These commands use , the automatic variable that points to the location for the profile, even if the profile doesn't exist. For more information about automatic variables, see about_Automatic_Variables.\n\nExample 3: Check whether there are any files besides a specified type\n\nThis command checks whether there are any files in the Commercial Buildings directory other than .dwg files. The command uses the Path parameter to specify the path. Because the path includes a space, the path is enclosed in quotation marks. The asterisk at the end of the path indicates the contents of the Commercial Building directory. With long paths, such as this one, type the first few letters of the path, and then use the TAB key to complete the path. The command specifies the Exclude parameter to specify files to omit from the evaluation. In this case, because the directory contains only .dwg files, the result is .\n\nExample 5: Check paths in the Registry\n\nThese commands use with the PowerShell registry provider. The first command tests whether the registry path of the Microsoft.PowerShell registry key is correct on the system. If PowerShell is installed correctly, the cmdlet returns . doesn't work correctly with all PowerShell providers. For example, you can use to test the path of a registry key, but if you use it to test the path of a registry entry, it always returns , even if the registry entry is present.\n\nExample 7: Test a path with null as the value\n\nExample 8: Test a path with whitespace as the value\n\nExample 9: Test a path that may have an invalid drive\n\nSpecifies a filter in the format or language of the provider. The value of this parameter qualifies the Path parameter. The syntax of the filter, including the use of wildcard characters, depends on the provider. Filters are more efficient than other parameters, because the provider applies them when it retrieves the objects instead of having PowerShell filter the objects after they're retrieved.\n\nIndicates that this cmdlet tests the syntax of the path, regardless of whether the elements of the path exist. This cmdlet returns if the path syntax is valid and if it's not. If the path being tested includes a drive specification, the cmdlet returns false when the drive does not exist. PowerShell returns false because it doesn't know which drive provider to test. A breaking change in the Path APIs was introduced in .NET 2.1. Those methods no longer check for invalid path characters. This change caused a regression in PowerShell where the IsValid check no longer tests for invalid characters. The regression will be addressed in a future release. For more information, see Breaking changes in .NET Core 2.1.\n\nSpecifies a path to be tested. Unlike Path, the value of the LiteralPath parameter is used exactly as it's typed. No characters are interpreted as wildcard characters. If the path includes characters that could be interpreted by PowerShell as escape sequences, you must enclose the path in single quote so that they won't be interpreted.\n\nThis is a dynamic parameter made available by the FileSystem provider.\n‚Ä¢ This parameter when you specify PathType as any value other than .\n‚Ä¢ The OlderThan parameter when used with this parameter.\n‚Ä¢ This parameter when Path points to a directory. Starting with PowerShell 7.5, you can use this parameter with any value for the PathType parameter, to test a date range with the OlderThan parameter, and to test the age of directories. For more information, see about_FileSystem_Provider.\n\nThis is a dynamic parameter made available by the FileSystem provider.\n‚Ä¢ This parameter when you specify PathType as any value other than .\n‚Ä¢ This parameter when used with the NewerThan parameter.\n‚Ä¢ This parameter when Path points to a directory. Starting with PowerShell 7.5, you can use this parameter with any value for the PathType parameter, to test a date range with the NewerThan parameter, and to test the age of directories. For more information, see about_FileSystem_Provider."
    },
    {
        "link": "https://stackoverflow.com/questions/39825440/check-if-a-path-is-a-folder-or-a-file-in-powershell",
        "document": "I'm trying to write a PowerShell script which goes through a list of values which are folder or file paths, and delete the files first, then remove the empty folders.\n\nMy script so far:\n\nNow I'm trying to test each line in the variable to see if it's a file and delete it first, and then go through and remove subfolders and folders. This is just so that it's a clean process.\n\nI can't quite get this next bit to work, but I think I need something like:\n\nThe next section can clean up the subfolders and folders."
    },
    {
        "link": "https://devblogs.microsoft.com/powershell-community/determine-if-a-folder-exists",
        "document": "Q: Is there any way to determine whether or not a specific folder exists on a computer? A: There are loads of ways you can do this.\n\nThe easiest way to do this is to use the cmdlet. It looks for a given path and returns if it exists, otherwise it returns . You could evaluate the result of the like in the code snippet below\n\nThis is similar to the operator for IF statements in Bash. is returned if exists, otherwise is returned.\n\nAnd for more information on see the Test-Path help page.\n\nSo as you saw, tests the existence of a path and returns a boolean value. This return value can be evaluated in a IF statement for example.\n\nThis article is based on an earlier Scripting Guys blog article at How can I determine if a folder exists on a computer?. I am not sure who wrote the original article."
    },
    {
        "link": "https://stackoverflow.com/questions/31888580/a-better-way-to-check-if-a-path-exists-or-not-in-powershell",
        "document": "Is there a more concise and less error-prone way in PowerShell to check if a path DOES NOT exist?\n\nThis is objectively too verbose for such a common use case:\n\nIt needs too many parenthesis and is not very readable when checking for \"not exist\". It's also error-prone because a statement like:\n\nwill actually return , when the user may expect .\n\nWhat is a better way to do this?\n\nUpdate 1: My current solution is to use aliases for and as explained here.\n\nUpdate 2: A proposed syntax that will also fix this is to allow the following grammar:\n\nHere's the related issue in PowerShell repository (please vote up üëç): https://github.com/PowerShell/PowerShell/issues/1970"
    },
    {
        "link": "https://netwrix.com/powershell-check-if-file-exists.html",
        "document": "\n‚Ä¢ Run a script like the following, which will return all files in the Accounting folder whose filename includes the string ‚Äúpayroll‚Äù:\n\nThe results will show all matching files.\n\nOnce you have a list of files that might contain sensitive data, you might want to move them to a secure location. However, your processing script will terminate with an error if the file path is invalid, so before running it, you should first check for the existence of the file or folder. The following PowerShell commands will help:\n‚Ä¢ Using Get-Item to check if a file exists ‚Äî You can use the Get-Item cmdlet in PowerShell to find a file by name. If the specified item path does not exist, the script will throw an error. Below is a PowerShell script that checks whether the file \"Payroll 2022 - 2023.xlsx\" exists using the Get-Item cmdlet. If the file exists, the script provides the file details; if not, it will display a message saying the file does not exist.\n‚Ä¢ Using Get-ChildItem to check if a file exists ‚Äî The Get-ChildItem cmdlet is typically used to retrieve a list of items in a specified location, but it can also be used to check for the existence of a specific file. The script below attempts to retrieve the file \"Payment_2021.rtf\". If the file exists, the script will return the file details and a success message; otherwise, no output will be returned by Get-ChildItem and the write host cmdlet will display the message \"The file does not exist.\"\n‚Ä¢ Using Test-Path to check if a file exists ‚Äî You can use the Test-Path cmdlet to check whether a specific file or folder exists. It returns True if the file or folder exists and False if it does not. For example, to check whether the ‚ÄúPayroll 2022 ‚Äì 2023‚Äù file exists, run the following script:\n\nTo determine whether there are any files in C:\\Shared\\Accounting\\ that have the .xlsx extension, run following Test-Pathcmdlet:\n\nYou can also use Test-Path to check whether a path is a file or a directory. Add the ‚ÄëPathType with ‚Äúleaf‚Äù as its value, and the cmdlet will return ‚Äútrue‚Äù if the path is a file.\n\nTo validate the network path of a shared folder on a remote computer, use this cmdlet:"
    }
]