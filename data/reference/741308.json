[
    {
        "link": "https://git-scm.com/docs/git-restore",
        "document": "Restore the working tree files with the content from the given tree. It is common to specify the source tree by naming a commit, branch or tag associated with it. If not specified, the contents are restored from if is given, otherwise from the index. As a special case, you may use as a shortcut for the merge base of <rev-A> and <rev-B> if there is exactly one merge base. You can leave out at most one of <rev-A>_ and <rev-B>, in which case it defaults to .\n\nInteractively select hunks in the difference between the restore source and the restore location. See the \"Interactive Mode\" section of git-add[1] to learn how to operate the mode. Note that can accept no pathspec and will prompt to restore all modified paths.\n\nSpecify the restore location. If neither option is specified, by default the working tree is restored. Specifying will only restore the index. Specifying both restores both.\n\nProgress status is reported on the standard error stream by default when it is attached to a terminal, unless is specified. This flag enables progress reporting even if not attached to a terminal, regardless of .\n\nWhen restoring files in the working tree from the index, use stage #2 ( ) or #3 ( ) for unmerged paths. This option cannot be used when checking out paths from a tree-ish (i.e. with the option). Note that during and , and may appear swapped. See the explanation of the same options in git-checkout[1] for details.\n\nWhen restoring files on the working tree from the index, recreate the conflicted merge in the unmerged paths. This option cannot be used when checking out paths from a tree-ish (i.e. with the option).\n\nThe same as option above, but changes the way the conflicting hunks are presented, overriding the configuration variable. Possible values are (default), , and .\n\nWhen restoring files on the working tree from the index, do not abort the operation if there are unmerged entries and neither , , or is specified. Unmerged paths on the working tree are left alone.\n\nIf <pathspec> names an active submodule and the restore location includes the working tree, the submodule will only be updated if this option is given, in which case its working tree will be restored to the commit recorded in the superproject, and any local modifications overwritten. If nothing (or ) is used, submodules working trees will not be updated. Just like git-checkout[1], this will detach of the submodule.\n\nIn overlay mode, never remove files when restoring. In no-overlay mode, remove tracked files that do not appear in the <tree> of , to make them match <tree> exactly. The default is no-overlay mode.\n\nPathspec is passed in <file> instead of commandline args. If <file> is exactly then standard input is used. Pathspec elements are separated by LF or CR/LF. Pathspec elements can be quoted as explained for the configuration variable (see git-config[1]). See also and global ."
    },
    {
        "link": "https://stackoverflow.com/questions/4235431/git-deleted-some-files-locally-how-do-i-get-them-from-a-remote-repository",
        "document": "Since git is a distributed VCS, your local repository contains all of the information. No downloading is necessary; you just need to extract the content you want from the repo at your fingertips.\n\nIf you haven't committed the deletion, just check out the files from your current commit:\n\nIf you have committed the deletion, you need to check out the files from a commit that has them. Presumably it would be the previous commit:\n\nbut if it's commits ago, use , or simply fire up , find the SHA1 of the appropriate commit, and paste it in."
    },
    {
        "link": "https://stackoverflow.com/questions/1992364/git-recover-deleted-remote-branch",
        "document": "I need to recover two Git branches that I somehow deleted during a push.\n\nThese two branches were created on a different system and then pushed to my \"shared\" (github) repository.\n\nOn my system, I (apparently) retrieved the branches during a fetch:\n\nRight after that I did a push to send my local changes up to the central repo. For some reason, these branches were deleted from both my local system and the central repo:\n\nIt's not terribly easy to get the branches off of their birthplace machine, so I'd like to try and recover them from my local if possible.\n\nAll of the git \"undo\" information I've googled has to with recovering lost commits. I don't think that applies here, since I don't have commit UIDs for these branches.\n\nI'd like to know how I can get these back. I'd also like to know how they were deleted in the first place and how I can avoid this in the future."
    },
    {
        "link": "https://rewind.com/blog/how-to-restore-deleted-branch-commit-git-reflog",
        "document": "Managing branches or commits in Git can be quite cumbersome. Issues ranging from merge conflicts to accidentally deleting branches are a nightmare for many developers. It could get even worse if you are working with a bunch of other developers, as it‚Äôs easy to modify or even completely remove another person‚Äôs work, whether knowingly or inadvertently.\n\nIn this tutorial, you will learn how to recover your deleted commits or branches using the ` command. This command is used to get a record of references to the tips of branches and commits that have been updated. Per the official documentation,\n\n‚ÄúReference logs, or ‚Äúreflogs,‚Äù record when the tips of branches and other references were updated in the local repository. Reflogs are useful in various Git commands, to specify the old value of a reference.‚Äù\n\nBefore diving further into the command, let‚Äôs take a look at some basics of Git.\n\n` ` is primarily a reference to a named branch in a Git repository. It is like a pointer that points to a branch, and that branch itself points to a particular commit. Thus, the ` ` pointer indirectly points to a particular commit.\n\nHowever, it can also point directly to a commit. This state is known as detached HEAD state. To better understand this, consider an example:\n\nIn the image above, the HEAD is pointing to the main branch and the main branch is pointing to the C1 commit.\n\nHere, the HEAD is not referencing or pointing to the main branch; instead, it is pointing directly to the C1 commit. This can be achieved using the ` command.\n\nAs you can see, when the new commit was created, the HEAD pointer changed its reference and now points toward the latest commit, C2. However, the main branch still points toward the C1 commit. This is known as a detached HEAD state.\n\nYou can also use ` ` to create a new branch by referencing a particular commit. For example:\n\nThis is your main branch. Let‚Äôs say that you want to create a new branch from commit C1. To do so, you must point the HEAD to the desired commit. There are a few ways to do this. One option is to point the HEAD directly to the C1 commit by specifying its SHA value. Alternatively, you can also make the HEAD point toward that commit by using the current position of the HEAD itself.\n\nYou can achieve this by using either of these commands:\n\nIn the example, HEAD now points to the C1 commit. To create a new branch, simply execute the command ` . Then, point the HEAD to the new branch using ` `. The commits that you will make after this will be updated in the new branch.\n\nNow that you have a basic understanding of these concepts in Git, let‚Äôs take a closer look at the ` ` command and see how you can use it to recover deleted branches or commits.\n\nAs mentioned previously, reference logs, otherwise known as ‚Äúreflogs,‚Äù are used to record when updates are made in the local repository to the tips of branches and commits.\n\nIn other words, using , you can get information about the HEAD pointer and the various commits to which it pointed in the past or present\n\nLet‚Äôs say that you have a main branch and then created a new branch named b1 using the command . Then you accidentally deleted this branch using . At this point, either you immediately realize the mistake (for example, deleting another branch instead of the intended one) and it was the last step you performed in your terminal, or you don‚Äôt even realize initially that you deleted the wrong branch but later you realize it.\n\nIn the first case, you can simply check the message in the terminal after the deletion of the branch. It may look something like this:\n\nIn the above message, you can see the SHA value of the commit to which the branch pointed when it was deleted.\n\nNext, execute the command. This command will point the HEAD to the commit of which the SHA value has been specified. This will create a detached HEAD state, which was discussed earlier.\n\nAfter this, execute the command. This will create a new branch from that commit itself, and the HEAD pointer will point to the branch.\n\nIn the second case, if you‚Äôve lost the message, you can use to find the SHA of the commit that was at the tip of the deleted branch. Be sure to name your commits properly so that you can find them easily.\n\nThen, to proceed, you may perform the same commands as detailed in the first case above.\n\nThe process for recovering a deleted commit is quite simple. All that is necessary is to use to find the SHA value of the commit that you want to go to, and then execute the command. Remember that this command will delete all your working directory changes that are not yet committed, so be sure to use it carefully.\n\nWhile can be particularly useful for restoring deleted branches and commits, it also has some drawbacks. Most notably, reference logs are stored locally, so you can‚Äôt really push or pull them from a remote repository. Also, they typically expire or are erased after a certain amount of time to save disk space.\n\nIn order to overcome these drawbacks, you can opt for a backup solution like BackHub by Rewind. With BackHub, you can automatically back up your repositories and crucial metadata (pull requests, issues, projects, etc.) on a daily basis. You can also restore your data using the GitHub API almost instantly. To get started, set up a free trial of BackHub or reach out to sales@rewind.com to schedule a demo and learn more."
    },
    {
        "link": "https://leonardomontini.dev/git-restore-deleted-file",
        "document": "Remember that file you deleted last week? Too bad, now you need it. Let‚Äôs see how can help you recover it.\n\nThere are a few ways to restore deleted files in git, depending on how far away in the history the file was deleted. I‚Äôll cover the most common scenarios and how you can find lost files with for those cases where you don‚Äôt exactly remember when it happened.\n\nAs usual, I recorded a video with a demo of how the command works, but if you‚Äôre just in for the commands you can find everything below.\n\nYou just deleted it\n\nThe easiest scenario, most IDEs will likely have a button somewhere (vscode has the SCM tab) to undo the deletion.\n\nIf you feel faster in the terminal, there‚Äôs a shortcut with :\n\nNice and clean, your file is back. Nothing happened.\n\nYou already committed the deletion\n\nNot too bad, you can use the exact same command as before, with to go back one commit:\n\nIf the situation is more complex, it‚Äôs probably time to explore how can help you. This command is specifically designed for this kind of operation (while checkout is more general) and comes with a few extra options.\n\nI‚Äôd recommend having a look at the official documentation to understand all the options, but here are a few common scenarios, starting with the basic one:\n\nThe deleted file is still on main\n\nYou deleted the file in your branch, a few commits ago, but you know for sure it‚Äôs still in . Let‚Äôs make it easy, you can use to bring it back:\n\nHere I also added to make sure it picks the file from the remote, but if you‚Äôre at the latest version on your local main, then will do its job.\n\nThe file was deleted a long time ago, and you don‚Äôt know when\n\nThis is where comes in handy. You can use it to find the commit where the file was deleted, and then use to bring it back.\n\nThis command will show you all the commits where files were deleted, and you can use the commit hash to restore the file.\n\nHowever, if this happened looong time ago there might be way too many commits to look through. Fear not, you can add a filter with the path to the file:\n\nThis will only show the commits where that specific file was deleted. You can now grab the commit hash and use it with :\n\nDon‚Äôt forget to add to the commit hash. The reason is as follow, that hash is the commit where the file has been deleted, which means it‚Äôs no longer there. With you‚Äôre simply going back one commit, the one before the deletion, where the file is still there.\n\nIn some other cases you might simply want to undo a commit. I got you covered! Check out this video where I explore some of the possibilities!\n\nTo be fair I undo commits quite often to the point I made a git alias for it that I called (it runs ).\n\nI hope you found this article useful and now let me ask you, how do you usually go recover deleted files in git? Let me know in the comments below, I‚Äôd love to hear about your workflow!"
    },
    {
        "link": "https://stackoverflow.com/questions/1628088/reset-local-repository-branch-to-be-just-like-remote-repository-head",
        "document": "How do I reset my local branch to be just like the branch on the remote repository?\n\nSetting your branch to exactly match the remote branch can be done in two steps: If you want to save your current branch's state before doing this (just in case), you can do: git commit -a -m \"Saving my work, just in case\" git branch my-saved-work Now your work is saved on the branch \"my-saved-work\" in case you decide you want it back (or want to look at it later or diff it against your updated branch). Note that the first example assumes that the remote repo's name is \"origin\" and that the branch named \"master\" in the remote repo matches the currently checked-out branch in your local repo. BTW, this situation that you're in looks an awful lot like a common case where a push has been done into the currently checked out branch of a non-bare repository. Did you recently push into your local repo? If not, then no worries -- something else must have caused these files to unexpectedly end up modified. Otherwise, you should be aware that it's not recommended to push into a non-bare repository (and not into the currently checked-out branch, in particular).\n\nThis is what I use often: Note that it is good practice not to make changes to your local master/develop branch, but instead checkout to another branch for any change, with the branch name prepended by the type of change, e.g. , , , etc. Thus you only need to pull changes, not push any changes from master. Same thing for other branches that others contribute to. So the above should only be used if you have happened to commit changes to a branch that others have committed to, and need to reset. Otherwise in future avoid pushing to a branch that others push to, instead checkout and push to the said branch via the checked out branch. If you want to reset your local branch to the latest commit in the upstream branch, what works for me so far is: Check your remotes, make sure your upstream and origin are what you expect, if not as expected then use , e.g. of the original GitHub repo that you forked from, and/or . On GitHub, you can also checkout the branch with the same name as the local one, in order to save the work there, although this isn't necessary if origin develop has the same changes as the local saved-work branch. I'm using the develop branch as an example, but it can be any existing branch name. Then if you need to merge these changes with another branch while where there are any conflicts, preserving the changes in develop, use: to preserve branch_name's conflicting changes. Otherwise use a mergetool with . With all the changes together: Note that instead of upstream/develop you could use a commit hash, other branch name, etc. Use a CLI tool such as Oh My Zsh to check that your branch is green indicating that there is nothing to commit and the working directory is clean (which is confirmed or also verifiable by ). Note that this may actually add commits compared to upstream develop if there is anything automatically added by a commit, e.g. UML diagrams, license headers, etc., so in that case, you could then pull the changes on to , if needed.\n\nPrevious answers assume that the branch to be reset is the current branch (checked out). In comments, OP hap497 clarified that the branch is indeed checked out, but this is not explicitly required by the original question. Since there is at least one \"duplicate\" question, Reset branch completely to repository state, which does not assume that the branch is checked out, here's an alternative: If branch \"mybranch\" is not currently checked out, to reset it to remote branch \"myremote/mybranch\"'s head, you can use this low-level command: This method leaves the checked out branch as it is, and the working tree untouched. It simply moves mybranch's head to another commit, whatever is given as the second argument. This is especially helpful if multiple branches need to be updated to new remote heads. Use caution when doing this, though, and use or a similar tool to double check source and destination. If you accidentally do this on the current branch (and git will not keep you from this), you may become confused, because the new branch content does not match the working tree, which did not change (to fix, update the branch again, to where it was before)."
    },
    {
        "link": "https://stackoverflow.com/questions/3334475/git-how-to-update-checkout-a-single-file-from-remote-origin-master",
        "document": "It is possible to do (in the deployed repository)\n\nThe fetch will download all the recent changes, but it will not put it in your current checked out code (working area).\n\nThe checkout will update the working tree with the particular file from the downloaded changes ( ).\n\nAt least this works for me for those little small typo fixes, where it feels weird to create a branch etc just to change one word in a file."
    },
    {
        "link": "https://git-tower.com/learn/git/commands/git-checkout",
        "document": "The \"checkout\" command can switch the currently active branch - but it can also be used to restore files.\n\nThe most common use case for \"checkout\" is when you want to switch to a different branch, making it the new HEAD branch.\n\nAnother use case for \"checkout\" is when you want to restore a historic version of a specific file. Thereby, you can reset single files to earlier revisions - while keeping the rest of the project untouched.\n\nThe name of a local branch that you want to switch to. By specifying the name of a local branch, you will switch to this branch and make it the current \"HEAD\" branch.\n\nCreates a new local branch and directly switches to it. This can be used as a shortcut instead of the following two commands:\n\n git branch <new-branch-name>\n\n git checkout <new-branch-name>.\n\nCreates a new local branch - and sets up an \"upstream\" configuration. This way, the new local branch has a tracking relationship with its remote counterpart. This allows you to more easily see when the two aren't in sync (i.e. when unpushed commits in the local branch or unpulled commits in the remote exist).\n\nRestores a historic revision of a given file. By providing HEAD as the revision, you can restore the last committed version of a file - effectively undoing any local changes that happened since then. If you want to restore a specific earlier revision you can provide that revision's SHA-1 hash.\n\nIn its simplest (and most common) form, only the name of an existing local branch is specified:\n\nThis will make the given branch the new HEAD branch. If, in one go, you also want to create a new local branch, you can use the \"-b\" parameter:\n\nBy using the \"--track\" parameter, you can use a remote branch as the basis for a new local branch; this will also set up a \"tracking relationship\" between the two:\n\n\n\n\n\n Another use case for \"checkout\" is when you want to restore an old revision of a file:\n\nIf you specify \"HEAD\" as the revision, you will restore the last committed version of the file, effectively undoing any local changes that you current have in that file:\n‚Ä¢ Check out the chapter Checking Out a Local Branch in our free online book\n‚Ä¢ Find the full command description in the Git documentation"
    },
    {
        "link": "https://freecodecamp.org/news/git-checkout-file-from-another-branch",
        "document": "While you're working on a repository in Git, you might need to checkout a specific file from another branch.\n\nLuckily, Git offers many possible ways to do this task quickly. One of the easiest solutions is to use the command with the specified file as an argument.\n\nIn this article, we will analyze different solutions to this problem and go through the process you'll need to follow for each.\n\nLet's get to it üòé.\n\nYou are working on a branch called containing a file named .\n\nYou have another branch called with an updated file.\n\nYou want to checkout that file and bring it from the branch called to the branch called .\n\nHere are three possible solutions for this task.\n\nThe command offers a simple way to get a file or a folder from another branch.\n\nHere is the syntax to checkout a file from another branch:\n\nHere is the process to follow:\n‚Ä¢ Checkout to the branch where you want to copy the file.\n‚Ä¢ Once you are on the correct branch, copy the file.\n‚Ä¢ None Use the git status command to ensure that the file has been copied.\n\nWhen using the checkout command, you can also get:\n‚Ä¢ Multiple files by specifying each one of them.\n\nAlso, note that you can get a file/folder from the stash.\n\nAnother option is to use the command with the command.\n\nIf you have never heard about those two commands, that's alright. They are relatively new. Git introduced them in version 2.23 in 2019.\n\nThe purpose of those two commands is to split up the command's responsibilities to simplify it for users.\n\nHere is the process to follow to get a file from another branch:\n‚Ä¢ Switch to the branch where you want to checkout the file.\n‚Ä¢ Get the file from the other branch.\n‚Ä¢ Commit and push the changes.\n\nFinally, we can use the command.\n\nHere is the process to follow:\n‚Ä¢ Get the file from the other branch.\n‚Ä¢ Commit and push the changes.\n\nNote: You need to specify the relative path from your directory's root this time.\n\nAs you can see, getting a file from another branch is not rocket science.\n\nWhen I need to do it in my day-to-day life, I usually use the command.\n\nPlease visit my blog if you are interested to discover more about Git or web development technologies like TypeScript.\n\nThank you for reading this article."
    },
    {
        "link": "https://namehero.com/blog/git-checkout-remote-branch-how-to-checkout-a-file-from-another-branch",
        "document": ""
    }
]