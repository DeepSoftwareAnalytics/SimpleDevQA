[
    {
        "link": "https://geeksforgeeks.org/how-to-create-and-add-data-to-sqlite-database-in-android",
        "document": "How to Create and Add Data to SQLite Database in Android?\n\nSQLite is another data storage available in Android where we can store data in the user‚Äôs device and can use it any time when required. In this article, we will take a look at creating an SQLite database in the Android app and adding data to that database in the Android app. This is a series of 4 articles in which we are going to perform the basic CRUD (Create, Read, Update, and Delete) operation with SQLite Database in Android. We are going to cover the following 4 articles in this series:\n‚Ä¢ None How to Create and Add Data to SQLite Database in Android?\n‚Ä¢ None How to Read Data from SQLite Database in Android?\n‚Ä¢ None How to Update Data to SQLite Database in Android?\n‚Ä¢ None How to Delete Data in SQLite Database in Android?\n\nAndroid SQLite Database is an open-source database provided in Android that is used to store data inside the user‚Äôs device in the form of a Text file. We can perform many operations on this data such as adding new data, updating, reading, and deleting this data. SQLite is an offline database that is locally stored in the user‚Äôs device and we do not have to create any connection to connect to this database.\n\nHow Data is Being Stored in the SQLite Database?\n\nData is stored in the Android SQLite database in the form of tables. When we store this data in our SQLite database it is arranged in the form of tables that are similar to that of an Excel sheet. Below is the representation of our SQLite database which we are storing in our SQLite database.\n\nBelow are the several important methods that we will be using in this SQLite database integration in Android.\n\nThis method is used to get the Array of column names of our SQLite table. This method will return the number of rows in the cursor. This method returns a Boolean value when our cursor is closed. This method returns the total number of columns present in our table. This method will return the name of the column when we passed the index of our column in it. This method will return the index of our column from the name of the column. This method will return the current position of our cursor in our table.\n\nWhat we are going to build in this article?\n\nWe will be building a simple application in which we will be adding data to the Android SQLite database. We will be creating a database for adding course name, course description, course duration, and course tracks. We will be saving all this data in our Android SQLite database. A sample video is given below to get an idea about what we are going to do in this article. Note that we are going to implement this project using the Java language.\n\nTo create a new project in Android Studio please refer to How to Create/Start a New Project in Android Studio. Note that select Java as the programming language.\n\nStep 2: Adding permissions to access the storage in the AndroidManifest.xml file\n\nNavigate to the app > AndroidManifest.xml and add the below code to it.\n\nNavigate to the app > res > layout > activity_main.xml and add the below code to that file.\n\nBelow is the code for the activity_main.xml file.\n\nNavigate to the app > java > your app‚Äôs package name > Right-click on it > New > Java class and name it as DBHandler and add the below code to it. Comments are added inside the code to understand the code in more detail.\n\n// below variable is for our database name. // below int is our database version // below variable is for our table name. // below variable is for our id column. // below variable is for our course name column // below variable id for our course duration column. // below variable for our course description column. // below variable is for our course tracks column. // below method is for creating a database by running a sqlite query // on below line we are creating // an sqlite query and we are // along with their data types. // at last we are calling a exec sql // this method is use to add new course to our sqlite database. // on below line we are creating a variable for // as we are writing data in our database. // on below line we are creating a // on below line we are passing all values // along with its key and value pair. // after adding all values we are passing // at last we are closing our // this method is called to check if the table exists already.\n\nGo to the MainActivity.java file and refer to the following code. Below is the code for the MainActivity.java file. Comments are added inside the code to understand the code in more detail.\n\nNow run your app and see the output of the app.\n\nAfter successfully executed the code enter the required data inside the EditText. Most importantly if you want to know How to View and Locate SQLite Database in Android Studio then please refer to this article.\n\nAnd you can see below this is how the data stored in the SQLite database.\n\nBelow is the complete project file structure after performing the create and add operation:"
    },
    {
        "link": "https://developer.android.com/training/data-storage/sqlite",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nSaving data to a database is ideal for repeating or structured data, such as contact information. This page assumes that you are familiar with SQL databases in general and helps you get started with SQLite databases on Android. The APIs you'll need to use a database on Android are available in the package.\n\nCaution: Although these APIs are powerful, they are fairly low-level and require a great deal of time and effort to use:\n‚Ä¢ There is no compile-time verification of raw SQL queries. As your data graph changes, you need to update the affected SQL queries manually. This process can be time consuming and error prone.\n‚Ä¢ You need to use lots of boilerplate code to convert between SQL queries and data objects. For these reasons, we highly recommended using the Room Persistence Library as an abstraction layer for accessing information in your app's SQLite databases.\n\nOne of the main principles of SQL databases is the schema: a formal declaration of how the database is organized. The schema is reflected in the SQL statements that you use to create your database. You may find it helpful to create a companion class, known as a contract class, which explicitly specifies the layout of your schema in a systematic and self-documenting way.\n\nA contract class is a container for constants that define names for URIs, tables, and columns. The contract class allows you to use the same constants across all the other classes in the same package. This lets you change a column name in one place and have it propagate throughout your code.\n\nA good way to organize a contract class is to put definitions that are global to your whole database in the root level of the class. Then create an inner class for each table. Each inner class enumerates the corresponding table's columns.\n\nNote: By implementing the interface, your inner class can inherit a primary key field called that some Android classes such as expect it to have. It's not required, but this can help your database work harmoniously with the Android framework.\n\nFor example, the following contract defines the table name and column names for a single table representing an RSS feed:\n\nOnce you have defined how your database looks, you should implement methods that create and maintain the database and tables. Here are some typical statements that create and delete a table:\n\nJust like files that you save on the device's internal storage, Android stores your database in your app's private folder. Your data is secure, because by default this area is not accessible to other apps or the user.\n\nThe class contains a useful set of APIs for managing your database. When you use this class to obtain references to your database, the system performs the potentially long-running operations of creating and updating the database only when needed and not during app startup. All you need to do is call or .\n\nNote: Because they can be long-running, be sure that you call or in a background thread. See Threading on Android for more information.\n\nTo use , create a subclass that overrides the and callback methods. You may also want to implement the or methods, but they are not required.\n\nFor example, here's an implementation of that uses some of the commands shown above:\n\nTo access your database, instantiate your subclass of :\n\nInsert data into the database by passing a object to the method:\n\nThe first argument for is simply the table name.\n\nThe second argument tells the framework what to do in the event that the is empty (i.e., you did not any values). If you specify the name of a column, the framework inserts a row and sets the value of that column to null. If you specify , like in this code sample, the framework does not insert a row when there are no values.\n\nThe methods returns the ID for the newly created row, or it will return -1 if there was an error inserting the data. This can happen if you have a conflict with pre-existing data in the database.\n\nTo read from a database, use the method, passing it your selection criteria and desired columns. The method combines elements of and , except the column list defines the data you want to fetch (the \"projection\"), rather than the data to insert. The results of the query are returned to you in a object.\n\nThe third and fourth arguments ( and ) are combined to create a WHERE clause. Because the arguments are provided separately from the selection query, they are escaped before being combined. This makes your selection statements immune to SQL injection. For more detail about all arguments, see the reference.\n\nTo look at a row in the cursor, use one of the move methods, which you must always call before you begin reading values. Since the cursor starts at position -1, calling places the \"read position\" on the first entry in the results and returns whether or not the cursor is already past the last entry in the result set. For each row, you can read a column's value by calling one of the get methods, such as or . For each of the get methods, you must pass the index position of the column you desire, which you can get by calling or . When finished iterating through results, call on the cursor to release its resources. For example, the following shows how to get all the item IDs stored in a cursor and add them to a list:\n\nTo delete rows from a table, you need to provide selection criteria that identify the rows to the method. The mechanism works the same as the selection arguments to the method. It divides the selection specification into a selection clause and selection arguments. The clause defines the columns to look at, and also allows you to combine column tests. The arguments are values to test against that are bound into the clause. Because the result isn't handled the same as a regular SQL statement, it is immune to SQL injection.\n\nThe return value for the method indicates the number of rows that were deleted from the database.\n\nWhen you need to modify a subset of your database values, use the method.\n\nUpdating the table combines the syntax of with the syntax of .\n\nThe return value of the method is the number of rows affected in the database.\n\nSince and are expensive to call when the database is closed, you should leave your database connection open for as long as you possibly need to access it. Typically, it is optimal to close the database in the of the calling Activity.\n\nThe Android SDK includes a shell tool that allows you to browse table contents, run SQL commands, and perform other useful functions on SQLite databases. For more information, see how to how to issue shell commands."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/android-sqlite-database-example-tutorial",
        "document": "Welcome to Android SQLite Example Tutorial. Android SQLite is the mostly preferred way to store data for android applications. For many applications, SQLite is the apps backbone whether it‚Äôs used directly or via some third-party wrapper. Below is the final app we will create today using Android SQLite database.\n\nAndroid SQLite is a very lightweight database which comes with Android OS. Android SQLite combines a clean SQL interface with a very small memory footprint and decent speed. For Android, SQLite is ‚Äúbaked into‚Äù the Android runtime, so every Android application can create its own SQLite databases. Android SQLite native API is not JDBC, as JDBC might be too much overhead for a memory-limited smartphone. Once a database is created successfully its located in data/data//databases/ accessible from Android Device Monitor. SQLite is a typical relational database, containing tables (which consists of rows and columns), indexes etc. We can create our own tables to hold the data accordingly. This structure is referred to as a schema.\n\nAndroid has features available to handle changing database schemas, which mostly depend on using the class. SQLiteOpenHelper is designed to get rid of two very common problems.\n‚Ä¢ When the application runs the first time - At this point, we do not yet have a database. So we will have to create the tables, indexes, starter data, and so on.\n‚Ä¢ When the application is upgraded to a newer schema - Our database will still be on the old schema from the older edition of the app. We will have option to alter the database schema to match the needs of the rest of the app.\n\nwraps up these logic to create and upgrade a database as per our specifications. For that we‚Äôll need to create a custom subclass of implementing at least the following three methods.\n‚Ä¢ Constructor : This takes the Context (e.g., an Activity), the name of the database, an optional cursor factory (we‚Äôll discuss this later), and an integer representing the version of the database schema you are using (typically starting from 1 and increment later).\n‚Ä¢ onCreate(SQLiteDatabase db) : It‚Äôs called when there is no database and the app needs one. It passes us a object, pointing to a newly-created database, that we can populate with tables and initial data.\n‚Ä¢ onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) : It‚Äôs called when the schema version we need does not match the schema version of the database, It passes us a SQLiteDatabase object and the old and new version numbers. Hence we can figure out the best way to convert the database from the old schema to the new one.\n\nWe define a class to perform all database CRUD(Create, Read, Update and Delete) operations.\n\nBefore performing any database operations like insert, update, delete records in a table, first open the database connection by calling getWritableDatabase() method as shown below:\n\nThe dbHelper is an instance of the subclass of . To close a database connection the following method is invoked.\n\nThe following code snippet shows how to insert a new record in the android SQLite database.\n\nContent Values creates an empty set of values using the given initial size. We‚Äôll discuss the other instance values when we jump into the coding part.\n\nThe following snippet shows how to update a single record.\n\nWe just need to pass the id of the record to be deleted as shown below.\n\nA Cursor represents the entire result set of the query. Once the query is fetched a call to cursor.moveToFirst() is made. Calling moveToFirst() does two things:\n‚Ä¢ It allows us to test whether the query returned an empty set (by testing the return value)\n‚Ä¢ It moves the cursor to the first result (when the set is not empty)\n\nThe following code is used to fetch all records:\n\nAnother way to use a Cursor is to wrap it in a . Just as adapts arrays, adapts Cursor objects, making their data available to an like a . Let‚Äôs jump to our project that uses SQLite to store some meaningful data.\n\nIn this application we wish to create records that store Country names and their respective currencies in the form of a ListView. We cover all the features discusses above.\n\nThe application consists of 5 classes. We begin with defining with DatabaseHelper, which is a subclass of SQLiteOpenHelper as follows:\n\nAs discussed above we have overridden the and methods besides the constructor. We‚Äôve assigned the names to the database and the table as JOURNALDEV_COUNTRIES.DB and COUNTRIES respectively. The index column is auto incremented whenever a new row is inserted. The column names for country and currency are ‚Äúsubject‚Äù and ‚Äúdescription‚Äù. The DBManager classes is where the DatabaseHelper is initialized and the CRUD Operations are defined. Below is the code for this class:\n\nThe class is the activity which is launched when the application starts. Below is layout defined for it:\n\nHere a ListView component is defined to included the records stored in the database. Initially the ListView would be empty hence a TextView is used to display the same.\n\nIn this activity the DBManager object is invoked to perform the CRUD Operations. A SimpleCursorAdapter is defined to add elements to the list from the query results that are returned in an Cursor Object. On list item click an intent is performed to open the ModifyCountryActivity class. The menu contains an item to add a new record from the ActionBar. Here again an intent is performed to open the AddCountryActivity class. Below is code.\n\nThe xml layout and code of file are defined below:\n\nTwo EditText components that take the inputs for country and currency along with a button to add the values to the database and display it in the ListView are defined.\n\nThe CRUD operation performed here is adding a new record to the database. The xml layout and code of ModifyCountryActivity.java file are defined below:\n\nIt‚Äôs similar to the previous layout except that modify and delete buttons are added.\n\nThe CRUD operations performed here are updating and deleting a record. The below images are the screenshots of the final output of our project. The first image is the output seen when the application is launched for the first time. The second image is the result of clicking the menu option from the ActionBar to add a new record as shown below. The third image shows an output when 3 records are added : The fourth image shows the output when any list item is clicked to modify or delete a record : The final image is the output when a record is deleted. In this example we delete the first record :\n\nAs we‚Äôve discussed earlier in this tutorial, the database file is stored in the internal storage that is accessible from the Android Device Monitor as visible in the pic below. To view this database we need to pull this file from the device to our desktop. This is done by clicking the menu option in the top right as seen in the image below : To open this file download the SQLiteBrowser from this link. The snippets below show the schema and tables in the browser. To view the table go to the Browse Data tab on top. The following image is seen: This brings an end to Android SQLite tutorial. The final Android SQLite Project is downloadable from the below link."
    },
    {
        "link": "https://stackoverflow.com/questions/24433625/android-database-crud-operations-for-multiple-tables-in-mvc",
        "document": "A newbie to Android and trying to save and view some info into/from a sql lite database. My tables are as follows:\n\nAs far as I understand, the Model part of MVC will store all the business logic, thus my 'Student', 'Course' and 'Registration' classes will have all the get/set methods. I have a DBHelper class that extends SQLiteOpenHelper and as I saw in many tutorial, this class contains all the CRUD operations in general.\n\nBut my question is, as I have multiple tables to work with, where should I place the CRUD operations like addStudent(), addCourse(), addRegistration(). I suppose it would not be feasible to have a very large DBHelper class containing all the CRUD methods in the universe. In some examples, I have seen view operations(viewStudent() for example) in MainActivity as well. Is it a good way to do it? An example (with Classes and and their methods) will be highly appreciated."
    },
    {
        "link": "https://simplifiedcoding.net/android-sqlite-database-example",
        "document": "Hey, friends here is an Android SQLite Database Example. You may already know that we have SQLite database in android that we can use as a local SQL Database for our android application.\n\nThis Android SQLite Database Example will cover Creating Database, Creating Tables, Creating Records, Reading Records, Updating Records and Deleting Records in Android SQLite Database. After going through this post you will be having a complete idea about using SQLite database for your Android Application. So let‚Äôs start.\n\nSQLite is an SQL Database. I am assuming here that you are familiar with SQL databases. So in SQL database, we store data in tables. The tables are the structure of storing data consisting of rows and columns. We are not going in depth of what is an SQL database and how to work in SQL database. If you are going through this post, then you must know the Basics of SQL.\n\nAs the heading tells you here, we are going to learn the CRUD operation in SQLite Database.\n\n But what is CRUD? CRUD is nothing but an abbreviation for the basic operations that we perform in any database. And the operations are\n‚Ä¢ Before moving ahead on this tutorial if you want to know what we will be building, you can get the final apk of this tutorial from the link given below.\n‚Ä¢ As always we will create a new Android Studio Project. For this example, I have a new project named SQLiteCRUDExample.\n‚Ä¢ Once your project is loaded, we can start working on it.\n‚Ä¢ The first thing needed is the database structure. We create database structure according to the system. But here we are not building an application, and it is only an example demonstrating the use of SQLite Database. So for this, I will use the following table structure.\n‚Ä¢ Now we have only a single table, but in real-world scenarios, you will have multiple tables with some complex relationships. Also, remember one thing whenever you create a table create a column named id with int as PRIMARY KEY and AUTOINCREMENT. (If you are confused don‚Äôt worry we will see now how do we create tables in database using SQL).\n‚Ä¢ Now let‚Äôs see how we can create the above table in our SQLite database.\n\nNote: * means selecting all the columns, if you want a specific column or multiple columns but not all you can write names of the columns like SELECT name, department.\n\nThese are just some simple basics operations, but we can perform many tasks in our database. For this, you need to learn SQL in detail.\n‚Ä¢ To implement all the above-given queries in our application, we need an Interface from where we can accomplish these tasks. Now, lets think about the screens that we need to make an app that will perform all the above-given queries with user interaction.\n‚Ä¢ The first thing is adding a new record to our database, and for this, we can use the following screen.\n‚Ä¢ As you can see we have EditText, Button, Spinner and some TextViews. To create the above interface, you can use the following XML code. You need to paste the following code inside activity_main.xml which is generated by default in any project because this will be the first screen for our application.\n‚Ä¢ For the spinner that we used in the above screen, we need to define an Array as the entries for the spinner. So go inside values->strings.xml and modify it as below.\n‚Ä¢ Now after storing employee to the database, we also need to see all the stored employee from the database. For this, we can use a ListView.\n‚Ä¢ So, to create a new EmptyActivity in your project named EmployeeActivity. It will create a java file named EmployeeActivity.java and a layout file called activity_employee.xml.\n‚Ä¢ For this screen we can use the following design.\n‚Ä¢ This screen contains a only a ListView. The xml for the above screen is below.\n‚Ä¢ But here we will not use a simple ListView as we need to display multiple items in the List we will be using a Custom ListView. You can learn about creating custom ListView from this tutorial -> Creating a CustomListview.\n‚Ä¢ And for the ListView item we need one more layout as well, so create one more layout file named list_layout_employee.xml and write the following xml code.\n‚Ä¢ The above xml code will generate the following layout.\n‚Ä¢ Now we will create one more layout file (not a new activity only a layout file because we will edit the employee in an alert dialog) to update the employee data. So create a new layout file named dialog_update_employee.xml.\n‚Ä¢ This code will generate the following design.\n‚Ä¢ We don‚Äôt need a separate design for deleting the employee as we will be doing it from the button that we created on the List.\n‚Ä¢ So we are done with the interface design. Now lets start coding.\n‚Ä¢ We will perform this operation inside MainActivity.java so inside this file write the following code.\n‚Ä¢ In the above code you see we used a method openOrCreateDatabase().\n‚Ä¢ This method takes 3 parameters.\n\n First parameter is the database name as String, that we need to open. Lets assume we passed some name ‚Äúxyz‚Äù as the first parameter then if there exist a database named ‚Äúxyz‚Äù it will open it, if no database found with the specified name it will create a new database named ‚Äúxyz‚Äù and will open it.\n\n Second Parameter is the open mode as int. We have some predefined values for it, right now we are using MODE_PRIVATE and it simply means that only this application can access this database.\n‚Ä¢ Now we will create a method to create the Employee table. So create a method named createEmployeeTable().\n‚Ä¢ Now just call this method just after calling the openOrCreateDatabase() method. In the above method we are just calling the method execSQL() to create our database table. The execSQL() method takes String as a parameter and the String is actually the SQL query that we need to execute.\n‚Ä¢ Remember we use execSQL() method only for creating table, inserting or updating records. We cannot use it to retrieve values.\n‚Ä¢ Till now we have the database, the table now we need to insert the employee in the table and we need to do this inside addEmployee() method.\n‚Ä¢ Now you can test your application for the Create Operation.\n‚Ä¢ Now lets move towards fetching the stored employees which we call the Read Operation.\n‚Ä¢ We will do this operation inside EmployeeActivity.java. But before fetching the employees, we need two more java classes to display employees in the list. The first class is a regular java class to store the employee as an object and a CustomAdapter class for the ListView.\n‚Ä¢ Create a simple java class named Employee.java and write the following code.\n‚Ä¢ Now we will create a custom adapter class for our ListView.\n‚Ä¢ Create a java class named EmployeeAdapter and write the following code.\n‚Ä¢ Now we can fetch the employees to display them in the ListView.\n‚Ä¢ Come inside EmployeeActivity.java and write the following code.\n‚Ä¢ Now try running the application to see the Read Operation.\n‚Ä¢ We have done with reate and ead, now lets do the Update Operation. We will perform it inside the EmployeeAdapter class.\n‚Ä¢ For the Update operation we need two new methods inside the EmployeeAdapter.java. One is to update the employee and the second one is to reload the employee from database to show updated information.\n‚Ä¢ So inside the class you need to make below given two methods named updateEmployee() and reloadEmployeesFromDatabase() method.\n‚Ä¢ The update operation is same as the insert operation, we changed the query only to update from insert. If you are having any confusion understanding the codes please comment and I will help you.\n‚Ä¢ Now we need to modify the getView() method of EmployeeAdapter as below.\n‚Ä¢ Now you can test the Update Operation.\n‚Ä¢ We have done with reate, ead and pdate. Now the last operation is the elete Operation. So lets do this to complete the CRUD for this tutorial.\n‚Ä¢ We will do the deletion also in the EmployeeAdapter class. The operation is same we just need to change the SQL String to perform delete operation the rest part is exactly the same.\n‚Ä¢ So to make the delete operation again modify the getView() of EmployeeAdapter as below.\n‚Ä¢ So the operation is complete and now you can test all the operation in your application and you should see something like this.\n‚Ä¢ If you are facing any troubles building, the application then don‚Äôt worry here is my source code for you.\n\nSo that‚Äôs all for this Android SQLite Database Example friends. I hope you liked it. For any confusions or questions just leave your comments below. Please write your real name in the comment box as I don‚Äôt approve comments with spam names.\n\nYou can share this post to help us. Thank You üôÇ"
    },
    {
        "link": "https://developer.android.com/guide/fragments/lifecycle",
        "document": "Each instance has its own lifecycle. When a user navigates and interacts with your app, your fragments transition through various states in their lifecycle as they are added, removed, and enter or exit the screen.\n\nTo manage lifecycle, implements , exposing a object that you can access through the method.\n\nEach possible state is represented in the enum.\n\nBy building on top of , you can use the techniques and classes available for Handling Lifecycles with Lifecycle-Aware Components. For example, you might display the device's location on the screen using a lifecycle-aware component. This component could automatically start listening when the fragment becomes active and stop when the fragment moves to an inactive state.\n\nAs an alternative to using a , the class includes callback methods that correspond to each of the changes in a fragment's lifecycle. These include , , , , , and .\n\nA fragment's view has a separate that is managed independently from that of the fragment's . Fragments maintain a for their view, which can be accessed using or . Having access to the view's is useful for situations where a Lifecycle-aware component should only perform work while a fragment's view exists, such as observing that is only meant to be displayed on the screen.\n\nThis topic discusses the lifecycle in detail, explaining some of the rules that determine a fragment's lifecycle state and showing the relationship between the states and the fragment lifecycle callbacks.\n\nWhen a fragment is instantiated, it begins in the state. For a fragment to transition through the rest of its lifecycle, it must be added to a . The is responsible for determining what state its fragment should be in and then moving them into that state.\n\nBeyond the fragment lifecycle, is also responsible for attaching fragments to their host activity and detaching them when the fragment is no longer in use. The class has two callback methods, and , that you can override to perform work when either of these events occur.\n\nThe callback is invoked when the fragment has been added to a and is attached to its host activity. At this point, the fragment is active, and the is managing its lifecycle state. At this point, methods such as return this fragment.\n\nis always called before any Lifecycle state changes.\n\nThe callback is invoked when the fragment has been removed from a and is detached from its host activity. The fragment is no longer active and can no longer be retrieved using .\n\nis always called after any Lifecycle state changes.\n\nNote that these callbacks are unrelated to the methods and . For more information on these methods, see Fragment transactions.\n\nWhen determining a fragment's lifecycle state, considers the following:\n‚Ä¢ A fragment's maximum state is determined by its . A fragment cannot progress beyond the state of its .\n‚Ä¢ As part of a , you can set a maximum lifecycle state on a fragment using .\n‚Ä¢ A fragment's lifecycle state can never be greater than its parent. For example, a parent fragment or activity must be started before its child fragments. Likewise, child fragments must be stopped before their parent fragment or activity.\n\nFigure 1 shows each of the fragment's states and how they relate to both the fragment's lifecycle callbacks and the fragment's view .\n\nAs a fragment progresses through its lifecycle, it moves upward and downward through its states. For example, a fragment that is added to the top of the back stack moves upward from to to . Conversely, when a fragment is popped off of the back stack, it moves downward through those states, going from to to and finally .\n\nWhen moving upward through its lifecycle states, a fragment first calls the associated lifecycle callback for its new state. Once this callback is finished, the relevant is emitted to observers by the fragment's , followed by the fragment's view , if it has been instantiated.\n\nWhen your fragment reaches the state, it has been added to a and the method has already been called.\n\nThis would be the appropriate place to restore any saved state associated with the fragment itself through the fragment's . Note that the fragment's view has not been created at this time, and any state associated with the fragment's view should be restored only after the view has been created.\n\nThis transition invokes the callback. The callback also receives a argument containing any state previously saved by . Note that has a value the first time the fragment is created, but it is always non-null for subsequent recreations, even if you do not override . See Saving state with fragments for more details.\n\nThe fragment's view is created only when your provides a valid instance. In most cases, you can use the fragment constructors that take a , which automatically inflates the view at the appropriate time. You can also override to programmatically inflate or create your fragment's view.\n\nIf and only if your fragment's view is instantiated with a non-null , that is set on the fragment and can be retrieved using . The is then updated with the newly corresponding with the fragment's view. The lifecycle callback is also called at this time.\n\nThis is the appropriate place to set up the initial state of your view, to start observing instances whose callbacks update the fragment's view, and to set up adapters on any or instances in your fragment's view.\n\nAfter the fragment's view has been created, the previous view state, if any, is restored, and the view's is then moved into the state. The view lifecycle owner also emits the event to its observers. Here you should restore any additional state associated with the fragment's view.\n\nThis transition also invokes the callback.\n\nIt is strongly recommended to tie Lifecycle-aware components to the state of a fragment, as this state guarantees that the fragment's view is available, if one was created, and that it is safe to perform a on the child of the fragment. If the fragment's view is non-null, the fragment's view is moved to immediately after the fragment's is moved to .\n\nWhen the fragment becomes , the callback is invoked.\n\nWhen the fragment is visible, all and effects have finished, and the fragment is ready for user interaction. The fragment's moves to the state, and the callback is invoked.\n\nThe transition to is the appropriate signal to indicate that the user is now able to interact with your fragment. Fragments that are not should not manually set focus on their views or attempt to handle input method visibility.\n\nWhen a fragment moves downward to a lower lifecycle state, the relevant is emitted to observers by the fragment's view , if instantiated, followed by the fragment's . After a fragment's lifecycle event is emitted, the fragment calls the associated lifecycle callback.\n\nAs the user begins to leave the fragment, and while the fragment is still visible, the s for the fragment and for its view are moved back to the state and emit the event to their observers. The fragment then invokes its callback.\n\nOnce the fragment is no longer visible, the s for the fragment and for its view are moved into the state and emit the event to their observers. This state transition is triggered not only by the parent activity or fragment being stopped, but also by the saving of state by the parent activity or fragment. This behavior guarantees that the event is invoked before the fragment's state is saved. This makes the event the last point where it is safe to perform a on the child .\n\nAs shown in figure 2, the ordering of the callback and the saving of the state with differs based on API level. For all API levels prior to API 28, is invoked before . For API levels 28 and higher, the calling order is reversed.\n\nAfter all of the exit animations and transitions have completed, and the fragment's view has been detached from the window, the fragment's view is moved into the state and emits the event to its observers. The fragment then invokes its callback. At this point, the fragment's view has reached the end of its lifecycle and returns a value.\n\nAt this point, all references to the fragment's view should be removed, allowing the fragment's view to be garbage collected.\n\nIf the fragment is removed, or if the is destroyed, the fragment's is moved into the state and sends the event to its observers. The fragment then invokes its callback. At this point, the fragment has reached the end of its lifecycle.\n\nFor more information related to the fragment lifecycle, see the following additional resources."
    },
    {
        "link": "https://developer.android.com/guide/fragments",
        "document": "A represents a reusable portion of your app's UI. A fragment defines and manages its own layout, has its own lifecycle, and can handle its own input events. Fragments can't live on their own. They must be hosted by an activity or another fragment. The fragment‚Äôs view hierarchy becomes part of, or attaches to, the host‚Äôs view hierarchy.\n\nFragments introduce modularity and reusability into your activity‚Äôs UI by letting you divide the UI into discrete chunks. Activities are an ideal place to put global elements around your app's user interface, such as a navigation drawer. Conversely, fragments are better suited to define and manage the UI of a single screen or portion of a screen.\n\nConsider an app that responds to various screen sizes. On larger screens, you might want the app to display a static navigation drawer and a list in a grid layout. On smaller screens, you might want the app to display a bottom navigation bar and a list in a linear layout.\n\nManaging these variations in the activity is unwieldy. Separating the navigation elements from the content can make this process more manageable. The activity is then responsible for displaying the correct navigation UI, while the fragment displays the list with the proper layout.\n\nDividing your UI into fragments makes it easier to modify your activity's appearance at runtime. While your activity is in the lifecycle state or higher, fragments can be added, replaced, or removed. And you can keep a record of these changes in a back stack that is managed by the activity, so that the changes can be reversed.\n\nYou can use multiple instances of the same fragment class within the same activity, in multiple activities, or even as a child of another fragment. With this in mind, only provide a fragment with the logic necessary to manage its own UI. Avoid depending on or manipulating one fragment from another.\n\nFor more documentation and resources related to fragments, see the following.\n‚Ä¢ Single Activity: Why, when, and how (Android Dev Summit '18)"
    },
    {
        "link": "https://developer.android.com/guide/components/activities/activity-lifecycle",
        "document": "As a user navigates through, out of, and back to your app, the instances in your app transition through different states in their lifecycle. The class provides a number of callbacks that let the activity know when a state changes or that the system is creating, stopping, or resuming an activity or destroying the process the activity resides in.\n\nWithin the lifecycle callback methods, you can declare how your activity behaves when the user leaves and re-enters the activity. For example, if you're building a streaming video player, you might pause the video and terminate the network connection when the user switches to another app. When the user returns, you can reconnect to the network and let the user resume the video from the same spot.\n\nEach callback lets you perform specific work that's appropriate to a given change of state. Doing the right work at the right time and handling transitions properly make your app more robust and performant. For example, good implementation of the lifecycle callbacks can help your app avoid the following:\n‚Ä¢ Crashing if the user receives a phone call or switches to another app while using your app.\n‚Ä¢ Consuming valuable system resources when the user is not actively using it.\n‚Ä¢ Losing the user's progress if they leave your app and return to it at a later time.\n‚Ä¢ Crashing or losing the user's progress when the screen rotates between landscape and portrait orientation.\n\nThis document explains the activity lifecycle in detail. The document begins by describing the lifecycle paradigm. Next, it explains each of the callbacks: what happens internally while they execute and what you need to implement during them.\n\nIt then briefly introduces the relationship between activity state and a process‚Äôs vulnerability to being killed by the system. Finally, it discusses several topics related to transitions between activity states.\n\nFor information about handling lifecycles, including guidance about best practices, see Handling Lifecycles with Lifecycle-Aware Components and Save UI states. To learn how to architect a robust, production-quality app using activities in combination with architecture components, see Guide to app architecture.\n\nTo navigate transitions between stages of the activity lifecycle, the class provides a core set of six callbacks: , , , , , and . The system invokes each of these callbacks as the activity enters a new state.\n\nAs the user begins to leave the activity, the system calls methods to dismantle the activity. In some cases, the activity is only partially dismantled and still resides in memory, such as when the user switches to another app. In these cases, the activity can still come back to the foreground.\n\nIf the user returns to the activity, it resumes from where the user left off. With a few exceptions, apps are restricted from starting activities when running in the background.\n\nThe system‚Äôs likelihood of killing a given process, along with the activities in it, depends on the state of the activity at the time. For more information on the relationship between state and vulnerability to ejection, see the section about activity state and ejection from memory.\n\nDepending on the complexity of your activity, you probably don't need to implement all the lifecycle methods. However, it's important that you understand each one and implement those that make your app behave the way users expect.\n\nThis section provides conceptual and implementation information about the callback methods used during the activity lifecycle.\n\nSome actions belong in the activity lifecycle methods. However, place code that implements the actions of a dependent component in the component, rather than the activity lifecycle method. To achieve this, you need to make the dependent component lifecycle-aware. To learn how to make your dependent components lifecycle-aware, see Handling Lifecycles with Lifecycle-Aware Components.\n\nYou must implement this callback, which fires when the system first creates the activity. On activity creation, the activity enters the Created state. In the method, perform basic application startup logic that happens only once for the entire life of the activity.\n\nFor example, your implementation of might bind data to lists, associate the activity with a , and instantiate some class-scope variables. This method receives the parameter , which is a object containing the activity's previously saved state. If the activity has never existed before, the value of the object is null.\n\nIf you have a lifecycle-aware component that is hooked up to the lifecycle of your activity, it receives the event. The method annotated with is called so your lifecycle-aware component can perform any setup code it needs for the created state.\n\nThe following example of the method shows fundamental setup for the activity, such as declaring the user interface (defined in an XML layout file), defining member variables, and configuring some of the UI. In this example, the XML layout file passes the file‚Äôs resource ID to .\n\nAs an alternative to defining the XML file and passing it to , you can create new objects in your activity code and build a view hierarchy by inserting new objects into a . You then use that layout by passing the root to . For more information about creating a user interface, see the user interface documentation.\n\nYour activity does not remain in the Created state. After the method finishes execution, the activity enters the Started state and the system calls the and methods in quick succession.\n\nWhen the activity enters the Started state, the system invokes . This call makes the activity visible to the user as the app prepares for the activity to enter the foreground and become interactive. For example, this method is where the code that maintains the UI is initialized.\n\nWhen the activity moves to the Started state, any lifecycle-aware component tied to the activity's lifecycle receives the event.\n\nThe method completes quickly and, as with the Created state, the activity does not remain in the Started state. Once this callback finishes, the activity enters the Resumed state and the system invokes the method.\n\nWhen the activity enters the Resumed state, it comes to the foreground, and the system invokes the callback. This is the state in which the app interacts with the user. The app stays in this state until something happens to take focus away from the app, such as the device receiving a phone call, the user navigating to another activity, or the device screen turning off.\n\nWhen the activity moves to the Resumed state, any lifecycle-aware component tied to the activity's lifecycle receives the event. This is where the lifecycle components can enable any functionality that needs to run while the component is visible and in the foreground, such as starting a camera preview.\n\nWhen an interruptive event occurs, the activity enters the Paused state and the system invokes the callback.\n\nIf the activity returns to the Resumed state from the Paused state, the system once again calls the method. For this reason, implement to initialize components that you release during and to perform any other initializations that must occur each time the activity enters the Resumed state.\n\nHere is an example of a lifecycle-aware component that accesses the camera when the component receives the event:\n\nThe preceding code initializes the camera once the receives the event. In multi-window mode, however, your activity might be fully visible even when it is in the Paused state. For example, when the app is in multi-window mode and the user taps the window that does not contain your activity, your activity moves to the Paused state.\n\nIf you want the camera active only when the app is Resumed (visible and active in the foreground), then initialize the camera after the event demonstrated previously. If you want to keep the camera active while the activity is Paused but visible, such as in multi-window mode, then initialize the camera after the event.\n\nHowever, having the camera active while your activity is Paused might deny access to the camera to another Resumed app in multi-window mode. Sometimes it is necessary to keep the camera active while your activity is Paused, but it might actually degrade the overall user experience if you do.\n\nFor this reason, think carefully about where in the lifecycle it is most appropriate to take control of shared system resources in the context of multi-window mode. To learn more about supporting multi-window mode, see Multi-window support.\n\nRegardless of which build-up event you choose to perform an initialization operation in, make sure to use the corresponding lifecycle event to release the resource. If you initialize something after the event, release or terminate it after the event. If you initialize after the event, release after the event.\n\nThe preceding code snippet places camera initialization code in a lifecycle-aware component. You can instead put this code directly into the activity lifecycle callbacks, such as and , but we don't recommend this. Adding this logic to an independent, lifecycle-aware component lets you reuse the component across multiple activities without having to duplicate code. To learn how to create a lifecycle-aware component, see Handling Lifecycles with Lifecycle-Aware Components.\n\nThe system calls this method as the first indication that the user is leaving your activity, though it does not always mean the activity is being destroyed. It indicates that the activity is no longer in the foreground, but it is still visible if the user is in multi-window mode. There are several reasons why an activity might enter this state:\n‚Ä¢ An event that interrupts app execution, as described in the section about the onResume() callback, pauses the current activity. This is the most common case.\n‚Ä¢ In multi-window mode, only one app has focus at any time, and the system pauses all the other apps.\n‚Ä¢ The opening of a new, semi-transparent activity, such as a dialog, pauses the activity it covers. As long as the activity is partially visible but not in focus, it remains paused.\n\nWhen an activity moves to the Paused state, any lifecycle-aware component tied to the activity's lifecycle receives the event. This is where the lifecycle components can stop any functionality that does not need to run while the component is not in the foreground, such as stopping a camera preview.\n\nUse the method to pause or adjust operations that can't continue, or might continue in moderation, while the is in the Paused state, and that you expect to resume shortly.\n\nYou can also use the method to release system resources, handles to sensors (like GPS), or any resources that affect battery life while your activity is Paused and the user does not need them.\n\nHowever, as mentioned in the section about , a Paused activity might still be fully visible if the app is in multi-window mode. Consider using instead of to fully release or adjust UI-related resources and operations to better support multi-window mode.\n\nThe following example of a reacting to the event is the counterpart to the preceding event example, releasing the camera that initializes after the event is received:\n\nThis example places the camera release code after the event is received by the .\n\nexecution is very brief and does not necessarily offer enough time to perform save operations. For this reason, don't use to save application or user data, make network calls, or execute database transactions. Such work might not complete before the method completes.\n\nInstead, perform heavy-load shutdown operations during . For more information about suitable operations to perform during , see the next section. For more information about saving data, see the section about saving and restoring state.\n\nCompletion of the method does not mean that the activity leaves the Paused state. Rather, the activity remains in this state until either the activity resumes or it becomes completely invisible to the user. If the activity resumes, the system once again invokes the callback.\n\nIf the activity returns from the Paused state to the Resumed state, the system keeps the instance resident in memory, recalling that instance when the system invokes . In this scenario, you don‚Äôt need to re-initialize components created during any of the callback methods leading up to the Resumed state. If the activity becomes completely invisible, the system calls .\n\nWhen your activity is no longer visible to the user, it enters the Stopped state, and the system invokes the callback. This can occur when a newly launched activity covers the entire screen. The system also calls when the activity finishes running and is about to be terminated.\n\nWhen the activity moves to the Stopped state, any lifecycle-aware component tied to the activity's lifecycle receives the event. This is where the lifecycle components can stop any functionality that does not need to run while the component is not visible on the screen.\n\nIn the method, release or adjust resources that are not needed while the app is not visible to the user. For example, your app might pause animations or switch from fine-grained to coarse-grained location updates. Using instead of means that UI-related work continues, even when the user is viewing your activity in multi-window mode.\n\nAlso, use to perform relatively CPU-intensive shutdown operations. For example, if you can't find a better time to save information to a database, you might do so during . The following example shows an implementation of that saves the contents of a draft note to persistent storage:\n\nThe preceding code sample uses SQLite directly. However, we recommend using Room, a persistence library that provides an abstraction layer over SQLite. To learn more about the benefits of using Room and how to implement Room in your app, see the Room Persistence Library guide.\n\nWhen your activity enters the Stopped state, the object is kept resident in memory: it maintains all state and member information, but is not attached to the window manager. When the activity resumes, it recalls this information.\n\nYou don‚Äôt need to re-initialize components created during any of the callback methods leading up to the Resumed state. The system also keeps track of the current state for each object in the layout, so if the user enters text into an widget, that content is retained so you don't need to save and restore it.\n\nNote: Once your activity is stopped, the system might destroy the process that contains the activity if the system needs to recover memory. Even if the system destroys the process while the activity is stopped, the system still retains the state of the objects, such as text in an widget, in a ‚Äîa blob of key-value pairs‚Äîand restores them if the user navigates back to the activity. For more information about restoring an activity to which a user returns, see the section about saving and restoring state.\n\nFrom the Stopped state, the activity either comes back to interact with the user, or the activity is finished running and goes away. If the activity comes back, the system invokes . If the is finished running, the system calls .\n\nis called before the activity is destroyed. The system invokes this callback for one of two reasons:\n‚Ä¢ The activity is finishing, due to the user completely dismissing the activity or due to being called on the activity.\n‚Ä¢ The system is temporarily destroying the activity due to a configuration change, such as device rotation or entering multi-window mode.\n\nWhen the activity moves to the destroyed state, any lifecycle-aware component tied to the activity's lifecycle receives the event. This is where the lifecycle components can clean up anything they need to before the is destroyed.\n\nInstead of putting logic in your to determine why it is being destroyed, use a object to contain the relevant view data for your . If the is recreated due to a configuration change, the does not have to do anything, since it is preserved and given to the next instance.\n\nIf the isn't recreated, then the has the method called, where it can clean up any data it needs to before being destroyed. You can distinguish between these two scenarios with the method.\n\nIf the activity is finishing, is the final lifecycle callback the activity receives. If is called as the result of a configuration change, the system immediately creates a new activity instance and then calls on that new instance in the new configuration.\n\nThe callback releases all resources not released by earlier callbacks, such as .\n\nThe system kills processes when it needs to free up RAM. The likelihood of the system killing a given process depends on the state of the process at the time. Process state, in turn, depends on the state of the activity running in the process. Table 1 shows the correlations among process state, activity state, and the likelihood of the system killing the process. This table only applies if a process is not running other types of application components.\n\nThe system never kills an activity directly to free up memory. Instead, it kills the process the activity runs in, destroying not only the activity but everything else running in the process as well. To learn how to preserve and restore your activity's UI state when system-initiated process death occurs, see the section about saving and restoring state.\n\nThe user can also kill a process by using the Application Manager, under Settings, to kill the corresponding app.\n\nFor more information about processes, see Processes and threads overview.\n\nA user expects an activity‚Äôs UI state to remain the same throughout a configuration change, such as rotation or switching into multi-window mode. However, the system destroys the activity by default when such a configuration change occurs, wiping away any UI state stored in the activity instance.\n\nSimilarly, a user expects UI state to remain the same if they temporarily switch away from your app to a different app and then come back to your app later. However, the system can destroy your application‚Äôs process while the user is away and your activity is stopped.\n\nWhen system constraints destroy the activity, preserve the user‚Äôs transient UI state using a combination of , , and/or local storage. To learn more about user expectations compared to system behavior and how to best preserve complex UI state data across system-initiated activity and process death, see Save UI states.\n\nThis section outlines what instance state is and how to implement the method, which is a callback on the activity itself. If your UI data is lightweight, you can use alone to persist the UI state across both configuration changes and system-initiated process death. But because incurs serialization/deserialization costs, in most cases you use both and , as outlined in Save UI states.\n\nNote: To learn more about configuration changes, how to restrict Activity recreation if needed, and how to react to those configuration changes from the View system and Jetpack Compose, check out the Handle configuration changes page.\n\nThere are a few scenarios in which your activity is destroyed due to normal app behavior, such as when the user presses the Back button or your activity signals its own destruction by calling the method.\n\nWhen your activity is destroyed because the user presses Back or the activity finishes itself, both the system's and the user's concept of that instance is gone forever. In these scenarios, the user's expectation matches the system's behavior, and you do not have any extra work to do.\n\nHowever, if the system destroys the activity due to system constraints (such as a configuration change or memory pressure), then although the actual instance is gone, the system remembers that it existed. If the user attempts to navigate back to the activity, the system creates a new instance of that activity using a set of saved data that describes the state of the activity when it was destroyed.\n\nThe saved data that the system uses to restore the previous state is called the instance state. It's a collection of key-value pairs stored in a object. By default, the system uses the instance state to save information about each object in your activity layout, such as the text value entered into an widget.\n\nSo, if your activity instance is destroyed and recreated, the state of the layout is restored to its previous state with no code required by you. However, your activity might have more state information that you'd like to restore, such as member variables that track the user's progress in the activity.\n\nNote: In order for the Android system to restore the state of the views in your activity, each view must have a unique ID, supplied by the attribute.\n\nA object isn't appropriate for preserving more than a trivial amount of data, because it requires serialization on the main thread and consumes system-process memory. To preserve more than a very small amount of data, take a combined approach to preserving data, using persistent local storage, the method, and the class, as outlined in Save UI states.\n\nAs your activity begins to stop, the system calls the method so your activity can save state information to an instance state bundle. The default implementation of this method saves transient information about the state of the activity's view hierarchy, such as the text in an widget or the scroll position of a widget.\n\nTo save additional instance state information for your activity, override and add key-value pairs to the object that is saved in the event that your activity is destroyed unexpectedly. When you override , you need to call the superclass implementation if you want the default implementation to save the state of the view hierarchy. This is shown in the following example:\n\nNote: is not called when the user explicitly closes the activity or in other cases when is called.\n\nTo save persistent data, such as user preferences or data for a database, take appropriate opportunities when your activity is in the foreground. If no such opportunity arises, save persistent data during the method.\n\nWhen your activity is recreated after it was previously destroyed, you can recover your saved instance state from the that the system passes to your activity. Both the and callback methods receive the same that contains the instance state information.\n\nBecause the method is called whether the system is creating a new instance of your activity or recreating a previous one, you need to check whether the state is null before you attempt to read it. If it is null, then the system is creating a new instance of the activity, instead of restoring a previous one that was destroyed.\n\nThe following code snippet shows how you can restore some state data in :\n\nInstead of restoring the state during , you can choose to implement , which the system calls after the method. The system calls only if there is a saved state to restore, so you do not need to check whether the is null.\n\nCaution: Always call the superclass implementation of so the default implementation can restore the state of the view hierarchy.\n\nAn app is likely to enter and exit an activity, perhaps many times, during the app‚Äôs lifetime, such as when the user taps the device‚Äôs Back button or the activity launches a different activity.\n\nThis section covers topics you need to know to implement successful activity transitions. These topics include starting an activity from another activity, saving activity state, and restoring activity state.\n\nStarting one activity from another\n\nAn activity often needs to start another activity at some point. This need arises, for instance, when an app needs to move from the current screen to a new one.\n\nDepending on whether or not your activity wants a result back from the new activity it‚Äôs about to start, you start the new activity using either the method or the method. In either case, you pass in an object.\n\nThe object specifies either the exact activity you want to start or describes the type of action you want to perform. The system selects the appropriate activity for you, which can even be from a different application. An object can also carry small amounts of data to be used by the activity that is started. For more information about the class, see Intents and Intent Filters.\n\nIf the newly started activity does not need to return a result, the current activity can start it by calling the method.\n\nWhen working within your own application, you often need to simply launch a known activity. For example, the following code snippet shows how to launch an activity called .\n\nYour application might also want to perform some action, such as send an email, text message, or status update, using data from your activity. In this case, your application might not have its own activities to perform such actions, so you can instead leverage the activities provided by other applications on the device, which can perform the actions for you.\n\nThis is where intents are really valuable. You can create an intent that describes an action you want to perform, and the system launches the appropriate activity from another application. If there are multiple activities that can handle the intent, then the user can select which one to use. For example, if you want to let the user send an email message, you can create the following intent:\n\nThe extra added to the intent is a string array of email addresses the email is to be sent to. When an email application responds to this intent, it reads the string array provided in the extra and places the addresses in the \"to\" field of the email composition form. In this situation, the email application's activity starts, and when the user is done, your activity resumes.\n\nSometimes you want to get a result back from an activity when it ends. For example, you might start an activity that lets the user pick a person in a list of contacts. When it ends, it returns the person that was selected. To do this, you call the method, where the integer parameter identifies the call.\n\nThis identifier is meant to distinguish between multiple calls to from the same activity. It's not a global identifier and is not at risk of conflicting with other apps or activities. The result comes back through your method.\n\nWhen a child activity exits, it can call to return data to its parent. The child activity must supply a result code, which can be the standard results , , or any custom values starting at .\n\nIn addition, the child activity can optionally return an object containing any additional data it wants. The parent activity uses the method, along with the integer identifier the parent activity originally supplied, to receive the information.\n\nIf a child activity fails for any reason, such as crashing, the parent activity receives a result with the code .\n\nWhen one activity starts another, they both experience lifecycle transitions. The first activity stops operating and enters the Paused or Stopped state, while the other activity is created. In case these activities share data saved to disc or elsewhere, it's important to understand that the first activity is not completely stopped before the second one is created. Rather, the process of starting the second one overlaps with the process of stopping the first one.\n\nThe order of lifecycle callbacks is well defined, particularly when the two activities are in the same process‚Äîin other words, the same app‚Äîand one is starting the other. Here's the order of operations that occur when Activity A starts Activity B:\n‚Ä¢ Activity B's , , and methods execute in sequence. Activity B now has user focus.\n‚Ä¢ If Activity A is no longer visible on screen, its method executes.\n\nThis sequence of lifecycle callbacks lets you manage the transition of information from one activity to another."
    },
    {
        "link": "https://geeksforgeeks.org/fragment-lifecycle-in-android",
        "document": "In Android, the fragment is the part of the Activity that represents a portion of the User Interface(UI) on the screen. It is the modular section of the Android activity that is very helpful in creating UI designs that are flexible in nature and auto-adjustable based on the device screen size. The UI flexibility on all devices improves the user experience and adaptability of the application. that can exist only inside an activity as its lifecycle is dependent on the lifecycle of the host activity. For example, if the host activity is paused, then all the methods and operations of the fragment related to that activity will stop functioning, the fragment is also termed a sub-activity. Fragments in Android can be added, removed, or replaced dynamically i.e., while the activity is running.\n\nBelow is the pictorial representation of fragment interaction with the activity:\n‚Ä¢ Single Fragment: Display only one single view on the device screen. This type of fragment in android is mostly used for mobile phones.\n‚Ä¢ List Fragment: This Fragment is used to display a list-view from which the user can select the desired sub-activity. The menu drawer of apps like Gmail is the best example of this kind of android fragment.\n‚Ä¢ Fragment Transaction: This kind of fragments in android supports the transition from one fragment in android to another at run time. Users can switch between multiple fragments like switching tabs.\n\nThe very first method to be called when the fragment has been associated with the activity. This method executes only once during the lifetime of a fragment. \n\n When we attach fragment(child) to Main(parent) activity then it call first and then not call this method any time(like you run an app and close and reopen) simple means that this method call only one time. This method initializes the fragment by adding all the required attributes and components. System calls this method to create the user interface of the fragment. The root of the fragment‚Äôs layout is returned as the View component by this method to draw the UI. \n\n You should inflate your layout in onCreateView but shouldn‚Äôt initialize other views using findViewById in onCreateView. It indicates that the activity has been created in which the fragment exists. View hierarchy of the fragment also instantiated before this function call. The system invokes this method to make the fragment visible on the user‚Äôs device. This method is called to make the visible fragment interactive. It indicates that the user is leaving the fragment. System call this method to commit the changes made to the fragment. Method to terminate the functioning and visibility of fragment from the user‚Äôs screen. System calls this method to clean up all kinds of resources as well as view hierarchy associated with the fragment. It will call when you can attach new fragment and destroy existing fragment Resoruce It is called to perform the final clean up of fragment‚Äôs state and its lifecycle. The system executes this method to disassociate the fragment from its host activity. \n\n It will call when your fragment Destroy(app crash or attach new fragment with existing fragment)\n\nConsider Fragment-1 is A and Fragment-2 is B and A is attached to the Main Activity\n\n 1. If you can replace B with A.\n\n A‚Äôs call back:\n\n onDestroyView()\n\n onDestroy()\n\n onDetach()\n\n2. If you can replace B with A without Losing resources.\n\n A‚Äôs call back:\n\n onDestroy()\n\n onDetach()\n\nFragments in android are always embedded in Activities i.e., they are added to the layout of activity in which they reside. Multiple fragments can be added to one activity. This task can be carried out in 2 ways:\n‚Ä¢ None Statically: Explicitly mention the fragment in the XML file of the activity. This type of fragment can not be replaced during the run time.\n‚Ä¢ FragmentManager is used to embed fragments with activities that enable the addition, deletion, or replacement of fragments at run time.\n\nAlmost all android app uses dynamic addition of fragments as it improves the user experience. Below is the step-by-step implementation of adding 2 fragments in one activity. A default fragment will be visible when the activity appears on the screen and the user can switch between the 2 fragments at the run time.\n‚Ä¢ None Click on File, then New => New Project.\n‚Ä¢ None Select the minimum SDK as per your need.\n\nAll the strings which are used in the activity are listed in this file\n\nOpen the activity_main.xml file and add 2 buttons to it which will be used to switch between the 2 fragments. Further, add the fragment element in the activity layout. It is the area in which the fragments in android will be displayed.\n\nThese files contain only the onCreateView() method to inflate the UI of the fragment and returns the root of the fragment layout. If the fragment does not have any UI, it will return null.\n\nStep 5: Creating Layouts for both the fragments\n\nCreate two Layout Resource Files for both the fragments. Fragment displays a text on the screen and have a background color to differentiate their area in the Activity layout. Below is the code to implement this layout.\n\nNow, the functionality of the button to perform operations on clicking will be defined in the MainActivity class. Moreover, the code for the replacement of fragments during run time is also mentioned in this file. Below is the code to implement this step."
    },
    {
        "link": "https://developer.android.com/guide/fragments/animate",
        "document": "The Fragment API provides two ways to use motion effects and transformations to visually connect fragments during navigation. One of these is the Animation Framework, which uses both and . The other is the Transition Framework, which includes shared element transitions.\n\nYou can specify custom effects for entering and exiting fragments and for transitions of shared elements between fragments.\n‚Ä¢ An enter effect determines how a fragment enters the screen. For example, you can create an effect to slide the fragment in from the edge of the screen when you navigate to it.\n‚Ä¢ An exit effect determines how a fragment exits the screen. For example, you can create an effect to fade the fragment out when navigating away from it.\n‚Ä¢ A shared element transition determines how a view that is shared between two fragments moves between them. For example, an image displayed in an in fragment A transitions to fragment B once B becomes visible.\n\nFirst, you need to create animations for your enter and exit effects, which are run when navigating to a new fragment. You can define animations as tween animation resources. These resources allow you to define how fragments should rotate, stretch, fade, and move during the animation. For example, you might want the current fragment to fade out and the new fragment to slide in from the right edge of the screen, as shown in figure 1.\n\nThese animations can be defined in the directory:\n\nYou can also specify animations for the enter and exit effects that are run when popping the back stack, which can happen when the user taps the Up or Back button. These are called the and animations. For example, when a user pops back to a previous screen, you might want the current fragment to slide off the right edge of the screen and the previous fragment to fade in.\n\nThese animations can be defined as follows:\n\nOnce you've defined your animations, use them by calling , passing in your animation resources by their resource ID, as shown in the following example:\n\nYou can also use transitions to define enter and exit effects. These transitions can be defined in XML resource files. For example, you might want the current fragment to fade out and the new fragment to slide in from the right edge of the screen. These transitions can be defined as follows:\n\nOnce you've defined your transitions, apply them by calling on the entering fragment and on the exiting fragment, passing in your inflated transition resources by their resource ID, as shown in the following example:\n\nFragments support AndroidX transitions. While fragments also support framework transitions, we strongly recommend using AndroidX transitions, as they are supported in API levels 14 and higher and contain bug fixes that are not present in older versions of framework transitions.\n\nPart of the Transition Framework, shared element transitions determine how corresponding views move between two fragments during a fragment transition. For example, you might want an image displayed in an on fragment A to transition to fragment B once B becomes visible, as shown in figure 3.\n\nAt a high level, here's how to make a fragment transition with shared elements:\n‚Ä¢ Assign a unique transition name to each shared element view.\n‚Ä¢ Add shared element views and transition names to the .\n\nFirst, you must assign a unique transition name to each shared element view to allow the views to be mapped from one fragment to the next. Set a transition name on shared elements in each fragment layout using , which provides compatibility for API levels 14 and above. As an example, the transition name for an in fragments A and B can be assigned as follows:\n\nTo include your shared elements in the fragment transition, your must know how each shared element's views map from one fragment to the next. Add each of your shared elements to your by calling , passing in the view and the transition name of the corresponding view in the next fragment, as shown in the following example:\n\nTo specify how your shared elements transition from one fragment to the next, you must set an enter transition on the fragment being navigated to. Call in the fragment's method, as shown in the following example:\n\nThe transition is defined as follows:\n\nAll subclasses of are supported as shared element transitions. If you want to create a custom , see Create a custom transition animation. , used in the previous example, is one of the available prebuilt translations that you can use. You can find additional subclasses in the API reference for the class.\n\nBy default, the shared element enter transition is also used as the return transition for shared elements. The return transition determines how shared elements transition back to the previous fragment when the fragment transaction is popped off the back stack. If you'd like to specify a different return transition, you can do so using in the fragment's method.\n\nYou can use predictive back with many, but not all, cross-fragment animations. When implementing predictive back, keep the following considerations in mind:\n‚Ä¢ Import or later and or later.\n‚Ä¢ The class and subclasses and AndroidX Transition library are supported.\n‚Ä¢ The class and framework library are not supported.\n‚Ä¢ Predictive fragment animations only work on devices that run Android 14 or higher.\n‚Ä¢ , , , , , , and are supported with predictive back.\n\nTo learn more, see Add support for predictive back animations.\n\nIn some cases, you might need to postpone your fragment transition for a short period of time. For example, you might need to wait until all views in the entering fragment have been measured and laid out so that Android can accurately capture their start and end states for the transition.\n\nAdditionally, your transition might need to be postponed until some necessary data has been loaded. For example, you might need to wait until images have been loaded for shared elements. Otherwise, the transition might be jarring if an image finishes loading during or after the transition.\n\nTo postpone a transition, you must first ensure that the fragment transaction allows reordering of fragment state changes. To allow reordering fragment state changes, call , as shown in the following example:\n\nTo postpone the enter transition, call in the entering fragment's method:\n\nOnce you've loaded the data and are ready to start the transition, call . The following example uses the Glide library to load an image into a shared , postponing the corresponding transition until image loading has completed.\n\nWhen dealing with cases such as a user's slow internet connection, you might need the postponed transition to start after a certain amount of time rather than waiting for all of the data to load. For these situations, you can instead call in the entering fragment's method, passing in the duration and the unit of time. The postponed then automatically starts once the specified time has elapsed.\n\nPostponed enter transitions should not start until all views in the entering fragment have been measured and laid out. When using a , you must wait for any data to load and for the items to be ready to draw before starting the transition. Here's an example:\n\nNotice that a is set on the parent of the fragment view. This is to ensure that all of the fragment's views have been measured and laid out and are therefore ready to be drawn before beginning the postponed enter transition.\n\nAnother point to consider when using shared element transitions with a is that you cannot set the transition name in the item's XML layout because an arbitrary number of items share that layout. A unique transition name must be assigned so that the transition animation uses the correct view.\n\nYou can give each item's shared element a unique transition name by assigning them when the is bound. For example, if the data for each item includes a unique ID, it could be used as the transition name, as shown in the following example:\n\nTo learn more about fragment transitions, see the following additional resources."
    }
]