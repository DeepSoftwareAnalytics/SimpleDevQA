[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_objects",
        "document": "JavaScript is designed on an object-based paradigm. An object is a collection of properties, and a property is an association between a name (or key) and a value. A property's value can be a function, in which case the property is known as a method. Objects in JavaScript, just as in many other programming languages, can be compared to objects in real life. In JavaScript, an object is a standalone entity, with properties and type. Compare it with a cup, for example. A cup is an object, with properties. A cup has a color, a design, weight, a material it is made of, etc. The same way, JavaScript objects can have properties, which define their characteristics. In addition to objects that are predefined in the browser, you can define your own objects. This chapter describes how to use objects, properties, and methods, and how to create your own objects.\n\nObject initializers are also called object literals. \"Object initializer\" is consistent with the terminology used by C++. The syntax for an object using an object initializer is: const obj = { property1: value1, // property name may be an identifier 2: value2, // or a number \"property n\": value3, // or a string }; Each property name before colons is an identifier (either a name, a number, or a string literal), and each is an expression whose value is assigned to the property name. The property name can also be an expression; computed keys need to be wrapped in square brackets. The object initializer reference contains a more detailed explanation of the syntax. In this example, the newly created object is assigned to a variable ‚Äî this is optional. If you do not need to refer to this object elsewhere, you do not need to assign it to a variable. (Note that you may need to wrap the object literal in parentheses if the object appears where a statement is expected, so as not to have the literal be confused with a block statement.) Object initializers are expressions, and each object initializer results in a new object being created whenever the statement in which it appears is executed. Identical object initializers create distinct objects that do not compare to each other as equal. The following statement creates an object and assigns it to the variable if and only if the expression is true: let x; if (cond) { x = { greeting: \"hi there\" }; } The following example creates with three properties. Note that the property is also an object with its own properties. Objects created with initializers are called plain objects, because they are instances of , but not any other object type. Some object types have special initializer syntaxes ‚Äî for example, array initializers and regex literals.\n\nAlternatively, you can create an object with these two steps:\n‚Ä¢ Define the object type by writing a constructor function. There is a strong convention, with good reason, to use a capital initial letter.\n‚Ä¢ Create an instance of the object with . To define an object type, create a function for the object type that specifies its name, properties, and methods. For example, suppose you want to create an object type for cars. You want this type of object to be called , and you want it to have properties for make, model, and year. To do this, you would write the following function: Notice the use of to assign values to the object's properties based on the values passed to the function. Now you can create an object called as follows: This statement creates and assigns it the specified values for its properties. Then the value of is the string , is the string , is the integer , and so on. The order of arguments and parameters should be the same. You can create any number of objects by calls to . For example, An object can have a property that is itself another object. For example, suppose you define an object called as follows: and then instantiate two new objects as follows: Then, you can rewrite the definition of to include an property that takes a object, as follows: To instantiate the new objects, you then use the following: Notice that instead of passing a literal string or integer value when creating the new objects, the above statements pass the objects and as the arguments for the owners. Then if you want to find out the name of the owner of , you can access the following property: You can always add a property to a previously defined object. For example, the statement adds a property to , and assigns it a value of . However, this does not affect any other objects. To add the new property to all objects of the same type, you have to add the property to the definition of the object type. You can also use the syntax instead of the syntax to define a constructor function. For more information, see the class guide.\n\nYou can access a property of an object by its property name. Property accessors come in two syntaxes: dot notation and bracket notation. For example, you could access the properties of the object as follows: An object property name can be any JavaScript string or symbol, including an empty string. However, you cannot use dot notation to access a property whose name is not a valid JavaScript identifier. For example, a property name that has a space or a hyphen, that starts with a number, or that is held inside a variable can only be accessed using the bracket notation. This notation is also very useful when property names are to be dynamically determined, i.e. not determinable until runtime. Examples are as follows: const myObj = {}; const str = \"myString\"; const rand = Math.random(); const anotherObj = {}; // Create additional properties on myObj myObj.type = \"Dot syntax for a key named type\"; myObj[\"date created\"] = \"This key has a space\"; myObj[str] = \"This key is in variable str\"; myObj[rand] = \"A random number is the key here\"; myObj[anotherObj] = \"This key is object anotherObj\"; myObj[\"\"] = \"This key is an empty string\"; console.log(myObj); // { // type: 'Dot syntax for a key named type', // 'date created': 'This key has a space', // myString: 'This key is in variable str', // '0.6398914448618778': 'A random number is the key here', // '[object Object]': 'This key is object anotherObj', // '': 'This key is an empty string' // } console.log(myObj.myString); // 'This key is in variable str' In the above code, the key is an object, which is neither a string nor a symbol. When it is added to the , JavaScript calls the method of , and use the resulting string as the new key. You can also access properties with a string value stored in a variable. The variable must be passed in bracket notation. In the example above, the variable held and it is that is the property name. Therefore, will return as undefined. str = \"myString\"; myObj[str] = \"This key is in variable str\"; console.log(myObj.str); // undefined console.log(myObj[str]); // 'This key is in variable str' console.log(myObj.myString); // 'This key is in variable str' This allows accessing any property as determined at runtime: let propertyName = \"make\"; myCar[propertyName] = \"Ford\"; // access different properties by changing the contents of the variable propertyName = \"model\"; myCar[propertyName] = \"Mustang\"; console.log(myCar); // { make: 'Ford', model: 'Mustang' } However, beware of using square brackets to access properties whose names are given by external input. This may make your code susceptible to object injection attacks. Nonexistent properties of an object have value (and not ).\n\nThere are three native ways to list/traverse object properties:\n‚Ä¢ loops. This method traverses all of the enumerable string properties of an object as well as its prototype chain.\n‚Ä¢ . This method returns an array with only the enumerable own string property names (\"keys\") in the object , but not those in the prototype chain.\n‚Ä¢ . This method returns an array containing all the own string property names in the object , regardless of if they are enumerable or not. You can use the bracket notation with to iterate over all the enumerable properties of an object. To illustrate how this works, the following function displays the properties of the object when you pass the object and the object's name as arguments to the function: function showProps(obj, objName) { let result = \"\"; for (const i in obj) { // Object.hasOwn() is used to exclude properties from the object's // prototype chain and only show \"own properties\" if (Object.hasOwn(obj, i)) { result += `${objName}.${i} = ${obj[i]}\n\n`; } } console.log(result); } The term \"own property\" refers to the properties of the object, but excluding those of the prototype chain. So, the function call would print the following: The above is equivalent to: There is no native way to list inherited non-enumerable properties. However, this can be achieved with the following function: function listAllProperties(myObj) { let objectToInspect = myObj; let result = []; while (objectToInspect !== null) { result = result.concat(Object.getOwnPropertyNames(objectToInspect)); objectToInspect = Object.getPrototypeOf(objectToInspect); } return result; } For more information, see Enumerability and ownership of properties.\n\nA method is a function associated with an object, or, put differently, a method is a property of an object that is a function. Methods are defined the way normal functions are defined, except that they have to be assigned as the property of an object. See also method definitions for more details. An example is: objectName.methodName = functionName; const myObj = { myMethod: function (params) { // do something }, // this works too! myOtherMethod(params) { // do something else }, }; where is an existing object, is the name you are assigning to the method, and is the name of the function. You can then call the method in the context of the object as follows: Methods are typically defined on the object of the constructor, so that all objects of the same type share the same method. For example, you can define a function that formats and displays the properties of the previously-defined objects. Notice the use of to refer to the object to which the method belongs. Then you can call the method for each of the objects as follows:\n\nUsing this for object references JavaScript has a special keyword, , that you can use within a method to refer to the current object. For example, suppose you have 2 objects, and . Each object has its own , and . In the function , notice the use of . When added to the 2 objects, the same function will print the message with the name of the respective object it's attached to. const Manager = { name: \"Karina\", age: 27, job: \"Software Engineer\", }; const Intern = { name: \"Tyrone\", age: 21, job: \"Software Engineer Intern\", }; function sayHi() { console.log(`Hello, my name is ${this.name}`); } // add sayHi function to both objects Manager.sayHi = sayHi; Intern.sayHi = sayHi; Manager.sayHi(); // Hello, my name is Karina Intern.sayHi(); // Hello, my name is Tyrone is a \"hidden parameter\" of a function call that's passed in by specifying the object before the function that was called. For example, in , is the object, because comes before the function . If you access the same function from another object, will change as well. If you use other methods to call the function, like or , you can explicitly pass the value of as an argument.\n\nA getter is a function associated with a property that gets the value of a specific property. A setter is a function associated with a property that sets the value of a specific property. Together, they can indirectly represent the value of a property. Getters and setters can be either\n‚Ä¢ added later to any existing object. Within object initializers, getters and setters are defined like regular methods, but prefixed with the keywords or . The getter method must not expect a parameter, while the setter method expects exactly one parameter (the new value to set). For instance: const myObj = { a: 7, get b() { return this.a + 1; }, set c(x) { this.a = x / 2; }, }; console.log(myObj.a); // 7 console.log(myObj.b); // 8, returned from the get b() method myObj.c = 50; // Calls the set c(x) method console.log(myObj.a); // 25\n‚Ä¢ ‚Äî a setter that sets the value of to half of the value is being set to Getters and setters can also be added to an object at any time after creation using the method. This method's first parameter is the object on which you want to define the getter or setter. The second parameter is an object whose property names are the getter or setter names, and whose property values are objects for defining the getter or setter functions. Here's an example that defines the same getter and setter used in the previous example: const myObj = { a: 0 }; Object.defineProperties(myObj, { b: { get() { return this.a + 1; }, }, c: { set(x) { this.a = x / 2; }, }, }); myObj.c = 10; // Runs the setter, which assigns 10 / 2 (5) to the 'a' property console.log(myObj.b); // Runs the getter, which yields a + 1 or 6 Which of the two forms to choose depends on your programming style and task at hand. If you can change the definition of the original object, you will probably define getters and setters through the original initializer. This form is more compact and natural. However, if you need to add getters and setters later ‚Äî maybe because you did not write the particular object ‚Äî then the second form is the only possible form. The second form better represents the dynamic nature of JavaScript, but it can make the code hard to read and understand."
    },
    {
        "link": "https://stackoverflow.com/questions/13750805/javascript-object-that-saves-loads-its-state",
        "document": "I'd like to create a Javascript object that can save and load its state (to local storage).\n\nThis is the basic pattern I'm using:\n\nBut there's one thing that annoys me about this pattern: I have to access the object's persistent properties through the 'state' property.\n\nHow can I rewrite this so I can use the object in a more natural way, like:\n\nThis is a very simple 'state', but the solution has to work for a complex state object with nested objects, arrays etc., so simply adding a 'name' property to my object is not what I'm after."
    },
    {
        "link": "https://robdodson.me/posts/take-control-of-your-app-with-the-javascript-state-patten",
        "document": "It looks like you've found one of my older posts üòÖ It's possible that some of the information may be out of date (or just plain wrong!) If you've still found the post helpful, but feel like it could use some improvement, let me know on Twitter\n\nLast week I wrote a post about communicating between views in Backbone.js and since then it has easily become my most popular article. The comments have forced me to think about the ways in which I typically manage state in very large Flash applications and how that might translate to JavaScript and Backbone. Today I want to present my all time favorite design pattern, the State pattern, and illustrate how it can help you maintain control of your application. I want to warn you that I'm going to show a rather large block of what looks like repetitive code because I want the pattern to be obvious. In tomorrow's post we'll clean it up and try it out with a Backbone Model and View.\n\nOk let's get started. I want to write a video player so I'm going to need an object that can handle , and states. I would say that there are probably a ton of video players out there that have , and methods on them, and I bet many look kind of like this:\n\nOr maybe instead of a long conditional there's a switch statement or something. But essentially you're querying some variable somewhere to check what state the object is in and you're branching your logic as a result. Now, I would argue that this is a really brittle process and probably error prone. You could imagine that in each of those conditional blocks there might be several lines of code: preparing to play, stopping the video, tearing down this or that... Or perhaps if you're moving from one state to another you want to animate something on screen, maybe do some ajax, who knows!? Really no matter what you're doing if you're tossing it into these big conditionals it's going to become a nightmare to manage.\n\nAlternatives? Ok, let's think of our video player in terms of the actions that it performs. Our player can play, it can stop and it can pause. What if instead of play, pause and stop acting as methods on our object, we make each of those states into its own object? So when the play state object is told to play it says 'Hey! I'm already playing. No need to change' and when it's told to stop it says 'Ah stopping, eh? Let me defer to my friend the Stop state object'.\n\nTo illustrate this I've written a very simple player which just logs what it's doing as you ask it to change state. I want to point out that this code is neither DRY nor very useful in a real world situation but it's intended to illustrate a point. Hopefully when you see the repetition you'll quickly say to yourself 'Hey! Those state objects could be made into a more general/abstract parent object.' That would be the correct mindset but I thought that if I skipped this part the pattern might not be obvious for those new to it.\n\nLots of code, I know. But there is serious value in digesting this pattern so stick with me here and I'll go through it bit by bit. Let's start at the top where we define our object:\n\nFirst we declare our object and give it a property of which we set to for now. We're going to be creating state object to delegate all of our method calls to so once we're ready to use our player we'll set its initial state.\n\nThe object (note the plurality) holds all of the different state objects that our player can use. In this version we've defined , and but you could also add states like or . Keep in mind that this pattern can be applied to just about anything. For instance, if you were making a game with an old prospector his state objects could be , and . The main thing to remember is that your state objects should all define the exact same public methods.\n\nWe can skip the and states since they're nearly identical to the state. Instead let's jump down to the bottom and look at the last bit.\n\nIn our player's initialize function we give each state a reference to the player object so we can tell it to . We also set our initial state to be the stopping state.\n\nNow let's look at the method. Do you see how it defers the call to whatever object is currently set as the player's ? Since refers to we're effectively calling the method of the state object. Go look at the other state objects to see how they respond to having their methods called. In the case of , calling is going to tell its (which is just a reference to the player) to , passing in the state.\n\nis kind of an awesome method because it does a ton of work but it does it very elegantly and efficiently. For starters it makes sure that the state we've asked to change to is actually different than our current state. Then it tells our current state to . A state's method is a great place to tear down any constructs that we may have built to support that action. Next it sets our current state to the new state. Lastly, it calls (a good place to build up supporting constructs) and , which is where we do the main work of our state. That's pretty straightforward right?\n\nSince , and are members of our player's public API, all of our states must also implement those methods. Otherwise you would get an error if you called on the object and its state did not support that method. Keep this in mind when you're designing your state objects.\n\nLet's look at our player in action:\n\nI like it, but...\n\nBefore you run for the hills due to the sheer volume of boilerplate code I want to remind you that almost all of this repetition can easily be cleaned up. If we defined a base state that all of our other states extended then they would only need to override the methods that they cared about. For instance, the state and state both tell their target to when someone calls . This kind of functionality is easily moved into a base state. Also if you have no need for and methods those can be removed or also thrown into the base state. I'll dig into this more tomorrow but for now play around with the example and leave some feedback if you have comments or suggestions. Thanks!\n\nYou should follow me on Twitter here."
    },
    {
        "link": "https://w3schools.invisionzone.com/topic/44018-javascript-game-state-handling",
        "document": "Then each state of the game inherits the GameState class and must implement all of the functions declared as virtual in the GameState class\n\nhere is the implementation if the TestState which just draws a rectangle on the screen.\n\nThe game class is the class that makes the game window and holds a vector (array) of the GameState objects. The last element in that array is the current state.The Game class also has changeState, pushState, and popState functions to change between states.\n\nhere is the implementation of the game class take a look at how the changeState method works, this is what I really want to emulate in Javascript.\n\nthen finally the main.cpp file will run the init in the Game class then add the TestState to the array of states with changeState\n\nAt this point you can just copy the TestState.h and TestState.cpp for each new level in your game which makes it easy to organize a game with many levels. (Sorry for such a long post) I hope that somebody can look at this and see how something similar can be done in JavaScript. If anyone is having trouble in C++ with what I have posted let me know and I will help. on http://27software.net/canvas/ I have a basic game loop working with javascript with a rectangle you can move around the screen, so I am good on how to draw on the canvas but thanks for that advice."
    },
    {
        "link": "https://stackoverflow.com/questions/21742193/store-state-of-a-javascript-object",
        "document": "Im trying to store the stats of 'this' in my javscript object so that later on in my application I can return 'this' to a previous state. I thought I could accomplish using a closure but so far I haven't successful. My idea was to do something like this\n\nso later on in my application if I needed to return to the point when I called storeState I could just do\n\nthat doesn't work though because any changes to my savedFeature object after I call storeState() are being reflected in the item im retrieving from called savedItem(). I'm guessing this is happening because closure is being set to a reference of self instead of copied to a new instance.\n\nIs there anyway to store the state of my entire object in a closure like this or do I need to store this some other way."
    },
    {
        "link": "https://stackoverflow.com/questions/19626680/is-settimeout-a-good-solution-to-do-async-functions-with-javascript",
        "document": "simply queues the code to run once the current call stack is finished executing. This can be useful for some things.\n\nSo yes, it's asynchronous in that it breaks the synchronous flow, but it's not actually going to execute concurrently/on a separate thread. If your goal is background processing, have a look at webworkers. There's also a way to use iframes for background processing.\n\nTo further clarify, there's a difference between concurrency/backgrounding and asynchronous-ness. When code is asynchronous that simply means it isn't executed sequentially. Consider:\n\nThe value 'poo' will be alerted because the code was not executed sequentially. The 'bar' value was assigned asynchronously. If you need to alert the value of when that asynchronous assignment happens, use callbacks:\n\nSo yes, there's some asynchronous-ness happening above, but it's all happening in one thread so there are no performance benefits.\n\nWhen an operation takes a long time, it is best to do it in the background. In most languages this is done by executing the operation on a new thread or process. In (browser) javascript, we don't have the ability to create new threads, but can use webworkers or iframes. Since this code running in the background breaks the sequential flow of things it is asynchronous.\n\nTLDR: All backgrounded/concurrent code happens asynchronously, but not all asynchronous code is happening concurrently.\n\nSee Also: Understanding Asynchronous Code in Layman's terms"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout",
        "document": "If is called with delay value that's not a number, implicit type coercion is silently done on the value to convert it to a number. For example, the following code incorrectly uses the string for the delay value, rather than the number ‚Äì but it nevertheless works, because when the code runs, the string is coerced into the number , and so the code executes 1 second later. But in many cases, the implicit type coercion can lead to unexpected and surprising results. For example, when the following code runs, the string ultimately gets coerced into the number ‚Äî and so, the code executes immediately, with zero delay. setTimeout(() => { console.log(\"Delayed for 1 second.\"); }, \"1 second\"); Therefore, don't use strings for the delay value but instead always use numbers:\n\nis an asynchronous function, meaning that the timer function will not pause execution of other functions in the functions stack. In other words, you cannot use to create a \"pause\" before the next function in the function stack fires. See the following example: setTimeout(() => { console.log(\"this is the first message\"); }, 5000); setTimeout(() => { console.log(\"this is the second message\"); }, 3000); setTimeout(() => { console.log(\"this is the third message\"); }, 1000); // Output: // this is the third message // this is the second message // this is the first message Notice that the first function does not create a 5-second \"pause\" before calling the second function. Instead, the first function is called, but waits 5 seconds to execute. While the first function is waiting to execute, the second function is called, and a 3-second wait is applied to the second function before it executes. Since neither the first nor the second function's timers have completed, the third function is called and completes its execution first. Then the second follows. Then finally the first function is executed after its timer finally completes. To create a progression in which one function only fires after the completion of another function, see the documentation on Promises.\n\nWhen you pass a method to , it will be invoked with a value that may differ from your expectation. The general issue is explained in detail in the JavaScript reference. Code executed by is called from an execution context separate from the function from which was called. The usual rules for setting the keyword for the called function apply, and if you have not set in the call or with , it will default to the (or ) object, even in strict mode. It will not be the same as the value for the function that called . See the following example: const myArray = [\"zero\", \"one\", \"two\"]; myArray.myMethod = function (sProperty) { console.log(arguments.length > 0 ? this[sProperty] : this); }; myArray.myMethod(); // prints \"zero,one,two\" myArray.myMethod(1); // prints \"one\" The above works because when is called, its is set to by the call, so within the function, is equivalent to . However, in the following: setTimeout(myArray.myMethod, 1.0 * 1000); // prints \"[object Window]\" after 1 second setTimeout(myArray.myMethod, 1.5 * 1000, \"1\"); // prints \"undefined\" after 1.5 seconds The function is passed to , then when it's called, its is not set, so it defaults to the object. There's also no option to pass a to as there is in Array methods such as and . As shown below, using to set doesn't work either. A common way to solve the problem is to use a wrapper function that sets to the required value: setTimeout(function () { myArray.myMethod(); }, 2.0 * 1000); // prints \"zero,one,two\" after 2 seconds setTimeout(function () { myArray.myMethod(\"1\"); }, 2.5 * 1000); // prints \"one\" after 2.5 seconds The wrapper function can be an arrow function: setTimeout(() => { myArray.myMethod(); }, 2.0 * 1000); // prints \"zero,one,two\" after 2 seconds setTimeout(() => { myArray.myMethod(\"1\"); }, 2.5 * 1000); // prints \"one\" after 2.5 seconds Alternatively, you can use to set the value of for all calls to a given function: const myArray = [\"zero\", \"one\", \"two\"]; const myBoundMethod = function (sProperty) { console.log(arguments.length > 0 ? this[sProperty] : this); }.bind(myArray); myBoundMethod(); // prints \"zero,one,two\" because 'this' is bound to myArray in the function myBoundMethod(1); // prints \"one\" setTimeout(myBoundMethod, 1.0 * 1000); // still prints \"zero,one,two\" after 1 second because of the binding setTimeout(myBoundMethod, 1.5 * 1000, \"1\"); // prints \"one\" after 1.5 seconds\n\nReasons for delays longer than specified There are a number of reasons why a timeout may take longer to fire than anticipated. This section describes the most common reasons. As specified in the HTML standard, browsers will enforce a minimum timeout of 4 milliseconds once a nested call to has been scheduled 5 times. This can be seen in the following example, in which we nest a call to with a delay of milliseconds, and log the delay each time the handler is called. The first four times, the delay is approximately 0 milliseconds, and after that it is approximately 4 milliseconds: let last = 0; let iterations = 10; function timeout() { // log the time of this call log(new Date().getMilliseconds()); // if we are not finished, schedule the next call if (iterations-- > 0) { setTimeout(timeout, 0); } } function run() { // clear the log const log = document.querySelector(\"#log\"); while (log.lastElementChild) { log.removeChild(log.lastElementChild); } // initialize iteration count and the starting timestamp iterations = 10; last = new Date().getMilliseconds(); // start timer setTimeout(timeout, 0); } function log(now) { // log the last timestamp, the new timestamp, and the difference const tableBody = document.getElementById(\"log\"); const logRow = tableBody.insertRow(); logRow.insertCell().textContent = last; logRow.insertCell().textContent = now; logRow.insertCell().textContent = now - last; last = now; } document.querySelector(\"#run\").addEventListener(\"click\", run); To reduce the load (and associated battery usage) from background tabs, browsers will enforce a minimum timeout delay in inactive tabs. It may also be waived if a page is playing sound using a Web Audio API . The specifics of this are browser-dependent:\n‚Ä¢ Firefox Desktop and Chrome both have a minimum timeout of 1 second for inactive tabs.\n‚Ä¢ Firefox for Android has a minimum timeout of 15 minutes for inactive tabs and may unload them entirely.\n‚Ä¢ Firefox does not throttle inactive tabs if the tab contains an . Firefox enforces additional throttling for scripts that it recognizes as tracking scripts. When running in the foreground, the throttling minimum delay is still 4ms. In background tabs, however, the throttling minimum delay is 10,000 ms, or 10 seconds, which comes into effect 30 seconds after a document has first loaded. See Tracking Protection for more details. The timeout can also fire later than expected if the page (or the OS/browser) is busy with other tasks. One important case to note is that the function or code snippet cannot be executed until the thread that called has terminated. For example: Will write to the console: After setTimeout foo has been called This is because even though was called with a delay of zero, it's placed on a queue and scheduled to run at the next opportunity; not immediately. Currently-executing code must complete before functions on the queue are executed, thus the resulting execution order may not be as expected. Firefox will defer firing timers while the current tab is loading. Firing is deferred until the main thread is deemed idle (similar to ), or until the load event is fired."
    },
    {
        "link": "https://sitepoint.com/javascript-settimeout-function-examples",
        "document": "The native JavaScript function calls a function or executes a code snippet after a specified delay (in milliseconds). This might be useful if, for example, you wished to display a popup after a visitor has been browsing your page for a certain amount of time, or you want a short delay before removing a hover effect from an element (in case the user accidentally moused out).\n‚Ä¢ The native JavaScript setTimeout function allows the execution of a function or a code snippet after a specified delay in milliseconds, useful for tasks such as displaying a popup after a certain amount of browsing time.\n‚Ä¢ setTimeout accepts a reference to a function as the first argument, which can be the name of a function, a variable that refers to a function, or an anonymous function. It can also execute a string of code, but this is not advisable due to readability, security, and speed issues.\n‚Ä¢ Parameters can be passed to a callback executed by setTimeout using an anonymous function as the first argument. However, an alternative method of listing parameters after the delay is not compatible with IE9 or below.\n‚Ä¢ The value of ‚Äòthis‚Äô in code executed by setTimeout runs in a separate execution context to the function from which it was called, which can cause issues when the context of the ‚Äòthis‚Äô keyword is important. This can be addressed using bind, a library function, or arrow functions.\n‚Ä¢ The return value of setTimeout is a numerical ID that can be used to cancel the timer with the clearTimeout function.\n\nThe following code block shows a simple example which will print a message to the console after a 2 second (2000 milliseconds) timeout:\n\nTo demonstrate the concept in more detail, the following demo displays a popup, two seconds after the button is clicked:\n\nSee the Pen Delayed Magnific Popup modal by SitePoint (@SitePoint) on CodePen.\n\nIf you don‚Äôt see the popup open, please visit CodePen and run the demo there.\n\nFrom the MDN documentation, the syntax for is as follows:\n‚Ä¢ is a numerical ID, which can be used in conjunction with clearTimeout to cancel the timer.\n‚Ä¢ refers to the Window interface or the WorkerGlobalScope interface.\n‚Ä¢ is the function to be executed after the timer expires.\n‚Ä¢ is an alternative syntax that allows you to include a string instead of a function, which is compiled and executed when the timer expires.\n‚Ä¢ is the number of milliseconds by which the function call should be delayed. If omitted, this defaults to 0.\n‚Ä¢ are additional arguments passed to the function specified by .\n\nYou‚Äôll notice that sometimes syntax above . Why is this?\n\nWell, when running code in the browser, would refer to the global object. Both and refer to the same function, the only difference being that in the second statement we are referencing the method as a property of the object.\n\nIn my opinion, this adds complexity for little or no benefit. If you‚Äôve defined an alternative method which would be found and returned in priority in the scope chain, then you‚Äôve probably got bigger problems to worry about.\n\nFor the purposes of this tutorial, I‚Äôll omit , but ultimately, which syntax you choose is up to you.\n\nThe method accepts a reference to a function as the first argument.\n\nThis can be the name of a function:\n\nAs noted above, it‚Äôs also possible to pass a string of code for it to execute:\n\nHowever, this is not advisable for the following reasons:\n‚Ä¢ It‚Äôs hard to read (and thus hard to maintain and/or debug).\n‚Ä¢ It uses an implied , which is a potential security risk.\n‚Ä¢ It‚Äôs slower than the alternatives, as it has to invoke the JS interpreter.\n\nThis Stack Overflow question offers more information on the above points.\n\nIn a basic scenario, the preferred, cross-browser way to pass parameters to a callback executed by is by using an anonymous function as the first argument.\n\nIn the following example, we select a random animal from an array and pass this random animal as a parameter to a function. The function is then executed by with a delay of one second:\n\nNote: I‚Äôve used a regular function ( ) to return a random element from an array. It would also be possible to write this as a function expression using an arrow function:\n\nWe‚Äôll get to arrow functions in the next section. Here‚Äôs a CodePen that contains the above code (you‚Äôll need to open the console to see the outputs).\n\nAs can be seen from the syntax at the top of the article, there‚Äôs a second method of passing parameters to a callback executed by . This involves listing any parameters after the delay.\n\nWith reference to our previous example, this would give us:\n\nUnfortunately, this doesn‚Äôt work in IE9 or below, where the parameters come through as . If you‚Äôre in the unenviable position of having to support IE9, there is a polyfill available on MDN.\n\nCode executed by is run in a separate execution context to the function from which it was called. This is problematic when the context of the keyword is important:\n\nThe reason for this output is that, in the first example, points to the object, whilst in the second example points to the global object (which doesn‚Äôt have a property).\n\nTo counteract this problem, there are various measures ‚Ä¶\n\nExplicitly Set the Value of\n\nYou can do this using bind, a method which creates a new function that, when called, has its keyword set to the provided value (in our case, the object). This would give us:\n\nMany libraries come with built-in functions to address this issue. For example, jQuery‚Äôs jQuery.proxy() method. This takes a function and returns a new one that will always have a particular context. In our case, that would be:\n\nArrow functions were introduced with ES6. They have a much shorter syntax than a regular function:\n\nYou can, of course, use them with , but there‚Äôs one gotcha to be aware of ‚Äî namely, that arrow functions don‚Äôt have their own value. Instead, they use the value of the enclosing lexical context.\n\nIn the second example, points to the global object (which again, doesn‚Äôt have a property).\n\nThis can trip us up when using arrow functions with . Previously we saw how we can supply a function called in a with the correct value:\n\nThis won‚Äôt work when using an arrow function in the method, as the arrow function doesn‚Äôt have its own value. The method will still log .\n\nHowever, because arrow functions don‚Äôt have their own value, it can also work to our advantage.\n\nConsider code like this:\n\nIt can be rewritten more concisely with an arrow function:\n\nIf you‚Äôd like a primer on arrow functions, please read ‚ÄúES6 Arrow Functions: Fat and Concise Syntax in JavaScript‚Äù.\n\nAs we learned at the start of the article, the return value of is a numerical ID which can be used to cancel the timer in conjunction with the function:\n\nLet‚Äôs see this in action. In the following Pen, if you click on the Start countdown button, a countdown will begin. If the countdown completes, the kittens get it. However, if you press the Stop countdown button, the timer will be halted and reset. (If you don‚Äôt see a cool effect when the countdown reaches zero, re-run the Pen using the button in the bottom right of the embed.)\n\nSee the Pen SetTimeout Kittens by SitePoint (@SitePoint) on CodePen.\n\nSee the Pen SetTimeout Kittens by SitePoint (@SitePoint) on CodePen.\n\nOne potential caveat to be aware of is the fact that is asynchronous. It queues the function reference it receives to run once the current call stack has finished executing. It doesn‚Äôt, however, execute concurrently, or on a separate thread (due to JavaScript‚Äôs single-threaded nature).\n\nAlthough we‚Äôre calling with a zero second delay, the numbers are still logged out of order. This is because when ‚Äòs timer has expired, the JavaScript engine places its callback function in a queue, behind the other statements, to be executed.\n\nIf you‚Äôd like to learn more about what happens when JavaScript runs, I highly recommend this video from JSConf 2014: What the heck is the event loop anyway?\n\nYou should also be aware of requestAnimationFrame. This method tells the browser that you wish to call a specified function before the next repaint.\n\nWhen making animations, we should favor over using , as it will fire roughly sixty times a second, as opposed to , which is called after a minimum of milliseconds. By using we can avoid changing something twice between two frame updates.\n\nHere‚Äôs an example of how to use to animate a element across the screen:\n\nYou could, of course, achieve the same thing using :\n\nBut as mentioned, using offers various advantages, such as allowing the browser to make optimizations and stopping animations in inactive tabs.\n\nSee the Pen Animation with requestAnimationFrame by SitePoint (@SitePoint) on CodePen.\n\nFinally, I‚Äôd like to clear up any confusion between the use of the native JavaScript function and jQuery‚Äôs delay method.\n\nThe method is meant specifically for adding a delay between methods in a given jQuery queue. There is no possibility to cancel the delay. For example, if you wanted to fade an image into view for one second, have it visible for five seconds, and then fade it out for a period of one second, you could do the following:\n\nis best used for everything else.\n\nNote: if you need to repeatedly execute code after a specified delay, then is more suited to the job. You can read more about this function here.\n\nIn this article, I‚Äôve demonstrated how to use to delay the execution of a function. I have also shown how to pass parameters to , maintain the value inside its callback and also how to cancel a timer.\n\nIf you run into a coding problem regarding the use of (or anything else, really), then please head to the SitePoint forums where we‚Äôll be happy to help."
    },
    {
        "link": "https://medium.com/@ashishkumarjena1437/understanding-how-settimeout-works-in-javascripts-single-threaded-environment-dd5889ea1599",
        "document": "JavaScript is often referred to as ‚Äúsingle-threaded,‚Äù meaning it has only one main thread for executing code. But if that‚Äôs the case, how do functions like allow us to execute code asynchronously without blocking other code from running? The answer lies in JavaScript‚Äôs unique runtime environment, which includes a little magic from the event loop and Web APIs. In this post, we‚Äôll break down how works and explain how JavaScript manages to handle asynchronous tasks while still being single-threaded.\n\n1. What Does It Mean to Be Single-Threaded? A single-threaded environment means that JavaScript has a single call stack for executing code. This stack is like a ‚Äúto-do list‚Äù where tasks are added and completed one by one. JavaScript executes functions synchronously, meaning each function must finish before the next one begins. If a task takes a long time, everything else waits, which is why JavaScript can feel ‚Äúblocked‚Äù during heavy operations. The above code runs from top to bottom. Each waits for the previous one to complete, ensuring the output is: This is straightforward. But what happens when we introduce ?\n\nis one of the most commonly used functions in JavaScript for scheduling code to run after a specified delay. Here‚Äôs an example: At first glance, it might seem like the function will block the code for two seconds, but that‚Äôs not what happens! The output will actually be: So, why didn‚Äôt JavaScript wait for two seconds before printing ‚ÄúEnd‚Äù? Here‚Äôs how it works under the hood.\n\nJavaScript‚Äôs asynchronous behavior is powered by a few additional components in the runtime environment: Web APIs, a Callback Queue, and the Event Loop. When is called, the browser (or Node.js environment) doesn‚Äôt pause JavaScript. Instead, it offloads the timing to a Web API (which the JavaScript engine doesn‚Äôt directly handle). The Web API sets up a timer and takes care of the countdown. In our example, when runs, it registers the timer with a 2-second delay in the Web API environment. JavaScript immediately moves to the next line ( ) without waiting for the timer to finish. After the timer completes, the callback function (in this case, ) is placed into a Callback Queue (or Task Queue), which is essentially a waiting area for asynchronous code. The Event Loop is the component that connects the synchronous and asynchronous parts of JavaScript. It constantly checks the call stack to see if it‚Äôs empty. If it is, the event loop picks up the next task from the callback queue and places it on the call stack.\n‚Ä¢ is logged first because it's synchronous.\n‚Ä¢ is registered, and the timer begins.\n‚Ä¢ is logged immediately after since JavaScript didn‚Äôt wait for the delay.\n‚Ä¢ After 2 seconds, the timer completes, and the callback function is added to the callback queue.\n‚Ä¢ The event loop checks if the call stack is clear. Since it is, the callback is moved from the callback queue to the call stack, and is finally logged.\n\n4. Why This Matters for Writing Efficient Code Understanding how works is essential for managing asynchronous code and optimizing performance. Since JavaScript is single-threaded, long-running code can block the entire call stack, leading to sluggish interfaces or unresponsive applications. By using and other asynchronous methods (like , , or ), you can ensure that JavaScript doesn‚Äôt hang, even during time-consuming tasks. For instance, if you have a function that takes a while to execute, you could use to split it into smaller chunks, allowing the event loop to handle user interactions or other tasks in between. With the above pattern, even if is lengthy, it‚Äôs scheduled asynchronously, so other parts of your application can still respond to events or user actions."
    },
    {
        "link": "https://w3schools.com/js/js_asynchronous.asp",
        "document": "The examples used in the previous chapter, was very simplified.\n\nThe purpose of the examples was to demonstrate the syntax of callback functions:\n\nIn the example above, is the name of a function.\n\nIt is passed to as an argument.\n\nWhen using the JavaScript function , you can specify a callback function to be executed on time-out:\n\nIn the example above, is used as a callback.\n\nis passed to as an argument.\n\n3000 is the number of milliseconds before time-out, so will be called after 3 seconds.\n\nInstead of passing the name of a function as an argument to another function, you can always pass a whole function instead:\n\nIn the example above, is used as a callback. It is a complete function. The complete function is passed to setTimeout() as an argument.\n\n3000 is the number of milliseconds before time-out, so will be called after 3 seconds.\n\nWhen using the JavaScript function , you can specify a callback function to be executed for each interval:\n\nIn the example above, is used as a callback.\n\nis passed to as an argument.\n\n1000 is the number of milliseconds between intervals, so will be called every second.\n\nWith asynchronous programming, JavaScript programs can start long-running tasks, and continue running other tasks in parallel.\n\nBut, asynchronus programmes are difficult to write and difficult to debug.\n\nBecause of this, most modern asynchronous JavaScript methods don't use callbacks. Instead, in JavaScript, asynchronous programming is solved using Promises instead."
    }
]