[
    {
        "link": "https://stackoverflow.com/questions/53446020/how-to-compare-oldvalues-and-newvalues-on-react-hooks-useeffect",
        "document": "Let's say I have 3 inputs: rate, sendAmount, and receiveAmount. I put that 3 inputs on useEffect diffing params. The rules are:\n‚Ä¢ If rate changed, I calculate when or I calculate when\n\nHere is the codesandbox https://codesandbox.io/s/pkl6vn7x6j to demonstrate the problem.\n\nIs there a way to compare the and like on instead of making 3 handlers for this case?\n\nHere is my final solution with https://codesandbox.io/s/30n01w2r06\n\nIn this case, I cannot use multiple because each change is leading to the same network call. That's why I also use to track the change too. This also helpful to track changes from local only, so I can prevent unnecessary network call because of changes from the server."
    },
    {
        "link": "https://blog.logrocket.com/accessing-previous-props-state-react-hooks",
        "document": "Editor‚Äôs note: This guide was last updated by Marie Starck on 1 May 2024 to provide a comparison of props vs. state in React, as well as to compare the use of and for tracking previous values, and to answer commonly asked questions for working with state in React, such as how Hooks differ from class components when handling state.\n\nAccessing the previous props or state from within a functional component is one of those deceptively simple problems you might face as you work with React Hooks. While no React Hook currently does this out of the box, you can manually retrieve either the previous state or props from within a functional component by using the , , and Hooks in React. In this article, we‚Äôll learn how.\n\nBefore we get started, brush up on your React Hooks knowledge with our React Hooks cheat sheet:\n\nReact offers a declarative approach to UI manipulation. Instead of directly modifying specific UI elements, we define the various states our component can take on via variables known as state.\n\nSimilarly, the previous state refers to the value of a state variable before it was updated. When multiple updates occur, the previous state refers to the state value before the current one. Here‚Äôs a visual to break it down:\n\nIt‚Äôs important to access previous state only for the right reasons. For example, if you only need previous state to clean up an effect, you should rely on the native React support. Consider the example below:\n\nIn this example, getting the previous prop is unnecessary because the cleanup function will capture it in a closure. If changes from to , will run first before .\n\nAlternatively, if you find yourself updating some state value in response to changes in another state or prop, this may be a sign of redundancy. Consider refactoring or simplifying your state representation. This will keep your component updates predictable and easy to understand.\n\nIf your use case doesn‚Äôt fall in the use cases mentioned above, then perhaps you need the previous state for the right reasons. This is usually a rare case, e.g., building a component. Now, let‚Äôs consider our solution using .\n\nGetting the previous props or state via\n\nConsider the following annotated example with a component:\n\nThe code above generates the following output:\n\nIn the annotated code block above, we update the state as usual via the state updater function. As soon as the state is updated, we also update the current value to the new state value.\n\nHowever, because assignments do not re-trigger component renders, the value in the render method (or return statement) will always point to the previous state value (the value of the ref before we made the update in ).\n\nBuilding upon the previous solution, we may create an abstraction via a Hook:\n\nTo use the custom Hook within your app, write the following code:\n\nAlthough this example seems straightforward, can you really explain how the Hook works? Let‚Äôs explore in clear terms what‚Äôs happening within the Hook and how the previous value is retained.\n\nI work with Hooks daily, both for personal and professional workplace projects. In my experience, I‚Äôve found that very few people understand and take advantage of the Hook. Apart from being great at handling DOM refs, is a perfect substitute for implementing instance-like variables within functional components.\n\nFurthermore, it remembers data between UI renders, allowing developers to access previous, overwritten values. Consider the following example with class components:\n\nEvery instantiated copy of the class will have its own instance variable. The Hook can simulate this behavior with an even more interesting feature:\n\nThe Hook takes in an initial value to be stored, i.e., , and it returns an object with a current property . Whatever value was initially passed into is saved to the property of the object:\n\nUnlike a normal variable, the ref object is not recomputed when the component is re-rendered. With , the value saved in the object is kept the same across re-renders. The value is neither lost nor recomputed; it remains the same.\n\nIt‚Äôs worth mentioning that the only way to update the object is to directly set the value of the current property, i.e., . Why is this explanation important?\n\nWell, to understand what‚Äôs going on, let‚Äôs walk through the step-by-step execution of the aforementioned solution to retrieving previous props and state:\n\nWhen the rendering process for the app begins, first, the Hook is invoked, and the variables and are set. Note that is now :\n\nAfterward, the next line will be executed. The Hook is invoked with the current value of the count state variable, :\n\nUpon invoking the Hook, React creates a new instance:\n\nThe initial value of this Hook is . The console returns because the current data doesn‚Äôt exist. This next step is where most people slip up. React doesn‚Äôt execute the call. Instead, the current value of the custom Hook is returned, as shown below:\n\nThe Hook is invoked only after the component from which it is called has been rendered. Essentially, the return value of the component must be executed first. Next, the execution within the component resumes. This time, the variable holds the value :\n\nThe value of the component is evaluated, as shown below:\n\nThis process returns to the screen, where and are and , respectively. To avoid blocking the browser from painting the DOM changes, the call within the Hook is now invoked asynchronously. is invoked after the functional component renders:\n\nWithin the function, we have the following:\n\nThe line within the function updates the current property of the object to value. now represents what the custom Hook was initially called with. In this case, the value is . In this current flow, remember has only been called once with the initial value of :\n\nNow, the ref holds the value . When the variable within the app is updated from to , or to a new count, the app will run this piece of code again. The Hook is invoked with the new state value .\n\nThen, the return statement is evaluated, returning , which would be , not , because the ref object isn‚Äôt updated yet. Here, is the previous value stored before the was triggered, or . The statement of the component is equally evaluated with the previous value successfully returned.\n\nOnly after the render is the call within the Hook updated with the new value, . This cycle continues, and in this way, you‚Äôll always get the previous value passed into the custom Hook, .\n\nTo understand why we can access previous props or state in this manner, you must remember the following:\n‚Ä¢ The object will always return the same value held in , except when it is explicitly updated\n‚Ä¢ is only called after the component is rendered with the previous value. Only after the render is done is the ref object updated within\n\nBy taking advantage of these two facts, you can easily replicate this functionality on your own.\n\nUsing vs. for tracking previous values\n\nSo far, this article has focused on using for tracking purposes. There is, however, a way to track the previous values using only . Indeed, allows us to access the previous state.\n\nFor example, using the counter example:\n\nIn this example, is our previous state and we are deciding how to transform it before setting it to the current count.\n\nAs a result, it would therefore be possible to store that previous count in a separate value for tracking purposes:\n\nWhile this solution looks simpler than using to track states, be very careful with .\n\nReact is asynchronous and uses batch updates when dealing with components so you have to be cautious when setting the state of a variable with another state. If not, you may end up with an infinite loop if you use to update something that also impacts count.\n\nUsing is more complex as it requires three different hooks: , , and . The main advantage of is that it doesn‚Äôt cause a component to re-render.\n\nIs there a way to get the previous props in React? Back in the day, when developers used class components and lifecycles functions, there used to be a function called that gave you the freedom to access a prop before and after component mutation. Since then, React has moved away from these functions. As a result, (or properties), are the latest values in a component and should be treated as read-only within that component.\n\nIf a developer wants to keep a history of the values, they can therefore use the state like the previous example with and .\n\nDo state and props render at the same time?\n\nThe answer is: not necessarily. Take this example. We have a component called that accepts a props and is used to set the initial value of :\n\nIn this example, even if the props changes, the count won‚Äôt. The reason for this is that despite the component re-rendering as a result of the props change, doesn‚Äôt re-render. The best way to fix this would be to move into the parent component and then pass as a props. Then, the updated count would display.\n\nCan you get a previous prop with a Hook?\n\nYes, we can use the Hook with a Hook.\n\nFor example, we can create a component called and pass the current count as a props. Then, we can call to create a ref with the previous count. As the props count changes, the Hook will also update and will console log the result and it will look like this:\n\nAs we mentioned earlier, historically, React offered many lifecycle functions such as , , and many more. These functions were used by developers to handle the state at various stages of the render cycle.\n\nDevelopers would use these lifecycle methods inside of class components. For example, here is a class component:\n\nSince then, React has stepped away from these and pushed for hooks. This reduces the amount of code written, while also increasing reusability. Hooks are a great way to extract and reuse code easily.\n\nToday, class components and lifecycle methods are only available under the legacy part of React and are not recommended for new projects.\n\nIf you want to use a third-party library for easy state management, I recommend the Zustand API. Zustand allows you to create subscribers, which are functions that let you get the previous and current values of your state variables. First, create a store and its subscriber as follows:\n\nAbove, we first declared a global variable called . Its initial value will be . Then, we created a function called . If the user executes this method, the program will increment the state.\n\nWe then coded a subscriber function that will log out the current value and an old value of the variable. To use this store in action, write the following code:\n\nWith the code above, we procured the variable and the function from our custom store:\n\nIn this article, we learned how to procure previous values from the , , , and Hooks in React. The object returned from invoking remains the same across re-renders of a functional component, which is a powerful feature to embrace. It does this without you having to pass in any array dependency, like in or .\n\nWhen you combine the ability to use as an instance variable with the fact that the Hook is always triggered after the return statement of the parent component is evaluated, you have an invaluable weapon at your fingertips."
    },
    {
        "link": "https://dev.to/mcavaliere/comparing-previous-useeffect-values-in-react-2o4g",
        "document": "With functional components now being the standard in React, we lost one notable perk of using the lifecycle hooks (such as ) of class-based components: the intrinsic ability to compare previous values to new ones.\n\nIf I wanted to respond to a component's \"count\" change for example, I could do something like:\n\n\n\nI came across the need to do this while working on Emoji Battle yesterday‚ÄîI wanted to show an animation anytime an emoji's vote count incremented.\n\nLuckily Stack Overflow had a great solution as usual, which I turned into a hook I'll probably reuse in the future.\n\nBasically you create a very simple custom hook that uses a React ref to track the previous value, and refer to it in the useEffect.\n\n\n\nBased on this, I used it to increment my Emoji counter as follows:\n\n\n\nTry this hook out next time you need to track value changes in React functional components."
    },
    {
        "link": "https://developerway.com/posts/implementing-advanced-use-previous-hook",
        "document": "After Context, ref is probably the most mysterious part of React. We almost got used to the ref attribute on our components, but not everyone is aware, that its usage is not limited to passing it back and forth between components and attaching it to the DOM nodes. We actually can store data there! And even implement things like usePrevious hook to get the previous state or props or any other value.\n\nBy the way, if you ever used that hook in the way that is written in React docs, have you investigated how it actually works? And what value it returns and why? The result might surprise you üòâ\n\nSo this is exactly what I want to do in this article: take a look at ref and how it works when it‚Äôs not attached to a DOM node; investigate how works and show why it‚Äôs not always a good idea to use it as-is; implement a more advanced version of the hook as a bonus üôÇ\n\nFirst of all, what is ref?\n\nLet‚Äôs remember some basics first, to understand it fully.\n\nImagine you need to store and manipulate some data in a component. Normally, we have two options: either put it in a variable or in the state. In a variable you‚Äôd put something that needs to be re-calculated on every re-render, like any intermediate value that depends on a prop value:\n\nCreating a new variable or changing that variable won‚Äôt cause component to re-render.\n\nIn the state, we usually put values that need to be saved between re-renders, typically coming from users interacting with our UI:\n\nChanging the state will cause the component to re-render itself.\n\nThere is, however, a third, lesser-known option: ref. It merges the behaviour of those two: it‚Äôs essentially a variable that doesn‚Äôt cause components to re-render, but its value is preserved between re-renders.\n\nLet‚Äôs just implement a counter (I promise, it‚Äôs the first and the last counter example in this blog) to illustrate all those three behaviours.\n\nThis is not going to work of course. In our we‚Äôll see the updated counter value, but the value rendered on the screen is not going to change - variables don‚Äôt cause re-renders, so our render output will never be updated.\n\nState, on the other hand, will work as expected: that‚Äôs exactly what state is for.\n\nNow the interesting part: the same with ref.\n\nThis is also not going to work. Almost. With every click on the button the value in the ref changes, but changing ref value doesn‚Äôt cause re-render, so the render output again is not updated. But! If something else causes a render cycle after that, render output will be updated with the latest value from the . For example, if I add both of the counters to the same function:\n\nThis will lead to an interesting effect: every time you click on the ‚Äúupdate ref counter‚Äù button nothing visible happens. But if after that you click the ‚Äúupdate state counter‚Äù button, the render output will be updated with both of the values. Play around with it in the codesandbox.\n\nCounter is obviously not the best use of refs. There is, however, a very interesting use case for them, that is even recommended in React docs themselves: to implement a hook usePrevious that returns previous state or props. Let‚Äôs implement it next!\n\nBefore jumping into re-inventing the wheel, let‚Äôs see what the docs have to offer:\n\nSeems simple enough. Now, before diving into how it actually works, let‚Äôs first try it out on a simple form.\n\nWe‚Äôll have a settings page, where you need to type in your name and select a price for your future product. And at the bottom of the page, I‚Äôll have a simple ‚Äúshow price change‚Äù component, that will show the current selected price, and whether this price increased or decreased compared to the previous value - this is where I‚Äôm going to use the hook.\n\nLet‚Äôs start with implementing the form with price only since it‚Äôs the most important part of our functionality.\n\nWorks like a charm, thank you React docs! See the codesandbox.\n\nNow the final small step: add the name input field to the form, to complete the functionality.\n\nWorks like a charm as well? No! üôÄ When I‚Äôm selecting the price, everything works as before. But as soon as I start typing in the name input - the value in the component resets itself to the latest selected value, instead of the previous. See the codesandbox.\n\nNow it‚Äôs time to take a closer look at the implementation of , remember how ref behaves, and how React lifecycle and re-renders works.\n\nFirst, during the initial render of the component, we call our hook. In there we create ref with an empty value. After that, we immediately return the value of the created ref, which in this case will be (which is intentional, there isn't a previous value on the initial render). After the initial render finishes, is triggered, in which we update the with the value we passed to the hook. And, since it‚Äôs a ref, not state, the value just ‚Äúsits‚Äù there mutated, without causing the hook to re-render itself and as a result without its consumer component getting the latest ref value.\n\nIf it‚Äôs difficult to imagine from the text, here is some visual aid:\n\nSo what happens then when I start typing in the name fields? The parent component updates its state ‚Üí triggers re-renders of its children ‚Üí component starts its re-render ‚Üí calls hook with the same price value (we changed only name) ‚Üí hook returns the updated value that we mutated during the previous render cycle ‚Üí render finishes, is triggered, done. On the pic before we‚Äôll have values transitioning to . And that will cause the value rendered in the component to be updated.\n\nSo what this hook in its current implementation does, is it returns a value from the previous render cycle. There are, of course, use cases for using it that way. Maybe you just need to trigger some data fetch when the value changes, and what happens after multiple re-renders doesn‚Äôt really matter. But if you want to show the ‚Äúprevious‚Äù value in the UI anywhere, a much more reliable approach here would be for the hook to return the actual previous value.\n\nusePrevious hook to return the actual previous value\n\nIn order to do that, we just need to save in ref both values - previous and current. And switch them only when the value actually changes. And here again where ref could come in handy:\n\nImplementation even became slightly simpler: we got rid of the mind-boggling magic of relying on and just accept a value, do an if statement, and return a value. And no glitches in the UI anymore! Check it out in the codesandbox.\n\nNow, the big question: do we really need refs here? Can‚Äôt we just implement exactly the same thing with the state and not resort to escape hatches (which ref actually is)? Well, technically yes, we can, the code will be pretty much the same:\n\nThere is one problem with this: every time the value changes it will trigger state update, which in turn will trigger re-render of the ‚Äúhost‚Äù component. This will result in the component being re-rendered twice every time the price prop changes - the first time because of the actual prop change, and the second - because of the state update in the hook. Doesn‚Äôt really matter for our small form, but as a generic solution that is meant to be used anywhere - not a good idea. See the code here, change the price value to see the double re-render.\n\nLast polish to the hook left: what will happen if I try to pass an object there? For example all the props?\n\nThe glitch, unfortunately, will return: we‚Äôre doing the shallow comparison here: , so the check will always return . To fix this, we can just introduce the deep equality comparison instead.\n\nPersonally, I‚Äôm not a huge fan of this solution: on big data sets it can become slow, plus depending on an external library (or implementing deep equality by myself) in a hook like that seems less than optimal.\n\nAnother way, since hooks are just functions and can accept any arguments, is to introduce a ‚Äúmatcher‚Äù function. Something like this:\n\nThat way we still can use the hook without the function - it will fallback to the shallow comparison. And also now have the ability to provide a way for the hook to compare the values:\n\nIt might not look that useful for props, but imagine a huge object of some data from external sources there. Typically it will have some sort of id. So instead of the slow deep comparison as in the example before, you can just do this:\n\nThat is all for today. Hope you found the article useful, able to use refs more confidently and use both variations of hooks with the full understanding of the expected result ‚úåüèº."
    },
    {
        "link": "https://react.dev/reference/react/useEffect",
        "document": "In this example, a cleanup function is not needed because the class manages only the DOM node that was passed to it. After the React component is removed from the tree, both the DOM node and the class instance will be automatically garbage-collected by the browser JavaScript engine. You can use an Effect to fetch data for your component. Note that if you use a framework, using your framework‚Äôs data fetching mechanism will be a lot more efficient than writing Effects manually. If you want to fetch data from an Effect manually, your code might look like this: Note the variable which is initialized to , and is set to during cleanup. This ensures your code doesn‚Äôt suffer from ‚Äúrace conditions‚Äù: network responses may arrive in a different order than you sent them.\n\nWriting data fetching directly in Effects gets repetitive and makes it difficult to add optimizations like caching and server rendering later. It‚Äôs easier to use a custom Hook‚Äîeither your own or maintained by the community. What are good alternatives to data fetching in Effects? Writing calls inside Effects is a popular way to fetch data, especially in fully client-side apps. This is, however, a very manual approach and it has significant downsides:\n‚Ä¢ Effects don‚Äôt run on the server. This means that the initial server-rendered HTML will only include a loading state with no data. The client computer will have to download all JavaScript and render your app only to discover that now it needs to load the data. This is not very efficient.\n‚Ä¢ Fetching directly in Effects makes it easy to create ‚Äúnetwork waterfalls‚Äù. You render the parent component, it fetches some data, renders the child components, and then they start fetching their data. If the network is not very fast, this is significantly slower than fetching all data in parallel.\n‚Ä¢ Fetching directly in Effects usually means you don‚Äôt preload or cache data. For example, if the component unmounts and then mounts again, it would have to fetch the data again.\n‚Ä¢ It‚Äôs not very ergonomic. There‚Äôs quite a bit of boilerplate code involved when writing calls in a way that doesn‚Äôt suffer from bugs like race conditions. This list of downsides is not specific to React. It applies to fetching data on mount with any library. Like with routing, data fetching is not trivial to do well, so we recommend the following approaches:\n‚Ä¢ If you use a framework, use its built-in data fetching mechanism. Modern React frameworks have integrated data fetching mechanisms that are efficient and don‚Äôt suffer from the above pitfalls.\n‚Ä¢ Otherwise, consider using or building a client-side cache. Popular open source solutions include React Query, useSWR, and React Router 6.4+. You can build your own solution too, in which case you would use Effects under the hood but also add logic for deduplicating requests, caching responses, and avoiding network waterfalls (by preloading data or hoisting data requirements to routes). You can continue fetching data directly in Effects if neither of these approaches suit you. Notice that you can‚Äôt ‚Äúchoose‚Äù the dependencies of your Effect. Every reactive value used by your Effect‚Äôs code must be declared as a dependency. Your Effect‚Äôs dependency list is determined by the surrounding code: If either or change, your Effect will reconnect to the chat using the new values. Reactive values include props and all variables and functions declared directly inside of your component. Since and are reactive values, you can‚Äôt remove them from the dependencies. If you try to omit them and your linter is correctly configured for React, the linter will flag this as a mistake you need to fix: To remove a dependency, you need to ‚Äúprove‚Äù to the linter that it doesn‚Äôt need to be a dependency. For example, you can move out of your component to prove that it‚Äôs not reactive and won‚Äôt change on re-renders: Now that is not a reactive value (and can‚Äôt change on a re-render), it doesn‚Äôt need to be a dependency. If your Effect‚Äôs code doesn‚Äôt use any reactive values, its dependency list should be empty ( ): An Effect with empty dependencies doesn‚Äôt re-run when any of your component‚Äôs props or state change. If you have an existing codebase, you might have some Effects that suppress the linter like this: When dependencies don‚Äôt match the code, there is a high risk of introducing bugs. By suppressing the linter, you ‚Äúlie‚Äù to React about the values your Effect depends on. Instead, prove they‚Äôre unnecessary.\n\nNow that you create the object inside the Effect, the Effect itself only depends on the string. With this fix, typing into the input doesn‚Äôt reconnect the chat. Unlike an object which gets re-created, a string like doesn‚Äôt change unless you set it to another value. Read more about removing dependencies. If your Effect depends on an object or a function created during rendering, it might run too often. For example, this Effect re-connects after every render because the function is different for every render: By itself, creating a function from scratch on every re-render is not a problem. You don‚Äôt need to optimize that. However, if you use it as a dependency of your Effect, it will cause your Effect to re-run after every re-render. Avoid using a function created during rendering as a dependency. Instead, declare it inside the Effect:"
    },
    {
        "link": "https://threejs.org/docs#api/en/renderers/WebGLRenderer.dispose",
        "document": ""
    },
    {
        "link": "https://threejs.org/docs/api/en/renderers/WebGLRenderer.html",
        "document": "The WebGL renderer displays your beautifully crafted scenes using [link:https://en.wikipedia.org/wiki/WebGL WebGL].\n\n[page:Object parameters] - (optional) object with properties defining the renderer's behavior. The constructor also accepts no parameters at all. In all cases, it will assume sane defaults when parameters are missing. The following are valid parameters:\n\n\n\n [page:DOMElement canvas] - A [link:https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas canvas] where the renderer draws its output. This corresponds to the [page:WebGLRenderer.domElement domElement] property below. If not passed in here, a new canvas element will be created.\n\n [page:WebGLRenderingContext context] - This can be used to attach the renderer to an existing [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext RenderingContext]. Default is null.\n\n [page:String precision] - Shader precision. Can be `\"highp\"`, `\"mediump\"` or `\"lowp\"`. Defaults to `\"highp\"` if supported by the device.\n\n [page:Boolean alpha] - controls the default clear alpha value. When set to `true`, the value is `0`. Otherwise it's `1`. Default is `false`.\n\n [page:Boolean premultipliedAlpha] - whether the renderer will assume that colors have [link:https://en.wikipedia.org/wiki/Glossary_of_computer_graphics#Premultiplied_alpha premultiplied alpha]. Default is `true`.\n\n [page:Boolean antialias] - whether to perform antialiasing. Default is `false`.\n\n [page:Boolean stencil] - whether the drawing buffer has a [link:https://en.wikipedia.org/wiki/Stencil_buffer stencil buffer] of at least 8 bits. Default is `false`.\n\n [page:Boolean preserveDrawingBuffer] - whether to preserve the buffers until manually cleared or overwritten. Default is `false`.\n\n [page:String powerPreference] - Provides a hint to the user agent indicating what configuration of GPU is suitable for this WebGL context. Can be `\"high-performance\"`, `\"low-power\"` or `\"default\"`. Default is `\"default\"`. See [link:https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.2 WebGL spec] for details.\n\n [page:Boolean failIfMajorPerformanceCaveat] - whether the renderer creation will fail upon low performance is detected. Default is `false`. See [link:https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.2 WebGL spec] for details.\n\n [page:Boolean depth] - whether the drawing buffer has a [link:https://en.wikipedia.org/wiki/Z-buffering depth buffer] of at least 16 bits. Default is `true`.\n\n [page:Boolean logarithmicDepthBuffer] - whether to use a logarithmic depth buffer. It may be necessary to use this if dealing with huge differences in scale in a single scene. Note that this setting uses gl_FragDepth if available which disables the [link:https://www.khronos.org/opengl/wiki/Early_Fragment_Test Early Fragment Test] optimization and can cause a decrease in performance. Default is `false`. See the [example:webgl_camera_logarithmicdepthbuffer camera / logarithmicdepthbuffer] example. [page:Boolean reverseDepthBuffer] - whether to use a reverse depth buffer. Requires the `EXT_clip_control` extension. This is a more faster and accurate version than logarithmic depth buffer. Default is `false`.\n\nDefines whether the renderer should automatically clear its output before rendering a frame. Default is `true`.\n\nIf [page:.autoClear autoClear] is true, defines whether the renderer should clear the color buffer. Default is `true`.\n\nIf [page:.autoClear autoClear] is true, defines whether the renderer should clear the depth buffer. Default is `true`.\n\nIf [page:.autoClear autoClear] is true, defines whether the renderer should clear the stencil buffer. Default is `true`.\n\nAn object containing details about the capabilities of the current [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext RenderingContext].\n\n - [page:Boolean floatFragmentTextures]: whether the context supports the [link:https://developer.mozilla.org/en-US/docs/Web/API/OES_texture_float OES_texture_float] extension.\n\n - [page:Boolean floatVertexTextures]: `true` if [page:Boolean floatFragmentTextures] and [page:Boolean vertexTextures] are both true.\n\n - [page:Method getMaxAnisotropy](): Returns the maximum available anisotropy.\n\n - [page:Method getMaxPrecision](): Returns the maximum available precision for vertex and fragment shaders. \n\n - [page:Boolean isWebGL2]: `true` if the context in use is a WebGL2RenderingContext object.\n\n - [page:Boolean logarithmicDepthBuffer]: `true` if the [page:parameter logarithmicDepthBuffer] was set to true in the constructor.\n\n - [page:Integer maxAttributes]: The value of `gl.MAX_VERTEX_ATTRIBS`.\n\n - [page:Integer maxCubemapSize]: The value of `gl.MAX_CUBE_MAP_TEXTURE_SIZE`. Maximum height * width of cube map textures that a shader can use.\n\n - [page:Integer maxFragmentUniforms]: The value of `gl.MAX_FRAGMENT_UNIFORM_VECTORS`. The number of uniforms that can be used by a fragment shader.\n\n - [page:Integer maxSamples]: The value of `gl.MAX_SAMPLES`. Maximum number of samples in context of Multisample anti-aliasing (MSAA).\n\n - [page:Integer maxTextureSize]: The value of `gl.MAX_TEXTURE_SIZE`. Maximum height * width of a texture that a shader use.\n\n - [page:Integer maxTextures]: The value of `gl.MAX_TEXTURE_IMAGE_UNITS`. The maximum number of textures that can be used by a shader.\n\n - [page:Integer maxVaryings]: The value of `gl.MAX_VARYING_VECTORS`. The number of varying vectors that can used by shaders.\n\n - [page:Integer maxVertexTextures]: The value of `gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS`. The number of textures that can be used in a vertex shader.\n\n - [page:Integer maxVertexUniforms]: The value of `gl.MAX_VERTEX_UNIFORM_VECTORS`. The maximum number of uniforms that can be used in a vertex shader.\n\n - [page:String precision]: The shader precision currently being used by the renderer.\n\n - [page:Boolean reverseDepthBuffer]: `true` if the [page:parameter reverseDepthBuffer] was set to `true` in the constructor and the context supports the [link:https://registry.khronos.org/webgl/extensions/EXT_clip_control/ EXT_clip_control] extension.\n\n - [page:Boolean vertexTextures]: `true` if [property:Integer maxVertexTextures] is greater than 0 (i.e. vertex textures can be used).\n\n\n\nUser-defined clipping planes specified as THREE.Plane objects in world space. These planes apply globally. Points in space whose dot product with the plane is negative are cut away. Default is [].\n\n- [page:Boolean checkShaderErrors]: If it is true, defines whether material shader programs are checked for errors during compilation and linkage process. It may be useful to disable this check in production for performance gain. It is strongly recommended to keep these checks enabled during development. If the shader does not compile and link - it will not work and associated material will not render. Default is `true`.\n\n - [page:Function onShaderError]( gl, program, glVertexShader, glFragmentShader ): A callback function that can be used for custom error reporting. The callback receives the WebGL context, an instance of WebGLProgram as well two instances of WebGLShader representing the vertex and fragment shader. Assigning a custom function disables the default error reporting. Default is `null`.\n\nA [link:https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas canvas] where the renderer draws its output.\n\n This is automatically created by the renderer in the constructor (if not provided already); you just need to add it to your page like so:\n\n\n\n- [page:Object get]( [param:String extensionName] ): Used to check whether various extensions are supported and returns an object with details of the extension if available. This method can check for the following extensions:\n\n\n\n- [page:Boolean has]( [param:String extensionName] ): `true` if the extension is supported.\n\nDefines the output color space of the renderer. Default is [page:Textures THREE.SRGBColorSpace].\n\nIf a render target has been set using [page:WebGLRenderer.setRenderTarget .setRenderTarget] then renderTarget.texture.colorSpace will be used instead.\n\nSee the [page:Textures texture constants] page for details of other formats.\n\nAn object with a series of statistical information about the graphics board memory and the rendering process. Useful for debugging or just for the sake of curiosity. The object contains the following fields:\n\nBy default these data are reset at each render call but when having multiple render passes per frame (e.g. when using post processing) it can be preferred to reset with a custom pattern. First, set `autoReset` to `false`. Call `reset()` whenever you have finished to render a single frame.\n\nDefines whether the renderer respects object-level clipping planes. Default is `false`.\n\nUsed internally by the renderer to keep track of various sub object properties.\n\nUsed internally to handle ordering of scene object rendering.\n\nThis contains the reference to the shadow map, if used.\n\n - [page:Boolean enabled]: If set, use shadow maps in the scene. Default is `false`.\n\n - [page:Boolean autoUpdate]: Enables automatic updates to the shadows in the scene. Default is `true`.\n\n If you do not require dynamic lighting / shadows, you may set this to `false` when the renderer is instantiated.\n\n - [page:Boolean needsUpdate]: When set to `true`, shadow maps in the scene will be updated in the next `render` call. Default is `false`.\n\n If you have disabled automatic updates to shadow maps (`shadowMap.autoUpdate = false`), you will need to set this to `true` and then make a render call to update the shadows in your scene.\n\n - [page:Integer type]: Defines shadow map type (unfiltered, percentage close filtering, percentage close filtering with bilinear filtering in shader). Options are:\n\nDefines whether the renderer should sort objects. Default is `true`.\n\n\n\n Note: Sorting is used to attempt to properly render objects that have some degree of transparency. By definition, sorting objects may not work in all cases. Depending on the needs of application, it may be necessary to turn off sorting and use other methods to deal with transparency rendering e.g. manually determining each object's rendering order.\n\nContains functions for setting various properties of the [page:WebGLRenderer.context] state.\n\nDefault is [page:Renderer NoToneMapping]. See the [page:Renderer Renderer constants] for other choices.\n\nThe normalized resolution scale for the transmission render target, measured in percentage of viewport dimensions. Lowering this value can result in significant improvements to [page:MeshPhysicalMaterial MeshPhysicalMaterial] transmission performance. Default is `1`.\n\nProvides access to the WebXR related [page:WebXRManager interface] of the renderer.\n\nTells the renderer to clear its color, depth or stencil drawing buffer(s). This method initializes the color buffer to the current clear color value.\n\n Arguments default to `true`.\n\nCompiles all materials in the scene with the camera. This is useful to precompile shaders before the first rendering. If you want to add a 3D object to an existing scene, use the third optional parameter for applying the target scene.\n\n Note that the (target) scene's lighting and environment should be configured before calling this method.\n\nAsynchronous version of [page:WebGLRenderer.compile .compile](). The method returns a Promise that resolves when the given scene can be rendered without unnecessary stalling due to shader compilation.\n\n\n\n This method makes use of the *KHR_parallel_shader_compile* WebGL extension.\n\nCopies pixels from the current WebGLFramebuffer into a 2D texture. Enables access to [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/copyTexImage2D WebGLRenderingContext.copyTexImage2D].\n\nCopies the pixels of a texture in the bounds '[page:Box3 srcRegion]' in the destination texture starting from the given position. 2D Texture, 3D Textures, or a mix of the two can be used as source and destination texture arguments for copying between layers of 3d textures. The `depthTexture` and `texture` property of render targets are supported as well.\n\n When using render target textures as `srcTexture` and `dstTexture`, you must make sure both render targets are initialized e.g. via [page:.initRenderTarget]().\n\nFrees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app.\n\nSimulate loss of the WebGL context. This requires support for the [link:https://developer.mozilla.org/en-US/docs/Web/API/WEBGL_lose_context WEBGL_lose_context] extensions.\n\nSimulate restore of the WebGL context. This requires support for the [link:https://developer.mozilla.org/en-US/docs/Web/API/WEBGL_lose_context WEBGL_lose_context] extensions.\n\nReturns a [page:Float float] with the current clear alpha. Ranges from `0` to `1`.\n\nReturns an object that describes the attributes set on the WebGL context when it was created.\n\nReturns the current [page:RenderTarget RenderTarget] if there are; returns `null` otherwise.\n\n[page:Vector4 target] ‚Äî the result will be copied into this Vector4.\n\n\n\n Returns the current viewport.\n\n[page:Vector2 target] ‚Äî the result will be copied into this Vector2.\n\n\n\n Returns the width and height of the renderer's drawing buffer, in pixels.\n\n[page:Vector4 target] ‚Äî the result will be copied into this Vector4.\n\n\n\n Returns the scissor region.\n\nReturns `true` if scissor test is enabled; returns `false` otherwise.\n\n[page:Vector2 target] ‚Äî the result will be copied into this Vector2.\n\n\n\n Returns the width and height of the renderer's output canvas, in pixels.\n\n[page:Vector4 target] ‚Äî the result will be copied into this Vector4.\n\n\n\n Returns the viewport.\n\nInitializes the given texture. Useful for preloading a texture rather than waiting until first render (which can cause noticeable lags due to decode and GPU upload overhead).\n\nInitializes the given WebGLRenderTarget memory. Useful for initializing a render target so data can be copied into it using [page:WebGLRenderer.copyTextureToTexture .copyTextureToTexture] before it has been rendered to.\n\nReset the GL state to default. Called internally if the WebGL context is lost.\n\nbuffer - Uint8Array is the only destination type supported in all cases, other types are renderTarget and platform dependent. See [link:https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.14.12 WebGL spec] for details.\n\nReads the pixel data from the renderTarget into the buffer you pass in. This is a wrapper around [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/readPixels WebGLRenderingContext.readPixels]().\n\nFor reading out a [page:WebGLCubeRenderTarget WebGLCubeRenderTarget] use the optional parameter activeCubeFaceIndex to determine which face should be read.\n\nAsynchronous, non-blocking version of [page:WebGLRenderer.readRenderTargetPixels .readRenderTargetPixels]. The returned promise resolves once the buffer data is ready to be used.\n\nSee the [example:webgl_interactive_cubes_gpu interactive / cubes / gpu] example.\n\nRender a [page:Scene scene] or another type of [page:Object3D object] using a [page:Camera camera].\n\n The render is done to a previously specified [page:WebGLRenderTarget renderTarget] set by calling [page:WebGLRenderer.setRenderTarget .setRenderTarget] or to the canvas as usual.\n\n By default render buffers are cleared before rendering but you can prevent this by setting the property [page:WebGLRenderer.autoClear autoClear] to false. If you want to prevent only certain buffers being cleared you can set either the [page:WebGLRenderer.autoClearColor autoClearColor], [page:WebGLRenderer.autoClearStencil autoClearStencil] or [page:WebGLRenderer.autoClearDepth autoClearDepth] properties to false. To forcibly clear one or more buffers call [page:WebGLRenderer.clear .clear].\n\nCan be used to reset the internal WebGL state. This method is mostly relevant for applications which share a single WebGL context across multiple WebGL libraries.\n\n[page:Function callback] ‚Äî The function will be called every available frame. If `null` is passed it will stop any already ongoing animation.\n\nA built in function that can be used instead of [link:https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame requestAnimationFrame]. For WebXR projects this function must be used.\n\nSets the clear alpha. Valid input is a float between `0.0` and `1.0`.\n\nSets device pixel ratio. This is usually used for HiDPI device to prevent blurring output canvas.\n\nrenderTarget -- The [page:WebGLRenderTarget renderTarget] that needs to be activated. When `null` is given, the canvas is set as the active render target instead.\n\n activeCubeFace -- Specifies the active cube side (PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5) of [page:WebGLCubeRenderTarget]. When passing a [page:WebGLArrayRenderTarget] or [page:WebGL3DRenderTarget] this indicates the z layer to render in to (optional).\n\n activeMipmapLevel -- Specifies the active mipmap level (optional).\n\n\n\n This method sets the active rendertarget.\n\nThe x, y, width, and height parameters of the scissor region.\n\n Optionally, a 4-component vector specifying the parameters of the region.\n\n\n\n Sets the scissor region from (x, y) to (x + width, y + height).\n\n (x, y) is the lower-left corner of the scissor region.\n\nEnable or disable the scissor test. When this is enabled, only the pixels within the defined scissor area will be affected by further renderer actions.\n\nSets the custom opaque sort function for the WebGLRenderLists. Pass null to use the default painterSortStable function.\n\nSets the custom transparent sort function for the WebGLRenderLists. Pass null to use the default reversePainterSortStable function.\n\nResizes the output canvas to (width, height) with device pixel ratio taken into account, and also sets the viewport to fit that size, starting in (0, 0). Setting [page:Boolean updateStyle] to false prevents any style changes to the output canvas.\n\nThe x, y, width, and height parameters of the viewport.\n\n Optionally, a 4-component vector specifying the parameters of a viewport.\n\n\n\n Sets the viewport to render from (x, y) to (x + width, y + height).\n\n (x, y) is the lower-left corner of the region."
    },
    {
        "link": "https://threejs.org/docs#api/en/renderers/WebGLRenderer.info",
        "document": ""
    },
    {
        "link": "https://threejs.org/docs#api/en/renderers/WebGLRenderer.capabilities",
        "document": ""
    },
    {
        "link": "https://discourse.threejs.org/t/changing-levels-would-you-re-initialize-the-renderer-or-dispose-of-every-resource/35039",
        "document": "I‚Äôm currently (still after years) in the process of building a game and right now tinkering with the idea of re-initializing the entire renderer when changing levels. Each level consists of ‚Äúcomponents‚Äù and a wide assortment of meshes, materials, etc. with some of them being unique to that level.\n\nFor as long as I can remember working with Three, there have been several questions about ‚Äúhow to properly dispose of objects‚Äù. Textures or geometries may reside in memory after an object has been removed from the scene. This made me wonder if it would be feasible to just re-initialize (recreate) the WebGLRenderer every time a level will load? The average time the player spends in one level varies from a couple of seconds to a few minutes tops.\n\nRight now every component in my engine has a method and it is each components‚Äô own responsibility to clean up/dispose of every resource it allocated, either geometry, materials, or other things unrelated to the renderer.\n\nI‚Äôm wondering how you would approach this situation? Would it be safer (avoiding accidental memory-leaks) to just re-initialize the WebGLRenderer every time a level loads, or is meticulously disposing of every resource manually really the way to go? I‚Äôm already pretty far into development, and its a pretty big refactor to change the current behavior of disposing everything one-by-one.\n\nSince I‚Äôm unsure of the caveats of either method, I‚Äôm really interested in your thoughts about this and especially the reasoning behind it."
    }
]