[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia",
        "document": "Secure context: This feature is available only in secure contexts (HTTPS), in some or all supporting browsers. The method of the interface prompts the user for permission to use a media input which produces a with tracks containing the requested types of media. That stream can include, for example, a video track (produced by either a hardware or virtual video source such as a camera, video recording device, screen sharing service, and so forth), an audio track (similarly, produced by a physical or virtual audio source like a microphone, A/D converter, or the like), and possibly other track types. It returns a that resolves to a object. If the user denies permission, or matching media is not available, then the promise is rejected with or respectively. Note: It's possible for the returned promise to neither resolve nor reject, as the user is not required to make a choice at all and may ignore the request.\n\nAlthough the user and operating system both granted access to the hardware device, and no hardware issues occurred that would cause a , throw if some problem occurred which prevented the device from being used. Thrown if current document is not fully active. Thrown if one or more of the requested source devices cannot be used at this time. This will happen if the browsing context is insecure (that is, the page was loaded using HTTP rather than HTTPS). It also happens if the user has specified that the current browsing instance is not permitted access to the device, the user has denied access for the current session, or the user has denied all access to user media devices globally. On browsers that support managing media permissions with Permissions Policy, this error is returned if Permissions Policy is not configured to allow access to the input source(s). Note: Older versions of the specification used for this instead; has taken on a new meaning. Thrown if no media tracks of the type specified were found that satisfy the given constraints. Thrown if, although the user granted permission to use the matching devices, a hardware error occurred at the operating system, browser, or Web page level which prevented access to the device. Thrown if the specified constraints resulted in no candidate devices which met the criteria requested. The error is an object of type , and has a property whose string value is the name of a constraint which was impossible to meet, and a property containing a human-readable string explaining the problem. Note: Because this error can occur even when the user has not yet granted permission to use the underlying device, it can potentially be used as a fingerprinting surface. Thrown if user media support is disabled on the on which was called. The mechanism by which user media support is enabled and disabled is left up to the individual user agent. Thrown if the list of constraints specified is empty, or has all constraints set to . This can also happen if you try to call in an insecure context, since is in an insecure context.\n\nAs an API that may involve significant privacy concerns, 's specification lays out a wide array of privacy and security requirements that browsers are obligated to meet. is a powerful feature that can only be used in secure contexts; in insecure contexts, is , preventing access to . A secure context is, in short, a page loaded using HTTPS or the URL scheme, or a page loaded from . In addition, user permission is always required to access the user's audio and video inputs. Only a window's top-level document context for a valid origin can even request permission to use , unless the top-level context expressly grants permission for a given to do so using Permissions Policy. Otherwise, the user will never even be asked for permission to use the input devices. For additional details on these requirements and rules, how they are reflected in the context in which your code is running, and about how browsers manage user privacy and security issues, read on.\n\nAs an API that may involve significant privacy concerns, is held by the specification to very specific requirements for user notification and permission management. First, must always get user permission before opening any media gathering input such as a webcam or microphone. Browsers may offer a once-per-domain permission feature, but they must ask at least the first time, and the user must specifically grant ongoing permission if they choose to do so. Of equal importance are the rules around notification. Browsers are required to display an indicator that shows that a camera or microphone is in use, above and beyond any hardware indicator that may exist. They must also show an indicator that permission has been granted to use a device for input, even if the device is not actively recording at the moment. For example in Firefox, the URL bar displays a pulsing red icon to indicate that recording is underway. The icon is gray if the permission is in place but recording is not currently underway. The device's physical light is used to indicate whether or not recording is currently active. If you've muted your camera (so-called \"facemuting\"), your camera's activity light goes out to indicate that the camera is not actively recording you, without discarding the permission to resume using the camera once muting is over.\n\nThere are a number of ways security management and controls in a user agent can cause to return a security-related error. The two Permissions Policy directives that apply to are and . For example, this HTTP header will enable use of a camera by the document and any embedded elements that are loaded from the same origin: This will request access to the microphone for the current origin and the specific origin : If you're using within an , you can request permission just for that frame, which is clearly more secure than requesting a more general permission. Here, indicate we need the ability to use both camera and microphone: The method is only available in secure contexts. A secure context is one the browser is reasonably confident contains a document which was loaded securely, using HTTPS/TLS, and has limited exposure to insecure contexts. If a document isn't loaded in a secure context, the property is , making access to impossible. Attempting to access in this situation will result in a . Because of the obvious security concern associated with if used unexpectedly or without security being carefully managed, it can only be used in secure contexts. There are a number of insecure ways to load a document that might, in turn, attempt to call . The following are examples of situations in which is not permitted to be called:\n‚Ä¢ A document loaded into a sandboxed element cannot call unless the has its attribute set to .\n‚Ä¢ A document loaded using a or URL which has no origin (such as when one of these URLs is typed by the user into the address bar) cannot call . These kinds of URLs loaded from JavaScript code inherit the script's permissions.\n‚Ä¢ Any other situation in which there is no origin, such as when the attribute is used to specify the contents of a frame.\n\nGenerally, you will access the singleton object using , like this: async function getMedia(constraints) { let stream = null; try { stream = await navigator.mediaDevices.getUserMedia(constraints); /* use the stream */ } catch (err) { /* handle the error */ } } Similarly, using the raw promises directly, the code looks like this: navigator.mediaDevices .getUserMedia(constraints) .then((stream) => { /* use the stream */ }) .catch((err) => { /* handle the error */ }); Note: If the current document isn't loaded securely, will be , and you cannot use . See Security for more information on this and other security issues related to using . Below are some examples of the parameter. The following requests both audio and video without any specific requirements: While information about a user's cameras and microphones are inaccessible for privacy reasons, an application can request the camera and microphone capabilities it needs and wants, using additional constraints. The following expresses a preference for 1280x720 camera resolution: The browser will try to honor this, but may return other resolutions if an exact match is not available, or the user overrides it. To require a capability, use the keywords , , or (a.k.a. ). The following demands a minimum resolution of 1280x720: If no camera exists with this resolution or higher, then the returned promise will be rejected with , and the user will not be prompted. The reason for the difference in behavior is that the keywords , , and are inherently mandatory ‚Äî whereas plain values and a keyword called are not. Here's a full example: An value, when used, has gravity ‚Äî which means that the browser will try to find the setting (and camera, if you have more than one), with the smallest fitness distance from the ideal values given. Plain values are inherently ideal, which means that the first of our resolution examples above could have been written like this: Not all constraints are numbers. For example, on mobile devices, the following will prefer the front camera (if one is available) over the rear one: To require the rear camera, use: Another non-number constraint is the constraint. If you have a from , you can use it to request a specific device: The above will return the camera you requested, or a different camera if that specific camera is no longer available. Again, to require the specific camera, you would use:"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices",
        "document": "This feature is well established and works across many devices and browser versions. It‚Äôs been available across browsers since September 2017 .\n\n* Some parts of this feature may have varying levels of support."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Build_a_phone_with_peerjs/Connect_peers/Get_microphone_permission",
        "document": "After you've created the peer, you'll want to get the browser's permission to access the microphone. We'll be using the method on the object. The endpoint takes a object that specifies which permissions are needed. is a promise which, when successfully resolved, returns a object. In our case this is going to contain the audio from our stream. If the promise isn't successfully resolved, you'll want to catch and display the error.\n‚Ä¢ Add the following code to the bottom of your file: function getLocalStream() { navigator.mediaDevices .getUserMedia({ video: false, audio: true }) .then((stream) => { window.localStream = stream; // A window.localAudio.srcObject = stream; // B window.localAudio.autoplay = true; // C }) .catch((err) => { console.error(`you got an error: ${err}`); }); }\n‚Ä¢ attaches the object (which we have assigned to on the previous line) to the window as the .\n‚Ä¢ sets the element with the ID of 's attribute to be the returned by the promise so that it will play our stream.\n‚Ä¢ sets the attribute of the element to true, so that the audio plays automatically. Warning: If you've done some sleuthing online, you may have come across and assumed you can use that instead of . You'd be wrong. The former is a deprecated method, which requires callbacks as well as constraints as arguments. The latter uses a promise so you don't need to use callbacks.\n‚Ä¢ Try calling your function by adding the following line at the bottom of your code:\n‚Ä¢ Refresh your app, which should still be running at ; you should see the following permission pop up:\n‚Ä¢ Plugin in some headphones before you allow the microphone usage so that when you unmute yourself later, you don't get any feedback. If you didn't see the permission prompt, open the inspector to see if you have any errors. Make sure your JavaScript file is correctly linked to your too.\n\nThis what it should all look like together:"
    },
    {
        "link": "https://stackoverflow.com/questions/74629182/i-would-like-to-ask-only-about-a-permission-to-a-microphone-for-mediadevices-get",
        "document": "Hi I have a problem with permission to userMedia API.\n\nI would like to call getUserMedia but before I have to ask about a permission to the microphone.\n\nIs it possible to only asks about the permission to the microphone without triggering red dot in a tab which means start recording.\n\nI would like to just ask using Javascript about a permission to the microphone without starting recording anything in MediaStream class."
    },
    {
        "link": "https://webrtc.org/getting-started/media-devices",
        "document": "When developing for the web, the WebRTC standard provides APIs for accessing cameras and microphones connected to the computer or smartphone. These devices are commonly referred to as Media Devices and can be accessed with JavaScript through the object, which implements the interface. From this object we can enumerate all connected devices, listen for device changes (when a device is connected or disconnected), and open a device to retrieve a Media Stream (see below).\n\nThe most common way this is used is through the function , which returns a promise that will resolve to a for the matching media devices. This function takes a single object that specifies the requirements that we have. For instance, to simply open the default microphone and camera, we would do the following.\n\nThe call to will trigger a permissions request. If the user accepts the permission, the promise is resolved with a containing one video and one audio track. If the permission is denied, a is thrown. In case there are no matching devices connected, a will be thrown.\n\nThe full API reference for the interface is available at MDN web docs.\n\nIn a more complex application, we will most likely want to check all the connected cameras and microphones and provide the appropriate feedback to the user. This can be done by calling the function . This will return a promise that resolves to an array of that describe each known media device. We can use this to present a UI to the user which let's them pick the one they prefer. Each contains a property named with the value , or , indicating what type of media device it is.\n\nMost computers support plugging in various devices during runtime. It could be a webcam connected by USB, a Bluetooth headset, or a set of external speakers. In order to properly support this, a web application should listen for the changes of media devices. This can be done by adding a listener to for the event.\n\nThe constraints object, which must implement the interface, that we pass as a parameter to allows us to open a media device that matches a certain requirement. This requirement can be very loosely defined (audio and/or video), or very specific (minimum camera resolution or an exact device ID). It is recommended that applications that use the API first check the existing devices and then specifies a constraint that matches the exact device using the constraint. Devices will also, if possible, be configured according to the constraints. We can enable echo cancellation on microphones or set a specific or minimum width and height of the video from the camera.\n\nThe full documentation for the interface can be found on the MDN web docs.\n\nOnce a media device has been opened and we have a available, we can assign it to a video or audio element to play the stream locally.\n\nThe HTML needed for a typical video element used with will usually have the attributes and . The attribute will cause new streams assigned to the element to play automatically. The attribute allows video to play inline, instead of only in full screen, on certain mobile browsers. It is also recommended to use for live streams, unless the user should be able to pause them."
    },
    {
        "link": "https://stackoverflow.com/questions/36067767/how-do-i-upload-a-file-with-the-js-fetch-api",
        "document": "I am still trying to wrap my head around it.\n\nI can have the user select the file (or even multiple) with the file input:\n\nAnd I can catch the event using <fill in your event handler here> . But once I do, how do I send the file using ?"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch",
        "document": "The Fetch API provides a JavaScript interface for making HTTP requests and processing the responses. Fetch is the modern replacement for : unlike , which uses callbacks, Fetch is promise-based and is integrated with features of the modern web such as service workers and Cross-Origin Resource Sharing (CORS). With the Fetch API, you make a request by calling , which is available as a global function in both and contexts. You pass it a object or a string containing the URL to fetch, along with an optional argument to configure the request. The function returns a which is fulfilled with a object representing the server's response. You can then check the request status and extract the body of the response in various formats, including text and JSON, by calling the appropriate method on the response. Here's a minimal function that uses to retrieve some JSON data from a server: async function getData() { const url = \"https://example.org/products.json\"; try { const response = await fetch(url); if (!response.ok) { throw new Error(`Response status: ${response.status}`); } const json = await response.json(); console.log(json); } catch (error) { console.error(error.message); } } We declare a string containing the URL and then call , passing the URL with no extra options. The function will reject the promise on some errors, but not if the server responds with an error status like : so we also check the response status and throw if it is not OK. Otherwise, we fetch the response body content as JSON by calling the method of , and log one of its values. Note that like itself, is asynchronous, as are all the other methods to access the response body content. In the rest of this page we'll look in more detail at the different stages of this process.\n\nThe request body is the payload of the request: it's the thing the client is sending to the server. You cannot include a body with requests, but it's useful for requests that send content to the server, such as or requests. For example, if you want to upload a file to the server, you might make a request and include the file as the request body. To set a request body, pass it as the option: You can supply the body as an instance of any of the following types: Other objects are converted to strings using their method. For example, you can use a object to encode form data (see setting headers for more information): const response = await fetch(\"https://example.org/post\", { method: \"POST\", headers: { \"Content-Type\": \"application/x-www-form-urlencoded\", }, // Automatically converted to \"username=example&password=password\" body: new URLSearchParams({ username: \"example\", password: \"password\" }), // ... }); Note that just like response bodies, request bodies are streams, and making the request reads the stream, so if a request contains a body, you can't make it twice: const request = new Request(\"https://example.org/post\", { method: \"POST\", body: JSON.stringify({ username: \"example\" }), }); const response1 = await fetch(request); console.log(response1.status); // Will throw: \"Body has already been consumed.\" const response2 = await fetch(request); console.log(response2.status); Instead, you would need to create a clone of the request before sending it: See Locked and disturbed streams for more information.\n\nCredentials are cookies, TLS client certificates, or authentication headers containing a username and password. To control whether or not the browser sends credentials, as well as whether the browser respects any response headers, set the option, which can take one of the following three values:\n‚Ä¢ : never send credentials in the request or include credentials in the response.\n‚Ä¢ (the default): only send and include credentials for same-origin requests. Note that if a cookie's attribute is set to or , then the cookie will not be sent cross-site, even if is set to . Including credentials in cross-origin requests can make a site vulnerable to CSRF attacks, so even if is set to , the server must also agree to their inclusion by including the header in its response. Additionally, in this situation the server must explicitly specify the client's origin in the response header (that is, is not allowed). This means that if is set to and the request is cross-origin, then:\n‚Ä¢ If the request is a simple request, then the request will be sent with credentials, but the server must set the and response headers, or the browser will return a network error to the caller. If the server does set the correct headers, then the response, including credentials, will be delivered to the caller.\n‚Ä¢ If the request is not a simple request, then the browser will send a preflighted request without credentials, and the server must set the and response headers, or the browser will return a network error to the caller. If the server does set the correct headers, then the browser will follow up with the real request, including credentials, and will deliver the real response, including credentials, to the caller.\n\nRequest and response bodies are actually objects, and whenever you read them, you're streaming the content. This is good for memory efficiency, because the browser doesn't have to buffer the entire response in memory before the caller retrieves it using a method like . This also means that the caller can process the content incrementally as it is received. For example, consider a request that fetches a large text file and processes it in some way, or displays it to the user: const url = \"https://www.example.org/a-large-file.txt\"; async function fetchText(url) { try { const response = await fetch(url); if (!response.ok) { throw new Error(`Response status: ${response.status}`); } const text = await response.text(); console.log(text); } catch (e) { console.error(e); } } If we use , as above, we must wait until the whole file has been received before we can process any of it. If we stream the response instead, we can process chunks of the body as they are received from the network: const url = \"https://www.example.org/a-large-file.txt\"; async function fetchTextAsStream(url) { try { const response = await fetch(url); if (!response.ok) { throw new Error(`Response status: ${response.status}`); } const stream = response.body.pipeThrough(new TextDecoderStream()); for await (const value of stream) { console.log(value); } } catch (e) { console.error(e); } } In this example, we iterate asynchronously over the stream, processing each chunk as it arrives. Note that when you access the body directly like this, you get the raw bytes of the response and must transform it yourself. In this case we call to pipe the response through a , which decodes the UTF-8-encoded body data as text."
    },
    {
        "link": "https://rapidapi.com/guides/send-files-to-server-fetch",
        "document": "Uploading files to your website or web application can be a challenging task, but with the modern web technologies available today, it doesn't have to be.\n\nThe Fetch API provides a fast and efficient way to send and receive data from a server using a simple and intuitive API.\n\nThe Fetch API is a modern Web API that allows you to make API requests in JavaScript. It provides a simpler and more flexible alternative to older technologies like AJAX or jQuery for sending and receiving data from a server.\n\nIf you want to learn more about Fetch API, you can read our guide here.\n\nBefore we can start using the Fetch API to upload files, we need to prepare our HTML form to handle file uploads properly.\n\nTo create a basic form for file uploads, we can use the element with the method attribute set to \"POST\" and the attribute set to \"multipart/form-data\". This tells the browser that we'll be sending binary data, which is necessary for file uploads.\n\nNext, we need to add input fields to our form that allow users to select the files they want to upload. We can use the element with the type attribute set to \"file\".\n\nFinally, we need to set some additional attributes on our form to ensure that file uploads are handled properly. The \"name\" attribute on the file input field should match the name of the field in our server-side code that will handle the file upload\n\nUsing fetch to send files to server\n\nThe basic structure of a Fetch request involves calling the fetch() function with a URL and an options object that specifies the HTTP method, headers, and other request options.\n\nTo upload files with the Fetch API, we need to create a request body that includes the file data. We can do this using the FormData object, which allows us to append file data to a new FormData instance.\n\nIn this example, a Fetch request is sent to the endpoint with the method and the form data as the request body.\n\nNote that you'll need to replace with the appropriate API endpoint.\n\nOnce the server has finished processing the file upload request, it will send a response back to the client to indicate whether the upload was successful or not. To handle this response on the client side, we can use the Response object that's returned by the function.\n\nWhen the response is received, we can use various methods of the object to retrieve the response data from the server. Here is how:\n\nLet‚Äôs use the File Upload API from the Rapid API hub.\n\nHere‚Äôs the entire code that includes a basic form for file uploads and a Fetch request to handle the file upload:\n\nWhen uploading files using the Fetch API, there are several common errors that can occur. These include network errors, server errors, and user errors, such as selecting an invalid file type or a file that exceeds the maximum file size allowed.\n\nTo handle these errors, we can use the try-catch block if we are using async/await with fetch. Here is how we can do it:\n\nThe code is wrapped in a block, which is used to catch any errors that may occur during the file upload or fetch request. If an error is caught, it will be logged to the console using console.error().\n\nIf the status code indicates success, the response is parsed using the method, and the parsed data is logged to the console using . If the status code indicates failure, an error is thrown using .\n\nThe Fetch API provides an efficient way to handle file uploads in web applications. With a few lines of code, you can create an HTML form for file uploads, use the Fetch API to make the request to the server and handle the response data."
    },
    {
        "link": "https://stackoverflow.com/questions/69120374/how-can-i-upload-file-and-also-include-json-data-with-fetch-api",
        "document": "Hope you're having a good day. So I'm using Fetch API to upload files to server but I also want to include a string as JSON for my backend. But I'm unable to do so.\n\nRight now this is what my upload-file function looks like. This works perfectly if I want to just upload a file and not include a string as JSON:\n\nGetting the file in my NodeJS backend with ;\n\nBut if I include a string as JSON and try to upload file then I get undefined in my NodeJS backend. This is how it looks like with string as JSON:\n\nNow if I want to get the file in my backend with:\n\nWhat is going wrong here?"
    },
    {
        "link": "https://tutorialspoint.com/ajax/fetch_api_uploading_files.htm",
        "document": "Fetch API provides a flexible way to create an HTTP request which will upload files to the server. We can use the fetch() function along with the FormData object to send single or multiple files in the request. Let us discuss this concept with the help of the following examples ‚àí\n\nIn the following program, we upload one file at a time using fetch API. Here we use the FormData object to store the file and then send it using the fetch() function to the given URL including the POST request method and the FormData object. After sending the request to the server now we use the then() function to handle the response. If we encounter an error, then that error is handled by the catch() function.\n\nIn the following program, we will upload multiple files from the single input using fetch API. Here we add a \"multiple\" property in the <input> tag to add multiple files. Then we use the FormData object to store multiple files and then send them using the fetch() function to the given URL including the POST request method and the FormData object. After sending the request to the server now we use the then() function to handle the response. If we encounter an error, then that error is handled by the catch() function.\n\nIn the following program, we will upload multiple files using fetch API. Here we select two files from the system in DOM with the attribute of file type. Then we add the input files in an array. Then we create a FormData object and append the input files to the object. Then we send them using the fetch() function to the given URL including the POST request method and the FormData object. After sending the request to the server now we use the then() function to handle the response. If we encounter an error, then that error is handled by the catch() function.\n\nSo this is how we can upload files to the given URL with the help of fetch() API. Here we can upload any type of file like jpg, pdf, word, etc and upload any number of files like one file at a time or multiple files at a time. Now in the next article, we will learn how the Fetch API handles responses."
    },
    {
        "link": "https://stackoverflow.com/questions/16534892/multipart-file-uploads-using-nodejs",
        "document": "I am having troubles getting file uploads to work with NodeJS. I am using Dropzone.JS to create a form that sends a POST request to /file-upload here:\n\nThen I have a route in app.js:\n\nHowever, the upload function here is never called. The server crashes with this error first:\n\nSo I am not sure what I should do because it appears that this is not my fault. I followed other tutorials and saw nothing wrong. Also, when I inspect my Network under chrome dev tools, it shows:"
    },
    {
        "link": "https://stackoverflow.com/questions/60629800/nodejs-handle-and-send-multipart-request",
        "document": "My application runs on Nodejs server and Nodejs also acts as a middle ware/proxy for requests originating from the application. So from browser all REST calls goes to NodeJs, and then to Java API.\n\nI see an issue handling requests with multipart-form data.\n\nI intercept the file upload REST call from browser in my nodejs, parse the request using multiparty library, and form a form-data object from the file upload request.\n\nI am using https module to send data to API, so how do I send the form data request to API, via https ?\n\nI send the Content-Type as multipart/form-data; boundary=----WebKitFormBoundary6fyv95baqEpoGJaK, got from browser."
    },
    {
        "link": "https://medium.com/@ritikkhndelwal/getting-the-data-from-the-multipart-form-data-in-node-js-dc2d99d10f97",
        "document": "In this blog, we will see how we can access the multipart/form-data sent from the front-end to the back-end node express server.\n\nSo first we need to create a back-end API server using the node js and express js to get the data. So let‚Äôs create a node project.\n\nFirst, we will initialize the node package manager by typing this command in the terminal. And open your terminal in your desired folder.\n\nThen we need to install the express module to make our API and along with it we need to install one more package called multer.\n\nMulter ‚Äî Multer is a node. js middleware for handling multipart/form-data , which is primarily used for uploading files.\n\nAfter installing the module then we will write the backend code to process the multipart/form-data.\n\nYou can also use multer to get multiple files by changing few things such as in the app.post definition where you need to change the upload.single to upload.array and now you can access the data using the req.files.\n\nTo handle the text only multipart data we can change the upload to .none()\n\nWe can also define the storage i.e where the file needs to be stored and how we need to store it, the name of the file and the extension of it.\n\nIn this we can get save the file in our server. There are other module that you can use along with multer to save the file directly to your image server.\n\nThank you for reading the blog and if you want any help or have any suggestion you can leave a comment and I will get back to you as soon as possible."
    },
    {
        "link": "https://github.com/expressjs/multer",
        "document": "Multer is a node.js middleware for handling , which is primarily used for uploading files. It is written on top of busboy for maximum efficiency.\n\nNOTE: Multer will not process any form which is not multipart ( ).\n\nThis README is also available in other languages:\n\nMulter adds a object and a or object to the object. The object contains the values of the text fields of the form, the or object contains the files uploaded via the form.\n\nDon't forget the in your form.\n\nIn case you need to handle a text-only multipart form, you should use the method:\n\nHere's an example on how multer is used in a HTML form. Take special note of the and fields:\n\nThen in your javascript file you would add these lines to access both the file and the body. It is important that you use the field value from the form in your upload function. This tells multer which field on the request it should look for the files in. If these fields aren't the same in the HTML form and on your server, your upload will fail:\n\nEach file contains the following information:\n\nMulter accepts an options object, the most basic of which is the property, which tells Multer where to upload the files. In case you omit the options object, the files will be kept in memory and never written to disk.\n\nBy default, Multer will rename the files so as to avoid naming conflicts. The renaming function can be customized according to your needs.\n\nThe following are the options that can be passed to Multer.\n\nIn an average web app, only might be required, and configured as shown in the following example.\n\nIf you want more control over your uploads, you'll want to use the option instead of . Multer ships with storage engines and ; More engines are available from third parties.\n\nAccept a single file with the name . The single file will be stored in .\n\nAccept an array of files, all with the name . Optionally error out if more than files are uploaded. The array of files will be stored in .\n\nAccept a mix of files, specified by . An object with arrays of files will be stored in .\n\nshould be an array of objects with and optionally a . Example:\n\nAccept only text fields. If any file upload is made, error with code \"LIMIT_UNEXPECTED_FILE\" will be issued.\n\nAccepts all files that comes over the wire. An array of files will be stored in .\n\nWARNING: Make sure that you always handle the files that a user uploads. Never add multer as a global middleware since a malicious user could upload files to a route that you didn't anticipate. Only use this function on routes where you are handling the uploaded files.\n\nThe disk storage engine gives you full control on storing files to disk.\n\nThere are two options available, and . They are both functions that determine where the file should be stored.\n\nis used to determine within which folder the uploaded files should be stored. This can also be given as a (e.g. ). If no is given, the operating system's default directory for temporary files is used.\n\nNote: You are responsible for creating the directory when providing as a function. When passing a string, multer will make sure that the directory is created for you.\n\nis used to determine what the file should be named inside the folder. If no is given, each file will be given a random name that doesn't include any file extension.\n\nNote: Multer will not append any file extension for you, your function should return a filename complete with an file extension.\n\nEach function gets passed both the request ( ) and some information about the file ( ) to aid with the decision.\n\nNote that might not have been fully populated yet. It depends on the order that the client transmits fields and files to the server.\n\nFor understanding the calling convention used in the callback (needing to pass null as the first param), refer to Node.js error handling\n\nThe memory storage engine stores the files in memory as objects. It doesn't have any options.\n\nWhen using memory storage, the file info will contain a field called that contains the entire file.\n\nWARNING: Uploading very large files, or relatively small files in large numbers very quickly, can cause your application to run out of memory when memory storage is used.\n\nAn object specifying the size limits of the following optional properties. Multer passes this object into busboy directly, and the details of the properties can be found on busboy's page.\n\nThe following integer values are available:\n\nSpecifying the limits can help protect your site against denial of service (DoS) attacks.\n\nSet this to a function to control which files should be uploaded and which should be skipped. The function should look like this:\n\nWhen encountering an error, Multer will delegate the error to Express. You can display a nice error page using the standard express way.\n\nIf you want to catch errors specifically from Multer, you can call the middleware function by yourself. Also, if you want to catch only the Multer errors, you can use the class that is attached to the object itself (e.g. ).\n\nFor information on how to build your own storage engine, see Multer Storage Engine."
    },
    {
        "link": "https://freecodecamp.org/news/handle-file-uploads-on-the-backend-in-node-js-nuxt",
        "document": "In some previous tutorials, I covered how to upload files using HTML and JavaScript. It requires sending HTTP requests with the header set to .\n\nToday, we are going to the back end to receive those requests and access the binary data from those files.\n\nMost of the concepts in this tutorial should broadly apply across frameworks, runtimes, and languages, but the code examples will be more specific.\n\nI‚Äôll be working within a Nuxt.js project that runs in a Node.js environment. Nuxt has some specific ways of defining API routes which require calling a global function called .\n\nThe argument provides access to work directly with the underlying Node.js request object (a.k.a. ) through . So we can write our Node-specific code in an abstraction, like a function called that receives this Node request object and does something with it.\n\nWorking directly with Node in this way means the code and concepts should apply regardless of whatever higher-level framework you‚Äôre working with. Ultimately, finish things up working in Nuxt.js.\n\nHow to Deal with in Node.js\n\nIn this section, we‚Äôll dive into some low-level concepts that are good to understand, but not strictly necessary. Feel free to skip this section if you are already familiar with chunks and streams and buffers in Node.js.\n\nUploading a file requires sending a request. In these requests, the browser will split the data into little ‚Äúchunks‚Äù and send them through the connection, one chunk at a time. This is necessary because files can be too large to send in as one massive payload.\n\nChunks of data being sent over time make up what‚Äôs called a ‚Äústream‚Äù. Streams are kind of hard to understand the first time around, at least they were for me. They deserve a full article (or many) on their own, so I‚Äôll share web.dev‚Äôs excellent guide in case you want to learn more.\n\nBasically, a stream is sort of like a conveyor belt of data, where each chunk can be processed as it comes in. In terms of an HTTP request, the backend will receive parts of the request, one bit at a time.\n\nNode.js provides us with an event handler API through the request object‚Äôs method, which allows us to listen to ‚Äúdata‚Äù events as they are streamed into the backend.\n\nFor example, when I upload a photo of Nugget making a cute yawny face, then look at the server‚Äôs console, I‚Äôll see some weird things that look like this:\n\nI used a screenshot here to prevent assistive technology from reading that gibberish out loud. Could you imagine?\n\nThese two pieces of garbled nonsense are called ‚Äúbuffers‚Äù and they represent the two chunks of data that made up the request stream containing the cute photo of Nugget.\n\nBuffers are another weird, low-level concept I have to explain when talking about working with files in JavaScript.\n\nJavaScript doesn‚Äôt work directly on binary data, so we get to learn about buffers. It‚Äôs also OK if these concepts still feel a little vague. Understanding everything completely is not the important part right now, and as you continue to learn about file transfers, you‚Äôll gain a better knowledge of how it all works together.\n\nWorking with one partial chunk of data is not super useful. What we can do instead is rewrite our function into something we can work with:\n‚Ä¢ Return a to make the async syntax easy to work with.\n‚Ä¢ Provide an to store the chunks of data to use later on.\n‚Ä¢ Listen for the ‚Äúdata‚Äù event and add the chunks to our collection as they arrive.\n‚Ä¢ Listen to the ‚Äúend‚Äù event and convert the chunks into something we can work with.\n‚Ä¢ Resolve the with the final request payload.\n‚Ä¢ We should also remember to handle ‚Äúerror‚Äù events.\n\nAnd every time that the request receives some data, it pushes that data into the array of chunks.\n\nSo with that function set up, we can actually that returned until the request has finished receiving all the data from the request stream, and log the resolved value to the console.\n\nThis is the request body. Isn‚Äôt it beautiful?\n\nI honestly don‚Äôt even know what a screen reader would do with if this was plain text.\n\nIf you upload an image file, it‚Äôll probably look like an alien has hacked your computer. Don‚Äôt worry, it hasn‚Äôt. That‚Äôs literally what the text contents of that file look like. You can even try opening up an image file in a basic text editor and see the same thing.\n\nIf I upload a more basic example, like a file with some plain text in it, the body might look like this:\n\nNotice that the request is broken up into different sections for each form field. The sections are separated by the ‚Äúform boundary‚Äù, which the browser will inject by default.\n\nI‚Äôll skip going into excess details, so if you want to read more, check out on MDN. The important thing to know is that requests are much more complex than just key/value pairs.\n\nMost server frameworks provide built-in tools to access the body of a request. So we‚Äôve actually reinvented the wheel. For example, Nuxt provides a global function. So we could have accomplished the same thing without writing our own code:\n\nThis works fine for other content types, but for , it has issues. The entire body of the request is being read into memory as one giant string of text. This includes the information, the form boundaries, and the form fields and values. Never mind the fact that the files aren‚Äôt even being written to disk.\n\nThe big issue here is if a very large file is uploaded, it could consume all the memory of the application and cause it to crash.\n\nThe solution is, once again, working with streams.\n\nWhen our server receives a chunk of data from the request stream, instead of storing it in memory, we can pipe it to a different stream. Specifically, we can send it to a stream that writes data to the file system using . As the chunks come in from the request, that data gets written to the file system, then released from memory.\n\nThat‚Äôs about as far down as I want to go into the low-level concepts. Let‚Äôs go back up to solving the problem without reinventing the wheel.\n\nHow to Use a Library to Stream Data onto Disk\n\nProbably my best advice for handling file uploads is to reach for a library that does all this work for you:\n‚Ä¢ Separate the files from the other form fields\n‚Ä¢ Stream the file data into the file system\n‚Ä¢ Provide you with the form field data as well as useful data about the files\n\nToday, I‚Äôm going to be using this library called formidable. You can install it with , then import it into your project.\n\nFormidable works directly with the Node request object, which we conveniently already grabbed from the Nuxt event (‚ÄúWow, what amazing foresight!!‚Äù ü§©).\n\nSo we can modify our function to use formidable instead. It should still return a promise because formidable uses callbacks, but promises are nicer to work with. Otherwise, we can mostly replace the contents of the function with formidable.\n\nWe‚Äôll need to create a formidable instance and use it to parse the request object. As long as there isn‚Äôt an error, we can resolve the promise with a single object that contains both the form fields and the files.\n\nThis provides us with a handy function to parse using promises and access the request‚Äôs regular form fields, as well as information about the files that were written to disk using streams.\n\nNow, we can examine the request body:\n\nWe should see an object containing all the form fields and their values, but for each file input, we‚Äôll see an object that represents the uploaded file, and not the file itself. This object contains all sorts of useful information including its path on disk, name, mimetype, and more.\n\nYou‚Äôll also notice that the is a hashed value. This is to ensure that if two files are uploaded with the same name, you will not lose data. You can, of course, modify how files are written to disk.\n\nNote that in a standard application, it‚Äôs a good idea to store some of this information in a persistent place, like a database, so you can easily find all the files that have been uploaded. But that‚Äôs not the point of this post.\n\nNow there‚Äôs one more thing I want to fix. I only want to process requests with formidable. Everything else can be handled by a built-in body parser like the one we saw above.\n\nSo I‚Äôll create a ‚Äúbody‚Äù variable first, then check the request headers, and assign the value of the body based on the ‚ÄúContent-Type‚Äù. I‚Äôll also rename my function to to be more explicit about what it does.\n\nHere‚Äôs what the whole thing looks like (note that is another built-in Nuxt function):\n\nThis way, we have an API that is robust enough to accept , plain text, or URL-encoded requests.\n\nThere‚Äôs no emoji rave horn, so those will have to do. We covered kind of a lot, so let‚Äôs do a little recap.\n\nWhen we upload a file using a request, the browser will send the data one chunk at a time, using a stream. That‚Äôs because we can‚Äôt put the entire file in the request object at once.\n\nIn Node.js, we can listen to the request‚Äôs ‚Äúdata‚Äù event to work with each chunk of data as it arrives. This gives us access to the request stream.\n\nAlthough we could capture all of that data and store it in memory, that‚Äôs a bad idea. A large file upload could consume all the server‚Äôs memory, causing it to crash.\n\nInstead, we can pipe that stream somewhere else, so each chunk is received, processed, then released from memory. One option is to use to create a that can write to the file system.\n\nInstead of writing our own low-level parser, we should use a tool like formidable. But we need to confirm that the data is coming from a request. Otherwise, we can use a standard body parser.\n\nWe covered a lot of low-level concepts, and landed on a high-level solution. Hopefully, it all made sense and you found this useful.\n\nIf you have any questions or if something was confusing, please go ahead and reach out to me. I‚Äôm always happy to help.\n\nThank you so much for reading. If you liked this article, and want to support me, the best ways to do so are to share it, sign up for my newsletter, and follow me on Twitter."
    }
]