[
    {
        "link": "https://cs.utexas.edu/~vl/teaching/378/pwc.pdf",
        "document": ""
    },
    {
        "link": "http://wp.doc.ic.ac.uk/arusso/wp-content/uploads/sites/47/2015/01/clingo_guide.pdf",
        "document": ""
    },
    {
        "link": "https://cs.cmu.edu/~cmartens/asp-notes.pdf",
        "document": ""
    },
    {
        "link": "https://personal.utdallas.edu/~gupta/courses/lpug/asphw.pdf",
        "document": ""
    },
    {
        "link": "https://potassco.org/clingo/python-api/5.4",
        "document": "Arguments to the grounder and solver. Function to intercept messages normally printed to standard error. The maximum number of messages passed to the logger. Note that only gringo options (without ) and clasp's search options are supported. Furthermore, a object is blocked while a search call is active; you must not call any member function during search. Whether the internal program representation is conflicting. If this (read-only) property is true, solve calls return immediately with an unsatisfiable solve result. Conflicts first have to be detected, e.g., initial unit propagation results in an empty clause, or later if an empty clause is resolved during solving. Hence, the property might be false even if the problem is unsatisfiable. A containing solve statistics of the last solve call. The statistics correspond to the output of clingo. The detail of the statistics depends on what level is requested on the command line. This property is only available in clingo. The following example shows how to dump the solving statistics in json format: A object, which can be used to iterate over the theory atoms. Whether do discard or keep learnt information from enumeration modes. If the enumeration assumption is enabled, then all information learnt from clasp's various enumeration modes is removed after a solve call. This includes enumeration of cautious or brave consequences, enumeration of answer sets with or without projection, or finding optimal models; as well as clauses added with . In general, the enumeration assumption should be enabled whenever there are multiple calls to solve. Otherwise, the behavior of the solver will be unpredictable because there are no guarantees which information exactly is kept. There might be small speed benefits when disabling the enumeration assumption for single shot solving. Extend the logic program with the given non-ground logic program in string form. The name of program block to add. The parameters of the program block to add. Assign a truth value to an external atom. A Boolean fixes the external to the respective truth value; and None leaves its truth value open. The truth value of an external atom can be changed before each solve call. An atom is treated as external if it has been declared using an directive, and has not been released by calling release_external() or defined in a logic program with some rule. If the given atom is not external, then the function has no effect. For convenience, the truth assigned to atoms over negative program literals is inverted. Cleanup the domain used for grounding by incorporating information from the solver. This function cleans up the domain used for grounding. This is done by first simplifying the current program representation (falsifying released external atoms). Afterwards, the top-level implications are used to either remove atoms from the domain or mark them as facts. Any atoms falsified are completely removed from the logic program. Hence, a definition for such an atom in a successive step introduces a fresh atom. Return the symbol for a constant definition of form: The name of the constant to retrieve. The function returns if no matching constant definition exists. Ground the given list of program parts specified by tuples of names and arguments. List of tuples of program names and program arguments to ground. A context object whose methods are called during grounding using the -syntax (if omitted methods, from the main module are used). Note that parts of a logic program without an explicit specification are by default put into a program called without arguments. This function is thread-safe and can be called from a signal handler. If no search is active, the subsequent call to is interrupted. The result of the method can be used to query if the search was interrupted. Extend the logic program with a (non-ground) logic program in a file. The path of the file to load. Registers the given observer to inspect the produced grounding. The observer to register. See below for a description of the requirede interface. If set to true, the output is just passed to the observer and nolonger to the underlying solver (or any previously registered observers). An observer should be a class of the form below. Not all functions have to be implemented and can be omitted if not needed. class Observer: def init_program(self, incremental: bool) -> None: \"\"\" Called once in the beginning. Parameters ---------- incremental : bool Whether the program is incremental. If the incremental flag is true, there can be multiple calls to `Control.solve`. Returns ------- None \"\"\" def begin_step(self) -> None: \"\"\" Marks the beginning of a block of directives passed to the solver. Returns ------- None \"\"\" def rule(self, choice: bool, head: List[int], body: List[int]) -> None: \"\"\" Observe rules passed to the solver. Parameters ---------- choice : bool Determines if the head is a choice or a disjunction. head : List[int] List of program atoms forming the rule head. body : List[int] List of program literals forming the rule body. Returns ------- None \"\"\" def weight_rule(self, choice: bool, head: List[int], lower_bound: int, body: List[Tuple[int,int]]) -> None: \"\"\" Observe rules with one weight constraint in the body passed to the solver. Parameters ---------- choice : bool Determines if the head is a choice or a disjunction. head : List[int] List of program atoms forming the head of the rule. lower_bound: The lower bound of the weight constraint in the rule body. body : List[Tuple[int,int]] List of weighted literals (pairs of literal and weight) forming the elements of the weight constraint. Returns ------- None \"\"\" def minimize(self, priority: int, literals: List[Tuple[int,int]]) -> None: \"\"\" Observe minimize directives (or weak constraints) passed to the solver. Parameters ---------- priority : int The priority of the directive. literals : List[Tuple[int,int]] List of weighted literals whose sum to minimize (pairs of literal and weight). Returns ------- None \"\"\" def project(self, atoms: List[int]) -> None: \"\"\" Observe projection directives passed to the solver. Parameters ---------- atoms : List[int] The program atoms to project on. Returns ------- None \"\"\" def output_atom(self, symbol: Symbol, atom: int) -> None: \"\"\" Observe shown atoms passed to the solver. Facts do not have an associated program atom. The value of the atom is set to zero. Parameters ---------- symbol : Symbolic The symbolic representation of the atom. atom : int The associated program atom (0 for facts). Returns ------- None \"\"\" def output_term(self, symbol: Symbol, condition: List[int]) -> None: \"\"\" Observe shown terms passed to the solver. Parameters ---------- symbol : Symbol The symbolic representation of the term. condition : List[int] List of program literals forming the condition when to show the term. Returns ------- None \"\"\" def output_csp(self, symbol: Symbol, value: int, condition: List[int]) -> None: \"\"\" Observe shown csp variables passed to the solver. Parameters ---------- symbol : Symbol The symbolic representation of the variable. value : int The integer value of the variable. condition : List[int] List of program literals forming the condition when to show the variable with its value. Returns ------- None \"\"\" def external(self, atom: int, value: TruthValue) -> None: \"\"\" Observe external statements passed to the solver. Parameters ---------- atom : int The external atom in form of a program literal. value : TruthValue The truth value of the external statement. Returns ------- None \"\"\" def assume(self, literals: List[int]) -> None: \"\"\" Observe assumption directives passed to the solver. Parameters ---------- literals : List[int] The program literals to assume (positive literals are true and negative literals false for the next solve call). Returns ------- None \"\"\" def heuristic(self, atom: int, type: HeuristicType, bias: int, priority: int, condition: List[int]) -> None: \"\"\" Observe heuristic directives passed to the solver. Parameters ---------- atom : int The program atom heuristically modified. type : HeuristicType The type of the modification. bias : int A signed integer. priority : int An unsigned integer. condition : List[int] List of program literals. Returns ------- None \"\"\" def acyc_edge(self, node_u: int, node_v: int, condition: List[int]) -> None: \"\"\" Observe edge directives passed to the solver. Parameters ---------- node_u : int The start vertex of the edge (in form of an integer). node_v : int Тhe end vertex of the edge (in form of an integer). condition : List[int] The list of program literals forming th condition under which to add the edge. Returns ------- None \"\"\" def theory_term_number(self, term_id: int, number: int) -> None: \"\"\" Observe numeric theory terms. Parameters ---------- term_id : int The id of the term. number : int The value of the term. Returns ------- None \"\"\" def theory_term_string(self, term_id : int, name : str) -> None: \"\"\" Observe string theory terms. Parameters ---------- term_id : int The id of the term. name : str The string value of the term. Returns ------- None \"\"\" def theory_term_compound(self, term_id: int, name_id_or_type: int, arguments: List[int]) -> None: \"\"\" Observe compound theory terms. Parameters ---------- term_id : int The id of the term. name_id_or_type : int The name or type of the term where - if it is -1, then it is a tuple - if it is -2, then it is a set - if it is -3, then it is a list - otherwise, it is a function and name_id_or_type refers to the id of the name (in form of a string term) arguments : List[int] The arguments of the term in form of a list of term ids. Returns ------- None \"\"\" def theory_element(self, element_id: int, terms: List[int], condition: List[int]) -> None: \"\"\" Observe theory elements. Parameters ---------- element_id : int The id of the element. terms : List[int] The term tuple of the element in form of a list of term ids. condition : List[int] The list of program literals forming the condition. Returns ------- None \"\"\" def theory_atom(self, atom_id_or_zero: int, term_id: int, elements: List[int]) -> None: \"\"\" Observe theory atoms without guard. Parameters ---------- atom_id_or_zero : int The id of the atom or zero for directives. term_id : int The term associated with the atom. elements : List[int] The elements of the atom in form of a list of element ids. Returns ------- None \"\"\" def theory_atom_with_guard(self, atom_id_or_zero: int, term_id: int, elements: List[int], operator_id: int, right_hand_side_id: int) -> None: \"\"\" Observe theory atoms with guard. Parameters ---------- atom_id_or_zero : int The id of the atom or zero for directives. term_id : int The term associated with the atom. elements : List[int] The elements of the atom in form of a list of element ids. operator_id : int The id of the operator (a string term). right_hand_side_id : int The id of the term on the right hand side of the atom. Returns ------- None \"\"\" def end_step(self) -> None: \"\"\" Marks the end of a block of directives passed to the solver. This function is called right before solving starts. Returns ------- None \"\"\" Registers the given propagator with all solvers. Each symbolic or theory atom is uniquely associated with a positive program atom in form of a positive integer. Program literals additionally have a sign to represent default negation. Furthermore, there are non-zero integer solver literals. There is a surjective mapping from program atoms to solver literals. All methods called during propagation use solver literals whereas and return program literals. The function can be used to map program literals or condition ids to solver literals. A propagator should be a class of the form below. Not all functions have to be implemented and can be omitted if not needed. class Propagator: def init(self, init: PropagateInit) -> None: \"\"\" This function is called once before each solving step. It is used to map relevant program literals to solver literals, add watches for solver literals, and initialize the data structures used during propagation. Parameters ---------- init : PropagateInit Object to initialize the propagator. Returns ------- None Notes ----- This is the last point to access theory atoms. Once the search has started, they are no longer accessible. \"\"\" def propagate(self, control: PropagateControl, changes: List[int]) -> None: \"\"\" Can be used to propagate solver literals given a partial assignment. Parameters ---------- control : PropagateControl Object to control propagation. changes : List[int] List of watched solver literals assigned to true. Returns ------- None Notes ----- Called during propagation with a non-empty list of watched solver literals that have been assigned to true since the last call to either propagate, undo, (or the start of the search) - the change set. Only watched solver literals are contained in the change set. Each literal in the change set is true w.r.t. the current Assignment. `PropagateControl.add_clause` can be used to add clauses. If a clause is unit resulting, it can be propagated using `PropagateControl.propagate`. If either of the two methods returns False, the propagate function must return immediately. c = ... if not control.add_clause(c) or not control.propagate(c): return Note that this function can be called from different solving threads. Each thread has its own assignment and id, which can be obtained using `PropagateControl.id`. \"\"\" def undo(self, thread_id: int, assignment: Assignment, changes: List[int]) -> None: \"\"\" Called whenever a solver with the given id undos assignments to watched solver literals. Parameters ---------- thread_id : int The solver thread id. assignment : Assignment Object for inspecting the partial assignment of the solver. changes : List[int] The list of watched solver literals whose assignment is undone. Returns ------- None Notes ----- This function is meant to update assignment dependent state in a propagator but not to modify the current state of the solver. \"\"\" def check(self, control: PropagateControl) -> None: \"\"\" This function is similar to propagate but is called without a change set on propagation fixpoints. When exactly this function is called, can be configured using the @ref PropagateInit.check_mode property. Parameters ---------- control : PropagateControl Object to control propagation. Returns ------- None Notes ----- This function is called even if no watches have been added. \"\"\" def decide(self, thread_id: int, assignment: Assignment, fallback: int) -> int: \"\"\" This function allows a propagator to implement domain-specific heuristics. It is called whenever propagation reaches a fixed point. Parameters ---------- thread_id : int The solver thread id. assignment : Assignment Object for inspecting the partial assignment of the solver. fallback : int The literal choosen by the solver's heuristic. Returns ------- int Тhe next solver literal to make true. Notes ----- This function should return a free solver literal that is to be assigned true. In case multiple propagators are registered, this function can return 0 to let a propagator registered later make a decision. If all propagators return 0, then the fallback literal is used. \"\"\" Release an external atom represented by the given symbol or program literal. This function causes the corresponding atom to become permanently false if there is no definition for the atom in the program. Otherwise, the function has no effect. The symbolic atom or program atom to release. If the program literal is negative, the corresponding atom is released. The following example shows the effect of assigning and releasing and external atom. List of (atom, boolean) tuples or program literals that serve as assumptions for the solve call, e.g., solving under assumptions only admits answer sets that contain atom . Optional callback for intercepting models. A object is passed to the callback. The search can be interruped from the model callback by returning False. Optional callback to update statistics. The step and accumulated statistics are passed as arguments. Optional callback called once search has finished. A also indicating whether the solve call has been intrrupted is passed to the callback. The solve call and the method of the returned handle are non-blocking. The return value depends on the parameters. If either or is true, then a handle is returned. Otherwise, a is returned. If neither nor is set, the function returns a SolveResult right away. Note that in gringo or in clingo with lparse or text output enabled this function just grounds and returns a SolveResult where is true. If this function is used in embedded Python code, you might want to start clingo using the option to disable all output from clingo. Note that asynchronous solving is only available in clingo with thread support enabled. Furthermore, the on_model and on_finish callbacks are called from another thread. To ensure that the methods can be called, make sure to not use any functions that block Python's GIL indefinitely. This function as well as blocking functions on the release the GIL but are not thread-safe. The following example shows how to intercept models with a callback: The following example shows how to yield models: >>> import clingo >>> ctl = clingo.Control(\"0\") >>> ctl.add(\"p\", [], \"1 { a; b } 1.\") >>> ctl.ground([(\"p\", [])]) >>> with ctl.solve(yield_=True) as handle: ... for m in handle: print(\"Answer: {}\".format(m)) ... handle.get() ... Answer: a Answer: b SAT The following example shows how to solve asynchronously: >>> import clingo >>> ctl = clingo.Control(\"0\") >>> ctl.add(\"p\", [], \"1 { a; b } 1.\") >>> ctl.ground([(\"p\", [])]) >>> with ctl.solve(on_model=lambda m: print(\"Answer: {}\".format(m)), async_=True) as handle: ... while not handle.wait(0): pass ... handle.get() ... Answer: a Answer: b SAT\n\nProvides access to a model during a solve call and provides a object to provided limited support to influence the running search. The string representation of a model object is similar to the output of models by clingo using the default output. objects cannot be constructed from Python. Instead they are obained during solving (see ). Furthermore, the lifetime of a model object is limited to the scope of the callback it was passed to or until the search for the next model is started. They must not be stored for later use. The following example shows how to store atoms in a model for usage after solving: >>> import clingo >>> ctl = clingo.Control() >>> ctl.add(\"base\", [], \"{a;b}.\") >>> ctl.ground([(\"base\", [])]) >>> ctl.configuration.solve.models=\"0\" >>> models = [] >>> with ctl.solve(yield_=True) as handle: ... for model in handle: ... models.append(model.symbols(atoms=True)) ... >>> sorted(models) [[], [a], [a, b], [b]] Object that allows for controlling the running search. Return the list of integer cost values of the model. The running number of the model. Whether the optimality of the model has been proven. The id of the thread which found the model. Efficiently check if an atom is contained in the model. Whether the given atom is contained in the model. The atom must be represented using a function symbol. Extend a model with the given symbols. The symbols to add to the model. This only has an effect if there is an underlying clingo application, which will print the added symbols. Check if the given program literal is true. Whether the given program literal is true. Return the list of atoms, terms, or CSP assignments in the model. Select all atoms in the model (independent of statements). Select all terms displayed with statements in the model. Select all atoms and terms as outputted by clingo. Return the complement of the answer set w.r.t. to the atoms known to the grounder. (Does not affect csp assignments.) Atoms are represented using functions ( objects), and CSP assignments are represented using functions with name where the first argument is the name of the CSP variable and the second its value."
    },
    {
        "link": "https://cs.cmu.edu/~cmartens/asp-notes.pdf",
        "document": ""
    },
    {
        "link": "http://wp.doc.ic.ac.uk/arusso/wp-content/uploads/sites/47/2015/01/clingo_guide.pdf",
        "document": ""
    },
    {
        "link": "https://cs.utexas.edu/~vl/teaching/378/pwc.pdf",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/64725693/how-do-i-encode-this-in-answer-set-programming",
        "document": "A simple 3 Step solving approach is the following:\n• generate what you want as a result, but leave the program a choice\n• give rules which solutions do not apply\n\ngenerate possible outcomes. Think of it in simple words: For every argument I choose it or not.\n\n The may or may not part can be solved with a subsum .\n\nor even simpler: I choose a subsum from the arguments\n\nLets check the solutions with Potassco and , resoning mode :\n\nAll combinations are found. Time to remove the wrong stuff. Again: think of it in simple words: It is not possible that I choose two arguments where one attacks the other. (If the head is left open, this is read a False.)\n\nNow check it again:\n\nNow we need to make sure every not choosen argument is attacked by a at least one choosen element:\n\nReads: For every argument , which is not choosen, the number of choosen arguments which attack it, is at least one.\n\nSince the contraints are normally formulated with an empty head, lets reformulate the last rule:\n\nReads: There is no argument , which is not choosen and has maximum 0 choosen arguments, which attack . It gives the same output."
    },
    {
        "link": "https://personal.utdallas.edu/~gupta/courses/lpug/asphw.pdf",
        "document": ""
    }
]