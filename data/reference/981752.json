[
    {
        "link": "https://nextjs.org/docs/app/api-reference/functions/cookies",
        "document": "is an async function that allows you to read the HTTP incoming request cookies in Server Components, and read/write outgoing request cookies in Server Actions or Route Handlers.\n\nThe following methods are available:\n\nWhen setting a cookie, the following properties from the object are supported:\n\nThe only option with a default value is .\n\nTo learn more about these options, see the MDN docs .\n‚Ä¢ is an asynchronous function that returns a promise. You must use or React's function to access cookies.\n‚Ä¢ In version 14 and earlier, was a synchronous function. To help with backwards compatibility, you can still access it synchronously in Next.js 15, but this behavior will be deprecated in the future.\n‚Ä¢ is a Dynamic API whose returned values cannot be known ahead of time. Using it in a layout or page will opt a route into dynamic rendering.\n‚Ä¢ The method can only be called:\n‚Ä¢ If it belongs to the same domain from which is called. For wildcard domains, the specific subdomain must be an exact match. Additionally, the code must be executed on the same protocol (HTTP or HTTPS) as the cookie you want to delete.\n‚Ä¢ HTTP does not allow setting cookies after streaming starts, so you must use in a Server Action or Route Handler.\n\nWhen working with cookies in Server Components, it's important to understand that cookies are fundamentally a client-side storage mechanism:\n‚Ä¢ Reading cookies works in Server Components because you're accessing the cookie data that the client's browser sends to the server in the HTTP request headers.\n‚Ä¢ Setting cookies cannot be done directly in a Server Component, even when using a Route Handler or Server Action. This is because cookies are actually stored by the browser, not the server.\n\nThe server can only send instructions (via headers) to tell the browser to store cookies - the actual storage happens on the client side. This is why cookie operations that modify state ( , , ) must be performed in a Route Handler or Server Action where the response headers can be properly set.\n\nYou can use the method to get a single cookie:\n\nYou can use the method to get all cookies with a matching name. If is unspecified, it returns all the available cookies.\n\nYou can use the method in a Server Action or Route Handler to set a cookie. The object is optional.\n\nYou can use the method to check if a cookie exists:\n\nThere are three ways you can delete a cookie.\n\nSetting a new cookie with the same name and an empty value:\n\nSetting the to 0 will immediately expire a cookie. accepts a value in seconds."
    },
    {
        "link": "https://stackoverflow.com/questions/77396564/setting-a-cookie-in-nextjs-14",
        "document": "I have this nextjs app where I'm trying to setup my authentication/authorization system. I have a refresh token (long duration) which i store in a cookie, and i have also an access token (short duration) in the cookies (at first, I wanted to store my access token as a header, but, setting that header up in server components and the client side got me crying for almost a week since it is impossible.)\n\nSo, if my access-token cookie expires, I need to call my api using this endpoint ( ) that generates the new token and sets the cookie, bu, if I call this endpoint in a server component, the cookie won't be set in my browser, and I understand that since a server component is running on the server side and not on client side.\n\nSo I tried to set the cookie in my next.js app. When i call the same endpoint, I return the access token and set it using , but it didn't work since server components can not have side effects for cache and design purposes (and things of that nature).\n\nThen i go to the docs, where they say that if i want to set a cookie, I need a server action or a route handler, and this is what I did.\n\nServer action (/app/action.ts) (this is the first fn that runs in my server component because i need to do this types of operations before streaming starts):\n\nThis also didn't work, and i got an error that says.\n\nThen I tried to use an API route handler (/app/api/set-cookie):\n\nThat didn't work as well.\n\nIt's been a week for me trying to setup a normal auth system for my app, and I've changed things about my system so that i can use nextjs, but I'm having problems again, how am i supposed to set my cookie now? Should I redirect to another page with mark and set the cookie then redirect here to my page with the server component? That work around sounds horrible, and I don't think it'll create a good user experience."
    },
    {
        "link": "https://propelauth.com/post/cookies-in-next-js",
        "document": "Cookies are a fundamental aspect of web development. You can use them for a wide array of tasks, from user authentication and session management to tracking user preferences and storing temporary data.\n\nAs Next.js has grown in complexity, it means there are a number of different ways to use cookies, each with their own caveats. You can read them in server components in the App Router, but you can‚Äôt modify them. You can set them in using the Pages Router and make them so they can‚Äôt be read from Javascript. You can use middleware to set them, but, currently, you can‚Äôt easily forward them from your middleware to your downstream routes.\n\nIt can be a lot, but in this guide, we‚Äôll walk through all the different ways to use cookies in Next.js.\n\nIn general, cookies within the Pages Router are pretty straightforward.\n\nFor this section, we‚Äôre going to just be talking about reading/writing cookies on the server. For more on reading/writing cookies in the browser, see the section further down.\n\nis a function that you can export from your pages that will be called server-side before the page renders. Because it runs on the server, you can use it to get or set HttpOnly cookies.\n\nLet‚Äôs look at a really simple example, like displaying a different message the first time a user visits a page vs subsequent times. If the cookie isn‚Äôt present, we‚Äôll assume this is their first time visiting the site and we‚Äôll set it for future requests. If it is present, we know they‚Äôve been here before.\n\nWe‚Äôll be using this example for the rest of the post, and while it‚Äôs not necessarily the best use case for cookies, its easy to understand and can be extrapolated to better uses for cookies.\n\nThe context parameter contains everything you need. To read the cookie, we used , which is a string ‚áí string map of the cookie‚Äôs name to its value. To write the cookie, we used to set a header with our cookie string.\n\nThe string is a valid cookie, but there‚Äôs a lot more that we can set. For example, the string is still a cookie with the name and the value , but it also will expire after 10 minutes (Max-Age), is only accessible on HTTPS sites/localhost (Secure), and is only accessible from the server (HttpOnly).\n\nYou don‚Äôt need to construct this string manually, you can use a library like cookie to do it for you:\n\nSetting cookies within API Routes is just as simple. If we wanted to take our same welcome message and instead turn it into an API, we can do this by making an API Route in\n\nThe code should look basically the same. When you visit http://localhost:3000/api/message for the first time after clearing your cookies, you‚Äôll see ‚ÄúWelcome!‚Äù and every subsequent time, you‚Äôll see ‚ÄúWelcome back!‚Äù\n\nI should also point out that if you are using API Routes, you should check that the HTTP method is appropriate, but I wanted to keep this focused on just the cookie code.\n\nAnother quick aside - careful how you set multiple cookies\n\nIf you have an endpoint where you want to set more than one cookie at a time, you might be tempted to do this:\n\nBut this actually doesn‚Äôt work as the second call overwrites the full header. Instead, you‚Äôll want to do this:\n\nwhich will set both cookies in the same response.\n\nThe App Router introduced a function that makes it easier to get and set cookies, but there are some gotchas to be aware of.\n\nRoute Handlers in the App Router are analogous to API Routes in the Pages Router. If we rewrite our example from above, but this time place it in\n\nAnd this is basically the same thing we had before. Note that we are specifically taking in instead of as it adds the field.\n\nIf we did want to specify additional cookie options, we no longer need to use an extra library, the call takes them in as options:\n\nAnd while all of this works, we can also use the cookies function from :\n\nThese two are basically identical (in the past there was a subtle difference around dynamic routing as highlighted by this Github issue, but I believe that issue was fixed), so you can choose whichever style you prefer.\n\nReact Server Components (RSC) let you write React components that are rendered on the server. Let‚Äôs try rewriting the same welcome message logic in a server component\n\nAnd we‚Äôll set it up in a page,\n\nThis looks basically the same as everything else we‚Äôve done, but when we go to http://localhost:3000/message we are greeted with this error:\n\nUltimately, what this means is that we cannot support this behavior with just Server Components. We need to use either an API call that sets the cookie, set the cookie in JS in the browser, use Server Actions, or we can use middleware, which we‚Äôll cover next.\n\nNext.js also supports middleware, which is similar to middleware in basically every other framework. You can see and modify the incoming requests and you can also see and modify the outgoing responses.\n\nLet‚Äôs revisit our last example:\n\nAnd let‚Äôs get it to work now using middleware. We‚Äôll set up our middleware to just handle the single route :\n\nAnd now it works like all the examples before. The full flow of what‚Äôs going on is:\n‚Ä¢ The middleware runs and calls indicating that Next should continue with the request.\n‚Ä¢ The Message component renders, checking if the cookie had been set and returning the correct message.\n‚Ä¢ The middleware continues running and sets a cookie on the response before it is returned to the user.\n\nYou can take this further by conditionally setting the cookie based on the response. In a more complicated example, you might want to check to make sure you only set the cookie on successful responses.\n\nThis approach is useful either for augmenting server components, or sharing your cookie logic across multiple routes/pages at the same time.\n\nWe‚Äôve seen that setting a cookie on the response is pretty straightforward in middleware, but what if we want to modify the cookie before the underlying page/route loads?\n\nThis pattern is very common in use cases like authentication, where you want to refresh a token and have all the downstream server components and routes see the updated token.\n\nIf we clear our cookies, and change our middleware to this:\n\nwhat would you expect it to display?\n\nIf you said ‚ÄúIt should always display ‚ÄòWelcome back!‚Äô because the request always has the cookie set‚Äù - that‚Äôs an incredibly reasonable take, but it‚Äôs unfortunately wrong. Modifying the request in middleware doesn‚Äôt impact the request anywhere else.\n\nWhat we have to do is‚Ä¶ a little involved. Right now, Next.js specifically allows you to pass down new headers, like so:\n\nSo one approach we can take is to grab and modify the header:\n\nAnd now, the user will always see the ‚ÄúWelcome back!‚Äù message since the middleware is always passing along a request with a cookie set.\n\nIf you are thinking that you don‚Äôt really love the idea of parsing and re-serializing all the cookies, just so the middleware can update the request, for one, I agree. For two, there is a slightly simpler approach - just make your own header.\n\nIn your route/component, you can do something like\n\nIn your middleware, you can then just set that specific header:\n\nAnd while all of this is‚Ä¶ fine, it‚Äôs not necessarily ideal. Hopefully this is something that gets better support within Next.js in the future.\n\nServer Actions are now stable in Next 14. They allow you to do things like, say, write SQL queries directly in your components.\n\nMost commonly, you‚Äôll see them triggered by an action, like submitting a form. Our same example, using Server Actions, looks like this:\n\nThis provides another option for us to use to manage cookies, as Server Actions will run on the server but can be called from either client or server components.\n\nI‚Äôd be hesitant to call this a complete guide without mentioning that cookies can be deleted as well. For functions like , there is a function that will do all the work for you. If you are manually specifying the cookie, you can delete by setting an empty value along with an expiration in the past.\n\nUp until now, we‚Äôve exclusively talked about setting/reading cookies on the server. We‚Äôve even seen that you can make a cookie - meaning your browser will enforce that it is inaccessible to javascript (e.g. or libraries like react-cookie). This is beneficial for any sensitive cookies, as it can mitigate the effect of an XSS attack.\n\nIn practice, if you are making a non-HttpOnly cookie, it‚Äôs worth asking if there‚Äôs a better way to do things. For example, if you want to store some information in the browser, another option is localStorage. localStorage can store more data and isn‚Äôt sent along on every request.\n\nIf you do want to use client-side cookies, libraries like react-cookie or universal-cookie can provide a way nicer experience. It means you can write familiar code like:"
    },
    {
        "link": "https://reddit.com/r/nextjs/comments/1e2ftfe/setting_and_deleting_cookies_in_nextjs_14_app",
        "document": "I'm facing a challenge in managing HTTP-only cookies for authentication in a Next.js 14 project with a Django backend. My Django app uses LinkedIn OAuth for authentication and sets JWT access and refresh tokens as cookies. However, I'm having trouble manipulating these cookies when they need to be refreshed or deleted on the frontend side.\n\nAfter a successful login, the backend issues the tokens, sets them as cookies, and redirects to the route, which is specific to each user.\n\nWhen the user is redirected to the dashboard, server-side API calls are made to fetch user details. I use the cookies module from next/headers to access the cookies, but I encounter issues when the access token expires. I have tried to refresh the tokens and manage cookie operations in a route handler (/api/cookie-handle) using NextResponse from next/server. (As its not possible to use set() or delete() in RSC ) .\n\nUnfortunately, neither setting cookies with nor deleting them has worked. I also tried the library with no success.\n\nHere are my code snippets :\n\nIn pages directory I used nookies in getServerSideProps as well as in API routes to set and delete cookies using nookies library. But in app router I am not able to figure out how to do it\n\nThe main challenge is setting and deleting HTTP-only cookies on the server side in Next.js 14. I am looking for advice on how to properly handle these operations, particularly in scenarios where tokens need refreshing or when redirecting users back to the landing page due to expired tokens. Any insights, code samples, or guidance on best practices for cookie management in Next.js, especially with external API interactions, would be greatly appreciated."
    },
    {
        "link": "https://prismic.io/blog/nextjs-cookies",
        "document": "Before we jump into the post and explore the benefits and drawbacks of cookies, what are they? Cookies are small pieces of data that are stored on a user‚Äôs device by their web browser after they visit a website. They can serve multiple purposes but they‚Äôre often used for customization and personalization, session management as well as tracking and analytics, and powering targeted advertising. In short, cookies are powerful, and they empower us with great functionality, but they also have their downsides, as we‚Äôll explore more in the next section.\n\nPros and cons of cookies on the web One of the most prominent benefits of cookies is their ability to allow us to easily offer custom experiences to users by remembering their preferences and selections for future visits, ensuring they have a consistent experience every time they visit. This is exactly what we‚Äôre going to be using cookies for in our example project later on! Unfortunately, though, this benefit can quite easily be flipped into a major issue. This is because while cookies can be used for customization to help improve the UX of a website, they can also be used for tracking. In fact, according to this article, tracking cookies are the most common type of cookie in use today which raises a lot of privacy concerns. The proliferation of cookies being used for tracking is one of the driving factors that led to the creation of privacy-focused laws like GDPR in the EU, which now mandate things like opt-in consent for cookies and tracking. Finally, if we step away from the customization and tracking side of cookies, they do have other uses too. One of the largest uses for cookies is in session management and storage, which is exactly what tools like Auth.js and Iron Session leverage to allow developers to implement authentication into their apps without needing a standalone database. However, if you are using cookies for session management, you do need to be aware of some potential security risks if the cookies are not implemented correctly, such as cross-site scripting (XSS), cross-site request forgery (CSRF), and session hijacking attacks.\n\nCookies can be created and consumed on both client devices and servers, but regardless of where they‚Äôre created, they‚Äôre always stored in the user‚Äôs browser. Because cookies are always stored in the user‚Äôs browser, they can be directly accessed by code running on the client with only one notable exception, which is httpOnly cookies. httpOnly cookies prevent client-side operations from interacting with them, limiting them to being consumable only on the server. This reduces the chance of falling prey to attacks like cross-site scripting (XSS).\n\nHow to handle cookies in Next.js App Router projects Now that we‚Äôve looked into what cookies are, their pros and cons, as well as the two types of cookies, let‚Äôs dive into our tutorial and how we can handle cookies in a Next.js App Router project. So, as mentioned earlier, we‚Äôre going to be building a small example project that allows us to switch between themes using cookies to store the user‚Äôs preference. In this tutorial, we‚Äôre going to make use of the Next.js App Router, the package (pre-installed with Next.js), and Tailwind CSS for styling. To get started with this project, create a new Next.js project by running the command . For the purposes of this tutorial, we'll use all the default configurations. After creating your new project, there are a couple of housekeeping changes we need to make before we can start implementing the cookies. The first is we need to update our file to add to the top of the config to enable us to manually switch between dark and light styles. This way we can add the class to the HTML DOM and Tailwind CSS will know to use the selector styles we define. You‚Äôre updated file should look like this.\n\nNow, with the Tailwind CSS config and global styles updated, we can move on to implementing the logic for getting, setting, and deleting cookies and, in response, switching between our light and dark modes. To start with we‚Äôre going to update our file to add in some code to allow us to get a cookie from the browser with the name . Then we‚Äôre going to use the value of that cookie to conditionally set the class we mentioned earlier; this is what will allow us to control if we‚Äôre in dark mode or not. To do this, we‚Äôll use the import from to fetch the value before then returning the HTML of the page. It‚Äôs important to note that the method from needs to be performed in a Server component to work as are designed to run only on the server. To implement this logic on our page, update the file to look like the one below.\n\nIn this code, there are two lines you need to pay attention to. The first is where we fetch the cookie from the incoming request, and the second is where we conditionally add the class to the element. By adding these two lines of code it‚Äôs enough to handle the switching between light and dark mode, but at this point, we have no way of performing the switch between them so let‚Äôs implement that in the next section.\n\nAs mentioned in the last section, we‚Äôre now ready to implement the functionality to handle the switching between light and dark mode as well as setting a theme cookie when one isn‚Äôt present. To do this, we‚Äôll update the file to add a new Server Action to handle the cookie setting. This is worth noting because, like the method, which can only be called in a Server Component, the (and ) methods can only be called in Server Actions or Route Handlers. To add in the logic for setting and updating the cookie, update your page to look like this.\n\nIn this code, we add a new form to the page and make use of Next.js forms to handle the submission and retrieve the value before setting the value of our cookie. If you would like to learn more about Next.js forms, make sure to read our tutorial. We also make use of the method we looked at in the previous section to fetch the current cookie value to conditionally render some UI on the page to inform the user if no cookie is set or what the current value of the cookie is. At this point, if you run in your terminal and visit http://localhost:3000, you should have an application that looks like below. However, at this point, you‚Äôll notice one notable exception: we can‚Äôt unset the theme's current value and return to the default, so let‚Äôs implement that. To add the functionality to allow the user to unset the stored theme value and revert to the default, we just need to implement some logic to allow the user to delete the cookie. This is as simple as adding a new Server Action and a new form to the page, so let‚Äôs do that."
    },
    {
        "link": "https://geeksforgeeks.org/http-cookies-in-node-js",
        "document": "Cookies are small data that are stored on a client side and sent to the client along with server requests. Cookies have various functionality, they can be used for maintaining sessions and adding user-specific features in your web app. For this, we will use cookie-parser module of npm which provides middleware for parsing of cookies.\n\n First set your directory of the command prompt to root folder of the project and run the following command:\n\nThis will ask you details about your app and finally will create a package.json file.\n\n After that run the following command and it will install the required module and add them in your package.json file\n\npackage.json file looks like this :\n\n\n\nAfter that we will setup basic express app by writing following code in our app.js file in root directory .\n\nAfter that if we run the command\n\nIt will start our server on port 3000 and if go to the url: localhost:3000, we will get a page showing the message :\n\nHere is screenshot of localhost:3000 page after starting the server :\n\n\n\nSo until now we have successfully set up our express app now let‚Äôs start with cookies.\n\nFor cookies first, we need to import the module in our app.js file and use it like other middlewares.\n\nLet‚Äôs say we have a user and we want to add that user data in the cookie then we have to add that cookie to the response using the following code :\n\nThis can be explained by the following example :\n\nSo if we restart our server and make a get request to the route: localhost:3000/getuser before setting the cookies it is as follows :\n\n\n\nAfter making a request to localhost:3000/setuser it will add user data to cookie and gives output as follows :\n\n\n\nNow if we again make a request to localhost:3000/getuser as this route is iterating user data from cookies using req.cookies so output will be as follows :\n\n \n\n If we have multiple objects pushed in cookies then we can access specific cookie using req.cookie.cookie_name .\n\nAdding Cookie with expiration Time\n\n We can add a cookie with some expiration time i.e. after that time cookies will be destroyed automatically. For this, we need to pass an extra property to the res.cookie object while setting the cookies.\n\n It can be done by using any of the two ways :\n\nDestroy the cookies :\n\n We can destroy cookies using following code :\n\nNow let us make a logout route which will destroy user data from the cookie. Now our app.js looks like :\n\nFor destroying the cookie make get request to following link: user logged out[/caption]\n\nTo check whether cookies are destroyed or not make a get request to localhost:3000/getuserand you will get an empty user cookie object.\n\n\n\nThis is about basic use of HTTP cookies using cookie-parser middleware. Cookies can be used in many ways like maintaining sessions and providing each user a different view of the website based on their previous transactions on the website."
    },
    {
        "link": "https://npmjs.com/package/cookie",
        "document": "Parse a HTTP header string and returning an object of all cookie name-value pairs. The argument is the string representing a header value and is an optional object containing additional parsing options.\n\naccepts these properties in the options object.\n\nSpecifies a function that will be used to decode a cookie-value. Since the value of a cookie has a limited character set (and must be a simple string), this function can be used to decode a previously-encoded cookie value into a JavaScript string.\n\nThe default function is the global , wrapped in a . If an error is thrown it will return the cookie's original value. If you provide your own encode/decode scheme you must ensure errors are appropriately handled.\n\nSerialize a cookie name-value pair into a header string. The argument is the name for the cookie, the argument is the value to set the cookie to, and the argument is an optional object containing additional serialization options.\n\naccepts these properties in the options object.\n\nSpecifies a function that will be used to encode a cookie-value. Since value of a cookie has a limited character set (and must be a simple string), this function can be used to encode a value into a string suited for a cookie's value, and should mirror when parsing.\n\nThe default function is the global .\n\nSpecifies the (in seconds) to be the value for the attribute.\n\nThe cookie storage model specification states that if both and are set, then takes precedence, but it is possible not all clients by obey this, so if both are set, they should point to the same date and time.\n\nSpecifies the object to be the value for the attribute. When no expiration is set clients consider this a \"non-persistent cookie\" and delete it the current session is over.\n\nThe cookie storage model specification states that if both and are set, then takes precedence, but it is possible not all clients by obey this, so if both are set, they should point to the same date and time.\n\nSpecifies the value for the attribute. When no domain is set clients consider the cookie to apply to the current domain only.\n\nSpecifies the value for the attribute. When no path is set, the path is considered the \"default path\".\n\nEnables the attribute. When enabled, clients will not allow client-side JavaScript to see the cookie in .\n\nEnables the attribute. When enabled, clients will only send the cookie back if the browser has a HTTPS connection.\n\nEnables the attribute. When enabled, clients will only send the cookie back when the current domain and top-level domain matches.\n\nThis is an attribute that has not yet been fully standardized, and may change in the future. This also means clients may ignore this attribute until they understand it. More information about can be found in the proposal.\n\nSpecifies the value for the attribute.\n‚Ä¢ will set the attribute to .\n‚Ä¢ will set the attribute to , the default priority when not set.\n‚Ä¢ will set the attribute to .\n\nMore information about priority levels can be found in the specification.\n\nSpecifies the value for the attribute.\n‚Ä¢ will set the attribute to for strict same site enforcement.\n‚Ä¢ will set the attribute to for lax same site enforcement.\n‚Ä¢ will set the attribute to for an explicit cross-site cookie.\n‚Ä¢ will set the attribute to for strict same site enforcement.\n\nMore information about enforcement levels can be found in the specification.\n\nThe following example uses this module in conjunction with the Node.js core HTTP server to prompt a user for their name and display it back on future visits."
    },
    {
        "link": "https://github.com/js-cookie/js-cookie",
        "document": "üëâüëâ If you're viewing this at https://github.com/js-cookie/js-cookie, you're reading the documentation for the main branch. View documentation for the latest release. üëàüëà\n\nJavaScript Cookie supports npm under the name .\n\nThe npm package has a field pointing to an ES module variant of the library, mainly to provide support for ES module aware bundlers, whereas its field points to an UMD module for full backward compatibility.\n\nNot all browsers support ES modules natively yet. For this reason the npm package/release provides both the ES and UMD module variant and you may want to include the ES module along with the UMD fallback to account for this:\n\nCreate a cookie that expires 7 days from now, valid across the entire site:\n\nCreate an expiring cookie, valid to the path of the current page:\n\nNote: It is not possible to read a particular cookie by passing one of the cookie attributes (which may or may not have been used when writing the cookie in question):\n\nThe cookie with the name will only be available on if it's visible from where the code is called; the domain and/or path attribute will not have an effect when reading.\n\nDelete a cookie valid to the path of the current page:\n\nIMPORTANT! When deleting a cookie and you're not relying on the default attributes, you must pass the exact same , , and attributes that were used to set the cookie:\n\nNote: Removing a nonexistent cookie neither raises any exception nor returns any value.\n\nIf there is any danger of a conflict with the namespace , the method will allow you to define a new namespace and preserve the original one. This is especially useful when running the script on third party sites e.g. as part of a widget or SDK.\n\nNote: The method is not necessary when using AMD or CommonJS, thus it is not exposed in those environments.\n\nThis project is RFC 6265 compliant. All special characters that are not allowed in the cookie-name or cookie-value are encoded with each one's UTF-8 Hex equivalent using percent-encoding. The only character in cookie-name or cookie-value that is allowed and still encoded is the percent character, it is escaped in order to interpret percent input as literal. Please note that the default encoding/decoding strategy is meant to be interoperable only between cookies that are read/written by js-cookie. To override the default encoding/decoding strategy you need to use a converter.\n\nNote: According to RFC 6265, your cookies may get deleted if they are too big or there are too many cookies in the same domain, more details here.\n\nCookie attribute defaults can be set globally by creating an instance of the api via , or individually for each call to by passing a plain object as the last argument. Per-call attributes override the default attributes.\n\nDefine when the cookie will be removed. Value must be a which will be interpreted as days from time of creation or a instance. If omitted, the cookie becomes a session cookie.\n\nTo create a cookie that expires in less than a day, you can check the FAQ on the Wiki.\n\nDefault: Cookie is removed when the user closes the browser.\n\nA indicating the path where the cookie is visible.\n\nThis means one cannot set a path using in case such pathname contains a filename like so: (or at least, such cookie cannot be read correctly).\n\nIn fact, you should never allow untrusted input to set the cookie attributes or you might be exposed to a XSS attack.\n\nA indicating a valid domain where the cookie should be visible. The cookie will also be visible to all subdomains.\n\nDefault: Cookie is visible only to the domain or subdomain of the page where the cookie was created, except for Internet Explorer (see below).\n\nAssuming a cookie that is being created on :\n\nThis means that if you omit the attribute, it will be visible for a subdomain in IE.\n\nEither or , indicating if the cookie transmission requires a secure protocol (https).\n\nA , allowing to control whether the browser is sending a cookie along with cross-site requests.\n\nNote that more recent browsers are making \"Lax\" the default value even without specifiying anything here.\n\nCreate a new instance of the api that overrides the default decoding implementation. All get methods that rely in a proper decoding to work, such as and , will run the given converter for each cookie. The returned value will be used as the cookie value.\n\nExample from reading one of the cookies that can only be decoded using the function:\n\nCreate a new instance of the api that overrides the default encoding implementation:\n\nReleasing should be done via the GitHub Actions workflow, so that published packages on npmjs.com have package provenance.\n\nGitHub releases are created as a draft and need to be published manually! (This is so we are able to craft suitable release notes before publishing.)\n\nMany thanks to BrowserStack for providing unlimited browser testing free of cost."
    },
    {
        "link": "https://stackoverflow.com/questions/27978868/destroy-cookie-nodejs",
        "document": "I am using Cookies module for setting cookie. Here is following my code:\n\nBut in documentation I haven't found how to destroy this cookie.\n\nAny suggestion would be appreciated."
    },
    {
        "link": "https://nodejs.org/api/http.html",
        "document": "This module, containing both a client and server, can be imported via (CommonJS) or (ES module).\n\nThe HTTP interfaces in Node.js are designed to support many features of the protocol which have been traditionally difficult to use. In particular, large, possibly chunk-encoded, messages. The interface is careful to never buffer entire requests or responses, so the user is able to stream data.\n\nHTTP message headers are represented by an object like this:\n\nKeys are lowercased. Values are not modified.\n\nIn order to support the full spectrum of possible HTTP applications, the Node.js HTTP API is very low-level. It deals with stream handling and message parsing only. It parses a message into headers and body but it does not parse the actual headers or the body.\n\nSee for details on how duplicate headers are handled.\n\nThe raw headers as they were received are retained in the property, which is an array of . For example, the previous message header object might have a list like the following:\n\nAn is responsible for managing connection persistence and reuse for HTTP clients. It maintains a queue of pending requests for a given host and port, reusing a single socket connection for each until the queue is empty, at which time the socket is either destroyed or put into a pool where it is kept to be used again for requests to the same host and port. Whether it is destroyed or pooled depends on the option. Pooled connections have TCP Keep-Alive enabled for them, but servers may still close idle connections, in which case they will be removed from the pool and a new connection will be made when a new HTTP request is made for that host and port. Servers may also refuse to allow multiple requests over the same connection, in which case the connection will have to be remade for every request and cannot be pooled. The will still make the requests to that server, but each one will occur over a new connection. When a connection is closed by the client or the server, it is removed from the pool. Any unused sockets in the pool will be unrefed so as not to keep the Node.js process running when there are no outstanding requests. (see ). It is good practice, to an instance when it is no longer in use, because unused sockets consume OS resources. Sockets are removed from an agent when the socket emits either a event or an event. When intending to keep one HTTP request open for a long time without keeping it in the agent, something like the following may be done: An agent may also be used for an individual request. By providing as an option to the or functions, a one-time use with default options will be used for the client connection. Change the default scheduling from 'fifo' to 'lifo'. Add option to specify the free socket scheduling strategy.\n‚Ä¢ <Object> Set of configurable options to set on the agent. Can have the following fields:\n‚Ä¢ <boolean> Keep sockets around even when there are no outstanding requests, so they can be used for future requests without having to reestablish a TCP connection. Not to be confused with the value of the header. The header is always sent when using an agent except when the header is explicitly specified or when the and options are respectively set to and , in which case will be used. Default: .\n‚Ä¢ <number> When using the option, specifies the initial delay for TCP Keep-Alive packets. Ignored when the option is or . Default: .\n‚Ä¢ <number> Maximum number of sockets to allow per host. If the same host opens multiple concurrent connections, each request will use new socket until the value is reached. If the host attempts to open more connections than , the additional requests will enter into a pending request queue, and will enter active connection state when an existing connection terminates. This makes sure there are at most active connections at any point in time, from a given host. Default: .\n‚Ä¢ <number> Maximum number of sockets allowed for all hosts in total. Each request will use a new socket until the maximum is reached. Default: .\n‚Ä¢ <number> Maximum number of sockets per host to leave open in a free state. Only relevant if is set to . Default: .\n‚Ä¢ <string> Scheduling strategy to apply when picking the next free socket to use. It can be or . The main difference between the two scheduling strategies is that selects the most recently used socket, while selects the least recently used socket. In case of a low rate of request per second, the scheduling will lower the risk of picking a socket that might have been closed by the server due to inactivity. In case of a high rate of request per second, the scheduling will maximize the number of open sockets, while the scheduling will keep it as low as possible. Default: .\n‚Ä¢ <number> Socket timeout in milliseconds. This will set the timeout when the socket is created. in are also supported. To configure any of them, a custom instance must be created.\n‚Ä¢ <Object> Options containing connection details. Check for the format of the options Produces a socket/stream to be used for HTTP requests. By default, this function is the same as . However, custom agents may override this method in case greater flexibility is desired. A socket/stream can be supplied in one of two ways: by returning the socket/stream from this function, or by passing the socket/stream to . This method is guaranteed to return an instance of the <net.Socket> class, a subclass of <stream.Duplex>, unless the user specifies a socket type other than <net.Socket>. Called when is detached from a request and could be persisted by the . Default behavior is to: This method can be overridden by a particular subclass. If this method returns a falsy value, the socket will be destroyed instead of persisting it for use with the next request. The argument can be an instance of <net.Socket>, a subclass of <stream.Duplex>. Called when is attached to after being persisted because of the keep-alive options. Default behavior is to: This method can be overridden by a particular subclass. The argument can be an instance of <net.Socket>, a subclass of <stream.Duplex>. Destroy any sockets that are currently in use by the agent. It is usually not necessary to do this. However, if using an agent with enabled, then it is best to explicitly shut down the agent when it is no longer needed. Otherwise, sockets might stay open for quite a long time before the server terminates them. The property now has a prototype. An object which contains arrays of sockets currently awaiting use by the agent when is enabled. Do not modify. Sockets in the list will be automatically destroyed and removed from the array on . The parameter is now optional.\n‚Ä¢ <Object> A set of options providing information for name generation\n‚Ä¢ <string> A domain name or IP address of the server to issue the request to\n‚Ä¢ <string> Local interface to bind for network connections when issuing the request\n‚Ä¢ <integer> Must be 4 or 6 if this doesn't equal . Get a unique name for a set of request options, to determine whether a connection can be reused. For an HTTP agent, this returns or . For an HTTPS agent, the name includes the CA, cert, ciphers, and other HTTPS/TLS-specific options that determine socket reusability. By default set to 256. For agents with enabled, this sets the maximum number of sockets that will be left open in the free state. By default set to . Determines how many concurrent sockets the agent can have open per origin. Origin is the returned value of . By default set to . Determines how many concurrent sockets the agent can have open. Unlike , this parameter applies across all origins. The property now has a prototype. An object which contains queues of requests that have not yet been assigned to sockets. Do not modify. The property now has a prototype. An object which contains arrays of sockets currently in use by the agent. Do not modify.\n\nThis object is created internally and returned from . It represents an in-progress request whose header has already been queued. The header is still mutable using the , , API. The actual header will be sent along with the first data chunk or when calling . To get the response, add a listener for to the request object. will be emitted from the request object when the response headers have been received. The event is executed with one argument which is an instance of . During the event, one can add listeners to the response object; particularly to listen for the event. If no handler is added, then the response will be entirely discarded. However, if a event handler is added, then the data from the response object must be consumed, either by calling whenever there is a event, or by adding a handler, or by calling the method. Until the data is consumed, the event will not fire. Also, until the data is read it will consume memory that can eventually lead to a 'process out of memory' error. For backward compatibility, will only emit if there is an listener registered. Set header to limit the response body size. If is set to , mismatching the header value will result in an being thrown, identified by . value should be in bytes, not characters. Use to determine the length of the body in bytes. - Deprecated. Listen for the event instead. Emitted when the request has been aborted by the client. This event is only emitted on the first call to . Indicates that the request is completed, or its underlying connection was terminated prematurely (before the response completion). Emitted each time a server responds to a request with a method. If this event is not being listened for, clients receiving a method will have their connections closed. This event is guaranteed to be passed an instance of the <net.Socket> class, a subclass of <stream.Duplex>, unless the user specifies a socket type other than <net.Socket>. A client and server pair demonstrating how to listen for the event: Emitted when the server sends a '100 Continue' HTTP response, usually because the request contained 'Expect: 100-continue'. This is an instruction that the client should send the request body. Emitted when the request has been sent. More specifically, this event is emitted when the last segment of the response headers and body have been handed off to the operating system for transmission over the network. It does not imply that the server has received anything yet. Emitted when the server sends a 1xx intermediate response (excluding 101 Upgrade). The listeners of this event will receive an object containing the HTTP version, status code, status message, key-value headers object, and array with the raw header names followed by their respective values. 101 Upgrade statuses do not fire this event due to their break from the traditional HTTP request/response chain, such as web sockets, in-place TLS upgrades, or HTTP 2.0. To be notified of 101 Upgrade notices, listen for the event instead. Emitted when a response is received to this request. This event is emitted only once. This event is guaranteed to be passed an instance of the <net.Socket> class, a subclass of <stream.Duplex>, unless the user specifies a socket type other than <net.Socket>. Emitted when the underlying socket times out from inactivity. This only notifies that the socket has been idle. The request must be destroyed manually. Emitted each time a server responds to a request with an upgrade. If this event is not being listened for and the response status code is 101 Switching Protocols, clients receiving an upgrade header will have their connections closed. This event is guaranteed to be passed an instance of the <net.Socket> class, a subclass of <stream.Duplex>, unless the user specifies a socket type other than <net.Socket>. A client server pair demonstrating how to listen for the event. Marks the request as aborting. Calling this will cause remaining data in the response to be dropped and the socket to be destroyed. The property is no longer a timestamp number. The property will be if the request has been aborted. The parameter can now be a . This method now returns a reference to . Finishes sending the request. If any parts of the body are unsent, it will flush them to the stream. If the request is chunked, this will send the terminating . If is specified, it is equivalent to calling followed by . If is specified, it will be called when the request stream is finished. The function returns for consistency with other Readable streams.\n‚Ä¢ <Error> Optional, an error to emit with event. Destroy the request. Optionally emit an event, and emit a event. Calling this will cause remaining data in the response to be dropped and the socket to be destroyed. See for further details. Is after has been called. See for further details. The property will be if has been called. will automatically be called if the request was initiated via . For efficiency reasons, Node.js normally buffers the request headers until is called or the first chunk of request data is written. It then tries to pack the request headers and data into a single TCP packet. That's usually desired (it saves a TCP round-trip), but not when the first data is not sent until possibly much later. bypasses the optimization and kickstarts the request. Reads out a header on the request. The name is case-insensitive. The type of the return value depends on the arguments provided to . Returns an array containing the unique names of the current outgoing headers. All header names are lowercase. Returns a shallow copy of the current outgoing headers. Since a shallow copy is used, array values may be mutated without additional calls to various header-related http module methods. The keys of the returned object are the header names and the values are the respective header values. All header names are lowercase. The object returned by the method does not prototypically inherit from the JavaScript . This means that typical methods such as , , and others are not defined and will not work. Returns an array containing the unique names of the current outgoing raw headers. Header names are returned with their exact casing being set. Returns if the header identified by is currently set in the outgoing headers. The header name matching is case-insensitive. Limits maximum response headers count. If set to 0, no limit will be applied. Removes a header that's already defined into headers object.\n‚Ä¢ <boolean> Whether the request is send through a reused socket. When sending request through a keep-alive enabled agent, the underlying socket might be reused. But if server closes connection at unfortunate time, client may run into a 'ECONNRESET' error. By marking a request whether it reused socket or not, we can do automatic error retry base on it. Sets a single header value for headers object. If this header already exists in the to-be-sent headers, its value will be replaced. Use an array of strings here to send multiple headers with the same name. Non-string values will be stored without modification. Therefore, may return non-string values. However, the non-string values will be converted to strings for network transmission. When the value is a string an exception will be thrown if it contains characters outside the encoding. If you need to pass UTF-8 characters in the value please encode the value using the RFC 8187 standard. Once a socket is assigned to this request and is connected will be called. Once a socket is assigned to this request and is connected will be called. Consistently set socket timeout only when the socket connects.\n‚Ä¢ <Function> Optional function to be called when a timeout occurs. Same as binding to the event. Once a socket is assigned to this request and is connected will be called. Reference to the underlying socket. Usually users will not want to access this property. In particular, the socket will not emit events because of how the protocol parser attaches to the socket. http ; options = { : , }; req = http. (options); req. (); req. ( , { ip = req. . ; port = req. . ; . ( `Your IP address is and your source port is .` ); }); http = ( ); options = { : , }; req = http. (options); req. (); req. ( , { ip = req. . ; port = req. . ; . ( `Your IP address is and your source port is .` ); }); This property is guaranteed to be an instance of the <net.Socket> class, a subclass of <stream.Duplex>, unless the user specified a socket type other than <net.Socket>. Is after has been called. This property does not indicate whether the data has been flushed, for this use instead. Is if all data has been flushed to the underlying system, immediately before the event is emitted. The parameter can now be a . Sends a chunk of the body. This method can be called multiple times. If no is set, data will automatically be encoded in HTTP Chunked transfer encoding, so that server knows when the data ends. The header is added. Calling is necessary to finish sending the request. The argument is optional and only applies when is a string. Defaults to . The argument is optional and will be called when this chunk of data is flushed, but only if the chunk is non-empty. Returns if the entire data was flushed successfully to the kernel buffer. Returns if all or part of the data was queued in user memory. will be emitted when the buffer is free again. When function is called with empty string or buffer, it does nothing and waits for more input.\n\nEmitted each time a request with an HTTP is received. If this event is not listened for, the server will automatically respond with a as appropriate. Handling this event involves calling if the client should continue to send the request body, or generating an appropriate HTTP response (e.g. 400 Bad Request) if the client should not continue to send the request body. When this event is emitted and handled, the event will not be emitted. Emitted each time a request with an HTTP header is received, where the value is not . If this event is not listened for, the server will automatically respond with a as appropriate. When this event is emitted and handled, the event will not be emitted. The default behavior will return a 431 Request Header Fields Too Large if a HPE_HEADER_OVERFLOW error occurs. The is the current buffer that just parsed. Adding this buffer to the error object of event is to make it possible that developers can log the broken packet. The default action of calling on the will no longer take place if there are listeners attached for . If a client connection emits an event, it will be forwarded here. Listener of this event is responsible for closing/destroying the underlying socket. For example, one may wish to more gracefully close the socket with a custom HTTP response instead of abruptly severing the connection. The socket must be closed or destroyed before the listener ends. This event is guaranteed to be passed an instance of the <net.Socket> class, a subclass of <stream.Duplex>, unless the user specifies a socket type other than <net.Socket>. Default behavior is to try close the socket with a HTTP '400 Bad Request', or a HTTP '431 Request Header Fields Too Large' in the case of a error. If the socket is not writable or headers of the current attached has been sent, it is immediately destroyed. is the object that the error originated from. When the event occurs, there is no or object, so any HTTP response sent, including response headers and payload, must be written directly to the object. Care must be taken to ensure the response is a properly formatted HTTP response message. is an instance of with two extra columns:\n‚Ä¢ : the bytes count of request packet that Node.js may have parsed correctly; In some cases, the client has already received the response and/or the socket has already been destroyed, like in case of errors. Before trying to send data to the socket, it is better to check that it is still writable.\n‚Ä¢ <http.IncomingMessage> Arguments for the HTTP request, as it is in the event\n‚Ä¢ <stream.Duplex> Network socket between the server and client\n‚Ä¢ <Buffer> The first packet of the tunneling stream (may be empty) Emitted each time a client requests an HTTP method. If this event is not listened for, then clients requesting a method will have their connections closed. This event is guaranteed to be passed an instance of the <net.Socket> class, a subclass of <stream.Duplex>, unless the user specifies a socket type other than <net.Socket>. After this event is emitted, the request's socket will not have a event listener, meaning it will need to be bound in order to handle data sent to the server on that socket. This event is emitted when a new TCP stream is established. is typically an object of type . Usually users will not want to access this event. In particular, the socket will not emit events because of how the protocol parser attaches to the socket. The can also be accessed at . This event can also be explicitly emitted by users to inject connections into the HTTP server. In that case, any stream can be passed. If is called here, the timeout will be replaced with when the socket has served a request (if is non-zero). This event is guaranteed to be passed an instance of the <net.Socket> class, a subclass of <stream.Duplex>, unless the user specifies a socket type other than <net.Socket>.\n‚Ä¢ <http.IncomingMessage> Arguments for the HTTP request, as it is in the event\n‚Ä¢ <stream.Duplex> Network socket between the server and client When the number of requests on a socket reaches the threshold of , the server will drop new requests and emit event instead, then send to client. Emitted each time there is a request. There may be multiple requests per connection (in the case of HTTP Keep-Alive connections). Not listening to this event no longer causes the socket to be destroyed if a client sends an Upgrade header.\n‚Ä¢ <http.IncomingMessage> Arguments for the HTTP request, as it is in the event\n‚Ä¢ <stream.Duplex> Network socket between the server and client\n‚Ä¢ <Buffer> The first packet of the upgraded stream (may be empty) Emitted each time a client requests an HTTP upgrade. Listening to this event is optional and clients cannot insist on a protocol change. After this event is emitted, the request's socket will not have a event listener, meaning it will need to be bound in order to handle data sent to the server on that socket. This event is guaranteed to be passed an instance of the <net.Socket> class, a subclass of <stream.Duplex>, unless the user specifies a socket type other than <net.Socket>. Stops the server from accepting new connections and closes all connections connected to this server which are not sending a request or waiting for a response. See . Closes all established HTTP(S) connections connected to this server, including active connections connected to this server which are sending a request or waiting for a response. This does not destroy sockets upgraded to a different protocol, such as WebSocket or HTTP/2. This is a forceful way of closing all connections and should be used with caution. Whenever using this in conjunction with , calling this after is recommended as to avoid race conditions where new connections are created between a call to this and a call to . Closes all connections connected to this server which are not sending a request or waiting for a response. Starting with Node.js 19.0.0, there's no need for calling this method in conjunction with to reap connections. Using it won't cause any harm though, and it can be useful to ensure backwards compatibility for libraries and applications that need to support versions older than 19.0.0. Whenever using this in conjunction with , calling this after is recommended as to avoid race conditions where new connections are created between a call to this and a call to . The default is now set to the minimum between 60000 (60 seconds) or .\n‚Ä¢ <number> Default: The minimum between or . Limit the amount of time the parser will wait to receive the complete HTTP headers. If the timeout expires, the server responds with status 408 without forwarding the request to the request listener and then closes the connection. It must be set to a non-zero value (e.g. 120 seconds) to protect against potential Denial-of-Service attacks in case the server is deployed without a reverse proxy in front. Starts the HTTP server listening for connections. This method is identical to from .\n‚Ä¢ <boolean> Indicates whether or not the server is listening for connections. Limits maximum incoming headers count. If set to 0, no limit will be applied. The default request timeout changed from no timeout to 300s (5 minutes). Sets the timeout value in milliseconds for receiving the entire request from the client. If the timeout expires, the server responds with status 408 without forwarding the request to the request listener and then closes the connection. It must be set to a non-zero value (e.g. 120 seconds) to protect against potential Denial-of-Service attacks in case the server is deployed without a reverse proxy in front. The default timeout changed from 120s to 0 (no timeout). Sets the timeout value for sockets, and emits a event on the Server object, passing the socket as an argument, if a timeout occurs. If there is a event listener on the Server object, then it will be called with the timed-out socket as an argument. By default, the Server does not timeout sockets. However, if a callback is assigned to the Server's event, timeouts must be handled explicitly. The maximum number of requests socket can handle before closing keep alive connection. A value of will disable the limit. When the limit is reached it will set the header value to , but will not actually close the connection, subsequent requests sent after the limit is reached will get as a response. The default timeout changed from 120s to 0 (no timeout). The number of milliseconds of inactivity before a socket is presumed to have timed out. A value of will disable the timeout behavior on incoming connections. The socket timeout logic is set up on connection, so changing this value only affects new connections to the server, not any existing connections. The number of milliseconds of inactivity a server needs to wait for additional incoming data, after it has finished writing the last response, before a socket will be destroyed. If the server receives new data before the keep-alive timeout has fired, it will reset the regular inactivity timeout, i.e., . A value of will disable the keep-alive timeout behavior on incoming connections. A value of makes the http server behave similarly to Node.js versions prior to 8.0.0, which did not have a keep-alive timeout. The socket timeout logic is set up on connection, so changing this value only affects new connections to the server, not any existing connections. Calls and returns a promise that fulfills when the server has closed.\n\nThis object is created internally by an HTTP server, not by the user. It is passed as the second parameter to the event. Indicates that the response is completed, or its underlying connection was terminated prematurely (before the response completion). Emitted when the response has been sent. More specifically, this event is emitted when the last segment of the response headers and body have been handed off to the operating system for transmission over the network. It does not imply that the client has received anything yet. This method adds HTTP trailing headers (a header but at the end of the message) to the response. Trailers will only be emitted if chunked encoding is used for the response; if it is not (e.g. if the request was HTTP/1.0), they will be silently discarded. HTTP requires the header to be sent in order to emit trailers, with a list of the header fields in its value. E.g., Attempting to set a header field name or value that contains invalid characters will result in a being thrown. The parameter can now be a . This method now returns a reference to . This method signals to the server that all of the response headers and body have been sent; that server should consider this message complete. The method, , MUST be called on each response. If is specified, it is similar in effect to calling followed by . If is specified, it will be called when the response stream is finished. The property will be if has been called. Flushes the response headers. See also: . Reads out a header that's already been queued but not sent to the client. The name is case-insensitive. The type of the return value depends on the arguments provided to . Returns an array containing the unique names of the current outgoing headers. All header names are lowercase. Returns a shallow copy of the current outgoing headers. Since a shallow copy is used, array values may be mutated without additional calls to various header-related http module methods. The keys of the returned object are the header names and the values are the respective header values. All header names are lowercase. The object returned by the method does not prototypically inherit from the JavaScript . This means that typical methods such as , , and others are not defined and will not work. Returns if the header identified by is currently set in the outgoing headers. The header name matching is case-insensitive. Boolean (read-only). True if headers were sent, false otherwise. When true, the Date header will be automatically generated and sent in the response if it is not already present in the headers. Defaults to true. This should only be disabled for testing; HTTP requires the Date header in responses. Sets a single header value for implicit headers. If this header already exists in the to-be-sent headers, its value will be replaced. Use an array of strings here to send multiple headers with the same name. Non-string values will be stored without modification. Therefore, may return non-string values. However, the non-string values will be converted to strings for network transmission. The same response object is returned to the caller, to enable call chaining. Attempting to set a header field name or value that contains invalid characters will result in a being thrown. When headers have been set with , they will be merged with any headers passed to , with the headers passed to given precedence. If method is called and this method has not been called, it will directly write the supplied header values onto the network channel without caching internally, and the on the header will not yield the expected result. If progressive population of headers is desired with potential future retrieval and modification, use instead of . Sets the Socket's timeout value to . If a callback is provided, then it is added as a listener on the event on the response object. If no listener is added to the request, the response, or the server, then sockets are destroyed when they time out. If a handler is assigned to the request, the response, or the server's events, timed out sockets must be handled explicitly. Reference to the underlying socket. Usually users will not want to access this property. In particular, the socket will not emit events because of how the protocol parser attaches to the socket. After , the property is nulled. http ; server = http. ( { ip = res. . ; port = res. . ; res. ( `Your IP address is and your source port is .` ); }). ( ); http = ( ); server = http. ( { ip = res. . ; port = res. . ; res. ( `Your IP address is and your source port is .` ); }). ( ); This property is guaranteed to be an instance of the <net.Socket> class, a subclass of <stream.Duplex>, unless the user specified a socket type other than <net.Socket>. When using implicit headers (not calling explicitly), this property controls the status code that will be sent to the client when the headers get flushed. After response header was sent to the client, this property indicates the status code which was sent out. When using implicit headers (not calling explicitly), this property controls the status message that will be sent to the client when the headers get flushed. If this is left as then the standard message for the status code will be used. After response header was sent to the client, this property indicates the status message which was sent out. If set to , Node.js will check whether the header value and the size of the body, in bytes, are equal. Mismatching the header value will result in an being thrown, identified by . Is after has been called. This property does not indicate whether the data has been flushed, for this use instead. Is if all data has been flushed to the underlying system, immediately before the event is emitted. The parameter can now be a . If this method is called and has not been called, it will switch to implicit header mode and flush the implicit headers. This sends a chunk of the response body. This method may be called multiple times to provide successive parts of the body. If is set to true in then writing to the body is not allowed when the request method or response status do not support content. If an attempt is made to write to the body for a HEAD request or as part of a or response, a synchronous with the code is thrown. can be a string or a buffer. If is a string, the second parameter specifies how to encode it into a byte stream. will be called when this chunk of data is flushed. This is the raw HTTP body and has nothing to do with higher-level multi-part body encodings that may be used. The first time is called, it will send the buffered header information and the first chunk of the body to the client. The second time is called, Node.js assumes data will be streamed, and sends the new data separately. That is, the response is buffered up to the first chunk of the body. Returns if the entire data was flushed successfully to the kernel buffer. Returns if all or part of the data was queued in user memory. will be emitted when the buffer is free again. Sends an HTTP/1.1 100 Continue message to the client, indicating that the request body should be sent. See the event on . Allow passing hints as an object. Sends an HTTP/1.1 103 Early Hints message to the client with a Link header, indicating that the user agent can preload/preconnect the linked resources. The is an object containing the values of headers to be sent with early hints message. The optional argument will be called when the response message has been written. Allow passing headers as an array. Return from to allow chaining with . A is thrown if is not a number in the range . Sends a response header to the request. The status code is a 3-digit HTTP status code, like . The last argument, , are the response headers. Optionally one can give a human-readable as the second argument. may be an where the keys and values are in the same list. It is not a list of tuples. So, the even-numbered offsets are key values, and the odd-numbered offsets are the associated values. The array is in the same format as . Returns a reference to the , so that calls can be chained. This method must only be called once on a message and it must be called before is called. If or are called before calling this, the implicit/mutable headers will be calculated and call this function. When headers have been set with , they will be merged with any headers passed to , with the headers passed to given precedence. If this method is called and has not been called, it will directly write the supplied header values onto the network channel without caching internally, and the on the header will not yield the expected result. If progressive population of headers is desired with potential future retrieval and modification, use instead. is read in bytes, not characters. Use to determine the length of the body in bytes. Node.js will check whether and the length of the body which has been transmitted are equal or not. Attempting to set a header field name or value that contains invalid characters will result in a [ ][] being thrown. Sends a HTTP/1.1 102 Processing message to the client, indicating that the request body should be sent.\n\nThe value returns after the incoming data is consumed. The value mirrors that of the socket. An object is created by or and passed as the first argument to the and event respectively. It may be used to access response status, headers, and data. Different from its value which is a subclass of <stream.Duplex>, the itself extends <stream.Readable> and is created separately to parse and emit the incoming HTTP headers and payload, as the underlying socket may be reused multiple times in case of keep-alive. Emitted when the request has been aborted. The close event is now emitted when the request has been completed and not when the underlying socket is closed. Emitted when the request has been completed. The property will be if the request has been aborted. The property will be if a complete HTTP message has been received and successfully parsed. This property is particularly useful as a means of determining if a client or server fully transmitted a message before a connection was terminated: req = http. ({ : , : , : , }, { res. (); res. ( , { (!res. ) . ( 'The connection was terminated while the message was still being sent' ); }); }); The function returns for consistency with other Readable streams. Calls on the socket that received the . If is provided, an event is emitted on the socket and is passed as an argument to any listeners on the event. The option in the and functions ensures that duplicate headers are not discarded, but rather combined using a comma separator, in accordance with RFC 9110 Section 5.3. is now lazily computed using an accessor property on the prototype and is no longer enumerable. Key-value pairs of header names and values. Header names are lower-cased. Duplicates in raw headers are handled in the following ways, depending on the header name:\n‚Ä¢ Duplicates of , , , , , , , , , , , , , , , , , or are discarded. To allow duplicate values of the headers listed above to be joined, use the option in and . See RFC 9110 Section 5.3 for more information.\n‚Ä¢ is always an array. Duplicates are added to the array.\n‚Ä¢ For duplicate headers, the values are joined together with .\n‚Ä¢ For all other headers, the values are joined together with . Similar to , but there is no join logic and the values are always arrays of strings, even for headers received just once. In case of server request, the HTTP version sent by the client. In the case of client response, the HTTP version of the connected-to server. Probably either or . Also is the first integer and is the second. Only valid for request obtained from . The request method as a string. Read only. Examples: , . The raw request/response headers list exactly as they were received. The keys and values are in the same list. It is not a list of tuples. So, the even-numbered offsets are key values, and the odd-numbered offsets are the associated values. Header names are not lowercased, and duplicates are not merged. The raw request/response trailer keys and values exactly as they were received. Only populated at the event. The object associated with the connection. With HTTPS support, use to obtain the client's authentication details. This property is guaranteed to be an instance of the <net.Socket> class, a subclass of <stream.Duplex>, unless the user specified a socket type other than <net.Socket> or internally nulled. Only valid for response obtained from . Only valid for response obtained from . The request/response trailers object. Only populated at the event. Similar to , but there is no join logic and the values are always arrays of strings, even for headers received just once. Only populated at the event. Only valid for request obtained from . Request URL string. This contains only the URL that is present in the actual HTTP request. Take the following request: To parse the URL into its parts: When is and is undefined: Ensure that you set to the server's host name, or consider replacing this part entirely. If using , ensure proper validation is used, as clients may specify a custom header.\n\nThis class serves as the parent class of and . It is an abstract outgoing message from the perspective of the participants of an HTTP transaction. Emitted when the buffer of the message is free again. Emitted when the transmission is finished successfully. Emitted after is called. When the event is emitted, all data has been processed but not necessarily completely flushed. Adds HTTP trailers (headers but at the end of the message) to the message. Trailers will only be emitted if the message is chunked encoded. If not, the trailers will be silently discarded. HTTP requires the header to be sent to emit trailers, with a list of header field names in its value, e.g. Attempting to set a header field name or value that contains invalid characters will result in a being thrown. Append a single header value to the header object. If the value is an array, this is equivalent to calling this method multiple times. If there were no previous values for the header, this is equivalent to calling . Depending of the value of when the client request or the server were created, this will end up in the header being sent multiple times or a single time with values joined using .\n‚Ä¢ <Error> Optional, an error to emit with event Destroys the message. Once a socket is associated with the message and is connected, that socket will be destroyed as well. The parameter can now be a . Finishes the outgoing message. If any parts of the body are unsent, it will flush them to the underlying system. If the message is chunked, it will send the terminating chunk , and send the trailers (if any). If is specified, it is equivalent to calling , followed by . If is provided, it will be called when the message is finished (equivalent to a listener of the event). For efficiency reason, Node.js normally buffers the message headers until is called or the first chunk of message data is written. It then tries to pack the headers and data into a single TCP packet. It is usually desired (it saves a TCP round-trip), but not when the first data is not sent until possibly much later. bypasses the optimization and kickstarts the message. Gets the value of the HTTP header with the given name. If that header is not set, the returned value will be . Returns an array containing the unique names of the current outgoing headers. All names are lowercase. Returns a shallow copy of the current outgoing headers. Since a shallow copy is used, array values may be mutated without additional calls to various header-related HTTP module methods. The keys of the returned object are the header names and the values are the respective header values. All header names are lowercase. The object returned by the method does not prototypically inherit from the JavaScript . This means that typical methods such as , , and others are not defined and will not work. Returns if the header identified by is currently set in the outgoing headers. The header name is case-insensitive. Read-only. if the headers were sent, otherwise . Overrides the method inherited from the legacy class which is the parent class of . Calling this method will throw an because is a write-only stream. Removes a header that is queued for implicit sending. Sets a single header value. If the header already exists in the to-be-sent headers, its value will be replaced. Use an array of strings to send multiple headers with the same name. Sets multiple header values for implicit headers. must be an instance of or , if a header already exists in the to-be-sent headers, its value will be replaced. When headers have been set with , they will be merged with any headers passed to , with the headers passed to given precedence.\n‚Ä¢ <Function> Optional function to be called when a timeout occurs. Same as binding to the event. Once a socket is associated with the message and is connected, will be called with as the first parameter. Reference to the underlying socket. Usually, users will not want to access this property. After calling , this property will be nulled. The number of times has been called. Is if has been called. This property does not indicate whether the data has been flushed. For that purpose, use instead. Is if all data has been flushed to the underlying system. The of the underlying socket if assigned. Otherwise, the default buffer level when starts returning false ( ). The parameter can now be a . Sends a chunk of the body. This method can be called multiple times. The argument is only relevant when is a string. Defaults to . The argument is optional and will be called when this chunk of data is flushed. Returns if the entire data was flushed successfully to the kernel buffer. Returns if all or part of the data was queued in the user memory. The event will be emitted when the buffer is free again.\n\nWhen using a object parsed username and password will now be properly URI decoded. It is possible to abort a request with an AbortSignal. The option is supported now. The option is supported now. The parameter can now be passed along with a separate object. The parameter can be a WHATWG object.\n‚Ä¢ <Object>\n‚Ä¢ <http.Agent> | <boolean> Controls behavior. Possible values:\n‚Ä¢ (default): use for this host and port.\n‚Ä¢ object: explicitly use the passed in .\n‚Ä¢ : causes a new with default values to be used.\n‚Ä¢ <Function> A function that produces a socket/stream to use for the request when the option is not used. This can be used to avoid creating a custom class just to override the default function. See for more details. Any stream is a valid return value.\n‚Ä¢ <number> Default port for the protocol. Default: if an is used, else .\n‚Ä¢ <number> IP address family to use when resolving or . Valid values are or . When unspecified, both IP v4 and v6 will be used.\n‚Ä¢ <string> A domain name or IP address of the server to issue the request to. Default: .\n‚Ä¢ <string> Alias for . To support , will be used if both and are specified.\n‚Ä¢ <boolean> If set to , it will use a HTTP parser with leniency flags enabled. Using the insecure parser should be avoided. See for more information. Default:\n‚Ä¢ <boolean> It joins the field line values of multiple headers in a request with instead of discarding the duplicates. See for more information. Default: .\n‚Ä¢ <number> Optionally overrides the value of (the maximum length of response headers in bytes) for responses received from the server. Default: 16384 (16 KiB).\n‚Ä¢ <string> Request path. Should include query string if any. E.G. . An exception is thrown when the request path contains illegal characters. Currently, only spaces are rejected but that may change in the future. Default: .\n‚Ä¢ <number> Port of remote server. Default: if set, else .\n‚Ä¢ <boolean>: Specifies whether or not to automatically add default headers such as , , , and . If set to then all necessary headers must be added manually. Defaults to .\n‚Ä¢ <boolean>: Specifies whether or not to automatically add the header. If provided, this overrides . Defaults to .\n‚Ä¢ <AbortSignal>: An AbortSignal that may be used to abort an ongoing request.\n‚Ä¢ <string> Unix domain socket. Cannot be used if one of or is specified, as those specify a TCP Socket.\n‚Ä¢ <number>: A number specifying the socket timeout in milliseconds. This will set the timeout before the socket is connected.\n‚Ä¢ <Array> A list of request headers that should be sent only once. If the header's value is an array, the items will be joined using . in are also supported. Node.js maintains several connections per server to make HTTP requests. This function allows one to transparently issue requests. can be a string or a object. If is a string, it is automatically parsed with . If it is a object, it will be automatically converted to an ordinary object. If both and are specified, the objects are merged, with the properties taking precedence. The optional parameter will be added as a one-time listener for the event. returns an instance of the class. The instance is a writable stream. If one needs to upload a file with a POST request, then write to the object. http ; { } ; postData = . ({ : , }); options = { : , : , : , : , : { : , : . (postData), }, }; req = http. (options, { . ( ); . ( ); res. ( ); res. ( , { . ( ); }); res. ( , { . ( 'No more data in response.' ); }); }); req. ( , { . ( ); }); req. (postData); req. (); http = ( ); postData = . ({ : , }); options = { : , : , : , : , : { : , : . (postData), }, }; req = http. (options, { . ( ); . ( ); res. ( ); res. ( , { . ( ); }); res. ( , { . ( 'No more data in response.' ); }); }); req. ( , { . ( ); }); req. (postData); req. (); In the example was called. With one must always call to signify the end of the request - even if there is no data being written to the request body. If any error is encountered during the request (be that with DNS resolution, TCP level errors, or actual HTTP parse errors) an event is emitted on the returned request object. As with all events, if no listeners are registered the error will be thrown. There are a few special headers that should be noted.\n‚Ä¢ Sending a 'Connection: keep-alive' will notify Node.js that the connection to the server should be persisted until the next request.\n‚Ä¢ Sending an 'Expect' header will immediately send the request headers. Usually, when sending 'Expect: 100-continue', both a timeout and a listener for the event should be set. See RFC 2616 Section 8.2.3 for more information.\n‚Ä¢ Sending an Authorization header will override using the option to compute basic authentication. Example using a as : In a successful request, the following events will be emitted in the following order:\n‚Ä¢ \n‚Ä¢ any number of times, on the object ( will not be emitted at all if the response body is empty, for instance, in most redirects) In the case of a connection error, the following events will be emitted: In the case of a premature connection close before the response is received, the following events will be emitted in the following order:\n‚Ä¢ with an error with message and code In the case of a premature connection close after the response is received, the following events will be emitted in the following order:\n‚Ä¢ \n‚Ä¢ any number of times, on the object\n‚Ä¢ on the object with an error with message and code If is called before a socket is assigned, the following events will be emitted in the following order:\n‚Ä¢ with an error with message and code , or the error with which was called If is called before the connection succeeds, the following events will be emitted in the following order:\n‚Ä¢ with an error with message and code , or the error with which was called If is called after the response is received, the following events will be emitted in the following order:\n‚Ä¢ \n‚Ä¢ any number of times, on the object\n‚Ä¢ on the object with an error with message and code , or the error with which was called If is called before a socket is assigned, the following events will be emitted in the following order: If is called before the connection succeeds, the following events will be emitted in the following order:\n‚Ä¢ with an error with message and code If is called after the response is received, the following events will be emitted in the following order:\n‚Ä¢ \n‚Ä¢ any number of times, on the object\n‚Ä¢ on the object with an error with message and code . Setting the option or using the function will not abort the request or do anything besides add a event. Passing an and then calling on the corresponding will behave the same way as calling on the request. Specifically, the event will be emitted with an error with the message , the code and the , if one was provided."
    },
    {
        "link": "https://nextjs.org/docs/app/api-reference/functions/cookies",
        "document": "is an async function that allows you to read the HTTP incoming request cookies in Server Components, and read/write outgoing request cookies in Server Actions or Route Handlers.\n\nThe following methods are available:\n\nWhen setting a cookie, the following properties from the object are supported:\n\nThe only option with a default value is .\n\nTo learn more about these options, see the MDN docs .\n‚Ä¢ is an asynchronous function that returns a promise. You must use or React's function to access cookies.\n‚Ä¢ In version 14 and earlier, was a synchronous function. To help with backwards compatibility, you can still access it synchronously in Next.js 15, but this behavior will be deprecated in the future.\n‚Ä¢ is a Dynamic API whose returned values cannot be known ahead of time. Using it in a layout or page will opt a route into dynamic rendering.\n‚Ä¢ The method can only be called:\n‚Ä¢ If it belongs to the same domain from which is called. For wildcard domains, the specific subdomain must be an exact match. Additionally, the code must be executed on the same protocol (HTTP or HTTPS) as the cookie you want to delete.\n‚Ä¢ HTTP does not allow setting cookies after streaming starts, so you must use in a Server Action or Route Handler.\n\nWhen working with cookies in Server Components, it's important to understand that cookies are fundamentally a client-side storage mechanism:\n‚Ä¢ Reading cookies works in Server Components because you're accessing the cookie data that the client's browser sends to the server in the HTTP request headers.\n‚Ä¢ Setting cookies cannot be done directly in a Server Component, even when using a Route Handler or Server Action. This is because cookies are actually stored by the browser, not the server.\n\nThe server can only send instructions (via headers) to tell the browser to store cookies - the actual storage happens on the client side. This is why cookie operations that modify state ( , , ) must be performed in a Route Handler or Server Action where the response headers can be properly set.\n\nYou can use the method to get a single cookie:\n\nYou can use the method to get all cookies with a matching name. If is unspecified, it returns all the available cookies.\n\nYou can use the method in a Server Action or Route Handler to set a cookie. The object is optional.\n\nYou can use the method to check if a cookie exists:\n\nThere are three ways you can delete a cookie.\n\nSetting a new cookie with the same name and an empty value:\n\nSetting the to 0 will immediately expire a cookie. accepts a value in seconds."
    },
    {
        "link": "https://propelauth.com/post/cookies-in-next-js",
        "document": "Cookies are a fundamental aspect of web development. You can use them for a wide array of tasks, from user authentication and session management to tracking user preferences and storing temporary data.\n\nAs Next.js has grown in complexity, it means there are a number of different ways to use cookies, each with their own caveats. You can read them in server components in the App Router, but you can‚Äôt modify them. You can set them in using the Pages Router and make them so they can‚Äôt be read from Javascript. You can use middleware to set them, but, currently, you can‚Äôt easily forward them from your middleware to your downstream routes.\n\nIt can be a lot, but in this guide, we‚Äôll walk through all the different ways to use cookies in Next.js.\n\nIn general, cookies within the Pages Router are pretty straightforward.\n\nFor this section, we‚Äôre going to just be talking about reading/writing cookies on the server. For more on reading/writing cookies in the browser, see the section further down.\n\nis a function that you can export from your pages that will be called server-side before the page renders. Because it runs on the server, you can use it to get or set HttpOnly cookies.\n\nLet‚Äôs look at a really simple example, like displaying a different message the first time a user visits a page vs subsequent times. If the cookie isn‚Äôt present, we‚Äôll assume this is their first time visiting the site and we‚Äôll set it for future requests. If it is present, we know they‚Äôve been here before.\n\nWe‚Äôll be using this example for the rest of the post, and while it‚Äôs not necessarily the best use case for cookies, its easy to understand and can be extrapolated to better uses for cookies.\n\nThe context parameter contains everything you need. To read the cookie, we used , which is a string ‚áí string map of the cookie‚Äôs name to its value. To write the cookie, we used to set a header with our cookie string.\n\nThe string is a valid cookie, but there‚Äôs a lot more that we can set. For example, the string is still a cookie with the name and the value , but it also will expire after 10 minutes (Max-Age), is only accessible on HTTPS sites/localhost (Secure), and is only accessible from the server (HttpOnly).\n\nYou don‚Äôt need to construct this string manually, you can use a library like cookie to do it for you:\n\nSetting cookies within API Routes is just as simple. If we wanted to take our same welcome message and instead turn it into an API, we can do this by making an API Route in\n\nThe code should look basically the same. When you visit http://localhost:3000/api/message for the first time after clearing your cookies, you‚Äôll see ‚ÄúWelcome!‚Äù and every subsequent time, you‚Äôll see ‚ÄúWelcome back!‚Äù\n\nI should also point out that if you are using API Routes, you should check that the HTTP method is appropriate, but I wanted to keep this focused on just the cookie code.\n\nAnother quick aside - careful how you set multiple cookies\n\nIf you have an endpoint where you want to set more than one cookie at a time, you might be tempted to do this:\n\nBut this actually doesn‚Äôt work as the second call overwrites the full header. Instead, you‚Äôll want to do this:\n\nwhich will set both cookies in the same response.\n\nThe App Router introduced a function that makes it easier to get and set cookies, but there are some gotchas to be aware of.\n\nRoute Handlers in the App Router are analogous to API Routes in the Pages Router. If we rewrite our example from above, but this time place it in\n\nAnd this is basically the same thing we had before. Note that we are specifically taking in instead of as it adds the field.\n\nIf we did want to specify additional cookie options, we no longer need to use an extra library, the call takes them in as options:\n\nAnd while all of this works, we can also use the cookies function from :\n\nThese two are basically identical (in the past there was a subtle difference around dynamic routing as highlighted by this Github issue, but I believe that issue was fixed), so you can choose whichever style you prefer.\n\nReact Server Components (RSC) let you write React components that are rendered on the server. Let‚Äôs try rewriting the same welcome message logic in a server component\n\nAnd we‚Äôll set it up in a page,\n\nThis looks basically the same as everything else we‚Äôve done, but when we go to http://localhost:3000/message we are greeted with this error:\n\nUltimately, what this means is that we cannot support this behavior with just Server Components. We need to use either an API call that sets the cookie, set the cookie in JS in the browser, use Server Actions, or we can use middleware, which we‚Äôll cover next.\n\nNext.js also supports middleware, which is similar to middleware in basically every other framework. You can see and modify the incoming requests and you can also see and modify the outgoing responses.\n\nLet‚Äôs revisit our last example:\n\nAnd let‚Äôs get it to work now using middleware. We‚Äôll set up our middleware to just handle the single route :\n\nAnd now it works like all the examples before. The full flow of what‚Äôs going on is:\n‚Ä¢ The middleware runs and calls indicating that Next should continue with the request.\n‚Ä¢ The Message component renders, checking if the cookie had been set and returning the correct message.\n‚Ä¢ The middleware continues running and sets a cookie on the response before it is returned to the user.\n\nYou can take this further by conditionally setting the cookie based on the response. In a more complicated example, you might want to check to make sure you only set the cookie on successful responses.\n\nThis approach is useful either for augmenting server components, or sharing your cookie logic across multiple routes/pages at the same time.\n\nWe‚Äôve seen that setting a cookie on the response is pretty straightforward in middleware, but what if we want to modify the cookie before the underlying page/route loads?\n\nThis pattern is very common in use cases like authentication, where you want to refresh a token and have all the downstream server components and routes see the updated token.\n\nIf we clear our cookies, and change our middleware to this:\n\nwhat would you expect it to display?\n\nIf you said ‚ÄúIt should always display ‚ÄòWelcome back!‚Äô because the request always has the cookie set‚Äù - that‚Äôs an incredibly reasonable take, but it‚Äôs unfortunately wrong. Modifying the request in middleware doesn‚Äôt impact the request anywhere else.\n\nWhat we have to do is‚Ä¶ a little involved. Right now, Next.js specifically allows you to pass down new headers, like so:\n\nSo one approach we can take is to grab and modify the header:\n\nAnd now, the user will always see the ‚ÄúWelcome back!‚Äù message since the middleware is always passing along a request with a cookie set.\n\nIf you are thinking that you don‚Äôt really love the idea of parsing and re-serializing all the cookies, just so the middleware can update the request, for one, I agree. For two, there is a slightly simpler approach - just make your own header.\n\nIn your route/component, you can do something like\n\nIn your middleware, you can then just set that specific header:\n\nAnd while all of this is‚Ä¶ fine, it‚Äôs not necessarily ideal. Hopefully this is something that gets better support within Next.js in the future.\n\nServer Actions are now stable in Next 14. They allow you to do things like, say, write SQL queries directly in your components.\n\nMost commonly, you‚Äôll see them triggered by an action, like submitting a form. Our same example, using Server Actions, looks like this:\n\nThis provides another option for us to use to manage cookies, as Server Actions will run on the server but can be called from either client or server components.\n\nI‚Äôd be hesitant to call this a complete guide without mentioning that cookies can be deleted as well. For functions like , there is a function that will do all the work for you. If you are manually specifying the cookie, you can delete by setting an empty value along with an expiration in the past.\n\nUp until now, we‚Äôve exclusively talked about setting/reading cookies on the server. We‚Äôve even seen that you can make a cookie - meaning your browser will enforce that it is inaccessible to javascript (e.g. or libraries like react-cookie). This is beneficial for any sensitive cookies, as it can mitigate the effect of an XSS attack.\n\nIn practice, if you are making a non-HttpOnly cookie, it‚Äôs worth asking if there‚Äôs a better way to do things. For example, if you want to store some information in the browser, another option is localStorage. localStorage can store more data and isn‚Äôt sent along on every request.\n\nIf you do want to use client-side cookies, libraries like react-cookie or universal-cookie can provide a way nicer experience. It means you can write familiar code like:"
    },
    {
        "link": "https://stackoverflow.com/questions/77396564/setting-a-cookie-in-nextjs-14",
        "document": "I have this nextjs app where I'm trying to setup my authentication/authorization system. I have a refresh token (long duration) which i store in a cookie, and i have also an access token (short duration) in the cookies (at first, I wanted to store my access token as a header, but, setting that header up in server components and the client side got me crying for almost a week since it is impossible.)\n\nSo, if my access-token cookie expires, I need to call my api using this endpoint ( ) that generates the new token and sets the cookie, bu, if I call this endpoint in a server component, the cookie won't be set in my browser, and I understand that since a server component is running on the server side and not on client side.\n\nSo I tried to set the cookie in my next.js app. When i call the same endpoint, I return the access token and set it using , but it didn't work since server components can not have side effects for cache and design purposes (and things of that nature).\n\nThen i go to the docs, where they say that if i want to set a cookie, I need a server action or a route handler, and this is what I did.\n\nServer action (/app/action.ts) (this is the first fn that runs in my server component because i need to do this types of operations before streaming starts):\n\nThis also didn't work, and i got an error that says.\n\nThen I tried to use an API route handler (/app/api/set-cookie):\n\nThat didn't work as well.\n\nIt's been a week for me trying to setup a normal auth system for my app, and I've changed things about my system so that i can use nextjs, but I'm having problems again, how am i supposed to set my cookie now? Should I redirect to another page with mark and set the cookie then redirect here to my page with the server component? That work around sounds horrible, and I don't think it'll create a good user experience."
    },
    {
        "link": "https://nextjs.org/docs/pages/building-your-application/routing/api-routes",
        "document": "Any file inside the folder is mapped to and will be treated as an API endpoint instead of a . They are server-side only bundles and won't increase your client-side bundle size.\n\nFor example, the following API route returns a JSON response with a status code of :\n‚Ä¢ API Routes can't be used with static exports. However, Route Handlers in the App Router can.\n‚Ä¢ API Routes will be affected by configuration in .\n\nTo handle different HTTP methods in an API route, you can use in your request handler, like so:\n‚Ä¢ - An object containing the cookies sent by the request. Defaults to\n‚Ä¢ - An object containing the query string . Defaults to\n‚Ä¢ - An object containing the body parsed by , or if no body was sent\n\nEvery API Route can export a object to change the default configuration, which is the following:\n\nis automatically enabled. If you want to consume the body as a or with , you can set this to .\n\nOne use case for disabling the automatic is to allow you to verify the raw body of a webhook request, for example from GitHub .\n\nis the maximum size allowed for the parsed body, in any format supported by bytes , like so:\n\nis an explicit flag that tells the server that this route is being handled by an external resolver like express or connect. Enabling this option disables warnings for unresolved requests.\n\nis automatically enabled, warning when an API Routes' response body is over 4MB.\n\nIf you are not using Next.js in a serverless environment, and understand the performance implications of not using a CDN or dedicated media host, you can set this limit to .\n\ncan also take the number of bytes or any string format supported by , for example , or . This value will be the maximum response size before a warning is displayed. Default is 4MB. (see above)\n\nThe Server Response object , (often abbreviated as ) includes a set of Express.js-like helper methods to improve the developer experience and increase the speed of creating new API endpoints.\n‚Ä¢ - A function to set the status code. must be a valid HTTP status code\n‚Ä¢ - Sends the HTTP response. can be a , an or a\n‚Ä¢ - Redirects to a specified path or URL. must be a valid HTTP status code . If not specified, defaults to \"307\" \"Temporary redirect\".\n‚Ä¢ - Revalidate a page on demand using . must be a .\n\nWhen sending a response back to the client, you can set the status code of the response.\n\nThe following example sets the status code of the response to ( ) and returns a property with the value of as a JSON response:\n\nWhen sending a response back to the client you can send a JSON response, this must be a serializable object . In a real world application you might want to let the client know the status of the request depending on the result of the requested endpoint.\n\nThe following example sends a JSON response with the status code ( ) and the result of the async operation. It's contained in a try catch block to handle any errors that may occur, with the appropriate status code and error message caught and sent back to the client:\n\nSending an HTTP response works the same way as when sending a JSON response. The only difference is that the response body can be a , an or a .\n\nThe following example sends a HTTP response with the status code ( ) and the result of the async operation.\n\nRedirects to a specified path or URL\n\nTaking a form as an example, you may want to redirect your client to a specified path or URL once they have submitted the form.\n\nThe following example redirects the client to the path if the form is successfully submitted:\n\nYou can make your API Routes more type-safe by importing the and types from , in addition to those, you can also type your response data:\n\nAPI Routes support dynamic routes, and follow the same file naming rules used for .\n\nNow, a request to will respond with the text: .\n\nAPI Routes can be extended to catch all paths by adding three dots ( ) inside the brackets. For example:\n‚Ä¢ matches , but also , and so on.\n\nMatched parameters will be sent as a query parameter ( in the example) to the page, and it will always be an array, so, the path will have the following object:\n\nAnd in the case of , and any other matching path, new parameters will be added to the array, like so:\n\nNow, a request to will respond with the text: .\n\nCatch all routes can be made optional by including the parameter in double brackets ( ).\n\nFor example, will match , , , and so on.\n\nThe main difference between catch all and optional catch all routes is that with optional, the route without the parameter is also matched ( in the example above).\n\nThe objects are as follows:\n‚Ä¢ Predefined API routes take precedence over dynamic API routes, and dynamic API routes over catch all API routes. Take a look at the following examples:\n‚Ä¢ - Will match , , etc. But not\n‚Ä¢ - Will match , , etc. But not ,\n\nIf you would like to use API Routes with the Edge Runtime, we recommend incrementally adopting the App Router and using Route Handlers instead.\n\nThe Route Handlers function signature is isomorphic, meaning you can use the same function for both Edge and Node.js runtimes."
    },
    {
        "link": "https://blog.logrocket.com/guide-cookies-next-js",
        "document": "Editor‚Äôs note: This article was reviewed for accuracy by Elijah Asaolu on 20 April 2024 and updated to include information about working with cookies in Next.js v14, as well as in the App Router vs. the Pages Router. Sections were also added regarding defining cookie behaviors and properties, setting multiple cookies, and working with cookies and Next.js route handlers, Server Components, middleware, Server Actions, and client-side vs. server-side cookies. The article was previously updated on 3 July 2023 to include information about common issues and fixes associated with the cookie attribute. For additional information about browser cookies, see this guide.\n\nCookies are data blobs that our browsers unknowingly contain. While some invade user privacy, others attempt to improve the browsing experience by keeping track of your browsing habits, preferences, and more. Cookies are useful in many situations, including authentication, improving UX, and quicker response times.\n\nIn this article, we‚Äôll explore how to manage cookies in Next.js server and client components as well as in middleware. We‚Äôll also go over two packages that will allow us to set cookies in the Next.js Pages Router and implement them into an actual use case.\n\nTo follow along, head over to this GitHub repository. Let‚Äôs get started!\n\nCookies are small pieces of data that web applications place on users‚Äô computers to store stateful information, such as user preferences or session management, as well as for tracking purposes.\n\nIn recent years, the idea of cookies has generated various heated discussions, considering that they have both benefits and drawbacks.\n\nFor one, cookies can help you easily store user personalization data, allowing you to better curate the UX to each user. On the other hand, cookies‚Äô ability to track users‚Äô online behavior raises privacy concerns.\n\nAs a result, there are now standards and regulations that require web applications to disclose their cookie usage and give users the choice to opt out.\n\nGiven the versatility of Next.js, there are multiple approaches to cookie management. Before now, we only needed to manage cookies in pages, API routes, and middleware. However, the addition of Server Components in Next 13 introduces even more new techniques.\n\nOne question a lot of people ask is if there are any differences between client and server-side cookies.\n\nCookies can be created from both client and server operations. Server-side cookies refer to cookies typically created and accessed via HTTP headers. Regardless of how you create them, cookies are still stored on the user‚Äôs browser and can be accessed directly on the client side.\n\nHowever, there‚Äôs an exception for cookies. If you create a cookie with the attribute enabled, such cookies cannot be directly accessed via client-side operations, reducing the risk of XSS attacks.\n\nLet‚Äôs start things off by exploring how to access and modify cookies in server components using the Next.js App Router. To proceed, create a new Next app by running the following command:\n\nDuring the installation process, choose your preferred configuration. However, don‚Äôt forget to select for the option. With the basic setup complete, let‚Äôs get into it!\n\nHow to get cookies\n\nTo read incoming request cookie values in server components, we use the method, as shown below:\n\nIn this example, if no cookie is stored with the tag, we‚Äôll get a blank screen. However, if multiple cookies match this tag, is set as the first match and will be displayed on the browser.\n\nTo get all cookies matching a certain name, we can use the method, as shown below:\n\nIn this updated example, if there‚Äôs more than one cookie with the tag, we iterated over them and displayed the name and value for each.\n\nWe can set new cookies via the method. However, because HTTP does not allow setting cookies after streaming starts, we can only modify cookie values (set and delete) in Server Actions or API routes. Here‚Äôs an example below:\n\nIn this example, we marked the function for setting our cookie with the statement, specifying it as a server action. We then rendered a form that allows the user to select a preferred theme. After the user submits the form, we get their selected theme value and set it to the cookie.\n\nFurthermore, we can use the syntax below to pass in additional options when setting a new cookie:\n\nThis way, we can create an cookie and set the cookie‚Äôs , , and expiration date.\n\nIf you‚Äôre using a version of Next.js that‚Äôs older than v14, you‚Äôll probably get the following error when using Server Actions:\n\nTo fix this, simply update your file to enable the experimental , as shown below:\n\nHowever, if you‚Äôre using Next.js v14 or newer, you should not encounter such an error.\n\nWe can delete cookies with the method. However, just like with setting cookies, we can only use this method in Server Actions or API routes, as shown below:\n\nWith this example above, when the user clicks the button to submit the form, the cookie will be deleted from the browser.\n\nWe can freely use all the cookie methods we just covered in Next.js Route Handlers ‚Äî the API routes equivalent for the directory ‚Äî without having to create Server Actions. You can see an example of this shown below:\n\nAlternatively, you can use the traditional Web APIs to read cookies from the request in both Route Handlers and API routes, as shown below:\n\nIn this example, we‚Äôre getting the theme cookie directly from the request object and returning it as the API response.\n\nNow, let‚Äôs look at how to manage cookies in the classic Next.js Pages Router. To get started, create a new Next.js application and make sure to select the during the configuration process.\n\nThe first package we will explore is react-cookie. This package aims to help you load and save cookies within your React application. To try things out, we‚Äôll create a simple application that keeps track of registered users.\n\nInstall react-cookie with the following code:\n\nTo start using the Hooks, add the component in the file, like so:\n\nThe Hooks are now available from any part of your application. Start using it by importing the Hook, as shown below:\n\nWe can now fetch, add, and remove cookies from the application. Let‚Äôs start off by adding a Hook to fetch all cookies on load:\n\nFor now, you shouldn‚Äôt be able to see any cookies. So, let‚Äôs create a function to set cookies using the function:\n\nThe function takes in three arguments: the key, the key-value, and some configuration choices. These choices include , , , , and others. The option was used in this case to allow the program to access the cookie from any location.\n\nAs you can see, we also used the Hook to reload our page using the method to avoid adding a URL entry into the history stack. It will just look like the page re-rendered!\n\nAs we move forward, remember that this tutorial is focused only on demonstrating the capabilities of the specific packages. Therefore, we will assume that you understand concepts like authentication flow.\n\nTo learn more about authentication in Next.js, refer to this guide on SuperTokens. You can also review authentication flows in this article.\n\nNext up, let‚Äôs bind this function to a . Input the following code:\n\nIn this case, the will only render if the cookie exists. Run the development server to see this in action. You can see this cookie visually using the dev tools by triggering and then selecting the Application section, as shown below:\n\nNow, let‚Äôs remove the cookie to allow the user to sign out. First, write another function:\n\nNext, bind it to another that will only render if the cookie is available. What does that mean? The cookie will be available if the user is registered. Here‚Äôs what that will look like in the code:\n\nAnd here‚Äôs how it will look in the application:\n\nWith that done, let‚Äôs explore the second package, cookies-next.\n\nUsing the cookies-next package in Next.js\n\nMoving forward, we will look at how to use the cookies-next package. This package fits more smoothly within the Next.js ecosystem because it can be used anywhere ‚Äî with both the Pages Router and the App Router, on the client side, on the server side through , and even with Next.js API routes.\n\nHere are the two packages head-to-head:\n\nAnother surprising fact about cookies-next ‚Äî this one‚Äôs for all the bundle-phobic developers ‚Äî is that it has a smaller bundle size compared to react-cookie. Essentially, this makes it more desirable to use in your next project! üéâ\n\nAs tradition goes, let‚Äôs start off by installing cookies-next with the following command:\n\nThe cookies-next package comes inbuilt with similar functions to the react-cookie package. These functions can be used for setting and removing cookies. Let‚Äôs create functions for setting and removing cookies with the following code:\n\nWith that done, you can test it by binding it to different that render if the cookie exists. In addition to and API routes, you can also use the cookies-next package on the server side of the application.\n\nLet‚Äôs look at an example where the user receives some information, has it verified, and then sets a cookie to indicate the information‚Äôs legitimacy, all on an API route.\n\nGo ahead and make a new API route inside . Inside the file, create a basic function with the following code:\n\nThe cookie will be set to indicate the trustworthiness of the user and expire after a specific period. More specifically, it will expire if there is some type of verification, such as a database to check the credentials or some OTP logic. The function is as follows:\n\nHere, the cookie expires after a week and will require the user to re-verify again. On successful verification, the API responds with a status message with relevant data that can be displayed in the frontend.\n\nNow, let‚Äôs try to access this route from the frontend. The function can be triggered only if the user is registered the first time. Create a function with the following code:\n\nWe can use the Hook to store the data coming from the API route and render the conditionally and based on the variable. Use the following code:\n\nWith this done, try out the code written so far. You can check if the cookie exists by opening up the dev tools and heading selecting the Application section, as shown below:\n\nI attempted to make the example more entertaining by generating a random code at every login. It will also set a cookie on the API route. You can experiment with your own original ideas and try out something cooler! Here‚Äôs what my example looks like:\n\nThe Next.js middleware design is consistent in both the Pages Router and App Router. As a result, cookie handling in middleware is the same for both. For example, we can and cookies via the middleware , as shown below:\n\nTo set new cookies in a middleware, we can also leverage the API, as shown below.\n\nThis way, the cookie is set globally in the user‚Äôs browser and can be accessed in Next.js pages, as we‚Äôve demonstrated in previous sections.\n\nThe feature is an important attribute of cookies, but it can also create issues in production-level applications:\n\nThe feature merely indicates whether a cookie can be retrieved through a different website with a different origin. Ideally, this should be accurate as it offers just one layer of defense against cross-site attacks.\n\nIn order to determine whether the scheme and the last portion of the domain name match, the browser mechanism analyzes the destination URI and the request coming from the client:\n\nSince the parameter is set to by default, the cookies won‚Äôt be registered if you‚Äôre a developer who frequently uses another smartphone and connects via the private IP address that the development server is hosted on your localhost.\n\nThe attribute is a crucial, yet occasionally confusing, element of cookies. This attribute determines which domains can access the cookie. If no domains are specified, the cookie‚Äôs default domain assignment will be the one that originally produced it.\n\nThis is why it‚Äôs advisable to set the domain attribute in cases where many sub-domains are attempting to access the same cookies:\n\nCookies are crucial to web development. The react-cookie and cookies-next packages are ideal for a variety of use cases because of their distinctive features and advantages.\n\nreact-cookie is far more popular, providing simple-to-use APIs and great compatibility with React framework. In contrast, cookies-next, a relatively new package explicitly created for Next.js, offers server-side rendering capabilities and improved security measures."
    }
]