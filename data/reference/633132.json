[
    {
        "link": "https://geeksforgeeks.org/dynamic-memory-allocation-in-c-using-malloc-calloc-free-and-realloc",
        "document": "In C, a variable defined in a function is stored in the stack memory. The requirement of this memory is that it needs to know the size of the data to memory at compile time (before the program runs). Also, once defined, we can neither change the size nor completely delete the memory.\n\nTo resolve this, C provides a feature called Dynamic Memory Allocation. It allows you to allocate memory at runtime, giving your program the ability to handle data of varying sizes. Dynamic resources are stored in the heap memory instead of the stack.\n\nThis feature is useful in a variety of situations. For example, changing the size of an array according to our requirement.\n\nAs we know, the size of an array in C is fixed and should be known at compile time. There can be two problems:\n\nThe size of the array is not sufficient to store all the elements. To resolve this, one might set the size to store the maximum theoretically possible elements. This creates another problem.\n\nThis size of the array is much more than what is required to store the elements. This leads to the wastage of memory.\n\nThis is where the dynamic memory allocation comes in. The size of the array can be increased if more elements are to be inserted and decreased of less elements are inserted. Moreover, there is no need to estimate the max possible size. The size can be decided at runtime according to the requirement.\n\nDynamic memory allocation is possible in C by using 4 library functions provided by <stdlib.h> library:\n\nLetâ€™s discuss each of them one by one.\n\nThe malloc() (stands for memory allocation) function is used to allocate a single block of contiguous memory on the heap at runtime. The memory allocated by malloc() is uninitialized, meaning it contains garbage values.\n\nwhere size is the number of bytes to allocate.\n\nThis function returns a void pointer to the allocated memory that needs to be converted to the pointer of required type to be usable. If allocation fails, it returns NULL pointer.\n\nAssume that we want to create an array to store 5 integers. Since the size of int is 4 bytes, we need 5 * 4 bytes = 20 bytes of memory. This can be done as shown:\n\nIn the above malloc call, we hardcoded the number of bytes we need to store 5 integers. But we know that the size of the integer in C depends on the architecture. So, it is better to use the sizeof operator to find the size of type you want to store.\n\nMoreover, if there is no memory available, the malloc will fail and return NULL. So, it is recommended to check for failure by comparing the ptr to NULL.\n\nThe calloc() (stands for contiguous allocation) function is similar to malloc(), but it initializes the allocated memory to zero. It is used when you need memory with default zero values.\n\nwhere n is the number of elements and size is the size of each element in bytes.\n\nThis function also returns a void pointer to the allocated memory that is converted to the pointer of required type to be usable. If allocation fails, it returns NULL pointer.\n\nWe can take the example of malloc() and try to do it with calloc() function.\n\nThe memory allocated using functions malloc() and calloc() is not de-allocated on their own. The free() function is used to release dynamically allocated memory back to the operating system. It is essential to free memory that is no longer needed to avoid memory leaks.\n\nwhere ptr is the pointer to the allocated memory.\n\nAfter freeing a memory block, the pointer becomes invalid, and it is no longer pointing to a valid memory location.\n\nAfter calling free(), it is a good practice to set the pointer to NULL to avoid using a â€œdangling pointer,â€ which points to a memory location that has been deallocated.\n\nrealloc() function is used to resize a previously allocated memory block. It allows you to change the size of an existing memory allocation without needing to free the old memory and allocate a new block.\n\nwhere, ptr is the pointer to the previously allocated memory block and new_size is the reallocated size that the memory block should have in bytes.\n\nThis function returns a pointer to the newly allocated memory, or NULL if the reallocation fails. If it fails, the original memory block remains unchanged.\n\nSuppose we initially allocate memory for 5 integers but later need to expand the array to hold 10 integers. We can use realloc() to resize the memory block:\n\nIt is important to note that if realloc() fails and returns NULL, the original memory block is not freed, so you should not overwrite the original pointer until youâ€™ve successfully allocated a new block. To prevent memory leaks, itâ€™s a good practice to handle the NULL return value carefully:\n\nConsider the first scenario where we were having issues with the fixes size array. Letâ€™s see how we can resolve both of these issues using dynamic memory allocation.\n\nIn this program, we are managing the memory allocated to the pointer ptr according to our needs by changing the size using realloc(). It can be a fun exercise to implement an array which grows according to the elements inserted in it. This kind of arrays are called dynamically growing arrays.\n\nAs useful as dynamic memory allocation is, it is also prone to errors that requires careful handling to avoid the high memory usage or even system crashes. Few of the common errors are given below:\nâ€¢ Dangling Pointers : Using a pointer after freeing its memory can cause undefined behavior or crashes.\nâ€¢ Fragmentation : Repeated allocations and deallocations can fragment memory, causing inefficient use of heap space.\nâ€¢ Allocation Failures : If memory allocation fails, the program may crash unless the error is handled properly.\n\nThe functions malloc() and calloc() works very similar to one another. So, why there was the need for two such similar functions.\n\nIt turns out that even though they are similar, they have different use cases due to the minor difference between them regarding the memory initialization. malloc() does not initialize memory while calloc() initializes the memory with zero.\n\nCan we only create arrays dynamically?\n\nWhat happens if memory allocation fails?\n\nWhat happens when you donâ€™t free memory after allocating?\n\nWhat is the limit of memory that we can allocate using these functions?\n\nCan we set the new size of allocated memory to 0 with realloc()?"
    },
    {
        "link": "https://stackoverflow.com/questions/25650111/dynamic-allocation-of-memory-for-an-array-in-c",
        "document": "I just wanted to ask that is there any way to dynamically allocate memory to an existing array of elements at runtime in C? For example.. if i declared int arr[25]; then I would be able to take maximum of 25 integers in my array.. But what if the user wants to enter some more integers.. but we dont know in advance how many? Also I dont want to waste the memory by assigning something like int arr[500]; just to be sure that the user doesnt exceed the upper bound of my array :( I'm really confused and sad as I'm unable to find a solution for this.. Does C even support such kind of thing? If not then in which programming language would it be easier to tackle a problem like this? P.S-> I'm new to programming so I'm sorry if this is a noob question. :/"
    },
    {
        "link": "https://geeksforgeeks.org/initialize-a-dynamic-array-in-c",
        "document": "In C, dynamic memory allocation is done to allocate memory during runtime. This is particularly useful when the size of an array is not known at compile time and needs to be specified during runtime. In this article, we will learn how to initialize a dynamic array in C.\n\nin C, can be initialized at the time of their declaration by using the function that allocates a block of memory and returns a pointer to it, or function that allocates memory for the given size and initializes all bytes to zero. After allocation, we can initialize the elements of the array using the .\n\nC Program to Dynamically Initialize an Array\n\nThe below example demonstrates the use of the malloc function to initialize a dynamic array in C.\n\nTime Complexity: O(n), where n is the size of the dynamically allocated array.\n\nAuxiliary Space: O(n)"
    },
    {
        "link": "https://medium.com/@muirujackson/best-practices-for-creating-dynamic-array-in-c-programming-d5017cb743da",
        "document": "In C programming, dynamic arrays can be created using pointers and memory allocation functions such as malloc, calloc, and realloc. Here are some best practices for creating dynamic arrays in C:\nâ€¢ Initialize the pointer: When creating a pointer for a dynamic array, it is a good practice to initialize it to NULL. This ensures that the pointer does not point to any random memory location.\nâ€¢ Use malloc/calloc to allocate memory: To allocate memory for a dynamic array, use the malloc or calloc function. Malloc allocates a block of memory of the specified size, while calloc allocates memory and initializes it to 0.\nâ€¢ Check for errors: Always check the return value of the memory allocation function to ensure that the allocation was successful. If the function returns NULL, then the allocation failed, and you should handle the error appropriately.\nâ€¢ Use sizeof to calculate the size: When allocating memory for a dynamic array, use the sizeof operator with a variable to calculate the size of each element. This ensures that you allocate enough memory for the array.\nâ€¢ Use realloc to resize the array: If you need to resize the dynamic array, use the realloc function. This function can resize the array and preserve its existing data.\nâ€¢ Free memory when done: Always remember to free the memory allocated for the dynamic array when youâ€™re done using it. This helps prevent memory leaks and improves the overall performance of your program.\nâ€¢ Avoid casting the result of malloc or calloc: It can hide an error if you forgot to include . This can cause crashes (or, worse, not cause a crash until way later in some totally different part of the code).\n\nHereâ€™s an example of creating a dynamic array of integers using malloc:\n\nAnd hereâ€™s an example of resizing the dynamic array using realloc:"
    },
    {
        "link": "https://stackoverflow.com/questions/722922/best-way-to-handle-memory-allocation-in-c",
        "document": "I know this is an old post but there hasn't really been much of a comprehensive answer to best practice in terms of style, which I think is what the op really wanted, so here is my take on memory allocation in C. Note I am more of a C++ person so much of my thoughts come from that attitude.\n\nIt is often handy to know whether your pointer is allocated, so always assign NULL to a pointer when you declare it. You can also create yourself a safe free function which frees the memory and then assigns NULL to it so you don't have to worry.\n\nIf you allocate memory in one C file then you should free it in the same file. This is perhaps more restrictive than needed, however if you are writing a library then you should definitely free any memory within your library that is malloc'd in your library. This is because on Windows dlls have a different heap to the exe, so mallocing memory in a dll and freeing it in the exe corrupts your heap.\n\nBy extension and for the sake of symmetry this means if you have a function which returns a pointer to allocated memory then you should have a function which frees that memory. This is why many librarys have an initialisation function which returns a pointer to some data (generally cast as a void *) then a cleanup function which will free the library's resources. If you can malloc and free within the same function then that is good as it makes it easy for you to keep track of things.\n\nDo not try to allocate all your memory at the beginning of a function and then free it at the end. This just means that if you want to return part way through the function you have to free all the memory, whereas if you malloc and free memory as you go you will have fewer pointers to free.\n\nIf you often have functions which allocate many pointers, then consider creating and array which holds pointers to all your pointers at the beginning of the function, then have a function that frees them all. This will save you the inevitable \"I'll come back and sort my memory leaks later\" syndrome if you want to return mid function.\n\nThe concept of factories is useful. A factory would be a function which mallocs the memory for a struct, assigns function pointer to the struct, initialises its variables and then returns the pointer to it. If the first of those was a destructor or an array of specific functions then you can have a generic destroy function that can call any struct's destructor, then free the struct's memory. You can also hide some of the internal details of the class by having different inward and outward facing definition of the struct. COM is built upon these principles.\n\nSo these are just the ways I look at memory in C. It isn't as elegant as in C++, but as you are relying on humans to deal with it, there are strategies like those above that can make things as simple as possible for them.\n\nNote also that there are always exceptions to every rule - these are just things that I think about when I use C. I'm sure other people have other ideas."
    },
    {
        "link": "https://geeksforgeeks.org/c-program-for-min-cost-path",
        "document": "Given a cost matrix cost[][] and a position (m, n) in cost[][], write a function that returns cost of minimum cost path to reach (m, n) from (0, 0). Each cell of the matrix represents a cost to traverse through that cell. Total cost of a path to reach (m, n) is sum of all the costs on that path (including both source and destination). You can only traverse down, right and diagonally lower cells from a given cell, i.e., from a given cell (i, j), cells (i+1, j), (i, j+1) and (i+1, j+1) can be traversed. You may assume that all costs are positive integers. For example, in the following figure, what is the minimum cost path to (2, 2)?\n\nThe path with minimum cost is highlighted in the following figure. The path is (0, 0) â€“> (0, 1) â€“> (1, 2) â€“> (2, 2). The cost of the path is 8 (1 + 2 + 2 + 3).\n\nPlease refer complete article on Dynamic Programming | Set 6 (Min Cost Path) for more details!"
    },
    {
        "link": "https://geeksforgeeks.org/min-cost-path-dp-6",
        "document": "Given a 2d matrix cost[][], the task is to calculate the minimum cost path to reach (m, n) from (0, 0). Each cell of the matrix represents a cost to traverse through that cell. The total cost of a path to reach (m, n) is the sum of all the costs on that path (including both source and destination). \n\nWe can only traverse down, right and diagonally lower cells from a given cell, i.e., from a given cell (i, j), cells (i+1, j), (i, j+1), and (i+1, j+1) can be traversed.\n\nFor the recursive approach, there are three potential cases for each cell in the grid (for any cell at position (m, n)):\nâ€¢ cost current cell can be calculated by moving left from cell (m, n-1).\nâ€¢ cost current ce ll can also be calculated by moving up from cell (m-1, n).\nâ€¢ cost can also be calculated by moving diagonally from cell (m-1, n-1).\n\n// C++ implementation to find the minimum cost path // Function to return the cost of the minimum cost path // from (0,0) to (m, n) in a cost matrix // If indices are out of bounds, return a large value // Function to return the cost of the minimum cost path // from (0,0) to (m, n) in a cost matrix // If indices are out of bounds, return a large value # Function to return the cost of the minimum cost path # from (0,0) to (m, n) in a cost matrix # If indices are out of bounds, return a large value // C# implementation to find the minimum cost path // Function to return the cost of the minimum cost path // from (0,0) to (m, n) in a cost matrix // If indices are out of bounds, return a large value // Function to return the cost of the minimum cost path // from (0,0) to (m, n) in a cost matrix // If indices are out of bounds, return a large value\n\n1. Optimal Substructure:The minimum cost to reach any cell in the grid can be derived from smaller subproblems (i.e., the cost to reach neighboring cells). Specifically, the recursive relation will look like: If the last element (i.e., cell (m, n)) is reached, the cost to reach it will be the value of the cell plus the minimum cost to reach one of its valid neighboring cells (left, up, or diagonal). In the recursive approach, subproblems are computed multiple times. For example, when computing the minimum cost from (m, n), we may need to compute the cost for (m-1, n) multiple times. This repetition can be avoided by storing the results of subproblems in a memoization table.\nâ€¢ 2D memo tabl (m x n) to store the computed values, initialized to -1 to indicate uncomputed subproblems.\nâ€¢ None If we are at the starting cell (0, 0), return the value of cost[0][0].\nâ€¢ None Before computing the result for any cell (m, n), check if the value at memo[m][n] is already computed. If it is, return the stored\nâ€¢ None If the value is not computed, recursively minimum cost and store it in memo[m][n].\nâ€¢ None Finally, return the value in memo[m][n] for the minimum cost to reach the target cell (m-1, n-1).\n\n// C++ implementation to find the minimum cost path // Function to return the cost of the minimum cost path // If indices are out of bounds, return a large value // Return precomputed value if available // Function to return the cost of the minimum cost path // If indices are out of bounds, return a large value // Return precomputed value if available # If indices are out of bounds, # Return precomputed value if available // C# implementation to find the minimum cost path // Function to return the cost of the minimum cost path // If indices are out of bounds, return a large value // Return precomputed value if available // If indices are out of bounds, return a large value // Return precomputed value if available\n\nThe approach here is similar to the recursive one but instead of breaking down the problem recursively, we iteratively build up the solution by calculating it in a bottom-up manner. We create a 2D array dp of size m*n where dp[i][j] represents the minimum cost to reach cell (i, j).\n\nUsing Space Optimized DP â€“ O(m*n) Time and O(n) Space\n\n// C++ implementation to find the minimum cost path // Fill the rest of the rows // Store the previous value of dp[j-1] // Update the first column (only depends on // Store the current dp[j] before updating it // Update dp[j] using the minimum of the // Update prev to be the old dp[j] for the // diagonal calculation in the next iteration // The last cell contains the // 1D dp array to store the minimum cost of the // Fill the rest of the rows // Store the previous value of dp[j-1] (for // Update the first column (only depends on the // Update dp[j] using the minimum of the // Update prev to be the old dp[j] for the // diagonal calculation in the next // The last cell contains the minimum cost path # Fill the rest of the rows # Store the previous value of dp[j-1] # Update the first column (only depends # Update dp[j] using the minimum of the top, # Update prev to be the old dp[j] for the # diagonal calculation in the next iteration # The last cell contains the minimum // C# implementation to find the minimum cost path // 1D dp array to store the minimum cost of the // Fill the rest of the rows // Store the previous value of dp[j-1] (for // Update the first column (only depends on the // Update dp[j] using the minimum of the // Update prev to be the old dp[j] for the // diagonal calculation in the next // The last cell contains the minimum cost path // 1D dp array to store the minimum cost of the current // Fill the rest of the rows // Store the previous value of dp[j-1] (for diagonal // Update the first column (only depends on the // Store the current dp[j] before updating it // Update dp[j] using the minimum of the top, // Update prev to be the old dp[j] for the // diagonal calculation in the next iteration // The last cell contains the minimum cost path\n\n// Directions for moving up, down, left, right, and diagonal // Distance matrix to store the minimum cost to reach each cell // If we reached the bottom-right // Ensure the new cell is within bounds // Directions for moving up, down, left, right, // Distance matrix to store the minimum cost to // If we reached the bottom-right corner, return // Ensure the new cell is within bounds # Directions for moving up, down, left, right, diagonal # If we reached the bottom-right corner, # Ensure the new cell is within bounds // Function to find the minimum cost path using Dijkstra // Directions: Up, Down, Left, Right, Diagonal // Use SortedSet to simulate the priority queue // Distance matrix to store minimum cost to each cell // Add the starting cell to the priority queue // Process the queue until it's empty // If destination is reached, return the cost // Process all valid neighbors (Up, Down, Left, Right) // Check if the neighbor is within bounds // If the cost to reach the neighbor is lower // Function to find the minimum cost path using Dijkstra // Directions: Up, Down, Left, Right, Diagonal // Distance matrix to store minimum cost to each cell // Process the priority queue until it's empty // If destination is reached, return the cost // Process all valid neighbors (Up, Down, Left, // Check if the neighbor is within bounds // If the cost to reach the neighbor is"
    },
    {
        "link": "https://stackoverflow.com/questions/77574923/dynamic-programming-problem-for-minimum-cost-tower-placement",
        "document": "Let's say the placement of a tower in cell i is valid if it, together with all previously placed towers, covers all cells <= i+5. Since the range within 5 is covered by the tower at i, we can place a tower there if every cell from 0 up to i-6 is covered.\n\nIn your DP array, the value in cell i is the min total cost a valid placement of a tower in cell i.\n\nThen, DP[i] = C[i] + min(DP[j]) for all j that cover i - range - 1 (the closest tower to the left not covered by tower i).\n\nAt the end, the answer is the minimum value of DP[i] for all the i that cover the last cell.\n\nThe tower that covers cell i can be placed in any of the 11 spots between i-5 and i+5.\n\nI'll give a smaller example -- same concept, but each tower covers cells within 2.\n\nWe fill out the DP array as follows:\n\nAny of the last 3 cover the last spot, so the answer is min(20, 23, 12) = 12.\n\nBy tracking which mins are selected each time, we can find the selection of towers that gives us the min.\n\nRuby code (read as pseudocode if you don't know Ruby)\n\nThis code doesn't track which indices were used."
    },
    {
        "link": "https://jenny-smith.medium.com/dynamic-programming-example-problems-80340452fed2",
        "document": "Dynamic programming (DP) is a powerful problem solving technique that helps break complex problems into smaller subproblems. Solving each only once and storing the results to avoid redundant computations.\n\nWhether you are preparing for coding interviews or just want to improving algorithmic thinking practicing Dynamic Programming Examples is one of the best ways to master this approach.\n\nIn this blog, We have listed top 15 easy, 10 medium and 10 hard DP problems providing a structured path to build-up skills step by step.\n\nHere are the top 15 easy-level Dynamic Programming example problems to help you build a strong foundation and improve your problem solving skills.\n\nGiven an integer , find the th Fibonacci number. The Fibonacci sequence is defined as:\n\nYou are climbing a staircase. It takes steps to reach the top. You can either climb or steps at a time. How many distinct ways can you reach the top?\n\nGiven an array representing money in each house, find the maximum amount of money you can rob without robbing two adjacent houses.\n\nEach step has a cost . You can start from index or . Find the minimum cost to reach the top\n\nGiven coins and amount , find the minimum number of coins needed to make that amount.\n\nGiven an array , find the length of the longest increasing subsequence.\n\nFind the maximum sum of a contiguous subarray in a given array.\n\nFind the minimum operations (insert, delete, replace) required to convert to .\n\nFind the number of ways to reach the bottom-right of an grid starting from the top-left.\n\nDetermine if the array can be partitioned into two subsets with equal sum.\n\nThe Tribonacci sequence is defined as:\n\nA message containing letters A-Z is encoded using the following mapping:\nâ€¢ Given a string consisting of digits, count the number of ways it can be decoded.\n\n13. Best Time to Buy and Sell Stock\n\nGiven an array where is the stock price on day , find the maximum profit you can achieve by buying and selling once.\n\nGiven an integer , return an array where is the number of 1â€™s in the binary representation of for .\n\nYou are given an array and a target sum . Find the number of ways to assign or signs to elements to achieve .\n\nHere are the top 10 medium-level Dynamic Programming examples to strengthen your problem solving skills and deepen your DP understanding.\n\nGiven a string , find the length of the longest palindromic subsequence in . A subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order.\n\nInput: \n\nOutput: \n\nExplanation: The longest palindromic subsequence is with length .\n\nThis problem can be solved using dynamic programming with the following observations:\n\n1. If , then these characters can be part of the LPS (Longest Palindromic Subsequence), so the length increases by and we move inward:\n\n2. If , we have two choices:\nâ€¢ Take the maximum of both:\n\nGiven an array of coins of size representing different denominations and an integer , find the minimum number of coins required to make up the amount. If it's not possible, return .\n\nInput: , \n\nOutput: \n\nExplanation: We can make using .\n\nWe define as the minimum number of coins needed to get the sum .\nâ€¢ Transition Formula: dp[i]=minâ¡(dp[iâˆ’coin]+1)âˆ€ coin in coinsdp[i] = \\min(dp[i â€” coin] + 1) \\quad \\forall \\text{ coin in coins}dp[i]=min(dp[iâˆ’coin]+1)âˆ€ coin in coins\nâ€¢ We iterate over all possible sums from to and check for each coin denomination.\n\nGiven an array of positive integers and a target sum , determine if there exists a subset with sum equal to .\n\nDefine as if a subset of the first elements has a sum equal to , else .\nâ€¢ If and no elements are considered,\nâ€¢ If is greater than , we exclude it:\nâ€¢ Otherwise, we check two cases:\n\nGiven two strings and , return the minimum number of operations required to convert to . Allowed operations:\n\nDefine as the minimum operations to convert to .\n\n1. Base Case: If one string is empty, operations equal the length of the other string.\nâ€¢ Else, choose the minimum of:\n\nYou are given an grid. A robot starts at the top-left corner and wants to reach the bottom-right corner . The robot can only move right or down at any point. Find the number of unique paths.\nâ€¢ Explanation: There are ways to reach from .\n\nDefine as the number of ways to reach cell .\n\nâž¢ Time Complexity: O(m Ã— n)\n\nâž¢ Space Complexity: O(m Ã— n), can be optimized to O(n).\n\nGiven an array of positive integers, determine if the array can be partitioned into two subsets with equal sums.\nâ€¢ Explanation: Two subsets and both have sum .\nâ€¢ The total sum must be even for partitioning to be possible.\nâ€¢ Use DP to solve it.\n\nGiven an array , find the contiguous subarray that has the maximum product.\nâ€¢ Explanation: The subarray has the maximum product .\nâ€¢ Maintain and at each step.\nâ€¢ If is negative, swap and .\n\nA string containing digits (1â€“9) can be decoded into letters (A-Z: ). Given an encoded string, count the number of ways to decode it.\nâ€¢ Explanation: can be decoded as , , or .\nâ€¢ Define as the number of ways to decode .\n\nâž¢ Time Complexity: O(n)\n\nâž¢ Space Complexity: O(n), can be optimized to O(1).\n\n9. Best Time to Buy and Sell Stock with Cooldown\n\nYou are given an array where is the price of a stock on the day. You may buy one share of stock on any day and sell it later, but after selling, you must wait one day (cooldown) before buying again. Find the maximum profit you can achieve.\nâ€¢ â†’ Maximum profit if in cooldown on day .\n\nâž¢ Time Complexity: O(n)\n\nâž¢ Space Complexity: O(n), can be optimized to O(1).\n\nGiven three strings , , and , return if is formed by an interleaving of and . An interleaving means maintaining the relative order of characters but merging the two strings.\nâ€¢ Explanation: can be formed by interleaving and .\n\nDefine as if can be formed using and .\nâ€¢ If the current character of matches , we check .\nâ€¢ If the current character of matches , we check .\n\ndp[i][j] = (dp[i âˆ’ 1][j] if s1[i âˆ’ 1] = s3[i + j âˆ’ 1]) OR (dp[i][j âˆ’ 1] if s2[j âˆ’ 1] = s3[i + j âˆ’ 1])\n\nâž¢ Time Complexity: O(m Ã— n)\n\nâž¢ Space Complexity: O(m Ã— n), can be optimized to O(n).\n\nHere are the top 10 hard-level Dynamic Programming examples to challenge your skills and master advanced DP techniques.\n\nGiven an array of integers, find the length of the longest increasing subsequence (LIS). A subsequence is a sequence derived by deleting some elements without changing the order of the remaining elements.\n\n1. Define as the length of the longest increasing subsequence that ends at index .\n\n2. Initialize array with , because each element alone is an increasing subsequence.\n\n3. Iterate over the array with two loops:\nâ€¢ Inner loop from to , checking if , then update .\n\n4. The result is the maximum value in the array.\n\nâž¢ Time Complexity: , but can be optimized to using binary search.\n\nGiven two strings and , return the minimum number of operations required to convert into . Allowed operations:\n\n1. Define as the minimum edit distance for and .\nâ€¢ If , then (no change needed).\n\nGiven jobs, each represented as , find the maximum profit that can be earned by scheduling jobs such that no two jobs overlap.\nâ€¢ Use DP where stores the maximum profit by considering jobs up to index .\nâ€¢ Use binary search to find the last job that does not overlap.\n\nGiven balloons, numbered from to , each with a positive integer value, maximize coins by bursting them. The coins collected by bursting is .\nâ€¢ Define as the max coins obtained from .\nâ€¢ Iterate over possible balloon bursts in the interval, updating .\n\nGiven two strings and , where contains wildcard characters:\nâ€¢ matches any sequence of characters (including empty sequence). Determine if matches .\n\nGiven a string , partition it such that every substring is a palindrome, and return the minimum cuts needed.\n\nInput: \n\nOutput: \n\nExplanation: We can partition as , needing 1 cut.\nâ€¢ Precompute palindromes:\n\nUse to check if is a palindrome.\nâ€¢ Define as the minimum cuts needed for .\n\nGiven an array representing the heights of histogram bars, find the largest rectangle that can be formed.\n\nInput: \n\nOutput: \n\nExplanation: The largest rectangle is formed using , which has area .\n\nGiven keys with search probabilities , construct a BST that minimizes the expected search cost.\nâ€¢ Define as the minimum cost for keys to .\n\nwhere is the root.\n\nGiven a string and a dictionary , return all possible sentences formed using words from .\nâ€¢ Use to store possible words forming .\n\nA galactic empire needs to relocate its citizens between N planets, each with limited resources. Each planet has a capacity (maximum citizens it can hold) and a relocation cost (cost of moving one citizen from planet to planet ).\n\nâž¢ You are given:\nâ€¢ : Initial number of citizens on each planet.\nâ€¢ : A square matrix representing the cost to move one citizen from planet to planet .\nâ€¢ Goal: Minimize the total relocation cost so that no planet exceeds its capacity.\nâ€¢ Define as the minimum cost to distribute excess citizens from planet to with citizens already moved.\nâ€¢ If has excess citizens, try moving them to minimizing cost using .\n\nKeep practicing these Dynamic Programming examples and gradually develop the skills to tackle even the toughest challenges with confidence! â€¦.ðŸš€\n\nHere we reached the bottom of this article! Mastering Dynamic Programming Examples takes patience and practice but once you grasp the core concepts then solving DP problems becomes much easier.\n\nBy working through these top 35 Dynamic Programming problems across different difficulty levels, youâ€™ll develop a strong intuition for recognizing patterns and optimizing solutions efficiently.\n\nKeep practicing, experiment with different approaches and soon DP will become one of your most valuable problem solving skills!"
    },
    {
        "link": "https://stackoverflow.com/questions/62359109/dynamic-programming-problem-minimum-cost-path",
        "document": "I was trying this problem - Minimum Cost Path. I have solved the problem using Dijkstra's Shortest Path Algorithm. But when i tried this using recursion+memoisation i.e. using dynamic programming, i got stuck and could not debug my code. I need help as to where my code is wrong!!\n\nI am really glad for the help.\n\nI am getting 2147483647 as the output for both the cases, which is the value of INT_MAX."
    }
]