[
    {
        "link": "https://html-agility-pack.net",
        "document": "HAP is an HTML parser written in C# to read/write DOM and supports plain XPATH or XSLT.\n\n\n\n \n\n Web scraping is a technique used in any language such as C# to extract data from a website.\n\n\n\n \n\n That's a gray zone! There is no official answer about it, and almost every company has some web scraping program. In short, do polite crawling and don't spam a website and everything will be fine.\n\n\n\n \n\n When is the v2.x coming? There is no official date, but the work is in progress. A lot of improvement is already planned to make web scraping even easier!\n\n\n\n \n\n You can enhance HAP with some third party libraries:"
    },
    {
        "link": "https://html-agility-pack.net/documentation",
        "document": ""
    },
    {
        "link": "https://zenrows.com/blog/html-agility-pack",
        "document": ""
    },
    {
        "link": "https://github.com/zzzprojects/html-agility-pack",
        "document": "This library is sponsored by Entity Framework Extensions\n\nIt is an agile HTML parser that builds a read/write DOM and supports plain XPATH or XSLT (No need to understand XPATH nor XSLT to use it, don't worry...). It is a .NET code library that allows you to parse \"out of the web\" HTML files. The parser is very tolerant of \"real world\" malformed HTML. The object model is very similar to what proposes System.Xml, but for HTML documents (or streams).\n‚Ä¢ You can also consult thousands of HAP questions on Stack Overflow\n\nThe best way to contribute is by spreading the word about the library:\n\nA HUGE THANKS for your help.\n‚Ä¢ and much more!\n\nTo view all our free and paid projects, visit our website ZZZ Projects."
    },
    {
        "link": "https://nuget.org/packages/htmlagilitypack",
        "document": "This is an agile HTML parser that builds a read/write DOM and supports plain XPATH or XSLT (you actually don't HAVE to understand XPATH nor XSLT to use it, don't worry...). It is a .NET code library that allows you to parse \"out of the web\" HTML files. The parser is very tolerant with \"real world\" malformed HTML. The object model is very similar to what proposes System.Xml, but for HTML documents (or streams).\n\nThis library is sponsored by ZZZ Projects:\n\nHAP is trusted by companies worldwide with over 150 million downloads."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/fundamentals/networking/http/httpclient",
        "document": "In this article, you learn how to make HTTP requests and handle responses with the class.\n\nHTTP endpoints commonly return JavaScript Object Notation (JSON) data, but not always. For convenience, the optional System.Net.Http.Json NuGet package provides several extension methods for and objects that perform automatic serialization and deserialization by using the üì¶ System.Text.Json NuGet package. The examples in this article call attention to places where these extensions are available.\n\nMost of the examples in this article reuse the same instance, so you can configure the instance once and use it for the remaining examples. To create an object, use the class constructor. For more information, see Guidelines for using HttpClient.\n\nThe code completes the following tasks:\n‚Ä¢ Instantiate a new instance as a variable. According to the guidelines, the recommended approach is to reuse instances during the application lifecycle.\n\nThis instance uses the base address to make subsequent requests. To apply other configurations, consider the following APIs:\n\nTo make an HTTP request, you call any of the following API methods:\n\nThe HttpContent type is used to represent an HTTP entity body and corresponding content headers. For HTTP methods (or request methods) that require a body ( , , ), you use the HttpContent class to specify the body of the request. Most examples show how to prepare the StringContent subclass with a JSON payload, but other subclasses exist for different content (MIME) types.\n‚Ä¢ FormUrlEncodedContent: Provides HTTP content for name/value tuples encoded by using the MIME type.\n‚Ä¢ MultipartContent: Provides a collection of HttpContent objects that get serialized by using the MIME type specification.\n‚Ä¢ MultipartFormDataContent: Provides a container for content encoded by using the MIME type.\n‚Ä¢ ReadOnlyMemoryContent: Provides HTTP content based on an ReadOnlyMemory<T> value.\n\nThe class is also used to represent the response body of the HttpResponseMessage class, which is accessible on the HttpResponseMessage.Content property.\n\nUse an HTTP GET request\n\nA request shouldn't send a body. This request is used (as the method name indicates) to retrieve (or get) data from a resource. To make an HTTP request given an instance and a Uri object, use the HttpClient.GetAsync method:\n\nThe code completes the following tasks:\n‚Ä¢ Write the request details to the console.\n‚Ä¢ Write the JSON response body to the console.\n\nThe method is a custom extension that isn't part of the framework. If you're curious about the implementation, consider the following C# code:\n\nThis functionality is used to write the request details to the console in the following form:\n\nAs an example, the request to the endpoint outputs the following message:\n\nCreate the HTTP GET request from JSON\n\nThe https://jsonplaceholder.typicode.com/todos endpoint returns a JSON array of objects. Their JSON structure resembles the following form:\n\nThe C# object is defined as follows:\n\nIt's a type, with optional , , , and properties. For more information on the type, see Introduction to record types in C#. To automatically deserialize requests into a strongly typed C# object, use the GetFromJsonAsync extension method that's part of the üì¶ System.Net.Http.Json NuGet package.\n\nThe code completes the following tasks:\n‚Ä¢ The query string represents the filtering criteria for the request. When the command succeeds, the response is automatically deserialized into a object.\n‚Ä¢ None Write the request details to the console, along with each object.\n\nA request sends data to the server for processing. The header of the request signifies what MIME type the body is sending. To make an HTTP request given an instance and a Uri object, use the HttpClient.PostAsync method:\n\nThe code completes the following tasks:\n‚Ä¢ Prepare a StringContent instance with the JSON body of the request (MIME type of ).\n‚Ä¢ Ensure the response is successful and write the request details to the console.\n‚Ä¢ Write the response body as a string to the console.\n\nTo automatically serialize request arguments and deserialize responses into strongly typed C# objects, use the PostAsJsonAsync extension method that's part of the System.Net.Http.Json NuGet package.\n\nThe code completes the following tasks:\n‚Ä¢ Serialize the instance as JSON and make a request to the endpoint.\n‚Ä¢ Ensure the response is successful and write the request details to the console.\n‚Ä¢ Deserialize the response body into a instance and write the object to the console.\n\nThe request method either replaces an existing resource or creates a new one by using the request body payload. To make an HTTP request given an instance and a Uri object, use the HttpClient.PutAsync method:\n\nThe code completes the following tasks:\n‚Ä¢ Prepare a StringContent instance with the JSON body of the request (MIME type of ).\n‚Ä¢ Ensure the response is successful and write the request details with the JSON response body to the console.\n\nTo automatically serialize request arguments and deserialize responses into strongly typed C# objects, use the PutAsJsonAsync extension method that's part of the System.Net.Http.Json NuGet package.\n\nThe code completes the following tasks:\n‚Ä¢ Serialize the instance as JSON and make a request to the endpoint.\n‚Ä¢ Ensure the response is successful and write the request details to the console.\n‚Ä¢ Deserialize the response body into a instance and write the objects to the console.\n\nThe request is a partial update to an existing resource. This request doesn't create a new resource and it isn't intended to replace an existing resource. Instead, this method only partially updates a resource. To make an HTTP request given an instance and a Uri object, use the HttpClient.PatchAsync method:\n\nThe code completes the following tasks:\n‚Ä¢ Prepare a StringContent instance with the JSON body of the request (MIME type of ).\n‚Ä¢ Ensure the response is successful and write the request details with the JSON response body to the console.\n\nNo extension methods exist for requests in the NuGet package.\n\nA request removes an existing resource and the request is idempotent, but not safe. Multiple requests to the same resources yield the same result, but the request affects the state of the resource. To make an HTTP request given an instance and a Uri object, use the HttpClient.DeleteAsync method:\n\nThe code completes the following tasks:\n‚Ä¢ Ensure the response is successful and write the request details to the console.\n\nThe request is similar to a request. Instead of returning the resource, this request returns only the headers associated with the resource. A response to the request doesn't return a body. To make an HTTP request given an instance and a Uri object, use the HttpClient.SendAsync method with the HttpMethod type set to :\n\nThe code completes the following tasks:\n‚Ä¢ Ensure the response is successful and write the request details to the console.\n‚Ä¢ Iterate over all of the response headers and write each header to the console.\n\nThe request is used to identify which HTTP methods a server or endpoint supports. To make an HTTP request given an instance and a Uri object, use the HttpClient.SendAsync method with the HttpMethod type set to :\n\nThe code completes the following tasks:\n‚Ä¢ Send an HTTP request to the endpoint.\n‚Ä¢ Ensure the response is successful and write the request details to the console.\n‚Ä¢ Iterate over all of the response content headers and write each header to the console.\n\nThe request can be useful for debugging as it provides application-level loop-back of the request message. To make an HTTP request, create an HttpRequestMessage by using the type:\n\nWhen you handle an HTTP response, you interact with the HttpResponseMessage type. Several members are used to evaluate the validity of a response. The HTTP status code is available in the HttpResponseMessage.StatusCode property.\n\nTo ensure the is (HTTP status code 200), you can evaluate the value as shown in the following example:\n\nThere are other HTTP status codes that represent a successful response, such as (HTTP status code 201), (HTTP status code 202), (HTTP status code 204), and (HTTP status code 205). You can use the HttpResponseMessage.IsSuccessStatusCode property to evaluate these codes as well, which ensures that the response status code is within the range 200-299:\n\nIf you need to have the framework throw the HttpRequestException error, you can call the HttpResponseMessage.EnsureSuccessStatusCode() method:\n\nThis code throws an error if the response status code isn't within the 200-299 range.\n\nWith a valid response, you can access the response body by using the Content property. The body is available as an HttpContent instance, which you can use to access the body as a stream, byte array, or string.\n\nThe following code uses the object to read the response body:\n\nYou can use different objects to read the response body. Use the object to read the response body:\n\nUse the object to read the response body:\n\nWhen you know an HTTP endpoint returns JSON, you can deserialize the response body into any valid C# object by using the System.Net.Http.Json NuGet package:\n\nIn this code, the value is the response body deserialized as the type .\n\nWhen an HTTP request fails, the system throws the HttpRequestException object. Catching the exception alone might not be sufficient. There are other potential exceptions thrown that you might want to consider handling. For example, the calling code might use a cancellation token that was canceled before the request completed. In this scenario, you can catch the TaskCanceledException error:\n\nLikewise, when you make an HTTP request, if the server doesn't respond before the HttpClient.Timeout value is exceeded, the same exception is thrown. In this scenario, you can distinguish that the time-out occurred by evaluating the Exception.InnerException property when catching the TaskCanceledException error:\n\nIn the code, when the inner exception is an TimeoutException type, then the time-out occurred and the cancellation token doesn't cancel the request.\n\nTo evaluate the HTTP status code when you catch the HttpRequestException object, you can evaluate the HttpRequestException.StatusCode property:\n\nIn the code, the EnsureSuccessStatusCode() method is called to throw an exception if the response isn't successful. The HttpRequestException.StatusCode property is then evaluated to determine if the response was a (HTTP status code 404). There are several helper methods on the object that implicitly call the method on your behalf.\n\nFor HTTP error handing, consider the following APIs:\n\nWhen you call these methods, you can handle the object and evaluate the HttpRequestException.StatusCode property to determine the HTTP status code of the response:\n\nThere might be scenarios where you need to throw the HttpRequestException object in your code. The HttpRequestException() constructor is public and you can use it to throw an exception with a custom message:\n\nAn HTTP proxy can be configured in one of two ways. A default is specified on the HttpClient.DefaultProxy property. Alternatively, you can specify a proxy on the HttpClientHandler.Proxy property.\n\nThe property is a static property that determines the default proxy that all instances use, if no proxy is set explicitly in the HttpClientHandler object passed through its constructor.\n\nThe default instance returned by this property initializes according to a different set of rules depending on your platform:\n‚Ä¢ Windows: Read proxy configuration from environment variables, or if variables aren't defined, read from user proxy settings.\n‚Ä¢ macOS: Read proxy configuration from environment variables, or if variables aren't defined, read from system proxy settings.\n‚Ä¢ Linux: Read proxy configuration from environment variables, or if variables aren't defined, initialize a nonconfigured instance to bypass all addresses.\n\nThe property initialization on Windows and Unix-based platforms uses the following environment variables:\n‚Ä¢ : The proxy server used on HTTP requests.\n‚Ä¢ : The proxy server used on HTTPS requests.\n‚Ä¢ : The proxy server used on HTTP and/or HTTPS requests when the and/or variables aren't defined.\n‚Ä¢ : A comma-separated list of hostnames to exclude from proxying. Asterisks aren't supported for wildcards. Use a leading period (.) when you want to match a subdomain. Examples: (with leading period) matches , but doesn't match . (without leading period) doesn't match . This behavior might be revisited in the future to match other ecosystems better.\n\nOn systems where environment variables are case-sensitive, the variable names can be all lowercase or all uppercase. The lowercase names are checked first.\n\nThe proxy server can be a hostname or IP address, optionally followed by a colon and port number, or it can be an URL, optionally including a username and password for proxy authentication. The URL must start with , not , and can't include any text after the hostname, IP, or port.\n\nThe HttpClientHandler.Proxy property identifies the WebProxy object to use to process requests to internet resources. To specify that no proxy should be used, set the property to the proxy instance returned by the GlobalProxySelection.GetEmptyWebProxy() method.\n\nThe local computer or application configuration file might specify that a default proxy is used. If the property is specified, then the proxy settings from the property override the local computer or application config file and the handler uses the proxy settings specified. If no proxy is specified in a config file and the property is unspecified, the handler uses the proxy settings inherited from the local computer. If there are no proxy settings, the request is sent directly to the server.\n\nThe HttpClientHandler class parses a proxy bypass list with wildcard characters inherited from local computer settings. For example, the class parses a bypass list of from browsers as a regular expression of . Therefore, a URL of bypasses the proxy by using the class.\n\nThe class supports local proxy bypass. The class considers a destination to be local if any of the following conditions are met:\n‚Ä¢ The destination contains a flat name (no periods (.) in the URL).\n‚Ä¢ The destination contains a loopback address (Loopback or IPv6Loopback) or the destination contains an IPAddress property assigned to the local computer.\n‚Ä¢ The domain suffix of the destination matches the local computer's domain suffix, as defined in the DomainName property.\n\nFor more information about configuring a proxy, see the following APIs:"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.net.http.httpclient?view=net-9.0",
        "document": ""
    },
    {
        "link": "https://medium.com/@codebob75/creating-and-consuming-apis-in-net-c-d24f9c414b96",
        "document": "How to create an API with code step by step?\n\nThis is the project to create the server API (aka the server that sends response), the request will be done in the second part of this blog (aka the client).\n\nThe first thing to do is to create a controller, go to the folder Controllers\n\nThe controller will be the entry point in your application to any API requests.\n\nA controller is often restricted to one class, e.g. CustomerController or HouseController\n\nWe now actually have the choice between:\n\nIn this blog we will stick with controller-based APIs ;)\n\nName file with ending Controller e.g. nameofyourclassController and add the following code (with your own class)\n\nNow let‚Äôs see what is happening there!\n\nWe are using a _service, that manages our interaction with the database.\n\nIf you are interested in checking how this works, please look at my other blog about EF Core.\n\nBasically, if you follow Clean Architecture principles, your EF Core DbContext should not be in the Controller.\n\nIt also explains about DTOs (Domain Transfer Objects) and why you should use them.\n\nThis is why the Brand_DTO class is used here!\n\nWe have 5 endpoints here, one for each method\n‚Ä¢ Get: Get all brands\n\nNow let‚Äôs look at how the controller is being set-up!\n\nRouting tells the external world how to find your endpoints\n\nThere are many ways of setting it, Attribute routing is one way of doing it\n‚Ä¢ First you need to set MapController in program.cs\n‚Ä¢ Then you would add\n\nIt will automatically get the route from the controller name\n\ne.g. BrandController.cs the route will be /api/brand\n\nHow to manually test an API?\n\nSo let‚Äôs test our controller! Run the app by clicking on the https, you should get this command line information\n\nThen open Postman (or download it if you don‚Äôt have it!)\n\nAnd that‚Äôs it :) you should get a 200 response or else!\n\nIf you need to add a token for authentication, you can add it here\n\nAlternatively, you can just use Swagger, it should enabled by default in the program.cs\n\nSo when you run the API app, the following page opens\n\nWhere you can just test your API directly\n\nWhat is the ApiController attribute?\n\nThis attribute enables you to make use of several features for your controller class, including:\n\nBasically what parameter binding does is take the request and automatically convert it into a C# class that you have defined.\n\nLet‚Äôs look at how that works, see below the list of referenced binding\n\nWithout having [ApiController], you‚Äôd need to explicitly add [FromBody]\n\nAnd now with [ApiController], [FromBody] is not needed anymore\n\nWhen using [ApiController], you now must add:\n\nBasically, it adds this piece of code automatically to all your methods so you don‚Äôt have to\n\n[ApiController] automatically manages exceptions and error responses. It will automatically send a message with the details about what went wrong\n\nWebApis projects should derive from ControllerBase whilst Controller adds support for views which is suited for WebApp (e.g. Blazor)\n\nSo now you can use the BadRequest reponse for instance\n\nConfigure the behaviour of the Controller class and methods by just adding attribute on top such as\n\nIndicates that this method accepts GET requests with an int as id, which in turn is passed to the method\n\nClearly indicates, documents and sets the behaviour of each of your API endpoint with the response status and type.\n\nWhat is an API Response? ActionResult\n\nAction Result gives you methods to return http Response status object, here are the most common ones:\n\nHow to filter the API request?\n\nWe can also explicitly filter requests using [FromQuery] and fetching one parameter and use it in the endpoint method\n\nHow to cache your API response?\n\nWhat if your API calls often send the same data?\n\nInstead of having to go back to the database again, you can just cache the data in memory.\n\nTo enable caching, in your program.cs add\n\nNow in your controller, you can add the caching attribute\n‚Ä¢ Duration is how many seconds the data will remain in memory\n‚Ä¢ Location can be Any, Client or None\n\nNone will indicate that the response shouldn‚Äôt be cached at all, mostly used in combination with NoStore = true, to always go to the Database\n\nInstead of having to add the same caching strategy to all endpoints, we can just create a caching strategy by doing so\n\nNow we can use our caching strategy to our endpoint\n\nOne common issue that arises is the amount of data being returned from an API.\n\nWhat if the response contains 1,000s or 1,000,000s of objects?\n\nWe would first need to update our repository and add :\n‚Ä¢ skip = The page we want to start at (e.g. skip 2)\n‚Ä¢ take = The amount of pages we want to retrieve\n\nAs a reminder, here‚Äôs my blog on the repository pattern ;)\n\nNow we can use it in the implementation of the interface\n\nSo what we do here is:\n‚Ä¢ Forbid requests that are more than 100 pages\n‚Ä¢ represents the number of pages to skip\n‚Ä¢ represents the number of entities to take per page.\n\nNow we can add it to our endpoint\n\nWe can even give the pagination as a response, first add a pagination model\n\nAnd then add it to the response\n\nSo you are building an API that clients can call, but what if you want to make changes?\n\nThen all the requests that the clients are sending will break!\n\nTo avoid this, you can provide versions to your APIs so that it doesn‚Äôt break user requests.\n\nYou will need two Nuget Packages:\n\nThen in program.cs, add api versioning with major and minor versions\n\nYou can now use the api version attribute in your controller\n\nActually you can even add multiple versions\n\nNow, since we have multiple version in our controller class, each method can now pick which version it implements\n\nAdditionally, the route needs to be updated to ensure that the correct api version is added to the URI\n\nFinally, our api versioning needs an ApiExplorer to handle our different api versions\n\nThe options.SubstituteApiVersionInUrl = true; will automatically add the api version to the route\n\nThis part of the article will focus on the client side, aka calling the API!\n\nMicrosoft makes it easy and provides you with out-the-box solutions, the two most common are:\n\nThey both send and receive http requests/reponses. So what are the differences and which should you pick?\n\nHow to use HttpClient()?\n‚Ä¢ Is the basic unit to make all your api calls!\n‚Ä¢ Basically the HttpClient gives you access to all the REST methods.\n‚Ä¢ The only thing that you need to do is input the URI and add content.\n\nHere‚Äôs a very basic example on how to use httpClient\n\nIt is recommended to\n‚Ä¢ Use ‚Äòusing‚Äô to properly dispose the client after its use\n\nIn production environment you will also populate the requests with authentication.\n‚Ä¢ Easy to set-up and use\n\nWhilst using httpclient is a great straightforward way of consuming APIs it comes with some issues:\n\nMaking an API call using an httpClient creates a connection between the client and the server. This connection is called a socket.\n\nWhen the API call is done, this connection/ socket remains open to ensure that all the data has been transferred. This state is called TIME_WAIT.\n\nTIME_WAIT is a feature of TCP/IP (the protocol used in APIs), by default it is set to 60 seconds. That means that even if you dispose your httpClient, the connection remains open.\n\nIf you use mutliple instances of HttpClient, you open a connection/socket for each which will remain open for at least one minute.\n\nWhat could happen is that you run out of sockets!\n\nNow, you might ask, how many TCP connections/ sockets are there? Let‚Äôs look at an Azure App instance\n\nAlmost 2,000 or 4,000 connections might not seem like few but think again, when your app starts growing and serving more requests, the number of API calls grows exponantially.\n\nIn any cases, you‚Äôd certainly want to play it safe :)\n\nYou can find the TCP connections result in your app in Azure by going:\n\nYou will land on this GUI\n\nOne way to solve socket exhaustion is to instantiate the httpClient object as singleton or static. Which is fine for small applications.\n\nHowever, the underlying issue is that httpClient uses an instance or http\n\nResource intensive: creating new httpClient for every request might lead to overuse of resources.\n\nConfigurations: have different httpClient might lead to different configurations and therefore difficulties in streamlining authentication or changes.\n\nResilience: http request could fail and httpClient has no built-in retry or fault tolerant mechanism\n\nif not Singleton, each instance of HttpClient will open a new socket connection and on high traffic sites you can exhaust the available pool and receive a System.Net.Sockets.SocketException\n\nHowever, if Singleton, the HttpClient doesn‚Äôt respect DNS changes!\n\nWhy and how to use IHttpClientFactory?\n\nMicrosoft became aware of the challenges of httpClient and introduced HttpClientFactory.\n\nHere‚Äôs how it mitigates the httpClient issues:\n\nWhen an HttpClient object is not in use, it automatically goes back to the pool of unused object so it can be reused, mitigating socket exhaustion.\n\nSo instead of creating an httpClient for every request, it will reuse instances and therefore reducing the amount of httpClient objects\n\nAlso HttpClientFactory can define the lifetime, or how long a TCP connection remains open, using the ‚ÄúPooledConnectionLifetime‚Äù.\n\nHttpFactory configures all httpClient in one place ensuring consistency.\n\nHttpClientFactory integrates the features of Polly, a resilience and transient-fault handling library.\n\nBasically, it enables your API to be resent if it fails along with many other features to ensure that your APIs are fault tolerant.\n\nWe will delve deeper in the resiliency topic in the next section.\n\n#4 Register your httpClient for dependency injection (the example includes optional settings such as TimeOut)\n\nYou also need the client in constructor or add it as scoped!\n\nWhy and how to make your HttpClient generic?\n\nNow, let‚Äôs imagine you have to create several httpClients for different projects or even solutions. That would be a lot of copy pasting!\n\nThis sounds like something we could make generic :)\n\nWe‚Äôve created two different commands, one that Post R content, another that get content, could based on an id or a string\n\nNote that we will use SendAsync which is a generic method that expects the REST verb to be inputted in a HttpRequestMessage\n\nNow we have a generic class that implements both methods, let‚Äôs use them with specific classes!\n\n#3 httpClient with specific class, first the interface\n\nNotice that we indicate the REST verb in HttpRequestMessage\n\nHow to implement API Resilience in .Net?\n\nWhat if your API fails to reach the server because it was down for a few seconds?\n\nHow do track and ensure that your APIs make it succesfully and what do you do if that fails?\n\nAPI resilience is key for ensuring that your system is up and running!\n\nLet‚Äôs see how to implement it\n\n.Net 8 announced two new libraries based on Polly, a widely recognized open-source project that was used to achieve API resiliency.\n\nHere are the two NuGet packages that we will be using:\n\nüì¶ Microsoft.Extensions.Http.Resilience provides resilience mechanisms specifically for the HttpClient class.\n\nFor all the other .Net packages for resilient microservices introduced in .net 8 please see below blog\n\nUsing the two packages you basically have three options to achieve resiliency.\n‚Ä¢ Use StandardResilienceHandler: This will set standard resilience settings\n‚Ä¢ Use StandardHedgingHandler: This will apply standard resilience settings and make use of hedging\n‚Ä¢ Use AddResilienceHandler: This is best to customise your resilience settings\n\nSo when to use which?\n\nAs you can see it can be cumbersome to have a specific implementation for each client, therefore you can use the .AddStandardResilienceHandler();\n\nHere are the 5 policies implemented with the standard resilience handler\n\nHelps in controlling the rate at which API requests are sent, preventing overwhelming the endpoint.\n\nThe Standard-RateLimiter allows up to 1000 requests at a time, processes requests in ‚ÄúOldestFirst‚Äù order, with no limit on the queue, ensuring controlled access to the API.\n\nEnsures that requests don‚Äôt exceed a time limit to execute. This prevents long running or stuck requests from consuming resources.\n\nThe ‚ÄúStandard-TotalRequestTimeout‚Äù sets an overall timeout of 30 seconds for the entire request, including retries, ensuring that requests do not exceed this time limit to prevent long-running or stuck requests, enhancing the API‚Äôs responsiveness.\n\nMechanism to ensure that if the endpoint is online, the API request will be sent again.\n\nThe ‚ÄúStandard-Retry‚Äù strategy enables retries up to 3 times with an exponential backoff, introducing random delays of up to 2 seconds between retries for resilience in case of transient errors.\n\nIf too many requests fail, it will prevent others from being sent, this allows the system to recover and avoid overloading the endpoint/server.\n\nThe ‚ÄúStandard-CircuitBreaker‚Äù monitors failure ratios and blocks execution for 5 seconds if 10% of requests fail within a 30-second sampling window, preventing further requests to protect the system from potential overload.\n\nIf a request passes this threshold it will return an error, this will avoid requests from running indefinitely.\n\nThe ‚ÄúStandard-AttemptTimeout‚Äù strategy sets a timeout of 10 seconds for each individual request attempt, ensuring requests do not exceed this duration to prevent hanging or excessively long-running requests.\n\nFor the full list of standard values, please refer to this GitHub post.\n\nAs a side note, the documentation is mostly based on Polly, so have a look at the below for setting your values right!\n\nIn case we want to customise some values, we could still do this by doing the following!\n\nFor scenarios where we want to reduce high latencies, we could also use the .AddStandardHedgingHandler(), its only main difference with AddStandardResilienceHandler() is that instead of retries, it uses hedging.\n\nWhat hedging does is that it retries slow requests in parallel.\n\nIt is recommended to use hedging only for idempotent requests (aka GET). Indeed, Since it sends the same requests in parallel this could lead to issues in case of PUT, POST, PATCH (i.e. the same values being written twice).\n\nHere‚Äôs how it gets implemented with customised options but .AddStandardHedgingHandler() by itself is sufficient.\n‚Ä¢ If you do not get a succesful response after 50millisec, send another concurrent request\n‚Ä¢ Then pick the fastest succesful one\n\nEnables you to create your own customised settings.\n\nTo add a strategy to the pipeline, call any of the available extension methods on the instance.\n‚Ä¢ : Try again if something fails, which is useful when the problem is temporary and might go away.\n‚Ä¢ : Stop trying if something is broken or busy, which benefits you by avoiding wasted time and making things worse.\n‚Ä¢ : Give up if something takes too long, which can improve performance by freeing up resources.\n‚Ä¢ : Limit how many requests you accept, which enables you to control inbound load.\n‚Ä¢ : Limit how many requests you make, which enables you to control outbound load.\n‚Ä¢ : Do something else when experiencing failures, which improves user experience.\n‚Ä¢ : Issue multiple requests in case of high latency or failure, which can improve responsiveness.\n‚Ä¢ : Sets the length of time that a HttpMessageHandler instance can be reused. Each named client can have its own configured handler lifetime value. The default value is two minutes\n\nMicrosoft recommends having at least these 5 resilience policies:\n\n.Net to JSON: how to (de)Serialize?\n\nWhat is (de)Serializing in .Net?\n\nRest accepts many formats in request and response bodies, the most widely used is JSON (JavaScript Object NotationJavaScript Object Notation).\n\nSo if you want to send a request or read a response, you need to turn your C# into JSON or turn JSON into C#, which is called Serializing and turning JSON into C# is called Deserializing.\n\nWhich to use Newtonsoft.Json or System.Text.Json?\n\nNewtonsoft.Json used to be the most widely used Nuget package to do these operations, but Microsoft recently improved its own: system.text.json\n\nIt is recommended to use System.Text.Json one moving forward\n\nHow to (de)Serialize using JsonSerializer in C#?\n\nWhen printing the string, it might come as a list of strings, if you want to make it easier to ready (aka pretty-read) use the following option\n\nIt is recommended to customise the name of the JSON value-type using [JsonPropertyName(‚ÄúName‚Äù)]\n\nTo Deserialize you can use the Deserialize Method\n\nHow to (de)Serialize using HttpContent?\n\nHttpContent enables you to do the same than previously but with way less code!\n\nBasically the GetFromJsonAsync automatically deserialize the content into the given object.\n\nWhilst PostAsJsonAsync automaitcally will create JSON with the given object (e.g. user).\n\nHere is the example used by Microsoft\n\nAnd here applied to our piece of code\n\nWhy do I need to ReadStream my HttpResponse C#/.Net?\n\nIn our case, this will come from a HttpResponse Object so you will first need to do the following\n\nSo why do we use Stream to read an HttpResponse?\n\nWell, the data sent back as a response can be read in mutliple ways, one of them is to read them into Byte!\n\nWe can do so using the Stream class in C# which has multiple methods to work with these bytes, such as reading and writing them.\n\nUsing stream loads the data incrementally rather than at once into the memory. This greatly improves performance for large data payloads.\n\nThe alternative to Stream is the ReadAsStringAsync that basically returns a string first and then deserialize it into your object like so\n\nThis however doesn‚Äôt get the performance improvement of using Stream."
    },
    {
        "link": "https://stackoverflow.com/questions/27108264/how-to-properly-make-a-http-web-get-request",
        "document": "I am still new on c# and I'm trying to create an application for this page that will tell me when I get a notification (answered, commented, etc..). But for now I'm just trying to make a simple call to the api which will get the user's data.\n\nI'm using Visual studio express 2012 to build the C# application, where (for now) you enter your user id, so the application will make the request with the user id and show the stats of this user id.\n\nhere is the code where I'm trying to make the request:\n\nthe class is an object and its being accessed from the form by just parsing it the user id and make the request.\n\nI have tried many of the examples I have looked on google, but not clue why I am getting on all ways this message \"ÔøΩ\".\n\nI am new in this kind of algorithm, if anyone can share a book or tutorial that shows how to do this kind of stuff (explaining each step), I would appreciate it"
    },
    {
        "link": "https://stackoverflow.com/questions/7917290/making-and-receiving-an-http-request-in-c-sharp",
        "document": "I want to make my C# application to be able to send an http request and receive the answer at runtime\n\nan explanation from the website I want to request from is HERE\n\nI don't have any experience with that before, so I'm a little confused about the JSON, XML stuff I know I'll need an XML parser or something like this to understand the request"
    }
]