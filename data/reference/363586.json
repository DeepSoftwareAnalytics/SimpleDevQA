[
    {
        "link": "https://jsonlint.com/mastering-json-format",
        "document": "Mastering JSON Format: Advantages, Best Practices and Comparison with Other Data Formats\n\nJSON, standing for JavaScript Object Notation, is already a big player in today's era of data interchange. I'll delve into what makes JSON so standout. It's a text-based, language-independent format that allows for the easy and structured exchange of information. Boasting simplicity and being exceptionally lightweight, JSON is king when it comes to data transfer across your favorite web applications.\n\nOne undeniable charm of JSON is its compatibility. It's like that friend we all need ‚Äî flexible and gets along with everyone. Whether you're coding in Python, JavaScript, or C++, JSON functions seamlessly across these and many more languages. Importantly, its plain text nature makes it readable to both humans and machines.\n\nThe beauty of JSON lies in its structure. Information is stored in a \"key: value\" pair format, which in essence is like a collection of Lego blocks. These 'blocks' or data objects can be assembled in various ways to form meaningful data structures.\n\nAn example of a simple JSON object could be:\n\nThis structure makes JSON adaptable and extendable. You can add, modify, and delete key-value pairs without disrupting the system, offering unparalleled flexibility in data storage.\n\nIn addition to supporting these object structures, JSON also supports arrays (ordered sequence of values), which further simplifies complex data representation. For instance, if you wanted to add job details for John Doe, it‚Äôd look something like this:\n\nLeveraging the power of arrays and objects, JSON can efficiently store virtually any data structure. Indeed, it is the backbone that drives today's internet, actively shaping the ways we store, retrieve, and process data.\n\nLooking into the wonderful world of JSON, it's clear there are a multitude of benefits when using this format. Let's dive deeper into why JSON makes such a significant impact in data interchange.\n\nFirstly, simplicity and readability play a key role in JSON's popularity. The structure is easy-to-follow, mimicking a simple key-value pair that anyone, coder or not, can grasp. It's this simplicity that helps developers quickly read, write or edit the data - a feature that doesn't go unnoticed in the fast-paced world of technology.\n\nJSON also shines in its compatibility with various programming languages. Languages such as JavaScript, Python, Ruby and many others natively support JSON. What does this mean? Simply put, JSON can readily integrate with these languages without any need for additional libraries. Now that's efficient.\n\nAnother winning feature of JSON is its support for arrays and objects. This ability to handle complex data through a recognized syntax makes JSON superior in data representation to many other formats. Whether you're dealing with multi-level arrays or nested objects, JSON has you covered.\n\nOne more advantage of JSON to highlight is its lightweight nature. JSON's format, without the need for end tags or closing tags, leads to reduced data redundancy and less data overall. This means faster data transmission and smoother execution ‚Äì an essential requirement in today's digital age.\n\nIn this internet era, JSON's importance in shaping how data is stored, retrieved, and processed is undeniable. From simple inventory lists to intricate game data, JSON delivers with reliability and flexibility.\n\nAs we delve further into the nitty-gritty of JSON, it's paramount we draw comparisons between JSON and other data formats. Two main competitors of JSON that come to mind are XML and CSV. Understanding where JSON stands in relation to these will help define its unique value more accurately.\n\nXML, just like JSON, is human-readable and used widely for data exchange. But where JSON really shines is in its simplicity. Rather than the verbose and complex syntax of XML that can quickly clutter your screen, JSON stays minimal and clean, something I absolutely appreciate. JSON's format is also more condense which leads to quicker data transmissions.\n\nWell, then we have CSV. While it's true that CSV files are typically smaller, they lack the depth of JSON. In a CSV, it's challenging to represent hierarchical or multi-dimensional data. JSON, on the other hand, as we discussed earlier, has robust support for arrays and objects. It's like comparing a black-and-white photo to a 3D movie; the depth that JSON provides far outshines a mere CSV's capabilities.\n\nLet's not forget one of JSON's formidable advantages - compatibility with various programming languages. XML requires parsers to be readable in different programming languages, and CSV files often need custom parsing solutions, both of which can be cumbersome for developers. With JSON, that isn't necessary - it's supported natively in many programming languages, easing integration and reducing development time.\n\nBut before we lean too far into JSON's corner, it's worth mentioning that there are scenarios where other formats may be more suitable. Binary formats like Protobuf or Avro might provide better performance for massive or complex datasets. The world of data formats isn't black and white - there are shades of grey that give room for all, each with its own use cases.\n\nMoving forward, we'll dissect how JSON is leveraged in web development, and its role in shaping APIs. By highlighting its advantages and pointing out certain usage pitfalls, this deep dive into JSON seeks to arm you with the knowledge to efficiently utilize JSON in your own projects.\n\nUnderstanding the syntax is fundamental to appreciating JSON's beauty. It's this simplicity and readability that make JSON a desirable format. JSON structures data in name-value pairs, much like a JavaScript object. Yet, it's not limited to a particular set of programming languages. Its universal syntax is what allowed me to integrate it in various environments easily.\n\nThe first thing to look at is data types that JSON supports. It can handle simple data types like strings, numbers, and Booleans ‚Äì true or false. At the same time, it embraces compound types such as arrays and other JSON objects. Being adept with these data types can make the information representation more effective.\n\nLet's take a look at a JSON object:\n\nIn this JSON object, you can see different types of data. The name is a string, the age a number, isVaccinated a Boolean, and familyNames an array of strings.\n\nWhen it comes to arrays, they are enclosed in square brackets. Each value is separated by a comma. Here's an example of a JSON array:\n\nThis array represents a list of people, each person being a JSON object itself.\n\nNext, we'll discuss how the JSON format shapes the landscape of web development, and how it‚Äôs used in creating user-friendly and feature-rich APIs. For developers seeking to use JSON in their projects, gaining a good grasp of the format and its syntax will be time well spent.\n\nParsing JSON data is a crucial skill in web development, making it an area that I must delve into due to its immense importance. It's necessary to understand that the process varies depending on the programming language you're using. In this regard, let's look at parsing JSON data using two popular languages, JavaScript and Python.\n\nParsing in JavaScript is straightforward. JavaScript natively supports JSON through the JSON object. To parse JSON using JavaScript, developers use the JSON.parse() method, converting the JSON data into a JavaScript object.\n\nIn this JavaScript example, we are converting a JSON string into a JavaScript object using the JSON.parse method. The alert function then displays the name value, \"John\".\n\nParsing in Python, on the other hand, requires the python 'json' library. Developers invoke the json.loads() method to parse JSON data.\n\nIn our Python example, after importing the json module, we invoke the json.loads() function to parse the JSON data into a python dictionary. The print function then outputs the name value, which is \"John\".\n\nTake note that converting JSON data into another data structure (for instance, a Python dictionary or JavaScript object) is called deserialization. It's an essential part of using JSON format in web development, allowing you to process the data as per your needs. As you work with JSON, remember to keep the syntax rules in mind to ensure data integrity. The ease with which JSON integrates into your coding process is what makes it a front runner in data interchange formats.\n\nMoving onward, let's delve into a crucial element associated with JSON - that's right, we're talking about JSON schema validation. This integral feature of JSON ensures code standardization, guarantees the integrity of data, and promotes a smooth coding process.\n\nSo what is JSON schema validation? Essentially, it's a powerful tool that validates your JSON data and checks if it adheres to the predefined specifications. And yes, it does all of this before you import that data into your JavaScript or Python environments, saving you from potential headaches.\n\nHere's how it works. When you're transferring data between applications using JSON, the data structure should be predictable and standardized. JSON schema validation, as its name suggests, is like a blueprint or a model for your data. It outlines what your data should look like - what elements it should contain, what data types those elements should be, whether certain fields are required or optional, and even the acceptable range of values for certain elements.\n\nApplying JSON schema validation can significantly improve your overall coding experience. It enables you to catch and address inconsistencies and errors early on, reducing debugging efforts. It helps maintain consistent data structures across multiple applications, which really comes in handy for large-scale projects involving various teams.\n\nTake a look at this simple example of JSON schema:\n\nIn this example, the schema defines an object that needs to have two properties, and . should be a string, whereas should be an integer and cannot be a negative value.\n\nNow that we've understood the concept of JSON schema validation, we'll be moving onto another exciting topic- creating custom JSON schemas. This will require another deep dive and you'll need your concentration caps on for this one. So, let's proceed...\n\nBest Practices for Using JSON\n\nJSON format is intuitive and offers a lot of flexibility, but to get the most out of it, it's crucial to follow certain best practices. These practices streamline the coding process, aid readability and optimize data interchange.\n\nFirst, always keep the JSON structure clean and organized. JSON data is represented in name-value pairs, meaning proper structuring ensures data integrity. It's easy to fall prey to messy code when dealing with complex data, so I emphasize consistency and neatness.\n\nSecondly, utilize JSON schema validation to its fullest extent. As explained before, JSON schema validation ensures code standardization and aids in catching inconsistencies early. A well-implemented validation process helps maintain the robustness of data interchange.\n\nIn addition, when dealing with large strings of data, it's better to use arrays rather than multiple name-value pairs. Data arrays in JSON are simple to understand and can hold data more efficiently than multiple name-value pairs.\n\nWhen creating custom JSON schemas for complex data, remember to keep things as simple as possible. Simplicity is the key to meaningful data representation in JSON.\n\nBelow, I've compiled a basic guide to JSON best practices:\n‚Ä¢ Maintain clean, organized structure: Do this by using consistent name-value pairs and avoid nesting data unnecessarily.\n‚Ä¢ Use arrays for large strings of data: Arrays are easier to manage and are intuitive for other developers.\n\nThese practices don't just apply to JSON -- they're a solid foundation for any data interchange format. The true power of these principles shines through when they're used consistently throughout a project. Get into this habit, and you'll see a marked improvement in your coding efficiency. While working with JSON, you'll soon discover other practices that can boost your experience - shaping and tailoring these guidelines to your workflow is equally important.\n\nIn the next section, we'll delve into comparing JSON with other data interchange formats - looking at where JSON stands out and where it might not be the best option. That's for another discussion though, so let's place the bookmark here.\n\nSo we've seen how JSON's simplicity and readability make it a powerful tool for data interchange. Its schema validation feature is a game changer, ensuring code standardization and catching errors early. I've shared some best practices for using JSON, like maintaining a clean structure, using arrays for large data strings, and keeping schemas simple. Remember, these aren't exclusive to JSON and can be applied to other data interchange formats too. In the next section, we'll dive into how JSON stacks up against other data formats. Stay tuned!"
    },
    {
        "link": "https://nylas.com/blog/the-complete-guide-to-working-with-json",
        "document": "Securely integrate with every email, calendar, and contacts provider using a single interface to streamline your users‚Äô workflows. Build real-time, bi-directional communications in your app up to 40x faster, saving months of development time. Sync, send, and receive messages to build contextual email, automated outreach, and other in-app experiences. Retrieve and manage calendars and events to build scheduling automation, calendar management, and other scheduling experiences. Sync and manage contact details to build contact management and other contact experiences.\n\nEmbed email and scheduling in your CRM Simplify client communications and scheduling by seamlessly integrating with all email providers in your CRM, boosting customer interactions and team efficiency. Seamlessly elevate your real estate platform with Nylas‚Äô streamlined communication, data-driven client management, and automated virtual tour scheduling all in one place. Enhance your application tracking system with automated email and scheduling features that take the pain out of hiring. Boost document delivery while maintaining end-user trust with secure and reliable contextual email capabilities.\n\n‚ÄúAdding bi-directional email sync provides our users with a way to increase their productivity within the Crunchbase platform [while encouraging upsells to a new pricing tier with premium features]‚Äù ‚ÄúOne of the advantages of integrating with Nylas was how straightforward it was to sync contacts across multiple service providers and regardless of which version of Exchange our customers use.‚Äù Salesloft partners with Nylas to unlock new enterprise market ‚ÄúWe have millions of emails sent each week. Nylas frees us up to focus on delivering new features to our customers and working with our data science team on exciting new projects.‚Äù ‚ÄúBy partnering with Nylas we were able to solve technical obstacles that would‚Äôve taken us a lot longer on our own and required a much larger investment of resources.‚Äù"
    },
    {
        "link": "https://linkedin.com/advice/1/how-do-you-handle-complex-nested-data-structures-json",
        "document": ""
    },
    {
        "link": "https://rock-the-prototype.com/en/learn-programming/json",
        "document": "JSON is a text format. As a text-based data format, it is completely independent of programming languages. Why is JSON so easy to use? JSON is based on established conventions from widely used programming languages such as JavaScript, PythonJava and C++. This means that if you have already worked with one of these languages, you can understand JSON intuitively and use it directly. Thanks to its simple but powerful structure, JSON enables: ‚úÖ Quick understanding & easy readability: even without programming knowledge, JSON is intuitive to understand. ‚úÖ Seamless integration: JSON can be easily integrated into various programming languages and systems. ‚úÖ Efficient data processing: JSON is compact, reduces overhead and can be processed particularly quickly by modern applications. These advantages make JSON the preferred standard for data exchange in modern web, API and database applications. At the same time, a large number of software developers are already directly familiar with JSON concepts. All these properties together make JSON the ideal format for data exchange. How does JSON work for data exchange? JSON formats are based on two data structures: 1. name and value pairs In various programming languages, a combination of a name with a value pair is called a In most languages, ordered lists of values are called These structures make it possible to display data hierarchically and modularly.\n\nBoth are universal JSON data structures that are therefore supported by almost all modern programming languages. JSON structures enable us programmers to use a data format that is interchangeable between programming languages and is also based on these familiar structures. A JSON object is an unordered set of name/value pairs.\n‚Ä¢ Each object begins with curved bracket open and ends with curved bracket close.\n‚Ä¢ Each name is followed by a colon followed by the value and\n‚Ä¢ The individual name/value pairs are separated from each other by comma. An array is an ordered list of values.\n‚Ä¢ Arrays begin with squarebracket open and end with squarebracket close.\n‚Ä¢ Values are separated from each other by comma. A value can be an object, an array, a string, a number or one of the expressions , or be. These structures can be nested within one another. A string is a character string and consists of no (empty character string) or more Unicode characters.\n‚Ä¢ Each string is enclosed in double quotation marks.\n‚Ä¢ A character string can contain escape sequences with a special meaning.\n‚Ä¢ A single character is represented by a character string consisting of only one character.\n‚Ä¢ A JSON string is very similar to one in C or Java. A number in JSON format is very similar to a number in C or Java, with the exception that octal and hexadecimal numbers are not used. JSON applications you should know:\n‚Ä¢ Web APIs: Here it enables seamless communication between server and client.\n‚Ä¢ Databases: In NoSQL databases such as MongoDB, JSON documents are stored as native data structures.\n‚Ä¢ Data visualization: JSON files are often used as input for tools such as D3.js. The JSON format is the established standard for most REST APIs, as it is easy to serialize and parse. Example:\n\nThe Rock the Prototype Podcast and the Rock the Prototype YouTube channel are the perfect place to go if you want to delve deeper into the world of web development, prototyping and technology. In the podcast, you can expect exciting discussions and valuable insights into current trends, tools and best practices ‚Äì ideal for staying on the ball and gaining fresh perspectives for your own projects. On the YouTube channel, you‚Äôll find practical tutorials and step-by-step instructions that clearly explain technical concepts and help you get straight into implementation. üöÄ Rock the Prototype is üëâ Your format for exciting topics such as software development, prototyping, software architecture, cloud, DevOps & much more. THINK PROTOTYPING ‚Äì PROTOTYPE DESIGN ‚Äì PROGRAM & GET STARTED ‚Äì JOIN IN NOW! Why is it worth checking back regularly? Both formats complement each other perfectly: in the podcast, you can learn new things in a relaxed way and get inspiring food for thought, while on YouTube you can see what you have learned directly in action and receive valuable tips for practical application. Whether you‚Äôre just starting out in software development or are passionate about prototyping, UX design or IT security. We offer you new technology trends that are really relevant ‚Äì and with the Rock the Prototype format, you‚Äôll always find relevant content to expand your knowledge and take your skills to the next level!"
    },
    {
        "link": "https://stackoverflow.com/questions/24020694/complex-json-data-structure-best-practice",
        "document": "I would like to know which of JSON data structure is simpler and more convenient for REST API consumers.\n\nSuppose, we have POST method, which require complex data structure in request body. Which of structures is more preferable? They are equavalent.\n\nOn one hand, first example may simpler for consumer. On other hand, second example is shorter and don't contain property names."
    },
    {
        "link": "https://makimo.com/blog/scientific-perspective-on-naming-in-programming",
        "document": "Many programmers are struggling with questions such as:\n‚Ä¢ what are the rules for naming a variable, class or a function?\n‚Ä¢ what are the variable naming conventions in Python, JavaScript or any other language?\n‚Ä¢ how to name a class or how to name a class method in Java or any other object-oriented language?\n\nIn fact, naming things in programming to convey its meaning in a precise fashion is an arduous task, often requiring much thought and years of experience. But fret not ‚Äì if you are an aspiring software developer, this skill will bring you a lot of value working with other developers on smaller and bigger projects.\n\nHow to read this article\n\nThis article is divided into two chapters.\n‚Ä¢ The first one, starting with section ‚ÄúIntroduction to naming in programming‚Äù presents a review of scientific literature present on the topic. That section will deepen your understanding of the current body of knowledge on naming things.\n‚Ä¢ The second chapter, starting with section ‚ÄúGuidelines for naming conventions in programming‚Äù presents actionable recommendations to improve your skills in choosing thoughtful class, function or variable names. If you‚Äôre looking for tips, go there.\n\nNaming is an essential but grossly underrated skill. Every programmer faces the problem of finding good names on a daily basis. According to one study which analyzed Eclipse source code, about 70% of code is made up of names [1]. Caprile et al. state that ‚ÄúidentiÔ¨Åer names are one of the most important sources of information about program entities‚Äù [2]. Hence, good naming is necessary for the code to be readable and maintainable ( imagine trying to understand a program in which identifiers were replaced with random strings). Yet, few programming textbooks and university courses discuss the topic beyond a few syntactic do‚Äôs and don‚Äôts. Vague rules such as ‚Äúidentifiers should be self-describing‚Äù are not explained and are hard to follow, especially for novices. Ironically, studies show that beginners are especially reliant on good names, as more experienced developers are better at reading contextual cues [3]. Moreover, ‚Äògiven the importance of identiÔ¨Åer naming, several re¬≠search projects have considered the issue of identiÔ¨Åer nam¬≠ing conventions. Naming conventions are important be¬≠cause ‚Äústudies of how people name things (in general not just in code) have shown that the probability of having two people apply the same name to an object is between 7% and 18%, depending on the object‚Äù [4].‚Äô While developers agree that naming matters, they adhere to different conventions and disagree on critical aspects such as acceptable names lengths. Very few use written guidelines or consult empirical evidence.\n\nThis article aims to discuss the results of the psychological research on naming and present a summary of naming guidelines based on current literature and the author‚Äôs own experience. It‚Äôs also meant to be used as a reference to help improve code style and inform code reviews. The Markdown version (without the introduction) is available at the bottom of the article. We also provide references and further reading.\n\nWhat is naming in programming?\n\nIn the context of computer programming, naming is the act of assigning identifying labels to programmatic constructs. It can be conceptualized as a process of expressing meaning or purpose as concisely and unambiguously as possible without revealing the underlying implementation. However, unlike in natural languages where speakers share a vast, mutually understood, but fairly fixed lexicon, naming in programming makes the intensive use of invented words. Liblit et al. point out that ‚Äúcompilers have no understanding of natural language, so ‚Äúblue‚Äù and ‚ÄúSgu9Asd1M‚Äù are equally opaque, arbitrary sequences of letters. Provided that the programmer uses consistent spelling and capitalization, any name is as good as any other. Yet precisely because names are arbitrary, programmers have great freedom to select names that promote code understanding. [6]‚Äù\n\nResearch into the cognitive processes that underlie language and text comprehension shows that the semantics of words is key to understanding [1]. In other words, names guide the psychological processes of understanding the code. Arnaoudova et al. explain: ‚ÄòIn his theory about program understanding, Brooks considers identifiers and comments as part of the internal indicators for the meaning of a program. Brooks presents the process of program understanding as a top-down hypothesis-driven approach, in which an initial and vague hypothesis is formulated ‚Äî based on the programmer‚Äôs knowledge about the program domain or other related domains ‚Äî and incrementally refined into more specific hypotheses based on the information extracted from the program lexicon. While trying to refine or verify the hypothesis, sometimes developers inspect the code in detail, e.g., check the comments against the code. [5]‚Äô\n\nMeaning and structure of names in programming\n\nNaming is a form of communication, be it between the author and herself or between the author and other programmers. The goal of a name is to communicate the author‚Äôs intent, the behaviour of something (name‚Äôs referent), its usage, significance, role or concept. Bad names obviously make the dialogue harder, but how good names convey meaning? In general, we deal with two types of entities: objects* and functions. In the case of objects, the problem is straightforward; we use a noun and optionally an adjective:\n\nA function name, on the other hand, stands for a group of statements to be executed (in imperative languages) or a composition of expressions (in functional languages) to be evaluated. Therefore, the name will express the implied action, side-effect or value by including a verb ‚Äî ‚Äúdo this!‚Äù. This is the case even in purely functional languages such as Haskell. Typically, a name will use the imperative mood with the second-person subject (e.g. calculateNumberOfCars), so the general form is a verb plus optional object.\n\nTypically there is little reason to deviate from this form, but there are, of course, exceptions, such as names of callbacks, e.g. on_widget_loaded, boolean functions ‚Äî is_user_authorized of transformations ‚Äî to_binary. However, even in those cases, the verb is often implied as we can see in previous examples: (do)_on_widget_loaded, (check)_is_user_authorized, (convert)_to_binary.\n\nCaprile and Tonella, based on the analysis of a few large open-source code-bases, defined a formal grammar describing function identifiers. In it, they identified six main name forms [7]:\n\nThe following table, taken from the paper, illustrates the number of occurrences for the top twenty verbs used in bash‚Äôs source code:\n\nConcision ‚Äì on long and short variable and function names\n\nNames are layers of indirection, separating essential features of what things are, or what they do, from the unnecessary details. They work very similarly to interfaces or abstract types in that their primary role is to express an abstract concept. ‚ÄúLayers of indirection can be peeled away incrementally, allowing us to work within a codebase without understanding its entirety. Without indirection, we‚Äôd be unable to write software longer than a few hundred lines.‚Äù [8] A perfectly concise name expresses the concept that needs to be understood by the reader, nothing more, nothing less. Revealing (or leaking) implementation is not only harmful because it leads to tight coupling, but it can also make the meaning harder to grasp. Let‚Äôs consider the following example:\n\nThe second name is precise and technically correct but also meaningless. Yes, the value of a variable is an integer, but what is its purpose? Let‚Äôs consider another example:\n\nThe further we get from this line of code, the higher the risk that someone may be confused by the variable‚Äôs name if she doesn‚Äôt know that blowfish is a cypher. Probably ‚ÄúcypherFn‚Äù or ‚ÄúcypherFunction‚Äù would be a better alternative ‚Äî this one is too specific.\n\nAnother aspect of conciseness is length. Unsurprisingly, studies show that single-letter abbreviations are terrible for comprehensibility, and longer names are better, but up to a point. Names that are too long can crowd a programmer‚Äôs short-term memory.\n\n‚ÄúThe study [‚Ä¶] shows that better comprehension is achieved when full-word identifiers are used rather than short (virtually) meaningless identifiers. It also shows that in many cases abbreviations are just as useful as the full-word‚Äù. [9]\n\nOn the other hand, it is more difficult to read and remember long variable names. This, in turn, suggests that software engineers are more productive when they can minimize the length of identifiers while preserving the use of full-words or carefully choosing abbreviations. Extraneous characters which increase the length of an identifier (e.g., ‚Äúits‚Äù in the attribute ‚ÄúitsHeight‚Äù or the use of Hungarian notation) make recall harder. Binkley at al. point out that ‚Äústatistical models derived from an experiment involving 158 programmers of varying degrees of experience show that longer names extracted from production code take more time to process and reduce correctness in a simple recall activity‚Äù and that ‚Äúmaximal comprehension occurs when the pressure to create longer more expressive names is balanced against limited programmer short-term memory.‚Äù [10]\n\nIn general, if it‚Äôs difficult to express the meaning in a few words it probably means that we have a problem with our program‚Äôs structure and should break something down into smaller components. For example, function findArticlesWithoutTitlesThenApplyDefaultStyles should be broken down into findArticlesWithoutTitles and applyDefaultStyles. Similarly, functions such as:\n\ncould be broken into following methods:\n\nIn general, if there‚Äôs a shorter but descriptive way to name the entity, then the name is too long and if the name is not easily reducible, then there‚Äôs probably a problem in technical design.\n\nAs we saw, one source of ambiguity are names that are too specific or too general. Other common problems include abbreviations, homonyms and synonyms. Studies clearly show that abbreviations negatively impact code comprehensibility. Compare the following two code fragments:\n\nOnly exceptions to this are abbreviations that are very well known or pretty much universal, such as auth, id, or sqrt. Some languages have specific abbreviations which are pretty much reserved, such as m for map and k for key in Clojure, so there is little reason for confusion, except for novices. In the following example, which takes advantage of well-established mathematical conventions, the abbreviated version is clearly more readable:\n\nWhat about one-letter indices? Indices such as i or j, are reasonably well-known, especially in languages that heavily use traditional loops, such as C. However, in modern languages, there is usually little reason to use them over higher-order functions such as map, forEach or for <name> in <collection>, which avoid indices altogether. Moreover, even though it should be immediately apparent that i and j are indices, it‚Äôs still very easy to mix them up because two letters are so similar to each other.\n\nHomonyms are words with multiple meanings, such as ‚Äúbark‚Äù, ‚Äúdie‚Äù, or ‚Äúspring‚Äù. Studies on comprehension of ambiguous sentences resulting from the presence homonyms have shown that readers who encounter homonyms experience slower comprehension. This is due to the mentally activiting various meanings of words [14].\n\nThe problem is especially subtle in programming because we rarely encounter homonyms from entirely different domains such as for a word ‚Äúcurrent‚Äù, which normally means ‚Äúbelonging to the present time‚Äù, not ‚Äúa body of water or air moving in a definite direction‚Äù. More likely, a source of confusion are names which by convention can refer to multiple different things such as ‚Äúfile‚Äù, which can mean file handle, filename, file path or simply contents of the file.\n\nSynonyms are problematic when the same objects are inconsistently named in different places with different synonyms, such as using ‚Äúcluster‚Äù in one place and ‚Äúgroup‚Äù in another. The reader won‚Äôt be sure whether the names refer to the same thing. This usually comes up when different programmers work in parallel on the same features and choose distinct names (which happens often).\n\nDeissenboeck and Pizka defined a formal model to express and validate precisely what does it mean for a name to be correct, consistent and concise [1]. In their model, greatly simplifying, they recognize concepts, names for the concepts, program entities and identifiers of program entities. Within the model, consistency (lack of synonyms and homonyms) means that there is a 1:1 correspondence, i.e. unique relation, between concept names and concepts themselves. On the other hand, correctness means that the identifier of a program entity that manifests a concept must correspond to the unique name of the concept or one of more general concepts. This rule makes sure that identifier names don‚Äôt become completely meaningless or incorrect. Let‚Äôs take, for example, a function called p, which returns a permutation of a set of elements. Because p is neither the name of the concept of permutation nor of a generalization of it, the identifier violates the correctness rule. A wrong identifier, such as load, would also be disqualified. However, correctness is not enough to make transformation an invalid identifier. It corresponds to the name of a generalization of the concept, but it is only of limited assistance for the reader. This is a very common problem: identifiers are often correct, but not concise enough [1]. Conciseness, therefore, requires that an identifier has exactly the same name as the concept it stands for, no generalizations allowed. In our example, only permutation would be a correct and concise name for the function p.\n\nIn summary, a name can be:\n‚Ä¢ i.e. too long or consisting of too many words to read at a glance\n‚Ä¢ i.e. an abbreviation that is unobvious\n\n4. Inconsistent, i.e. expressing already-named concept using a different name\n\nOne reason for poor naming may be related to the hindsight bias ‚Äî the ‚Äúcurse of knowledge‚Äù [12]. It‚Äôs a phenomenon where people already with the knowledge of something have a hard time imagining they don‚Äôt possess it. When you‚Äôre an expert, something that is hard and unobvious for your less-experienced colleagues seems trivial to you, which leads to a handicap in estimating the difficulty the novices will face.\n\nIn the context of naming, this may lead to a situation where the name seems good at the time because the programmer has all the contextual knowledge fresh in their working memory. However, the name is only tested when the reader has to use it for cueing memory retrieval or for guiding new memory formation. In other words, we are destined to be poor judges of our own names. When writing the code, most esoteric abbreviations and most generic names will seem evident because we already know what they mean. One solution to this problem is, of all things, compassion. Always ask yourself: ‚Äúwould a junior programmer understand this?‚Äù.\n\nDeissenboeck and Pizka also point out that ‚Äúamongst others, there are three important reasons for the inappropriate naming of identifiers encountered in numerous codebases:\n‚Ä¢ Identifiers can be arbitrarily chosen by developers and elude automated analysis.\n‚Ä¢ Developers have only limited knowledge about the names already used somewhere else in the system.\n‚Ä¢ Identifiers are subject to decay during system evolution. The concepts they refer to are altered or abandoned without properly adapting the names. One reason for this is the lack of tool support for globally renaming sets of identifiers referring to the same concept.\n\nDue to 3 naming deficiencies can not solely be explained as a result of neglect by careless programmers. It is indeed practically impossible to preserve globally consistent naming during long-term development efforts, maintenance, or evolution without additional tools. Note, in contrast to a rather simpler name refactoring all identifiers names referring to a concept must be found and renamed consistently each time the concept itself changes. [1]‚Äù Finally, as we said earlier, the probability of having two people apply the same name to an object is very low.\n\nBelow, we present a summary of naming guidelines based on current literature, specifically a catalogue of linguistic antipatterns proposed by Arnaoudova et al. [13] and guidelines compiled by Hilton [14] and us. The relevance of some rules depends on the paradigm or community consensus, which should, in general, override any rules posted here.\n\nConsistency in naming makes reading and memory retrieval much, much easier. Conversely, changing rules and mixing conventions are very confusing and significantly increase cognitive load. Follow language, company, and project conventions for names, even if you don‚Äôt like them.\n\nMost programming languages have stylistic conventions for writing names ‚Äì if not official, most communities provide their own. Use language-specific code linters to check the code.\n\nOnly use words and abbreviations that are in the dictionary. Use abbreviations and acronyms only if everyone knows what they mean. Make exceptions for abbreviations such as and other well-known or documented domain-specific abbreviations. Names can become confusing if spelling errors are made, especially inconsistently. In general, abbreviations, if not well-known, add further ambiguity.\n‚Ä¢ Avoid neologisms and slang.\n\nUse existing, well-known names, especially if your team is not all native English speakers.\n‚Ä¢ Avoid letter-only names.\n\nEspecially single-letter names. Yes, this counts for loops too. Unless you‚Äôre using C, there is little reason for using manual loops anyway, as most languages support functional iteration.\n‚Ä¢ Avoid esoteric abbreviations and acronyms.\n\nEspecially arbitrary ones you too will forget in five minutes. Example:\n\nThis will make it easier for your brain to remember them.\n‚Ä¢ Avoid special symbols.\n\nMake exception for in snake case and other special conventions. For example, and are valid function identifiers in Scala, colloquially named fish and space ship. In Clojure, function is a well-known ‚Äúthread-first‚Äù macro (together with , ‚Äúthread-last‚Äù macro‚Äù).\n‚Ä¢ Only use underscores between words (and other symbols).\n\nExample violation: or .\n‚Ä¢ Only use one underscore at a time.\n\nException: In Python, double underscore indicates special method defined by the Python language, e.g. .\n\nNo hard rules here; use your good judgement. In general:\n‚Ä¢ Limit name word count (<= 4). Avoid unnecessary context and keep your name length to a maximum of four words. Names should be limited to the maximum number of words people can read at a glance.\n‚Ä¢ Limit character length. Keep name length within 20 characters.\n‚Ä¢ Non-reducible longer length name marks a problem in technical design in most cases. For example:\n\n1.6 Make sure names are hard to mix up\n‚Ä¢ Make names differ by more than word order.\n\nFor example, and in the same lexical context would be very easy to mix up.\n‚Ä¢ Avoid numeric suffixes. Do not add numbers to multiple identifiers that share the same base name, e.g:\n\nDon‚Äôt rewrite a value as a name; name what the value represents. Replace number names with either domain-specific terms, such as , or a name that describes the concept that the number represents, such as . However, don‚Äôt define constants for values which don‚Äôt have names and/or are not special:\n\nMake sure that a name is not:\n‚Ä¢ too specific\n‚Ä¢ too long or consisting of too many words to read at a glance\n‚Ä¢ too ambiguous\n‚Ä¢ an abbreviation that is unobvious to a junior\n‚Ä¢ inconsistent, i.e. expressing an already-named concept using a different name.\n‚Ä¢ Use large vocabulary to avoid homonyms and synonyms.\n\n can be replaced with , , or , according to it‚Äôs specific meaning. If you‚Äôre trying to express the concept of ‚Äúperimeter‚Äù, use identifier instead of\n‚Ä¢ At the same time, make sure you‚Äôre consistent in your naming and not using too exoteric words, especially if the team is not speaking English natively.\n‚Ä¢ Use problem domain terms.\n\nPrefer terms which relate to the problem the software is solving or that the client is using.\n‚Ä¢ Be specific.\n\nAvoid abstract and generic words like it, everything, data, handle, stuff, do, routine, perform. Examples:\n‚Ä¢ Abbreviate with care.\n\nAs a rule of thumb, if you‚Äôre not sure if a junior in your team knows particular abbreviation, it‚Äôs a good idea to skip it. Also, watch whether the abbreviation is ambigous. Examples:\n‚Ä¢ Use standard, neutral language.\n\n is better than or .\n‚Ä¢ Make names differ in meaning\n\nNames like input and , and and can be easily confused if used in the same lexical context:\n\nThe name should express precisely what needs to be understood by the reader, nothing more. Avoid overspecifying meaning; treat names as kind-of generic interfaces ‚Äì boil down the essence of what something is, identify and remove all that is not essential or can change. Leaking implementation is bad because it increases noise in the code and the coupling between different objects (in this case, between statements or expressions that use an overspecified term).\n‚Ä¢ Keep name‚Äôs meaning relevant to the semantics in its immediate context, nothing more. For example, if you‚Äôre working with in-memory key-value database such as Redis, then probably your business logic shouldn‚Äôt know all the details about its client object, such as that it is in-memory or Redis specficially. Then the would be a better name than or .\n‚Ä¢ Omit type information, except for prefix for Booleans. Generally, it‚Äôs a good idea to avoid Hungarian like notations which leak the type of object, but the problem with Booleans such as is that ‚Äúactive‚Äù on its own can be confused with an adjective with an implied noun ‚Äì ‚Äúactive something‚Äù instead of ‚Äúis something active?‚Äù. Booleans don‚Äôt generally change types to non-Booleans, so it‚Äôs a safer and more readable option.\n‚Ä¢ should only return Boolean.\n\nMethods starting with , e.g. should return or , nothing else, and should not produce side-effects.\n‚Ä¢ method shouldn‚Äôt return anything.\n\nSetter methods imply that their result is a side-effect (of setting some variable) ‚Äì returning something is confusing and counter-intuitive.\n‚Ä¢ should return something.\n\nBy convention, getter methods should always return something. Example violation: method sets the state of some global variable and doesn‚Äôt return anything.\n‚Ä¢ Predicates should answer question.\n\nMethod names in form of a predicate (e.g. ) should return a Boolean, not a or an object. Example violation: attribute of type where the declared type and values are not documented.\n‚Ä¢ Use Boolean variable names that imply true or false.\n\nIf method or a variable is of Boolean type, its name should suggest so, e.g. .\n‚Ä¢ Don‚Äôt use , or prefixes for functions with side-effects.\n\nThose words don‚Äôt imply or suggest that side-effects can‚Äôt happen, so the reader cannot assume that they will happen. If they do, it will probably be surprising to the reader.\n‚Ä¢ Method name and behavior should be consistent.\n\nFor example, the result of calling function should be a side-effect of disabling something, not, for example, returning object or function which can disable something.\n‚Ä¢ Attribute name and type should be consistent.\n\nExample violation: attribute is of type .\n‚Ä¢ Match plurality.\n\nIf an attribute is of collection type, its name should reflect that, e.g. instead of . Use plural nouns for function names which work on collections, e.g. instead of and return collections if name suggests so.\n‚Ä¢ Don‚Äôt contradict comments. Keep them up to date."
    },
    {
        "link": "https://en.wikipedia.org/wiki/Naming_convention_(programming)",
        "document": "Set of rules for naming entities in source code and documentation\n\nIn computer programming, a naming convention is a set of rules for choosing the character sequence to be used for identifiers which denote variables, types, functions, and other entities in source code and documentation.\n\nReasons for using a naming convention (as opposed to allowing programmers to choose any character sequence) include the following:\n‚Ä¢ To reduce the effort needed to read and understand source code; 1\n‚Ä¢ To enable code reviews to focus on issues more important than syntax and naming standards.\n‚Ä¢ To enable code quality review tools to focus their reporting mainly on significant issues other than syntax and style preferences.\n\nThe choice of naming conventions can be a controversial issue, with partisans of each holding theirs to be the best and others to be inferior. Colloquially, this is said to be a matter of dogma.[2] Many companies have also established their own set of conventions.\n\nBenefits of a naming convention can include the following:\n‚Ä¢ to provide additional information (i.e., metadata) about the use to which an identifier is put;\n‚Ä¢ to help formalize expectations and promote consistency within a development team;\n‚Ä¢ to enable the use of automated refactoring or search and replace tools with minimal potential for error;\n‚Ä¢ to enhance clarity in cases of potential ambiguity;\n‚Ä¢ to enhance the aesthetic and professional appearance of work product (for example, by disallowing overly long names, comical or \"cute\" names, or abbreviations);\n‚Ä¢ to help avoid \"naming collisions\" that might occur when the work product of different organizations is combined (see also: namespaces);\n‚Ä¢ to provide meaningful data to be used in project handovers which require submission of program source code and all relevant documentation;\n‚Ä¢ to provide better understanding in case of code reuse after a long interval of time.\n\nThe choice of naming conventions (and the extent to which they are enforced) is often a contentious issue, with partisans holding their viewpoint to be the best and others to be inferior. Moreover, even with known and well-defined naming conventions in place, some organizations may fail to consistently adhere to them, causing inconsistency and confusion. These challenges may be exacerbated if the naming convention rules are internally inconsistent, arbitrary, difficult to remember, or otherwise perceived as more burdensome than beneficial.\n\nWell-chosen identifiers make it significantly easier for developers and analysts to understand what the system is doing and how to fix or extend the source code to apply for new needs.\n\nFor example, although\n\nis syntactically correct, its purpose is not evident. Contrast this with:\n\nwhich implies the intent and meaning of the source code, at least to those familiar with the context of the statement.\n\nExperiments suggest that identifier style affects recall and precision and that familiarity with a style speeds recall.[3]\n\nThe exact rules of a naming convention depend on the context in which they are employed. Nevertheless, there are several common elements that influence most if not all naming conventions in common use today.\n\nFundamental elements of all naming conventions are the rules related to identifier length (i.e., the finite number of individual characters allowed in an identifier). Some rules dictate a fixed numerical bound, while others specify less precise heuristics or guidelines.\n\nIdentifier length rules are routinely contested in practice, and subject to much debate academically.\n‚Ä¢ shorter identifiers may be preferred as more expedient, because they are easier to type (although many IDEs and text-editors provide text-completion, which mitigates this)\n‚Ä¢ extremely short identifiers (such as 'i' or 'j') are very difficult to uniquely distinguish using automated search and replace tools (although this is not an issue for regex-based tools)\n‚Ä¢ longer identifiers may be preferred because short identifiers cannot encode enough information or appear too cryptic\n‚Ä¢ longer identifiers may be disfavored because of visual clutter\n\nIt is an open research issue whether some programmers prefer shorter identifiers because they are easier to type, or think up, than longer identifiers, or because in many situations a longer identifier simply clutters the visible code and provides no perceived additional benefit.\n\nBrevity in programming could be in part attributed to:\n‚Ä¢ early linkers which required variable names to be restricted to 6 characters to save memory. A later \"advance\" allowed longer variable names to be used for human comprehensibility, but where only the first few characters were significant. In some versions of BASIC such as TRS-80 Level 2 Basic, long names were allowed, but only the first two letters were significant. This feature permitted erroneous behaviour that could be difficult to debug, for example when names such as \"VALUE\" and \"VAT\" were used and intended to be distinct.\n‚Ä¢ much of computer science originating from mathematics, where variable names are traditionally only a single letter\n\nSome naming conventions limit whether letters may appear in uppercase or lowercase. Other conventions do not restrict letter case, but attach a well-defined interpretation based on letter case. Some naming conventions specify whether alphabetic, numeric, or alphanumeric characters may be used, and if so, in what sequence.\n\nA common recommendation is \"Use meaningful identifiers.\" A single word may not be as meaningful, or specific, as multiple words. Consequently, some naming conventions specify rules for the treatment of \"compound\" identifiers containing more than one word.\n\nAs most programming languages do not allow whitespace in identifiers, a method of delimiting each word is needed (to make it easier for subsequent readers to interpret which characters belong to which word). Historically some early languages, notably FORTRAN (1955) and ALGOL (1958), allowed spaces within identifiers, determining the end of identifiers by context. This was abandoned in later languages due to the difficulty of tokenization. It is possible to write names by simply concatenating words, and this is sometimes used, as in for Java package names,[4] though legibility suffers for longer terms, so usually some form of separation is used.\n\nOne approach is to delimit separate words with a non-alphanumeric character. The two characters commonly used for this purpose are the hyphen (\"-\") and the underscore (\"_\"); e.g., the two-word name \" \" would be represented as \" \" or \" \".\n\nThe hyphen is used by nearly all programmers writing COBOL (1959), Forth (1970), and Lisp (1958); it is also common in Unix for commands and packages, and is used in CSS.[5] This convention has no standard name, though it may be referred to as lisp-case or COBOL-CASE (compare Pascal case), kebab-case, brochette-case, or other variants.[6][7][8][9] Of these, kebab-case, dating at least to 2012,[10] has achieved some currency since.[11][12]\n\nBy contrast, languages in the FORTRAN/ALGOL tradition, notably languages in the C and Pascal families, used the hyphen for the subtraction infix operator, and did not wish to require spaces around it (as free-form languages), preventing its use in identifiers.\n\nAn alternative is to use underscores; this is common in the C family (including Python), with lowercase words, being found for example in The C Programming Language (1978), and has come to be known as snake case or snail case. Underscores with uppercase, as in UPPER_CASE, are commonly used for C preprocessor macros, hence known as MACRO_CASE, and for environment variables in Unix, such as BASH_VERSION in bash. Sometimes this is humorously referred to as SCREAMING_SNAKE_CASE (alternatively SCREAMING_SNAIL_CASE).\n\nAnother approach is to indicate word boundaries using medial capitalization, called \"camelCase\", \"PascalCase\", and many other names, thus respectively rendering \" \" as \" \" or \" \". This convention is commonly used in Pascal, Java, C#, and Visual Basic. Treatment of initialisms in identifiers (e.g. the \"XML\" and \"HTTP\" in ) varies. Some dictate that they be lowercase (e.g. ) to ease typing, readability and ease of segmentation, whereas others leave them uppercased (e.g. ) for accuracy.\n\nSome naming conventions represent rules or requirements that go beyond the requirements of a specific project or problem domain, and instead reflect a greater overarching set of principles defined by the software architecture, underlying programming language or other kind of cross-project methodology.\n\nPerhaps the most well-known is Hungarian notation, which encodes either the purpose (\"Apps Hungarian\") or the type (\"Systems Hungarian\") of a variable in its name.[17] For example, the prefix \"sz\" for the variable szName indicates that the variable is a null-terminated string.\n\nA style used for very short (eight characters and less) could be: LCCIIL01, where LC would be the application (Letters of Credit), C for COBOL, IIL for the particular process subset, and the 01 a sequence number.\n\nThis sort of convention is still in active use in mainframes dependent upon JCL and is also seen in the 8.3 (maximum eight characters with period separator followed by three character file type) MS-DOS style.\n\nIBM's \"OF Language\" was documented in an IMS (Information Management System) manual.\n\nIt detailed the PRIME-MODIFIER-CLASS word scheme, which consisted of names like \"CUST-ACT-NO\" to indicate \"customer account number\".\n\nPRIME words were meant to indicate major \"entities\" of interest to a system.\n\nMODIFIER words were used for additional refinement, qualification and readability.\n\nCLASS words ideally would be a very short list of data types relevant to a particular application. Common CLASS words might be: NO (number), ID (identifier), TXT (text), AMT (amount), QTY (quantity), FL (flag), CD (code), W (work) and so forth. In practice, the available CLASS words would be a list of less than two dozen terms.\n\nCLASS words, typically positioned on the right (suffix), served much the same purpose as Hungarian notation prefixes.\n\nThe purpose of CLASS words, in addition to consistency, was to specify to the programmer the data type of a particular data field. Prior to the acceptance of BOOLEAN (two values only) fields, FL (flag) would indicate a field with only two possible values.\n\nAdobe's Coding Conventions and Best Practices suggests naming standards for ActionScript that are mostly consistent with those of ECMAScript.[citation needed] The style of identifiers is similar to that of Javascript.\n\nIn Ada, the only recommended style of identifiers is .[18]\n\nIn APL dialects, the delta (Œî) is used between words, e.g. PERFŒîSQUARE (no lowercase traditionally existed in older APL versions). If the name used underscored letters, then the delta underbar (‚çô) would be used instead.\n\nIn C and C++, keywords and standard library identifiers are mostly lowercase. In the C standard library, abbreviated names are the most common (e.g. for a function testing whether a character is alphanumeric), while the C++ standard library often uses an underscore as a word separator (e.g. ). Identifiers representing macros are, by convention, written using only uppercase letters and underscores, for example and (this is related to the convention in many programming languages of using all-upper-case identifiers for constants). Names containing double underscore or beginning with an underscore and a capital letter are reserved for implementation (compiler, standard library) and should not be used (e.g. or ).[19][20] This is superficially similar to stropping, but the semantics differ: the underscores are part of the value of the identifier, rather than being quoting characters (as is stropping): the value of is (which is reserved), not (but in a different namespace).\n\nC# naming conventions generally follow the guidelines published by Microsoft for all .NET languages[21] (see the .NET section, below), but no conventions are enforced by the C# compiler.\n\nThe Microsoft guidelines recommend the exclusive use of only and , with the latter used only for method parameter names and method-local variable names (including method-local values). A special exception to PascalCase is made for two-letter acronyms that begin an identifier; in these cases, both letters are capitalized (for example, ); this is not the case for longer acronyms (for example, ). The guidelines further recommend that the name given to an be preceded by the capital letter , as in .\n\nThe Microsoft guidelines for naming fields are specific to , , and fields; fields that are not and that have other accessibility levels (such as and ) are explicitly not covered by the guidelines.[22] The most common practice is to use for the names of all fields, except for those which are (and neither nor ), which are given names that use preceded by a single underscore; for example, .\n\nAny identifier name may be prefixed by the commercial-at symbol ( ), without any change in meaning. That is, both and refer to the same object. By convention, this prefix is only used in cases when the identifier would otherwise be either a reserved keyword (such as and ), which may not be used as an identifier without the prefix, or a contextual keyword (such as and ), in which cases the prefix is not strictly required (at least not at its declaration; for example, although the declaration is valid, this would typically be seen as to indicate to the reader immediately that the latter is a variable name).\n\nIn the Dart language, used in the Flutter SDK, the conventions are similar to those of Java, except that constants are written in lowerCamelCase. Dart imposes the syntactic rule that non-local identifiers beginning with an underscore ( ) are treated as private (since the language does not have explicit keywords for public or private access). Additionally, source file names do not follow Java's \"one public class per source file, name must match\" rule, instead using snake_case for filenames.[23]\n\nIn Go, the convention is to use or rather than underscores to write multiword names. When referring to structs or functions, the first letter specifies the visibility for external packages. Making the first letter uppercase exports that piece of code, while lowercase makes it only usable within the current scope.[24]\n\nIn Java, naming conventions for identifiers have been established and suggested by various Java communities such as Sun Microsystems,[25] Netscape,[26] AmbySoft,[27] etc. A sample of naming conventions set by Sun Microsystems are listed below, where a name in \"CamelCase\" is one composed of a number of words joined without spaces, with each word's -- excluding the first word's -- initial letter in capitals ‚Äì for example \"camelCase\".\n\nJava compilers do not enforce these rules, but failing to follow them may result in confusion and erroneous code. For example, and imply significantly different behaviours: implies an invocation to method in an instance named , whereas implies an invocation to static method in class .\n\nOne widely used Java coding style dictates that be used for classes and be used for instances and methods.[25] Recognising this usage, some IDEs, such as Eclipse, implement shortcuts based on CamelCase. For instance, in Eclipse's content assist feature, typing just the upper-case letters of a CamelCase word will suggest any matching class or method name (for example, typing \"NPE\" and activating content assist could suggest ).\n\nInitialisms of three or more letters are CamelCase instead of uppercase (e.g., instead of ). One may also set the boundary at two or more letters (e.g. ).\n\nThe built-in JavaScript libraries use the same naming conventions as Java. Data types and constructor functions use upper camel case ( , , , ) and methods use lower camel case ( , , ). In order to be consistent most JavaScript developers follow these conventions.[28] See also: Douglas Crockford's conventions\n\nCommon practice in most Lisp dialects is to use dashes to separate words in identifiers, as in and . Dynamic variable names conventionally start and end with asterisks: . Constants names are marked by plus signs: .[29][30]\n\nMicrosoft .NET recommends , also known as PascalCase, for most identifiers. ( is recommended for parameters and variables) and is a shared convention for the .NET languages.[31] Microsoft further recommends that no type prefix hints (also known as Hungarian notation) are used.[32] Instead of using Hungarian notation it is recommended to end the name with the base class' name; instead of .[33]\n\nObjective-C has a common coding style that has its roots in Smalltalk .\n\nTop-level entities, including classes, protocols, categories, as well as C constructs that are used in Objective-C programs like global variables and functions, are in UpperCamelCase with a short all-uppercase prefix denoting namespace, like , , or . Constants may optionally be prefixed with a lowercase letter \"k\" like .\n\nInstance variables of an object use lowerCamelCase prefixed with an underscore, like and .\n\nMethod names use multiple lowerCamelCase parts separated by colons that delimit arguments, like: , and .\n\nWirthian languages Pascal, Modula-2 and Oberon generally use or identifiers for programs, modules, constants, types and procedures, and or identifiers for math constants, variables, formal parameters and functions.[34] While some dialects support underscore and dollar signs in identifiers, snake case and macro case is more likely confined to use within foreign API interfaces.[35]\n\nPerl takes some cues from its C heritage for conventions. Locally scoped variables and subroutine names are lowercase with infix underscores. Subroutines and variables meant to be treated as private are prefixed with an underscore. Package variables are title cased. Declared constants are all caps. Package names are camel case excepting pragmata‚Äîe.g., and ‚Äîwhich are lowercase. [36] [37]\n\nPHP recommendations are contained in PSR-1 (PHP Standard Recommendation 1) and PSR-12.[38] According to PSR-1, class names should be in PascalCase, class constants should be in MACRO_CASE, and function and method names should be in camelCase.[39]\n\nPython and Ruby both recommend for class names, for constants, and for other names.\n\nIn Python, if a name is intended to be \"private\", it is prefixed by one or two underscores. Private variables are enforced in Python only by convention. Names can also be suffixed with an underscore to prevent conflict with Python keywords. Prefixing with double underscores changes behaviour in classes with regard to name mangling. Prefixing and suffixing with double underscores - the so-called \"dunder\" (\"double under\") methods in Python - are reserved for \"magic names\" which fulfill special behaviour in Python objects.[40]\n\nWhile there is no official style guide for R, the tidyverse style guide from R-guru Hadley Wickham sets the standard for most users.[41] This guide recommends avoiding special characters in file names and using only numbers, letters and underscores for variable and function names e.g. fit_models.R.\n\nRaku follows more or less the same conventions as Perl, except that it allows an infix hyphen or an apostrophe (or single quote) within an identifier (but not two in a row), provided that it is followed by an alphabetic character. Raku programmers thus often use kebab case in their identifiers; for example, and are valid identifiers. [42]\n\nRust recommends for type aliases and struct, trait, enum, and enum variant names, for constants or statics and for variable, function and struct member names.[43]\n\nSwift has shifted its naming conventions with each individual release. However a major update with Swift 3.0 stabilised the naming conventions for across variables and function declarations. Constants are usually defined by enum types or constant parameters that are also written this way. Class and other object type declarations are .\n\nAs of Swift 3.0 there have been made clear naming guidelines for the language in an effort to standardise the API naming and declaration conventions across all third party APIs. [44]\n‚Ä¢ coding-guidelines.com has a pdf that uses linguistics and psychology to attempt a cost/benefit analysis of identifier naming issues"
    },
    {
        "link": "https://programmingduck.com/articles/naming",
        "document": "Programming principles tell us that naming in code is important. This article aims to be a complete learner‚Äôs guide for naming in code. It also aims to be a reference about naming that you can refer to in the future if you need to.\n\nFor certain things, such as naming methods, there are different naming conventions. We‚Äôll mention a few so that you‚Äôre aware of how they work and the options you can choose from.\n‚Ä¢ established naming conventions for specific things such as variables and classes\n\nThe motivation for good names comes from clean code and programming principles. Code should be:\n\nBeing easy to understand helps because:\n‚Ä¢ code that‚Äôs easy to understand will be faster to understand. This means that you can work faster. You‚Äôll spend less time trying to understand old code and more time writing new code.\n‚Ä¢ code will be possible to understand. In comparison, if some code is difficult to understand, you may not understand it even after spending a long time reading it. Someone who‚Äôs less experienced may have even worse luck. Additionally, you may misunderstand how the code works, especially if you‚Äôre not fully paying attention that day. Misunderstanding code makes it very easy to create bugs.\n\nGood names help with both cases.\n\nIf something is well-named, then you don‚Äôt need further details to understand it. This saves you time.\n\nFor example, consider:\n\nIn a codebase, you would have a pretty good idea of what those do just from the name.\n\nWhen reading code, you have to:\n‚Ä¢ read (parse) what it does\n‚Ä¢ understand why it does it, or rather, understand what it‚Äôs trying to do conceptually\n\nFor example, it‚Äôs not enough to think \"this code removes initial whitespace from the string, then it sends a network request\". Instead, you have to understand \"this code formats the username and then sends a password reset request\".\n\nWhat‚Äôs the there for? What‚Äôs ? Why does it return a minimum of ? What‚Äôs the purpose of this function?\n\nIf you‚Äôre trying to do something such as change the area, you don‚Äôt know if this function is relevant or not. Even if you suspect it is, you don‚Äôt know what it does or why.\n\nSomething like this would be much better:\n\nSo, good names help, because they provide meaning. They help you understand what the code does and why it does it.\n\nTo get the benefit, all you have to do is give a good name to the thing.\n\nAs another example, someone may not understand . They may think \" , , power of 2‚Ä¶ What the heck is that??\". To make it easier, all you have to do is replace that line with . It helps a lot.\n\nIn short, a good name is something that immediately tells you what something is or does. It‚Äôs not surprising. It doesn‚Äôt take effort to understand it. You understand it without thinking about it.\n\nA bad name is something that you read and you wonder \"what‚Äôs that\", or \"what does that do?\". Something that requires you to think more.\n\nWhen writing names, they should be understandable by someone that‚Äôs never seen this code before. They need to make sense, be consistent and be sufficiently descriptive.\n\nHere are some pointers to accomplish this.\n\nYour codebase should have clear conventions. This is probably the most important point in this article. If you‚Äôre already following a convention, it‚Äôs probably best to stick to it, even if an alternative may be more descriptive.\n\nConventions apply consistency. Programming principles tell us that consistency is very important.\n\nIt allows you to work faster. You can make certain assumptions about how the code works and what certain things mean. Additionally, when thinking of a name for something, the convention may already have a rule for it. This makes things easier.\n\nAlso, not following conventions can cause mistakes. You may assume that a common convention is being followed in the codebase. If you‚Äôre wrong, then you may have the wrong idea about how some code works. At that point, it‚Äôs very easy to create bugs.\n\nIdeally, you should follow conventions that already exist in your programming language or framework. This makes things easier for new developers to the company. Some examples are the .NET naming guidelines and Airbnb JavaScript style guide. Otherwise, you can also create your own custom conventions for your project or company.\n\nAlways consider, will the next person who looks at this name understand it easily?\n\nGenerally, full words are easier to understand. For example or . Abbreviated words may be harder to understand. In general, avoid names like or .\n\nIn particular, avoid single-letter or very short variables, such as . It could mean anything: the , , , or .\n\nThe exception to this is when the name is used in a very small scope and what it represents is immediately obvious. In this case, it‚Äôs easy to look one or two lines up and see where it was defined. Here‚Äôs a code example using the variable .\n\nHere, the variable represents the event object. We know this because the name and the function signature represent an event handler. is only used one line under where it is defined, so it‚Äôs still easy to work with.\n\nNevertheless, I would still personally use . I consider readability more important than minor saving of keystrokes like that.\n\nAnother acceptable example is using in for loops and such. That‚Äôs a convention that everyone understands.\n\nIf an acronym is very common, then it‚Äôs okay to use it. Some examples are the acronyms HTML, UI, IO, OS, JSON, XML, HTTP.\n\nIf an acronym is uncommon, then prefer the fully expanded name. If in doubt, you should probably use the full version.\n\nNames that are sufficiently descriptive come first. However, that doesn‚Äôt mean that you need super long names.\n\nSuper long names, such as a variable named are difficult to work with. would be sufficient.\n\nIn general, if you can have the same clarity with a shorter name, use the shorter name.\n\nThe name of the surrounding context can provide useful clues for the purpose of something. This means that sometimes, you can get away with using shorter names.\n\nFor example, if you have a class called , then the method for creating a new user can be called . The usage of it would be something like (where is an instance of ). That‚Äôs sufficiently descriptive. You don‚Äôt need to call the method in this case.\n\nThe prevalent casings in programming (excluding HTML and CSS) are pascal case, camel case and snake case. The one you use depends on the conventions for your programming language or framework.\n\nSnake casing is lower cased and uses underscores to separate words. For example .\n\nIn pascal casing, every word begins with a capital letter. For example .\n\nCamel casing is similar to pascal casing, except that the first word begins with a lowercase letter. For example .\n\nOn the front end, it seems that acronyms are always fully capitalised, regardless of length. Some examples are , , and .\n\nHowever, in some other languages, such as the .NET languages, the convention is:\n‚Ä¢ if an acronym is only two letters long, the second letter should have the same casing (upper or lower case) as the first one. For example, (pascal case), (camel case) and .\n‚Ä¢ if an acronym is three letters or longer, only the first letter should be capitalised if necessary. For example (pascal case), (camel case).\n\nIt‚Äôs a convention to treat compound words as one word in terms of capitalisation. For example, use and instead of and . You can find a thorough list of common compound words, used in programming, on the .NET naming guidelines on capitalisation.\n\nSemantic naming means to name something after its purpose or meaning. In order of priority, this means:\n‚Ä¢ what the purpose of it is, or what it does\n‚Ä¢ how it does it\n\nAs a bonus, it also results in code that is less likely to change in the future.\n\nWhen naming things, consider: what‚Äôs the most important thing about the thing you‚Äôre naming? What‚Äôs the most suitable name for someone else to understand it conceptually?\n\nUsually, users care more about what something is doing, rather than how it‚Äôs doing it. Although, sometimes, it‚Äôs the \"how\" that‚Äôs the most important.\n\nHere are some examples of semantic naming.\n\nExample with a variable name\n\nIf you have a variable that holds a collection of users, the important part is that it contains users. Whether it‚Äôs a list or a map is less important. Not to mention that your IDE and type declarations provide that information anyway.\n\nTherefore, the name:\n‚Ä¢ is less preferable. The \"list\" part is less important than the part. Also, if you change the data structure in the future you‚Äôll have to update the variable name.\n‚Ä¢ is also less preferable, because the \"collection\" part is less important than the \"user\" part. However, at least you won‚Äôt have to update the variable name if you change the data structure in the future.\n\nExample with interfaces and implementations\n\nIn OOP code, you tend to have interfaces with potentially multiple implementations. An interface may be called something semantic and generic, such as , for a sorting algorithm. That‚Äôs the significant thing about it, the fact that it sorts. The how isn‚Äôt important at the interface level.\n\nThe different implementations can be called after the sorting algorithm they implement. That‚Äôs the important thing about them and the only thing that separates them from one another. It‚Äôs the information a user of that specific class would want. For example , , .\n\nExample with a method for sorting\n\nImagine that you have a class containing a collection of something. You also have a method for sorting it, say, alphabetically.\n\nIf you only have one sorting method, then it would be preferable to name it . A name such as or would be unnecessary information that the user doesn‚Äôt care about. If you think about it, the caller of the code wants to sort. They aren‚Äôt particularly interested in the specific algorithm your class uses. (The only exception is if your class is an actual bottleneck to performance or something, but that‚Äôs a different topic.)\n\nAdditionally, in the future, you may change the sorting algorithm that the class uses to merge sort. In that case, the name wouldn‚Äôt make sense any more.\n\nThe solution is to name your public method .\n\nThe fact that you‚Äôre using quicksort is still important. Developers working on the implementation of the class would want to know that. Some options for that are to have a private method named , or import and use a function from somewhere else in the codebase.\n\nIn front end CSS, there are a few approaches. The approach you choose decides what‚Äôs important about the name of your class.\n\nWhen using the BEM naming convention, the important thing is the purpose of the element, not the styling. For example, you would use the CSS class instead of . That‚Äôs because, tomorrow, the styling of the page heading may change. At that point, the non-semantic name won‚Äôt make sense anymore, but the semantic name will.\n\nIf you‚Äôre using a UI component library, then the styling of the component is more important than the purpose of the component. For example instead of . That‚Äôs because classes like are the main ones you‚Äôll be working with throughout your code.\n\nSome tips that are mentioned in Uncle Bob‚Äôs book Clean Code are to:\n‚Ä¢ make meaningful distinctions. Avoid variables that seem similar or the same, such as or . A user of that code won‚Äôt be able to tell the difference.\n‚Ä¢ use pronounceable names. Names should be easy to read out loud. Some examples to avoid are names such as and . Better names would be and .\n‚Ä¢ use searchable names. Names should be easy to search using your code editor. Essentially, avoid names that are one or two letters long, as searching for them will return too many matches.\n‚Ä¢ avoid using cute / offensive words. Avoid names such as and . Be professional and consistent.\n‚Ä¢ pick one word per concept. For example, don‚Äôt mix the words \"fetch\", \"get\" and \"retrieve\" for the same kind of operation throughout your codebase. Pick one of them and use it consistently.\n‚Ä¢ avoid puns. Avoid using the same word for different concepts. For example, if in one class adds two numbers, in a different class shouldn‚Äôt insert into a list.\n\nOther tips from the .NET naming conventions\n\n.NET makes some additional recommendations. Some of them are specifically for .NET languages. However, you may want to keep them in mind anyway.\n\nThe recommendations are to:\n‚Ä¢ prefer naturally readable names. For example, use instead of .\n‚Ä¢ avoid using names that conflict with common keywords in other programming languages\n‚Ä¢ prefer semantic names rather than language specific names. For example, use instead of .\n‚Ä¢ prefer generic CLR type names instead of language-specific names. For example name a method instead of . That‚Äôs because methods like these may be used in other CLR-compatible languages where the data type doesn‚Äôt exist. Therefore, that name won‚Äôt make sense in those languages. However, exists and makes sense for all CLR languages.\n\nHere are some common naming conventions for things such as variables, functions, classes, etc.\n\nVariables are just names or labels for values and objects. Some general conventions for them are that:\n‚Ä¢ they should be nouns. For example , , , , , ,\n‚Ä¢ they generally use camel case or snake case, depending on your programming language\n\nThe rules change a bit for constants and variables holding Boolean values.\n\nSome programming languages write constants fully capitalised and with snake case. This includes JavaScript, Python and Java. Some example constants are:\n\nHere, \"constant\" refers to special values. These are values that don‚Äôt depend on runtime. They could easily be placed in a configuration file, away from your application code.\n\n\"Constant\" doesn‚Äôt refer to a normal local variable that just happens to be immutable. Those follow the same conventions as normal variables.\n\nHere are some examples of \"constants\" and \"normal variables that just happen to be immutable\":\n\nFor variables that have Boolean values, the convention is to phrase them as a question. Start them with a predicate such as \"is\", \"has\", \"had\" and \"can\". These clearly denote that the variable holds a Boolean.\n\nSome example Boolean variables are:\n\nIn addition to being readable standalone, they read nicely in conditional statements:\n\nIn comparison, if you don‚Äôt use a predicate, you would use a name such as . This is both a verb and an adjective. It can denote a number of things. It could be a function that you run to complete something, or a variable that holds things that have already completed, or a Boolean that states whether something has completed or not, or an event name. What it represents is more ambiguous, so prefer predicates instead.\n\nA verb like is slightly better. It can‚Äôt denote a function, because the \"ing\" in \"completing\" means that something is already happening. It‚Äôs not something that you can start running now (like a function call). However, it can still be any of the other options. Overall, it‚Äôs still preferable to use predicates.\n\nFunctions are units of code that do something. Conventions for function names are that:\n‚Ä¢ they should be verbs\n‚Ä¢ they generally use camel case or snake case, depending on your programming language\n\nSome example function names are:\n\nFor functions that return a Boolean, a common convention is for them to start with a predicate. This is similar to variables that contain Boolean values.\n\nSome example names for functions that return Booleans are:\n\nAnother convention I‚Äôve seen is for \"transformer\" or \"converter\" functions. These are functions that convert from one thing to another. They usually begin with \"to\", followed by the type they‚Äôre converting to.\n\nSome examples of transformer function names are:\n\nClasses are units of code that contain methods and attributes.\n\nSome conventions for classes are that:\n‚Ä¢ they should be nouns (or noun phrases)\n\nSome example class names are:\n\nIn general, attributes are named similarly to variables. Methods are named similarly to functions.\n\nHowever, as mentioned earlier, the name of the class provides some context.\n\nThis means that you may be able to use a less specific name for a method / attribute than you would use for the equivalent function / variable.\n\nFor example, inside a class , you may have a method named . The usage of it would be something like (where is an instance of ), which is sufficiently descriptive.\n\nIn terms of casing and prefixes, different languages and frameworks have different conventions.\n\nFor example, the Java naming conventions mention that methods and attributes should be camel cased.\n\nThe PEP 8 Python naming convention also mentions camel casing. However, it adds that private properties should be prefixed with an underscore. For example ( ).\n\nThe C# coding conventions seem the strictest. They state that:\n‚Ä¢ public properties should be pascal cased (for example or )\n‚Ä¢ private or internal properties should be prefixed with underscore and be camel cased (for example )\n‚Ä¢ private or internal static properties should be prefixed with and be camel cased (for example )\n‚Ä¢ private or internal thread properties should be prefixed with and be camel cased (for example )\n\nIf, for whatever reason, you were creating your own convention, I would personally recommend:\n‚Ä¢ pascal casing for methods and camel casing for attributes (this is the convention used in the Unity game engine). The reason for this is be to differentiate between Boolean attributes (such as ) and methods that return Booleans (such as ). As a second choice, I would use camel case for methods.\n‚Ä¢ possibly (not sure yet) the and prefixes from C# for the relevant things. As the Zen of Python says \"Namespaces are one honking great idea ‚Äî let‚Äôs do more of those!\" (I consider prefixes to have a similar effect)\n\nNames for interfaces are similar to class names. They use pascal case and are usually nouns. Sometimes they can be named with an adjective, for example \"Readable\".\n\nIn the book Clean Code, Uncle Bob recommends avoiding the prefix for interfaces. The Java naming conventions recommend the same. For example .\n\nThe C# coding conventions recommend prefixing interfaces with I. For example .\n\nPersonally, I have a minor preference for avoiding the prefix. That‚Äôs because, as a user of the code, I‚Äôm not particularly interested on whether I‚Äôm working with an interface or a class.\n\nThe Java convention is to treat enums like classes with constants. This means to name the enum type with pascal case and the fields fully uppercase.\n\nC# also treats them the same as classes. This means to name both the enum type and the fields using pascal case.\n\nPersonally, I prefer the Java convention because it differentiates between constants and other values.\n\nThere are a few things to consider regarding events and their relevant functions.\n‚Ä¢ are normally named using verbs. For example \"downloaded\", \"loaded\", \"deleted\", \"damaged\", \"moved\".\n‚Ä¢ generally use present tense for events that fire before an action starts. For example, before submitting a password reset request, you might fire an event named \"passwordResetRequestSubmitting\".\n‚Ä¢ generally use past tense for events that fire after an action completes. For example, after submitting a password reset request, you might fire an event named \"passwordResetRequestSubmitted\".\n\nIn my experience, these conventions are common across many languages. However, there isn‚Äôt much official documentation for them. One exception is with .NET, where they formally state these guidelines.\n\nFor the actual name of the event, you can use whatever makes sense to you. If your event is created in a class, the class name may provide sufficient context. For example, if you have a class , you may have an event named . The usage would be something like or . The event name \"areaChanged\" is sufficiently descriptive in this case.\n\nIn terms of casing, follow the convention in your programming language. C# uses pascal casing for public members (including events). Most other languages use camel casing.\n\nSome example event names are:\n\nFor event handler functions, there are a few conventions. In front end, React tends to use the prefix \"handle\". C# recommends the suffix \"EventHandler\". Other languages may have other conventions.\n\nSome example names of event handler functions are:\n\nMy personal preference is to use the \"handle\" prefix. This keeps the function a verb, which is the convention for functions.\n\nFunctions that exist solely to raise events tend to have the name . For example \"onAreaChanged\".\n\nOne case for using these is in classes that may be derived.\n\nHere, we have a method named whose only purpose is to raise the event.\n\nThis convention may work a bit differently in front end, but it still follows the general idea. For example, in React, you can name props something like \"onClick\" or \"onSomeEvent\". Event handler functions that you define inside a component can use the \"handle\" prefix.\n\nHere, each component creates event handler functions prefixed with \"handle\". The child component has the prop named \"onClick\". In the child component, the function calls the prop.\n\nPubSub (message bus) and analytics have similarities to local events, but they are more global. They span a much larger area of the codebase. The can even span multiple applications (as might be the case for analytics).\n\nWith these, it‚Äôs important to use more specific names, otherwise you won‚Äôt know what they refer to.\n\nA good way to do this is to use namespaces and prefixes, along with specified delimiters.\n\nFor example, with PubSub event names, you can have a namespace for the relevant area of the codebase. The format of the event name can be . For example:\n\nAnd, as explained on clean analytics by David Wells, for analytics you could use a format like . For example:\n\nThese are just examples. In your own codebase, you can use as many namespaces as you want. The namespaces can be anything.\n\nLikewise, the delimiter(s) can be anything you want. Some examples are \"/\", \"::\", \":\", \"_\", or even no delimiter.\n\nCommands are written similarly to functions. They are verbs in an imperative mood. They are also used in PubSub. The notes about namespaces and delimiters, mentioned above, apply to them.\n\nCommands also usually expect a response. In other words, a command such as \"CreateUser\" will have a response message such as \"CreateUserResult\", \"CreateUserSucceeded\" or even \"UserCreatedNotification\". Overall, I‚Äôm not aware of strong conventions for these, so you can probably use whatever you like.\n\nMy personal preference for response names comes from Jimmy Bogard‚Äôs post on message naming conventions. I generally append \"Result\", \"Reply\" or \"Response\" to the original command name.\n\nSome example formats for command names and their namespaces are and . For example:\n‚Ä¢ Possible commands are \"RegisterUser\" or \"user/register\". Possible responses are \"registerUserResponse\" or \"user/register_result\"\n‚Ä¢ Possible commands are \"DamagePlayer\", \"player/damage\". Possible responses are \"DamagePlayerResponse\", \"player/damage_result\"\n\nFor file names, you need to consider conventions for casing, as well as what to name the file based on the code it contains.\n\nFor file naming, there are different conventions depending on the language, framework and style guide you follow.\n\nMany conventions recommend file names that are all lower case. Words can be separated with either hyphens (-) or underscores (_). For example:\n‚Ä¢ in HTML, the convention is all lower case, with hyphens as separators. Underscores are far less common. One reason for this is because the HTML file name may reflect in the URL (especially with older servers). Underscores in URLs are far less common than hyphens.\n‚Ä¢ in CSS, the convention is all lower case with hyphens or underscores as separators\n‚Ä¢ In Python, PEP 8 recommends file names to be all lower case, with underscores as separators\n‚Ä¢ the Google JavaScript style guide recommends file names to be all lower case, with underscores or hyphens as separators\n\nBetween hyphens and underscores, you can use either. Both are acceptable. In general, I prefer to use hyphens to be consistent with my CSS classes (which conventionally use hyphens) and for the reasons mentioned for the HTML. However, if you commonly use snake case in your programming language, or if you don‚Äôt write HTML and CSS, it might feel more consistent to use underscores instead of hyphens.\n\nSome example file names are:\n\nAlong with that, there are other conventions that recommend camel or pascal case for your files. For example:\n‚Ä¢ C# and Java recommend naming your file the same as the main thing in your file. This means using pascal case, same as your classes and interfaces.\n‚Ä¢ the AirBnB JavaScript style guide recommends naming your file the same thing as your default export. Again, this means using camel or pascal case, at least for your JavaScript files.\n‚Ä¢ React takes it a step further and recommends naming all of your files consistently in each folder. For example:\n‚Ä¢ MyComponent.test.js (test files tend to have the special extension .test.js)\n\nSo which should you choose? First, consider if one of the conventions is more common than the others for your programming language or framework. That‚Äôs the natural choice. Otherwise, you can do whatever you like. My personal recommendation is to choose the naming convention that best matches the code in your files. For example, when working on the front end, the convention is for everything in your HTML and CSS to be lower case with hyphens as separators. Therefore, you might want to use that as the naming convention.\n\nAs another example, when working on React applications that use CSS modules, you might prefer to write CSS using pascal case and underscores. This makes it easier to use your CSS in your JavaScript, for example (where is your CSS class), as hyphens aren‚Äôt allowed in JavaScript. In this case, it may feel more natural to name your files using pascal case.\n\nChoosing a file name based on the code it contains\n\nIn general, you want to name your file based on its purpose.\n\nThis is supported by the C# naming conventions and Java naming conventions. They state that your file name should be the same as the main thing you define in your file. For example, if you define a class Foo, your file name should be Foo.cs or Foo.java.\n\nThe AirBnB JavaScript style guide also agrees with this. It states that your file should be named after your default export. Whether or not you use default exports is a separate matter. But the point is the same. It means to name it after the purpose, or the most important thing in your file. Normally (but not always) that‚Äôs thing that you would , if you were using export default.\n\nOne exception is if your default export is named \"main\", \"setup\" or something similar. It doesn‚Äôt make sense for a file to be called \"main\", especially if many files have a similar default export. In that case, consider what the purpose of the file is. An alternative is to consider what the equivalent OOP code would be.\n\nFor example, consider that you have a class that deals with carousel functionality. Your OOP code would probably be a class named \"Carousel\". In comparison, if you write it using functions, it might look like this:\n\nIn the equivalent OOP code, the code in would be in the constructor of the class . In this case, my recommendation would be to name the file . That‚Äôs its true purpose. Alternatively, you could also change to or something and name the file after that.\n\nAs for some other cases:\n‚Ä¢ If your file defines multiple classes: Well, most style guides would tell you to avoid files with multiple classes. Consider whether you can separate each class into its own file. Although, if you only have one public class, then that‚Äôs fine. Name the file after the one public class, not the private ones.\n‚Ä¢ If you use functions instead of classes, there might be some cases where none of the functions would suitable to export default. Again, you need to consider what the purpose of the file is. For example, if you have some functions that are used in your test files, then perhaps \"test-utilities\" would be a good name. Alternatively, you can consider what the equivalent OOP code would be. You would probably have a static class with static methods. Name your file after the name of that static class.\n\nIn practice, many packages don‚Äôt follow naming conventions at all. That‚Äôs because a developer can upload a package with whatever name they want. There usually aren‚Äôt many checks.\n\nHowever, there are naming conventions for packages and for different package repositories.\n\nJava and Maven use the format of . The group ID part is generally a reversed domain name. For example, if your domain is example.com, the group ID would be \"com.example\". It can have subgroups (additional namespaces). For example \"com.example.plugins\". The artifactID is the name of the jar. For example \"junit\" or \"spring-web\". In general, artifact IDs tend to be fully lower case with hyphens to separate words.\n\nNPM (node package manager) tends to use direct package names, such as \"react-dom\", or prefixed with a namespace or company name, such as \"@babel/preset-env\". They tend to be fully lower case with hyphens to separate words.\n\nWith NuGet (package repository for .NET), the number of namespaces vary, just like with Maven and subgroups. There are many packages with a single name, such as \"Moq\". There are also many packages of the format , such as \"AWSSDK.Core\". There are also packages with many namespaces, such as \"Microsoft.Extensions.FileProviders.Abstractions\". If you want to follow the example of the packages released by Microsoft, then use pascal case, optionally a company prefix and as many namespaces as you need.\n\nNamespaces (in code) seem to follow similar concepts and conventions to packages.\n\nHowever, spending some time to come up with a reasonable name is usually worth it.\n\nAlso, as always, be pragmatic. It‚Äôs okay to break these conventions once in a while. They are only here to help you make good and consistent decisions most of the time. For example, it‚Äôs okay if you feel that adding the data structure to the name will help, such as . It‚Äôs up to you to decide what‚Äôs best for your project.\n\nIn addition, you probably can‚Äôt spend an unreasonable amount of time coming up with good names. So, sometimes, if you‚Äôve already spent too long, you might need to use the best name you‚Äôve come up with so far and move on.\n\nOverall, the most important thing from this article is that you understand the principles behind naming. In particular, that names should make the code easy to understand. If you understand that, then you‚Äôll be fine. You‚Äôll be able to come up with your own solutions and conventions even in unfamiliar situations.\n\nSo that‚Äôs it for the article. I hope that you found it useful.\n\nIf you‚Äôve encountered any awful names in code you‚Äôve worked on, please leave a comment with them!\n\nAlso, if you want to discuss anything, disagree with anything, or have any feedback in general, please leave a comment below.\n\nAlright, see you next time üôÇ\n‚Ä¢ Clear Bulb Beside White Notepad on White Surface ‚Äì Photo by Burak Kebapci on Pexels\n‚Ä¢ Green leaf with white card ‚Äì Photo by Helena Hertz on Unsplash"
    },
    {
        "link": "https://devcom.com/tech-blog/coding-standards-and-best-practices-guide-implementation-tips",
        "document": "Coding standards are something that each development team should consider. Without standardization, engineers can stitch code together in their own style. Collaboration stalls as your team wastes hours untangling each other‚Äôs logic and rewriting after each other. As a result, the delays grow, costs soar, and your technical debt increases.\n\nThis guide explains how globally accepted programming standards, rules, and guidelines can overcome these problems. We will describe the best conventions and practices that can make your development process faster and code cleaner. Finally, we‚Äôll tell you how you can start integrating good coding standards step-by-step without overburdening your teams.\n\nCoding standards are rules, conventions, and guidelines that dictate how to produce code. They provide a consistent framework for development teams to write, format, and organize software code across projects in a way that‚Äôs high-quality, secure, maintainable, and scalable.\n\nWith the proper implementation, these standards can greatly improve larger teams‚Äô workflow, productivity, and privacy compliance.\n\nCoding standards are essential because they simplify and organize every stage of the software development lifecycle and IT operations:\n‚Ä¢ Software development. Coding standards in software engineering make code consistent across several development teams, making it easier to follow and debug.\n‚Ä¢ Testing and quality assurance (QA). tandards ensure consistency in naming, formatting, and structure, helping developers write quality unit tests. This helps the testers to validate the individual units (functions, classes, modules) of the code.\n‚Ä¢ Project management. With a standardized codebase, project managers can more accurately track key performance indicators (KPIs) across modules, sprints, and teams.\n‚Ä¢ Knowledge sharing. A common set of coding rules and practices ensures team members are on the same page. Besides, new employees don‚Äôt have to spend too much time learning inconsistent practices.\n\nTo illustrate the importance of coding standards, let‚Äôs look at the advantages they can bring.\n\nDon‚Äôt think of coding standards as limitations. Instead, look at them as guidance that makes the development process more manageable in the long run. Coding standards within developer teams offer far-reaching benefits to your organization, such as:\n‚Ä¢ Improved consistency. When developers adhere to a unified set of standards, the codebase becomes more consistent. This reduces the likelihood of errors introduced by conflicting practices, leading to a more reliable release.\n‚Ä¢ Higher code quality. Coding standards often include best practices for error handling, input validation, and resource management.\n‚Ä¢ Increased efficiency. Developers and testers can improve their productivity because they will spend less time correcting inconsistent and duplicate code.\n‚Ä¢ Faster onboarding. New developers can become more productive if your codebase adheres to familiar standards. Similarly, if a team member leaves, the standardized code allows others to continue the work seamlessly.\n‚Ä¢ Improved security and compliance. Secure coding practices embedded in the development can mitigate vulnerabilities and help adhere to data privacy regulations, including GDPR. Meanwhile, thorough documentation makes it easier to prepare for security and compliance audits.\n‚Ä¢ Enhanced scalability. By following coding conventions, you can make your software more optimized and modular. It will help the product handle increased workloads and allow you to scale components independently when needed.\n‚Ä¢ Reduced technical debt. Technical debt refers to the long-term consequences of choosing shortcuts that lead to rework later. Good coding practices make your codebase future-ready, predictable, and easier to modify, lowering maintenance costs.\n‚Ä¢ Long-term savings. The cost savings come from improved productivity, less rework, lower maintenance costs, and fewer risks of non-compliance.\n\nNow, let‚Äôs look at the fundamental components of coding standards, which are more or less applicable to any organization.\n\nAspects are the building blocks of coding standards. Understanding them is essential for establishing an efficient pipeline that addresses all critical areas of development.\n\nNaming conventions are a foundational element of coding standards. Purposeful names make the code much easier to modify and troubleshoot, especially in large projects.\n\nThere is quite a selection of naming conventions you can choose. They include:\n‚Ä¢ Camel case: Words are joined together without spaces, starting with a lowercase letter, and the subsequent words are capitalized (\n‚Ä¢ Snake case: Names are all lowercase, and words are separated by underscores (\n‚Ä¢ Kebab case: Similar to snake case, but words are separated by hyphens (\n‚Ä¢ Pascal case: Every word starts with an uppercase letter (\n‚Ä¢ Descriptive and purposeful names for code elements, such as variables, functions, and classes. For example, a variable is self-explanatory compared to a vague name like\n‚Ä¢ Constants (values that don‚Äôt change during the execution of a program) are usually named in uppercase letters with underscores to distinguish them from other variables. For example, for the upper limit of allowed connections in a system.\n‚Ä¢ Local variables are defined and used within a specific function or block in camel case.\n‚Ä¢ Function names are usually written in camel case, starting with a lowercase letter.\n\nConsistent formatting is about making the code look organized and easier to understand. After all, you want the programmers to have an easier time understanding it.\n‚Ä¢ Whitespace (spaces, tabs, and line breaks) can help separate different parts of code, letting you visually organize it in a consistent structure.\n‚Ä¢ Indentation is a whitespace that visually maps the nesting and hierarchy in the code, basically helping you show the relationships between parent-child elements (in conditions, loops, classes, etc.).\n‚Ä¢ Restricted line length to about 120 characters prevents horizontal scrolling, making the code easily viewable on different devices.\n‚Ä¢ Code spacing goes a long way to make code human-readable, which programmers will be thankful for.\n‚Ä¢ Smaller and reusable functions are much easier to understand and maintain than deeply nested code.\n\nThe commentary explains the purpose and reasoning behind the code segment. It‚Äôs invaluable for other developers when the context isn‚Äôt immediately apparent from the code itself.\n\nWe also recommend avoiding redundant notes that merely repeat something that‚Äôs evident from the code. As a rule, comments should be for non-obvious segments, business logic explanations, regulatory requirements, and workarounds. Alternatively, they could point to areas for improvement.\n‚Ä¢ Place inline comments in the same line or immediately above the code it refers to.\n‚Ä¢ Reduce redundant comments that restate something already expressed with the code.\n‚Ä¢ Remove temporary comments used for debugging or troubleshooting once resolved.\n‚Ä¢ Use specialized tools for external documentation , such as Javadoc for Java, Doxygen for C++, or Docstrings for Python.\n‚Ä¢ Add headers with detailed information on how to use certain headers (module headers).\n\nYou should standardize error-handling practices for consistent responses to errors across all parts of the application. It enables your teams to deal with unexpected issues and runtime anomalies without disrupting user experience or causing system failures.\n‚Ä¢ Use try-catch blocks to manage errors and exceptions. Try blocks are used for sections of code where errors are expected, and catch blocks contain the logic to handle it (so the system doesn‚Äôt crash).\n‚Ä¢ Log errors with meaningful messages , such as timestamps, error types, stack traces, and other contexts. Additionally, use structured formats (like JSON) for easier parsing.\n‚Ä¢ Configure standardized error return values for your functions, such as for success. This practice will reduce ambiguity when analyzing logs and debugging.\n‚Ä¢ Include an auto-recovery mechanism , such as retrying operations after a short delay, to minimize the impact of transient issues (like network outages).\n\nStandardized control systems provide a structured way to manage the codebase. They allow dev teams to track code changes and work simultaneously without overwriting each other‚Äôs work.\n‚Ä¢ Write descriptive commit messages in version control explaining the changes‚Äô purpose and scope. You should enforce a consistent format (like a short summary followed by a detailed description if necessary).\n‚Ä¢ Use a consistent branching strategy within a version control system. For instance, in Gitflow, the system is usually divided into Master, Developer, Feature, Release, and Hotfix branches.\n‚Ä¢ Enforce code reviews before integrating changes into the main codebase. It‚Äôs best to focus on reviewing smaller changes frequently instead of going through massive pull requests.\n‚Ä¢ Backup code regularly using automated tools to keep all relevant versions.\n‚Ä¢ Measure the impact of changes by tracking metrics like the number of bugs resolved, reduction in technical debt, and time spent on reviewing the code.\n\nCompanies must incorporate secure coding guidelines to build a proactive defense against vulnerabilities and adhere to strict data privacy laws.\n‚Ä¢ Use input validation systems to prevent malicious actors from injecting harmful commands into your system. All user-provided inputs should adhere to expected formats and boundaries.\n‚Ä¢ Encrypt sensitive data to ensure that all credentials and personally identifiable information (passwords, payment details, health records, etc.) are accessible only to authorized users.\n‚Ä¢ Don‚Äôt hardcode secrets , such as passwords and API keys, directly in the codebase. These variables and credentials should always be stored in secure environments.\n‚Ä¢ Enforce the principle of least privilege , granting users the minimum level of access necessary to perform their coding tasks.\n\nFocus on writing and structuring code for efficiency and resource management to minimize latency and system overhead.\n‚Ä¢ Use profiling to find code sections that cause the most delays. This is about focusing on parts of the code that cause the most latency and avoiding those that don‚Äôt impact performance significantly.\n‚Ä¢ Minimize lines of code , rewriting complex segments into shorter equivalents. Examples include replacing loops with vectorized operations or using anonymous functions for simple processes instead of full functions.\n‚Ä¢ Use efficient algorithms with lower time complexity. For example, using a hash table for lookups (instead of a list) can reduce the search times.\n‚Ä¢ Use green coding practices that involve writing code in a way that minimizes energy consumption. It will not just enhance the performance but also improve sustainability.\n\nWith the key foundations out of the way, let‚Äôs look at the principles that work across programming languages and frameworks.\n\nUnderstanding these widely recognized standards helps developers align their code with industry expectations.\n\nThe DRY principle emphasizes reducing duplication in code. Instead of copying and pasting similar code in multiple places, developers should abstract repeated logic into reusable components like functions, classes, or modules. If multiple modules perform the same data validation, you should create a validation function that all modules use.\n\nYou can use inheritance and composition to reduce duplication. In object-oriented programming, inheritance allows a class to inherit properties from a parent class. Composition involves building classes that contain instances of other classes.\n\nSystems work best when they are kept simple rather than made complex. In other words, it‚Äôs about avoiding unnecessary complexity and over-engineering.\n\nResist the temptation to add unnecessary layers of abstraction. Opt for the simplest algorithms that accomplish the task. It‚Äôs also about decomposing complex problems into smaller sub-problems that can be solved with simple code.\n\nYAGNI (You Aren‚Äôt Gonna Need It)\n\nThe YAGNI principle advises developers to implement features only when they are needed, not based on speculation about future requirements. Develop features in response to concrete requirements or user stories. Do not include code for scenarios that have an extremely low chance of occurring.\n\nThe SOLID principles are a set of five coding standards intended to make object-oriented software more understandable and maintainable:\n‚Ä¢ The Single Responsibility Principle (SRP) means that a class, module, or function should have only one reason to change. If a function handles multiple concerns, changes in one concern may affect others that you don‚Äôt intend to change.\n‚Ä¢ The Open-Closed Principle (OCP) states that software entities should be open for extension but closed for modification. Instead of modifying existing code to add new features, create new classes, modules, or functions that extend the existing ones.\n‚Ä¢ Liskov Substitution Principle (LSP) means objects of a superclass can be replaced with objects of their subclasses without breaking the application. This promotes reliable inheritance hierarchies and helps apply the same code in different subclasses.\n‚Ä¢ Interface Segregation Principle (ISP) prevents overblown interfaces. The idea behind the ISP code guidelines is that multiple specific interfaces are better than one general-purpose interface with numerous unwanted features.\n‚Ä¢ Dependency Inversion Principle (DIP) means making high-level and low-level modules depend on abstractions instead of depending directly on each other. These coding practices make the code more modular and extensible.\n\nCertain industries have regulatory requirements that include standard coding practices. The same goes for safety-critical sectors that require you to use closed standards (developed by specific organizations) instead of freely available open standards.\n\nFor example, developing software for the transportation industry might require you to follow ISO 26262 (a functional safety standard in the automotive industry). Or, your team might follow HL7 standards to ensure interoperability of electronic health records.\n\nNot every coding standard is universal‚Äîthey are often tailored to a specific programming language, industry, or project.\n\nDifferent languages have their unique standards. We won‚Äôt name them all, but let‚Äôs concentrate on the essential coding best practices for the most popular languages and frameworks.\n\nThis only covers the essentials. If you need the most comprehensive set of standards for each programming language, read the official documentation.\n\nIn some cases, you may face resistance to change from your team. Some of them may cling to old habits or won‚Äôt understand why you want to make code human-readable and visually appealing. Besides, adherence to strict code quality standards can be burdensome under deadlines, too.\n\nHowever, these practices can help you implement standard coding practices with minimal resistance.\n‚Ä¢ Involve the team in defining standards. Engage your team from the bottom up, encouraging them to share their suggestions.\n‚Ä¢ Start small. Begin with key guidelines and rules and gradually expand as the team becomes more comfortable.\n‚Ä¢ Adapt and customize. Make sure the standards are practical and acceptable. Adapt standards to fit the context of your projects.\n‚Ä¢ Document standards clearly. Create a well-defined document with your guiding principles, conventions, and rules. Use code snippets to illustrate both compliant and non-compliant code.\n‚Ä¢ Provide training and onboarding. Conduct training sessions and pair less experienced developers with seniors who can help them adjust to new practices.\n‚Ä¢ Recognize and reward compliance. Consider implementing rewards or recognition programs to motivate employees to adopt the new rules.\n\nThe key lies in communication, collaboration, and support for your team. However, if you lack internal knowledge, you can partner with a technical vendor to help you implement code standards.\n\nSome tools are very useful for identifying bugs, style violations, and security issues or automating other tasks that can save developers time. They can be divided into linters (for spotting logical problems in the code), formatters (to enforce style across projects), static code analyzers (to gauge performance metrics for the codebase), and IDEs (integrated development environments that streamline editing, compiling, debugging and other tasks).\n\nHere are some of the tools we want to highlight:\n‚Ä¢ ESLint for JavaScript can identify stylistic issues and potential bugs. It offers customizable rules, autofix capabilities and has a broad integration ecosystem.\n‚Ä¢ SpotBugs can reveal tricky bugs, performance issues and concurrency problems in Java code.\n‚Ä¢ gofmt helps make code easier to read, review and maintain in Go projects.\n‚Ä¢ Prettier formats code according to defined rules in multiple programming languages and editors.\n‚Ä¢ JetBrains Rider IDE inspects code for inconsistencies, provides quick-fix resolutions, allows sharing of custom code configurations and syncs formatting and syntax rules.\n‚Ä¢ IntelliJ IDEA can help define style rules across databases, check for violations and fix issues in real time.\n‚Ä¢ Visual Studio IDE offers built-in code-style settings and analyzers, cleanup and refactoring operations, and integrates with various formatting tools.\n\nInvesting in coding standards can position your company for long-term success, innovation, and competitiveness. However, it requires certain knowledge and commitment from all levels of the organization.\n\nOften, you need to rework large chunks of your codebase. After all, you can‚Äôt have uniformity if only some of your systems adhere to coding standards and best practices.\n\nAt DevCom, we specialize in helping companies implement effective coding standards and best practices. Our code audit services include codebase reviews, architecture evaluations, UI design assessments, and security tests. We will analyze your entire codebase, deliver a comprehensive report, and, if you‚Äôre willing, update your system to the highest standards.\n\nContact us today to learn how we can elevate your software development life cycle and quality."
    },
    {
        "link": "https://quora.com/When-programming-what-are-your-naming-conventions-and-such-Do-you-camelCase-underscore-or-use-specific-words-for-specific-concepts",
        "document": "Something went wrong. Wait a moment and try again."
    }
]