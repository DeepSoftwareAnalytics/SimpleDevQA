[
    {
        "link": "https://stackoverflow.com/questions/63327271/scroll-to-element-on-page-load-with-react-hooks",
        "document": "I'm trying to create a functional component that fetches data from an API and renders it to a list. After the data is fetched and rendered I want to check if the URL id and list item is equal, if they are then the list item should be scrolled into view.\n\nBelow is my code:\n\nMy problem here is that is always . Please advice what I'm doing wrong. Thanks in advance."
    },
    {
        "link": "https://stackoverflow.com/questions/71168934/useeffect-triggers-everything",
        "document": "Hi just trying to learn about hooks inside a Next.JS project. Have implemented a useEffect to listen for scrolling behavior with the goal of displaying different content in a header is the page is scrolled.\n\nThen i just have something like\n\nThis works for its purpose but an unintended effect is that scrolling is now additionally triggering everything in the component, so for example if I have console.logs outwith the useEffect they would get triggered on every scroll of the page. Is it possible to have my UE purely update the scrollY state?\n\nExample of an issue would be:\n\nTest would be logged repeatedly on every scroll."
    },
    {
        "link": "https://dev.to/masakudamatsu/how-to-use-html-canvas-with-react-hooks-2j47",
        "document": "Everything about `<hr>`: When to use it and how to style it\n\nEverything about `<abbr>`: when to use it and how to style it in small caps\n\nJSON web tokens are NOT meant for authenticating the same user repeatedly: Use session tokens instead\n\nHow to handle invalid user inputs in React forms for UX design best practices\n\n4 gotchas when setting up Google Maps API with Next.js and ESLint\n\nWhich fallback fonts should we choose to make FOUT less jarring\n\nLoading Google Fonts and any other web fonts as fast as possible in early 2021\n\nDefinitive edition of \"How to Favicon\" in 2023\n\nHow to use HTML Canvas with React Hooks\n\nBeyond create-react-app: Why you might want to use Next.js or Gatsby instead\n\nI'm making a color picker web app with React. Drawing a raster image like the color picker on the web requires a HTML element. But the HTML canvas and React do not easily go hand in hand.\n\nI've found a bunch of web articles on the topic, most of which are outdated as they use React class components. Those with React hooks are helpful but not fully accurate. So it took quite a while for me to make it work in my web dev project.\n\nTo help you (and my future self) save time to set up a canvas element in React app, let me share the definitive version of how to use the HTML canvas with React hooks (with a link to my demo).\n\nFirst, create a React component out of the element:\n\n\n\nThen, use this component with the referring to the function to draw an image ( ) and to the image resolution and aspect ratio ( and ):\n\n\n\nDemo for the above code is available at my CodeSandbox.\n\nBelow I break down the above code into 6 steps, to help you understand what is going on. ;-)\n\nNOTE: To learn how to draw an image with the canvas element, I recommend MDN's tutorial (MDN Contributors 2019).\n\nThe and attributes determine two things about the image created by the canvas element: the image resolution and the aspect ratio.\n\nIn the above example, the image has 100 x 100 pixels. In this case, drawing a line thinner than 1/100 of the image width ends up in sub-pixel rendering, which should be avoided for the performance reason (see MDN Contributors 2019b). If the thinnest line is, say, 1/200 of the image width, then you should set .\n\nThe above example also defines the aspect ratio of the image as 1 to 1 (i.e. a square). If we fail to specify the and attributes (as so many articles on HTML canvas do), the default aspect ratio of 2:1 (300px wide and 150px high) will apply. This can cause a stretched image, depending on how you style it with CSS (see MDN Contributors 2019a). Corey's (2019) helpful article on how to use React hooks to render a canvas element appears to fall this trap by failing to specify and attributes.\n\nUp until now, it has nothing to do with React. Anytime you use the HTML canvas, you should set and attributes.\n\nTo draw an image with a element, you first need to refer to it in JavaScript. An introductory tutorial to the HTML canvas (e.g. MDN Contributors 2019a) tells you to use where is the attribute value of the canvas element.\n\nIn React, however, using the hook is the way to go (see Farmer 2018 for why).\n\nCreate a variable pointing to , and then use this variable as the value of the attribute of the canvas element:\n\n\n\nThis way, once the canvas element is rendered on the screen, we can refer to it as in our JavaScript code. See React (2020a) for more detail.\n\nTo draw an image in the canvas element, you then need to create the object (often assigned a variable name like or in the code).\n\nThis step is the trickiest part of using the HTML canvas with React. The solution is the hook:\n\n\n\nAs explained in the previous step, the refers to the element in the above code. But it's until React actually renders the canvas element on the screen. To run a set of code after React renders a component, we need to enclose it with the hook (see West 2019 for when the code block runs during the React component life cycle).\n\nWithin its code block, therefore, the does refer to the element. This is the technique I've learned from Corey (2019), Nanda 2020 and van Gilst (2019).\n\nNow we're ready to draw an image with various methods of the object (see MDN Contributors 2020).\n\nTo reuse the code that we have written so far, however, it's best to separate it from the code for drawing an image. So we pass a function to draw an image as a prop to the component (I borrow this idea from Nanda 2020):\n\n\n\nThe function draws the image, to be defined in another file. To access to various drawing methods, it takes as its argument.\n\nAs the component now takes props, I add to make explicit the data type of each prop (see React 2020b).\n\nNow if we want to reuse this component, we do not want to hard-code its and attributes. Different images have different resolutions and aspect ratios.\n\nSo convert these two values into additional props:\n\n\n\nOne benefit of using is that, by adding , we will be alerted in the console in case we forget setting the prop values. As mentioned above (see Step 1), the and attributes are best specified for performance and for avoiding image distortion. With the above code, we will be alerted when we forget specifying their values.\n\nFinally, in a parent component, render the component together with specifying the function:\n\n\n\nCheck out how it actually works with my CodeSandbox demo.\n\nHope this article and the above demo help you kickstart drawing canvas images with React in your web app project!\n\nThis article is part of Web Dev Survey from Kyoto, a series of my blog posts on web development. It intends to simulate that the reader is invited to Kyoto, Japan, to attend a web dev conference. So the article ends with a photo of Kyoto in the current season, as if you were sightseeing after the conference was over. :-)\n\nToday I take you to the entrance garden of Seigen-in, a sub-temple of Ryoan-ji of the rock garden fame:\n\n \n\n Seigen-ji Sub-temple Entrance Garden at 9:54 am on 1 December, 2020. Photographed by Masa Kudamatsu (the author of this article)\n\nHope you have learned something today! Happy coding!\n\nI use the Author-Date referencing system in this article, to refer to various articles on web development.\n\nFarmer, Andrew H. (2018) ‚ÄúWhy to use refs instead of IDs‚Äù, JavaScript Stuff, Jan 27, 2018."
    },
    {
        "link": "https://dhiwise.com/post/boosting-performance-with-react-scroller-best-practices",
        "document": "Majorly busy listening to songs, scrolling Reddit and reading other‚Äôs articles. And yeah, also a senior frontend engineer with 4+ years of experience, crafting performant and stunning UI using React, Next.js, JavaScript, TailwindCSS, TypeScript.\n\nReact Scroller is a powerful tool that allows developers to handle scrolling in their React applications. The term \"react scroll\" is used to refer to the process of implementing scrolling functionality in a React application. This can be done in various ways, such as using the native scroll event, using third-party libraries, or using the built-in scroll functionality in React.\n\nScrolling is a fundamental interaction in web applications, and React provides several ways to handle it. The most basic way is to use the scroll event, which is fired whenever a user scrolls on a page.\n\nThis event can be used to trigger various actions, such as loading more data when the user reaches the bottom of the page, or changing the active link in a navigation bar as the user scrolls through different sections of the page.\n\nHowever, handling scroll events directly can be complex and error-prone, especially when dealing with complex layouts and dynamic content. This is where React Scroller comes in. React Scroller provides a high-level API for handling scroll events, making it easier to implement complex scroll behaviors.\n\nFor example, with React Scroller, you can easily implement smooth scrolling, where the page smoothly animates to a new position when the user clicks on a link. You can also employ endless scrolling, which automatically loads and adds new material to the website as the user scrolls down.\n\nIn this blog post, we will explore how to use React Scroller to implement various scroll behaviors in a React application.\n\nTo create a scroll in React, you first need to import React and create a React component. In the component's JSX, you can use the div element with a specified height and overflow property set to \"scroll\" to create a scrollable area.\n\nIn this example, the div will have a height of 200 pixels, and any content that exceeds this height will be scrollable.\n\nHowever, this is just a basic example. In a real-world application, you might need more control over the scroll behavior. For example, you might want to animate the scroll, or you might want to load more content when the user scrolls to the bottom of the page. This is where React Scroller comes in.\n\nSmooth scrolling is a popular effect where the page smoothly animates to a new position when the user clicks on a link. This can be achieved in React using the scrollIntoView method or the scrollTo method.\n\nThe scrollIntoView method scrolls the page until the specified element is in view. It takes an options object as a parameter, where you can specify the behavior and block position. The behavior can be set to \"smooth\" for smooth scrolling.\n\nIn this example, the page will smoothly scroll until the start of the element with the id \"my-element\" is in view.\n\nThe scrollTo method, on the other hand, scrolls the page to a specified position. It also takes an options object as a parameter, where you can specify the top position and the behavior.\n\nIn this example, the page will smoothly scroll to the position 1000 pixels from the top of the page.\n\nHowever, these methods only provide basic smooth scrolling functionality. If you need more granular control over the scroll animation, such as custom easing functions or duration, you might need to use a third-party library like React Scroller.\n\nInfinite scrolling and virtualized scrolling are two popular techniques used to handle large lists of data in web applications. While they might seem similar at first glance, they serve different purposes and have different trade-offs.\n\nReact Infinite Scroller is a library that allows you to implement infinite scrolling in your React applications. Infinite scrolling is a technique where new content is automatically loaded and added to the page as the user scrolls down. This can be a good way to handle large lists of data, as it allows the user to browse through the data without having to click on pagination links.\n\nHere's an example of how you can use React Infinite Scroller:\n\nIn this example, the InfiniteScroll component will automatically call the loadData function when the user scrolls to the bottom of the page. The loadData function should load more data and update the state of the component.\n\nReact Virtualized, on the other hand, is a library that allows you to implement virtualized scrolling in your React applications. Virtualized scrolling is a technique where only the visible items in a list are rendered, while the rest are replaced with placeholders.\n\nThis can be a good way to handle very large lists of data, as it reduces the memory footprint and improves performance.\n\nHere's an example of how you can use React Virtualized:\n\nIn this example, the List component will only render the visible items in the list, and replace the rest with placeholders.\n\nIn summary, while both React Infinite Scroller and React Virtualized can be used to handle large lists of data, they serve different purposes and have different trade-offs.\n\nReact Infinite Scroller is good for loading more data as the user scrolls, while React Virtualized is good for reducing the memory footprint and improving performance when dealing with very large lists.\n\nImplementing infinite scrolling in React can be done using the scroll event and the scrollTop, clientHeight, and scrollHeight properties of an element. The idea is to add a scroll event listener to the scrollable element, and when the user scrolls near the bottom of the element, load more data.\n\nIn this example, the handleScroll function is called whenever the user scrolls on the element with the id \"my-element\". When the user scrolls to the bottom of the element, the handleScroll function updates the page state, which triggers the useEffect hook that loads more data.\n\nHowever, this is just a basic example. In a real-world application, you might need to handle more complex scenarios, such as loading data from multiple sources, handling errors, or showing loading indicators.\n\nThis is where a library like React Infinite Scroller can be helpful. React Infinite Scroller provides a high-level API for implementing infinite scrolling, making it easier to handle complex scenarios.\n\nIn addition to vertical scrolling, React also supports horizontal scrolling. This can be useful for creating carousels, timelines, or other types of content that require horizontal navigation.\n\nTo create a horizontal scroll in React, you can use the overflow-x CSS property. Here's an example:\n\nIn this example, the div will be scrollable horizontally, and any content that exceeds the width of the div will be scrollable.\n\nReact also provides a way to scroll to a specific element or position on the page using the scrollTo method. This can be useful for implementing \"scroll to top\" buttons, navigation links, or other types of scroll interactions.\n\nHere's an example of a ScrollToTop component:\n\nIn this example, the ScrollToTop component renders a button that scrolls the page to the top when clicked.\n\nReact provides a way to capture and handle scroll events using the onScroll event handler. The onScroll event handler is called whenever the user scrolls on an element.\n\nIn this example, the handleScroll function is called whenever the user scrolls on the div. The handleScroll function receives an event object as a parameter, which contains information about the scroll event, such as the scroll position and the target element.\n\nHowever, handling scroll events directly can be complex and error-prone, especially when dealing with complex layouts and dynamic content. This is where React Scroller comes in. React Scroller provides a high-level API for handling scroll events, making it easier to implement complex scroll behaviors.\n\nIn conclusion, React Scroller is a powerful tool that allows developers to handle scrolling in their React applications. Whether you need to implement basic scrolling, smooth scrolling, infinite scrolling, horizontal scrolling, or capture and handle scroll events, React Scroller has got you covered.\n\nWith its high-level API and flexible options, React Scroller makes it easy to implement complex scroll behaviors with just a few lines of code. So the next time you need to handle scrolling in your React application, consider using React Scroller. It might just make your life a whole lot easier!\n\nShort on time? Speed things up with DhiWise!\n\nTired of manually designing screens, coding on weekends, and technical debt? Let DhiWise handle it for you!\n\nYou can build an e-commerce store, healthcare app, portfolio, blogging website, social media or admin panel right away. Use our library of 40+ pre-built free templates to create your first application using DhiWise."
    },
    {
        "link": "https://koenvangilst.nl/blog/react-hooks-with-canvas",
        "document": "In this tutorial, I will use React Hooks to create an html canvas drawing website. I will start from zero using the Create React App starter kit. The resulting app offers basic features like , and saves drawings using localStorage.\n\nWith this tutorial, I'd like to show you how hooks make the composition and reuse of stateful logic possible using custom hooks.\n\nWe'll start by creating a new React app using .\n\nYour browser should open and you should see a spinning React logo. You're now ready to go!\n\nOpen the file in your favorite editor and replace the contents with the following code:\n\nClicking somewhere in the open browser window should now display an alert popup, telling you the x coordinate of the mouse click.\n\nNow let's draw something. For that, we need a to the canvas element and our first hook is going to help us with that.\n\nNormally in React you don't need a to update something, but the canvas is not like other DOM elements. Most DOM elements have a property like that you can update directly. The canvas works with a context ( in our app) that allows you to draw things. For that, we have to use a , which is a reference to the actual canvas DOM element.\n\nNow that we have the canvas context it's time to draw something. For that, I'm going to copy-paste the code that draws an SVG hook. It's got nothing to do with hooks, so don't worry if you don't fully understand it.\n\nAll this does is draw an SVG shape (a fishing hook!) on position and . As it's not relevant to this tutorial I will omit it from now on.\n\nTry it out, and see if it works!\n\nThe next features we'd like to add are the and buttons. For that, we need to keep track of the user interactions with the hook.\n\nThere! We've added state to our app. You can verify this by adding a just above the . In the console, you should see a growing array of user clicks.\n\nCurrently, we're not doing anything with that state. We're drawing the hooks just like we did before. Let's see how we can fix this with the hook.\n\nA lot is going on here so let's break it down. We've moved the drawing function from the onClick handler to the callback. This is important because drawing on the canvas is a side effect determined by the app state. Later we'll add persistency using localStorage, which will also be a side effect of state updates.\n\nI've also made a few changes to the actual drawing on the canvas itself. In the current implementation, every render first clears the canvas and then draws all the locations. We could be smarter than that, but to keep it simple I'll leave it to the reader to further optimize this.\n\nWe've done all the hard work, and adding the new feature should be easy now. Let's create the button.\n\nThe Clear feature is just a simple state update: we clear the state by setting it to an empty array . That was easy, right?\n\nI've also taken the opportunity to clean up a bit, by moving the canvas handler to a separate function.\n\nLet's do another feature: the button. Same principle, even though this state update is a bit more tricky.\n\nSince any state update in React has to be immutable, we can't use something like to remove the most recent item from the array. We have to do it without changing the original array. The way to do this is with , i.e. by slicing off all the elements up until the last one. You can do that with , but is smart enough to interpret as the last item in the array.\n\nBefore we continue, let's clean up the HTML and add some CSS. Add the following around the buttons:\n\nAnd replace the CSS in with the following:\n\nLooking good, let's get started on the next feature: persistence!\n\nAs mentioned before, we also want our drawings to be saved to . As this is another side effect, we'll add another .\n\nWe've now completed all the features we set out to build, but we're not done yet. One of the coolest things about hooks is that you can use existing hooks to compose new custom hooks. Let me demonstrate this by creating a custom hook.\n\nThere! We've created our first custom hook and all the logic that relates to saving and getting the state from localStorage is extracted from the App component. And we did this in a way that the hook can be reused by other components. There's nothing in there that's specific for this component.\n\nLet's repeat this trick for the logic that relates to the canvas.\n\nAs you can see our App component has become quite small. All the logic that is related to storing the state in localStorage and drawing on the canvas is extracted to custom hooks. You could clean up this file even further by moving the hooks into a hooks file. That way other components could reuse this logic, for instance, to compose even better hooks.\n\nWhat makes hooks so special if you compare them to the lifecycle methods (like , )? Looking at the examples above:\n‚Ä¢ hooks allow you to reuse lifecycle logic in different components\n‚Ä¢ with hooks, you can use composition to create richer custom hooks, just like you can use composition to create richer UI components\n‚Ä¢ hooks are shorter and cleaner - no more bloated, and sometimes confusing, lifecycle methods\n\nIt's still too early to tell whether hooks are going to solve all these problems - and what new bad practices might arise from them - but looking at the above I'm pretty excited and optimistic for React's future!\n\nLet me know what you think! You can reach me on Twitter using @vnglst.\n\nSource code is also available on Github."
    },
    {
        "link": "https://stackoverflow.com/questions/63534492/handling-mouse-event-inside-ref-div-react-hooks-typescript",
        "document": "I have a working code which handles an outside click in my custom dropdown element.\n\nI just can't make the TypeScript stop complaining.\n\nIt looks like this:\n\nMy TS Error looks like this:"
    },
    {
        "link": "https://stackoverflow.com/questions/64646680/testing-mouse-event-listener-added-using-ref-in-react-functional-component",
        "document": "Testing this sort of component can be tricky, but using I think I was able to come up with something useful.\n\nI did have to make some changes to your component to expose the API a bit, and I also made some changes so that it stops listening to the events on which may not be the specific event you want.\n\nI called out in comments the main differences.\n\nAnd here's an example test:\n\nWhat's happening here, is we're rendering the component, then firing events to ensure the function prop is called when we expect.\n\nWe have to do rather than just the object because it's called with a which contains other properties.\n\nAnother test we might want to add is an unmount test to ensure the listeners are no longer triggering events.\n\nYou can look at/experiment with this Code Sandbox with this component and the tests. Hope this helps üëç"
    },
    {
        "link": "https://devtrium.com/posts/react-typescript-events",
        "document": "Events are everywhere in React, but learning how to properly use them and their handlers with TypeScript can be surprisingly tricky. There are several ways to do it, some better than others.\n\nIn this article we'll cover all kinds of events in TypeScript: click, form, select, input, ... First we'll see how to type events on a toy example, then I'll show you how to type any event.\n\nIf you just want to quickly jump to the solution, use this link.\n\nTo show how to type events in React, we'll use the following example:\n\nIt's a very simple React app with an input field and a submit button. But if you're using TypeScript with this code, it must be screaming all kinds of obscenities right now! Don't worry, we're about to see how to set it at ease.\n\nNote that we don't really use 's' argument in this code, so you could just omit it and TypeScript would be happy. But I've included it anyway just to show how you would type if you'd had a use for it.\n\nThere are several ways to type the above code, and we'll see the 3 main ones. There are:\n\nLet's start with typing the event. This one is quite straightforward. React provides a type you can directly use!\n\nLet's move on to the function.\n\nIt's pretty similar to , with a significant difference. You also import a type directly from react, which this time is called . The difference is that is a Generic type to which you have to provide what kind of DOM element is being used.\n\nThe result is the following:\n\nOne thing to note in the code above is that refers specifically to HTML's tag. If we were using a , we would be using instead.\n\nAnd there you have it! You made TypeScript happy üòÅ\n\nInstead of typing the event itself, as we did above, we can also type the functions themselves.\n\nIt looks very similar, and it's mostly a matter of taste. I find typing the event more flexible so I tend to use the first one, but being aware of this other option is always good.\n\nLastly, you can also rely on inferred types and not type anything yourself. For this, you need to inline your callbacks, which isn't always what you want to do.\n\nOf course, there's a lot of other events than the two shown above.\n\nA good way to find the complete list supported by React is to have a peak at the type definitions, in the React typings source code itself!\n\nHere are the first few.\n\nYou can notice that every event inherits from , which is the base event.\n\nBuilding forms is very common in web development. We already saw how to handle text inputs, let's now see an example (directly taken from React's docs on forms) of a , as well as a form submit events.\n\nAs you can see, it looks very similar to our first example.\n\nLastly, let's see an example of handling keyboard events since those are also quite common!\n\nI hope this article clears up how to handle events with React and Typescript! As you can see, it's pretty simple once you know how to do it."
    },
    {
        "link": "https://javascript.plainenglish.io/smooth-animations-for-interactive-html-canvas-simulations-with-react-b6fc1109ecd7",
        "document": "The HTML canvas is a really fun and easy way to create awesome 2D graphics and animations on any web page. When combined with the benefits of a UI framework like React, it can become a really powerful tool to create cool effects, interactive simulations, custom visualizations, or even complete games. However, are some caveats to consider for consistently achieving smooth animations, especially once your app becomes more complex. This guide will go over the basics of setting up React + TypeScript + canvas, and then dive deeper into attaining smooth animations even in large apps with a lot of UI components and render updates.\n\nThis section will go over how to get a canvas component working in React with TypeScript. Feel free to skip to the next section if you already know the basics and/or just want to learn about optimizing for smooth animations.\n\nFor convenience, I created a simple demo with all the code you can check out on GitHub.\n\nCreate a new React project if you haven‚Äôt already: . It can be beneficial to start with a fresh project to experiment with different ideas and implementations.\n\nFor now, this only draws a black rectangle on the screen. But here is the breakdown of what‚Äôs happening:\n‚Ä¢ allows us to reference the canvas component after it has been rendered on the web page. We need this in order to fetch the 2D context used for rendering each frame.\n‚Ä¢ waits until the component, along with the canvas, is fully loaded to call .\n‚Ä¢ Finally, the function just draws a black rectangle across the canvas‚Äôs entire width and height, clearing out anything that was there before.\n\nNext, let‚Äôs draw a circle in the middle of the screen. Define a function and call right after we call .\n\nNow let‚Äôs make the red circle follow the user‚Äôs mouse position. We can capture the mouse position with the canvas‚Äôs callback and save it to a state variable. Then, we can modify the to re-render whenever the mouse position changed.\n‚Ä¢ is just there to make TypeScript typing simpler.\n‚Ä¢ keeps track of the cursor‚Äôs position, initialized to (0, 0).\n‚Ä¢ The now has as a dependency, so it will run each time changes. The call to can be wrapped in which will come into play later.\n‚Ä¢ Finally, the prop of the canvas component runs the function, which figures out the cursor‚Äôs (x, y) position on the canvas and updates the state accordingly with .\n\nTo make the demo more interesting, let‚Äôs add some additional animations around the red circle. We can also move the canvas into its own component to separate out the animation logic from the rest of the app.\n\nThe biggest change here is that the canvas is now animated consistently instead of only reacting to the user‚Äôs mouse movement.\n‚Ä¢ , , and capture the values used to draw each frame (see below) so that we can access them in the scope of the animation loop.\n‚Ä¢ The first kicks off the animation loop. The ID of every requested animation frame is stored in . If the component is unmounted, it will trigger the returned callback from this to cancel the animation loop.\n‚Ä¢ will call the function as soon as the system is ready to repaint and allows for a variable frame rate.\n‚Ä¢ The second listens to changes in and updates so the animation loop can access the most up-to-date coordinates on the next frame render. We need to set the ref so the value can be accessed from inside the animation loop‚Äôs scope.\n‚Ä¢ We use to compute so that the animation speed is consistent across a variable frame rate.\n‚Ä¢ Finally, just uses some simple trigonometry to compute the position of a small blue circle revolving around the bigger red circle. At every frame, the angle, stored in , is incremented (scaled by ) and the small circle is drawn.\n\nWe can simplify accordingly:\n\nHere are the results:\n\nThis is just a really basic example of things you can do. There are limitless animation possibilities. Here are just a few ideas:\n‚Ä¢ Anything related to 2D animation that you can think of.\n\nThis so far is a great starting point, and if your app is fairly light weight, it may be a perfectly adequate solution. Try adding buttons, styles, and other UI components and and make sure you still have smooth animations.\n\nIf your app gets really big and has a lot of complex React components that get re-rendered with a frequently changing state (e.g. when the user is typing or if you need to track the cursor‚Äôs movement), you may start seeing choppy animation issues.\n\nWhen I was developing a Kalman Filter simulation (a linear state prediction algorithm) using React + canvas, I needed three main parts of the code to run smoothly:\n‚Ä¢ The React UI, featuring sliders and 96 individual text input fields for six 4x4 matrices, and a state to store all of those values. I used MUI for easy styling and quickly building the UI components.\n‚Ä¢ The Kalman Filter algorithm‚Äôs update logic, running at 60 intervals per second, accessing the state‚Äôs values and the user‚Äôs real-time mouse position to compute its prediction.\n‚Ä¢ The canvas animation code, which also referenced the state to draw the simulation results.\n\nThe outcome? An unusably choppy simulation that barely worked.\n\nIn my Kalman Filter example, the entire state (slider values, matrix inputs, and cursor position) was stored in the root component as a single object and passed to the component, the individual UI sub-components, and the Kalman Filter‚Äôs logic code (running on a constant interval using ). Whenever the user started typing or moving the mouse, all of the UI components would be re-rendered with the new state being passed down. The browser simply couldn‚Äôt keep up as React frantically re-rendered constantly, so the animation frames were delayed, causing the frame rate to plummet.\n\nThe solution is to optimize the code a bit and avoid re-rendering that many components at such a high frequency. There are a few ways we can achieve this.\n\nUse memoized components. This way, a component will only ever re-render if its specific dependencies were changed, and not when anything else in the state changed. This can be done with a wrapper around the component, as follows:\n\nThis is similar to wrapping the component in a hook in the parent component, which is also an option.\n\nIf most of your re-renders are triggered by text input events, debouncing the state update callbacks could work (e.g. with the lodash debounce function). However, this is not a good solution for real-time inputs such as mouse movement, since it would wait for the user to stop moving completely before updating the state.\n\nThis solution is a bit odd, but I tried it and thought it would be fun to mention. Instead of calling a re-render on every event, you can store all of the user input values in hooks, and then use to periodically sample those values and call the state update function(s). But this is very inefficient if your app is idle, and still requires re-rendering everything at a fairly high (but more predictable and manageable) frequency.\n\nReact applications can get very complex and filled with thousands of sub-components needing re-rendering. Even if you‚Äôre not trying to achieve 60 FPS animations with canvas, you can start to run into issues where user input events are too frequent for the app to efficiently re-render everything so often. Memoization or debouncing of inputs could help greatly reduce the amount of work your app does, resulting in an overall smoother experience for the user.\n\nMore content at PlainEnglish.io. Sign up for our free weekly newsletter. Follow us on Twitter and LinkedIn. Join our community Discord."
    },
    {
        "link": "https://joshwcomeau.com/snippets/react-hooks/use-mouse-position",
        "document": "For certain interactions, you need to know exactly where the user's cursor is.\n\nFor example, on this blog, I have a ‚Äúlike‚Äù button which responds to the user's cursor position:\n\nis a low-level hook used in effects like these. It measures the user's current mouse position, in pixels, from the top/left corner. It stores this data in React state, and updates it whenever the cursor moves.\n\nBecause it's held in React state, the component will re-render whenever the user moves the mouse, and so you can safely use it to calculate things like CSS transform values, canvas animations, etc.\n\nThis component will re-render whenever the user moves the mouse. This can be dozens and dozens of times a second.\n\nOriginally, this hook included ‚Äúthrottle‚Äù functionality, which would limit the updates to a user-specified interval. In testing, though, it seemed to make performance worse. No matter how hard I tried, I couldn't come up with a contrived scenario where the throttle actually improved performance (while still updating often enough for smooth animations).\n\nThat said, you do still need to be a bit careful where you use this hook. It shouldn't be used in a top-level component like or , since that will cause a huge chunk of your React tree to re-render very often. Use this hook in the small ‚Äúleaf node‚Äù components near the bottom of the tree.\n\nFor maximum performance, you can use a library like React Spring or Framer Motion, which will allow you to update values without triggering React renders. In my experience, though, as long as you're using this hook on smaller components that don't have a big DOM impact, you should be just fine.\n\nIf you're going to be using this hook to animate an element's position, be sure to consider the user's motion preferences!\n\nYou can check with the use-prefers-reduced-motion hook. For example:\n\nThis hook is written to respond exclusively to mouse events. This means that it'll ignore the movement of fingers across a touchscreen.\n\nIn my experience, I generally don't want to handle touch events in the same way. Dragging a finger across the screen is more like scrolling than it is like moving a mouse.\n\nI mainly use this hook for cosmetic desktop-only effects, like the 404 error page (opens in new tab) on this blog.\n\nFor those curious, though, here's how I'd write this hook if it needed to also track touch position:"
    }
]