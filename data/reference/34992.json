[
    {
        "link": "https://opengl.org/resources/libraries/glut/glut_downloads.php",
        "document": "2000/03/22 - GLUT 3 specification is now available in PDF format!\n\nGLUT (pronounced like the glut in gluttony) is the OpenGL Utility Toolkit, a window system independent toolkit for writing OpenGL programs. It implements a simple windowing application programming interface (API) for OpenGL. GLUT makes it considerably easier to learn about and explore OpenGL programming. GLUT provides a portable API so you can write a single OpenGL program that works on both Win32 PCs and X11 workstations.\n\nGLUT is designed for constructing small to medium sized OpenGL programs. While GLUT is well-suited to learning OpenGL and developing simple OpenGL applications, GLUT is not a full-featured toolkit so large applications requiring sophisticated user interfaces are better off using native window system toolkits like Motif. GLUT is simple, easy, and small. My intent is to keep GLUT that way.\n\nThe GLUT library supports the following functionality:\n• Utility routines to generate various solid and wire frame objects.\n\nThe GLUT library has both C, C++ (same as C), FORTRAN, and Ada programming bindings. The GLUT source code distribution is portable to nearly all OpenGL implementations for the X Window System and Windows 95 and NT. GLUT also works well with Brian Paul's Mesa, a freely available implementation of the OpenGL API.\n\nBecause GLUT is window system independent (as much as possible), GLUT can be implemented for window systems other than X. Implementations of GLUT for OS/2, NT & Windows 95, and the Mac have ben implemented, but only the Win32 and X11 versions are part of the official GLUT source code distrbution.\n\nThe current version of the GLUT API is 3. The current source code distribution is GLUT 3.7.\n\nGLUT is distributed in source code form; compiled libraries for Win32 are also available. The current version, 3.7, is in late beta. The programs and associated files contained in the distrbution were developed by Mark J. Kilgard (unless otherwise noted). The programs are not in the public domain, but they are freely distributable without licensing fees. These programs are provided without gurantee or warrantee expressed or implied.\n\nSince the data files for some of the new advanced GLUT examples are large, they are contained in a separate distribution.\n\nYou can still download the previous version of GLUT (GLUT 3.6), and the GLUT 3.6 data files.\n\nYou can also download GLUT from the University of North Carolina, Chapel Hill's SunSITE archive by either FTP or HTTP:\n\nWARNING: GLUT 3.7 and GLUT 3.6 are not on sunsite.unc.edu yet (just GLUT 3.5 currently).\n\nFor SGI users that want to save the hassle of compiling GLUT 3.6 by hand, you can download installable images for GLUT 3.6. Image images include:\n\nThe GLUT 3.6 images work with IRIX 5.3, IRIX 6.1, IRIX 6.2, IRIX 6.3, and IRIX 6.4. The installable images make it easy to install, upgrade, and remove GLUT. This is particularly true if you want N32 or 64-bit versions of GLUT. The N32 version refers to the new N32 object format that results in better performance from MIPS's current R4400, R8000, and R10000 processors. N32 is supported in IRIX 6.1 and later IRIX releases. The glut_dev.sw32.dev system is now marked for install by default since N32 is the default object format in IRIX 6.4.\n\nThe images are distributed as a file. You can either untar the file, or run on the tar file to automatically start SGI's Software Manager ( ). Otherwise, you can run or on the untar'ed files.\n\nDownload the GLUT 3.6 installable images by downloading this (shift Left in Netscape).\n\nIf your browser is configured to use tardist, try clicking the above link to start automatically. Note that not all the GLUT example source code in the source distribution is included with the GLUT images.\n\nRon Bielalski has built binaries of GLUT 3.7 beta for Solaris on SPARC processors in both 32 bit (16.5 MB) and 64 bit (18.3 MB) forms. John Martin has built binaries of GLUT 3.7 beta for Solaris on x86 in both 32 bit (15.2MB) and 64 bit (17.4MB) and forms. Note that these files are very large - they contain a completely built GLUT source tree, including all source and object files as well as the final headers and libraries. Please direct questions about GLUT for Solaris to graphics-help@eng.sun.com\n\nNate Robins and Paul Mayfield with help from Layne Christensen have implemented the original version of GLUT for Win32 (Windows 95,98,Me,NT,2000,XP). Here's a link to their GLUT for Windows web page. These pages include GLUT for Win32 dll, lib and header file (everything you need to get started programming with GLUT) and GLUT source code distribution (including a whole slew of great example programs + data).\n\nThe most signficant update to GLUT is the integration of the X Window System and Win32 versions of GLUT in a single source tree. GLUT works for either Win32 or X11 now. Nate Robins deserves the credit for this merging. To help Win32 users better utilize GLUT, PC-style files are available for download.\n\nYou will need a PC unzip utility that understands long file names to unzip these files correctly. Once you have the file unzipped, consult the file.\n\nIf you want just the GLUT header file, the , and files all pre-compiled for Intel platforms, you can simply download the file (149 kilobytes).\n\nYou can still download the previous version, GLUT 3.6:\n\n Download the zipped GLUT 3.6 source code distribution: \n\n Download the GLUT 3.6 image datafile distribution: \n\n Download the GLUT 3.6 headers and pre-compiled libraries:\n\nYou can also download pre-compiled GLUT 3.6 libraries for Windows NT Alpha platforms by downloading (82 kilobytes). GLUT for Alpha questions should be directed to Richard Readings ( ).\n\nThe OpenGL Utility Toolkit (GLUT) Programming Interface, API version 3 specifies all the routines in the GLUT API and how they operate. This document is available in HTML, PostScript, and PDF formats (the PDF version was generated and contributed by Richard Banks - thanks!). There have been no revisions since GLUT 3.2.\n\nThere is also a column on GLUT published in The X Journal available in PostScript. Unfortunately, The X Journal is no longer published, but back issues contain various other OpenGL columns using OpenGL with GLUT.\n\nGLUT is fully described in the book Programming OpenGL for the X Window System (Addison-Wesley, ISBN 0-201-48359-9). Consult this book for a full tutorial on GLUT.\n\nGLUT 3.0 involves an update to the GLUT API to version 3 so the GLUT library has new routines included in it implementing new functionality. There are also bug fixes, better support for IRIX 6.x's 64-bit and N32 object formats, and more sample programs.\n\nThe important new API additions are support for overlays, determining font character widths, new bitmap fonts, returning held down modifiers for mouse and keyboard events, and full screen windows.\n\nThere are a few minor bug fixes in the library. Various build problems on various built platforms have been resolved. GLUT 3.1 should build much cleanly on HP/UX, AIX, Linux, Solaris, and SunOS platforms now (cross finger). There are also a few more example programs. See the file for details.\n\nGLUT 3.2 fixed a few more minor bugs in the library. Mesa users will benefit from a hack to speed double-buffered damage regeneration. Man pages for the complete GLUT API are now included. The tests are expanded. New examples from Mesa distribution (converted to use GLUT) and advanced OpenGL programs from the Advanced OpenGL Rendering SIGGRAPH '96 class are now included. See the file for details.\n\nGLUT 3.3 is more portable; nearly all compiler warning are resolved. Lots of new GLUT-based OpenGL examples have been added or improved. Some new API has been added that will be codified with the GLUT 4 API revision. For example, an API for using InfiniteReality's dynamic video resize (DVR) capability is included. Also, a better way of getting window status is supported. There were some bug in the GLUT library itself that are now fixed. Some the warning or error messages weren't quite right. before a window is first displayed now ensures that the window need not be positioned by the user. See the file for details.\n\nAn Ada binding for SGI machines is included along with an Ada example. Many new sample programs. Several such as dinoshade.c demonstrate real-time rendering techniques relevant for games. Examples using Sam Leffler's libtiff library for loading, drawing, and writing TIFF image files. GLUT version of the facial animation \"geoview\" decibed in the Parke and Water's book Computer Facial Animation. New API interfaces to be made part of the GLUT 4 API update (not yet fully finalized though). for example. Improved portability and a few bug fixes.\n\nThe most significant change with GLUT 3.5 is unifying the X Window System and Win32 versions of GLUT into a single source code distribution. Henk Kok contributed several cool new demos ( , , ). All the demos build cleanly under Win32. Lots of bug fixes. Interesting new OpenGL rendering techniques are demonstrated in a number of new examples: , dinoshade, , , , , , , , . Also, Tom Davis contributed a user interface library called microUI (MUI) that is layered on top of GLUT.\n\nGLUT 3.6 has substantially improved the Win32 GLUT compliance and performance. Windows 95 & NT users should find GLUT 3.6 a substantial improvement over GLUT 3.5's Win32 support. Lots more demos and examples have been added. is a notable addition. Linas Vesptas's GLE Tubing and Extrusion library with documentation and example programs is now a part of GLUT. Many minor bugs were fixed.\n\nGLUT 3.7 adds a full-screen game mode for programs which wish to take over the entire display. The glsmap library for dynamic real-time sphere mapping is included, along with demos showing how to use glsmap for multiple reflections. A port of the Iris GL \"wave physics\" demo by Erik Larsen and a red-blue stereo demo program from Walter Vannini are included. Man pages are updated, and missing entry points added to the GLUT Ada bindings. Win32 performance improvements and bug fixes.\n\nI've collected a page of GLUT frequently asked questions that I expect about GLUT 3.6.\n\nIf you have benefited from using GLUT and have developed a cool GLUT program that you would like included with a future GLUT source code distribution, feel free to notify me by email about including it.\n\nPlease send email to to report bugs or problems with GLUT. Win32 GLUT programs can be sent to Nate Robins at ."
    },
    {
        "link": "https://opengl.org/resources/libraries/glut",
        "document": "We direct you to use FreeGLUT found on SourceForge: http://freeglut.sourceforge.net/. The original GLUT has been unsupported for 20 years."
    },
    {
        "link": "https://people.math.sc.edu/Burkardt/cpp_src/opengl/opengl.html",
        "document": ""
    },
    {
        "link": "https://ece.lsu.edu/xinli/OpenGL/GLUTSetup.htm",
        "document": ""
    },
    {
        "link": "https://math.hws.edu/graphicsbook/c3/s6.html",
        "document": "OpenGL is an API for graphics only, with no support for things like windows or events. OpenGL depends on external mechanisms to create the drawing surfaces on which it will draw. Windowing APIs that support OpenGL often do so as one library among many others that are used to produce a complete application. We will look at two cross-platform APIs that make it possible to use OpenGL in applications, one for C/C++ and one for Java.\n\nFor simple applications written in C or C++, one possible windowing API is GLUT (OpenGL Utility Toolkit). GLUT is a small API. It is used to create windows that serve as simple frames for OpenGL drawing surfaces. It has support for handling mouse and keyboard events, and it can do basic animation. It does not support controls such as buttons or input fields, but it does allow for a menu that pops up in response to a mouse action. The original version of GLUT is no longer actively supported, and a version called freeglut (http://freeglut.sourceforge.net/) is recommended instead. For example, the version included in Linux is actually freeglut. For details of the freeglut API, see\n\nJOGL (Java OpenGL) is a collection of classes that make it possible to use OpenGL in Java applications. JOGL is integrated into Swing and AWT, the standard Java graphical user interface APIs. With JOGL, you can create Java GUI components on which you can draw using OpenGL. These OpenGL components can be used in any Java application, in much the same way that you would use a Canvas or JPanel as a drawing surface. Like many things Java, JOGL is immensely complicated. We will use it only in fairly simple applications. JOGL is not a standard part of Java. It's home web site is\n\nThis section contains information to get you started using GLUT and JOGL, assuming that you already know the basics of programming with C and Java. It also briefly discusses glsim.js, a JavaScript library that I have written to simulate the subset of OpenGL 1.1 that is used in this book.\n\nTo work with GLUT, you will need a C compiler and copies of the OpenGL and GLUT (or freeglut) development libraries. I can't tell you exactly that means on your own computer. On my computer, which runs Linux Mint, for example, the free C compiler gcc is already available. To do OpenGL development, I installed several packages, including freeglut3-dev and libgl1-mesa-dev. (Mesa is a Linux implementation of OpenGL.) If glutprog.c contains a complete C program that uses GLUT, I can compile it using a command such as The \"-o glutprog\" tells the compiler to use \"glutprog\" as the name of its output file, which can then be run as a normal executable file; without this option, the executable file would be named \"a.out\". The \"-lglut\" and \"-lGL\" options tell the compiler to link the program with the GLUT and OpenGL libraries. (The character after the \"-\" is a lower case \"L\".) Without these options, the linker won't recognize any GLUT or OpenGL functions. If the program also uses the GLU library, compiling it would require the option \"-lGLU, and if it uses the math library, it would need the option \"-lm\". If a program requires additional .c files, they should be included as well. For example, the sample program glut/color-cube-of-spheres.c depends on camera.c, and it can be compiled with the Linux gcc compiler using the command: The sample program glut/glut-starter.c can be used as a starting point for writing programs that use GLUT. While it doesn't do anything except open a window, the program contains the framework needed to do OpenGL drawing, including doing animation, responding to mouse and keyboard events, and setting up a menu. The source code contains comments that tell you how to use it. On Windows, you might consider installing the WSL, or Windows Subsystem for Linux, (https://docs.microsoft.com/en-us/windows/wsl/), which as I write this should soon include the ability to work with GUI programs. WSL is an official Microsoft system lets you install a version of Linux inside Windows. Another option is the older open source project, Cygwin (https://cygwin.com/). (Using Cygwin, I installed the packages gcc-core, xinit, xorg-server, libglut-devel, libGLU-devel, and libGL-devel. After starting the X11 window system with the startxwin command, I was able to compile and run OpenGL examples from this textbook in a Cygwin terminal window using the same commands that I would use in Linux.) For MacOS, the situation is more complicated, because OpenGL has been deprecated in favor of Metal, Apple's own proprietary API. However, as I write this, OpenGL can still be used on MacOS with Apple's XCode developer tools. The examples from this textbook require some modification to work with XCode tools, since the OpenGL and GLUT libraries are not loaded in the same way on Mac as they are on Linux. Modified programs for use on MacOS can be found in the source folder glut/glut-mac. See the README.txt file in that folder for more information. The GLUT library makes it easy to write basic OpenGL applications in C. GLUT uses event-handling functions. You write functions to handle events that occur when the display needs to be redrawn or when the user clicks the mouse or presses a key on the keyboard. To use GLUT, you need to include the header file glut.h (or freeglut.h) at the start of any source code file that uses it, along with the general OpenGL header file, gl.h. The header files should be installed in a standard location, in a folder named GL. (But note that the folder name could be different, or omitted entirely.) So, the program usually begins with something like On my computer, saying #include <GL/glut.h> actually includes the subset of FreeGLUT that corresponds to GLUT. To get access to all of FreeGLUT, I would substitute #include <GL/freeglut.h>. Depending on the features that it uses, a program might need other header files, such as #include <GL/glu.h> and #include <math.h>. The program's main() function must contain some code to initialize GLUT, to create and open a window, and to set up event handling by registering the functions that should be called in response to various events. After this setup, it must call a function that runs the GLUT event-handling loop. That function waits for events and processes them by calling the functions that have been registered to handle them. The event loop runs until the program ends, which happens when the user closes the window or when the program calls the standard exit() function. To set up the event-handling functions, GLUT uses the fact that in C, it is possible to pass a function name as a parameter to another function. For example, if display() is the function that should be called to draw the content of the window, then the program would use the command to install this function as an event handler for display events. A display event occurs when the contents of the window need to be redrawn, including when the window is first opened. Note that display must have been previously defined, as a function with no parameters: Keep in mind that it's not the name of this function that makes it an OpenGL display function. It has to be set as the display function by calling glutDisplayFunc(display). All of the GLUT event-handling functions work in a similar way (except many of them do need to have parameters). There are a lot of possible event-handling functions, and I will only cover some of them here. Let's jump right in and look at a possible main() routine for a GLUT program that uses most of the common event handlers: int main(int argc, char** argv) { glutInit(&argc, argv); // Required initialization! glutInitDisplayMode(GLUT_DOUBLE | GLUT_DEPTH); glutInitWindowSize(500,500); // size of display area, in pixels glutInitWindowPosition(100,100); // location in screen coordinates glutCreateWindow(\"OpenGL Program\"); // the parameter is the window title glutDisplayFunc(display); // called when window needs to be redrawn glutReshapeFunc(reshape); // called when size of the window changes glutKeyboardFunc(keyFunc); // called when user types a character glutSpecialFunc(specialKeyFunc);// called when user presses a special key glutMouseFunc(mouseFunc); // called for mousedown and mouseup events glutMotionFunc(mouseDragFunc); // called when mouse is dragged glutIdleFunc(idleFun); // called when there are no other events glutMainLoop(); // Run the event loop! This function never returns. return 0; // (This line will never actually be reached.) } The first five lines do some necessary initialization, the next seven lines install event handlers, and the call to glutMainLoop() runs the GLUT event loop. I will discuss all of the functions that are used here. The first GLUT function call must be glutInit, with the parameters as shown. (Note that argc and argv represent command-line arguments for the program. Passing them to glutInit allows it to process certain command-line arguments that are recognized by GLUT. I won't discuss those arguments here.) The functions glutInitWindowSize and glutInitWindowPosition do the obvious things; size is given in pixels, and window position is given in terms of pixel coordinates on the computer screen, with (0,0) at the upper left corner of the screen. The function glutCreateWindow creates the window, but note that nothing can happen in that window until glutMainLoop is called. Often, an additional, user-defined function is called in main() to do whatever initialization of global variables and OpenGL state is required by the program. OpenGL initialization can be done after calling glutCreateWindow and before calling glutMainLoop. Turning to the other functions used in main(), glutInitDisplayMode(GLUT_DOUBLE | GLUT_DEPTH) — Must be called to define some characteristics of the OpenGL drawing context. The parameter specifies features that you would like the OpenGL context to have. The features are represented by constants that are OR'ed together in the parameter. GLUT_DEPTH says that a depth buffer should be created; without it, the depth test won't work. If you are doing 2D graphics, you wouldn't include this option. GLUT_DOUBLE asks for double buffering, which means that drawing is actually done off-screen, and the off-screen copy has to copied to the screen to be seen. The copying is done by glutSwapBuffers(), which must be called at the end of the display function. (You can use GLUT_SINGLE instead of GLUT_DOUBLE to get single buffering; in that case, you have to call glFlush() at the end of the display function instead of glutSwapBuffers(). However, all of the examples in this book use GLUT_DOUBLE.) glutDisplayFunc(display) — The display function should contain OpenGL drawing code that can completely redraw the scene. This is similar to paintComponent() in the Java Swing API. The display function can have any name, but it must be declared as a void function with no parameters: void display(). glutReshapeFunc(reshape) — The reshape function is called when the user changes the size of the window. Its parameters tell the new width and height of the drawing area: For example, you might use this method to set up the projection transform, if the projection depends only on the window size. A reshape function is not required, but if one is provided, it should always set the OpenGL viewport, which is the part of the window that is used for drawing. Do this by calling The viewport is set automatically if no reshape function is specified. glutKeyboardFunc(keyFunc) — The keyboard function is called when the user types a character such as 'b' or 'A' or a space. It is not called for special keys such as arrow keys that do not produce characters when pressed. The keyboard function has a parameter of type unsigned char which represents the character that was typed. It also has two int parameters that give the location of the mouse when the key was pressed, in pixel coordinates with (0,0) at the upper left corner of the display area. So, the definition of the key function must have the form: Whenever you make any changes to the program's data that require the display to be redrawn, you should call glutPostRedisplay(). This is similar to calling repaint() in Java. It is better to call glutPostRedisplay() than to call the display function directly. (I also note that it's possible to call OpenGL drawing commands directly in the event-handling functions, but it probably only makes sense if you are using single buffering; if you do this, call glFlush() to make sure that the drawing appears on the screen.) glutSpecialFunc(specialKeyFunc) — The \"special\" function is called when the user presses certain special keys, such as an arrow key or the Home key. The parameters are an integer code for the key that was pressed, plus the mouse position when the key was pressed: GLUT has constants to represent the possible key codes, including GLUT_KEY_LEFT, GLUT_KEY_RIGHT, GLUT_KEY_UP, and GLUT_KEY_DOWN for the arrow keys and GLUT_KEY_HOME for the Home key. For example, you can check whether the user pressed the left arrow key by testing if (key == GLUT_KEY_LEFT). glutMouseFunc(mouseFunc) — The mouse function is called both when the user presses and when the user releases a button on the mouse, with a parameter to tell which of these occurred. The function will generally look like this: void mouseFunc(int button, int buttonState, int x, int y) { if (buttonState == GLUT_DOWN) { // handle mousePressed event } else { // buttonState is GLUT_UP // handle mouseReleased event } } The first parameter tells which mouse button was pressed or released; its value is the constant GLUT_LEFT_BUTTON for the left, GLUT_MIDDLE_BUTTON for the middle, and GLUT_RIGHT_BUTTON for the right mouse button. The other two parameters tell the position of the mouse. The mouse position is given in pixel coordinates with (0,0) in the top left corner of the display area and with y increasing from top to bottom. glutMotionFunc(mouseDragFunc) — The motion function is called when the user moves the mouse while dragging, that is, while a mouse button is pressed. After the user presses the mouse in the OpenGL window, this function will continue to be called even if the mouse moves outside the window, and the mouse release event will also be sent to the same window. The function has two parameters to specify the new mouse position: glutIdleFunc(idleFunction) — The idle function is called by the GLUT event loop whenever there are no events waiting to be processed. The idle function has no parameters. It is called as often as possible, not at periodic intervals. GLUT also has a timer function, which schedules some function to be called once, after a specified delay. To set a timer, call The parameter to timerFunction when it is called will be the same integer that was passed as the third parameter to glutTimerFunc. If you want to use glutTimerFunc for animation, then timerFunction should end with another call to glutTimerFunc. A GLUT window does not have a menu bar, but it is possible to add a hidden popup menu to the window. The menu will appear in response to a mouse click on the display. You can set whether it is triggered by the left, middle, or right mouse button. A menu is created using the function glutCreateMenu(menuHandler), where the parameter is the name of a function that will be called when the user selects a command from the menu. The function must be defined with a parameter of type int that identifies the command that was selected: Once the menu has been created, commands are added to the menu by calling the function glutAddMenuEntry(name,commandID). The first parameter is the string that will appear in the menu. The second is an int that identifies the command; it is the integer that will be passed to the menu-handling function when the user selects the command from the menu. Finally, the function glutAttachMenu(button) attaches the menu to the window. The parameter specifies which mouse button will trigger the menu. Possible values are GLUT_LEFT_BUTTON, GLUT_MIDDLE_BUTTON, and GLUT_RIGHT_BUTTON. As far as I can tell, if a mouse click is used to trigger the popup menu, than the same mouse click will not also produce a call to the mouse-handler function. Note that a call to glutAddMenuEntry doesn't mention the menu, and a call to glutAttachMenu doesn't mention either the menu or the window. When you call glutCreateMenu, the menu that is created becomes the \"current menu\" in the GLUT state. When glutAddMenuEntry is called, it adds a command to the current menu. When glutAttachMenu is called, it attaches the current menu to the current window, which was set by a call to glutCreateWindow. All this is consistent with the OpenGL \"state machine\" philosophy, where functions act by modifying the current state. As an example, suppose that we want to let the user set the background color for the display. We need a function to carry out commands that we will add to the menu. For example, we might define function doMenu( int commandID ) { if ( commandID == 1) glClearColor(0,0,0,1); // BLACK else if ( commandID == 2) glClearColor(1,1,1,1); // WHITE else if ( commandID == 3) glClearColor(0,0,0.5,1); // DARK BLUE else if (commandID == 10) exit(0); // END THE PROGRAM glutPostRedisplay(); // redraw the display, with the new background color } We might have another function to create the menu. This function would be called in main(), after calling glutCreateWindow: function createMenu() { glutCreateMenu( doMenu ); // Call doMenu() in response to menu commands. glutAddMenuEntry( \"Black Background\", 1 ); glutAddMenuEntry( \"White Background\", 2 ); glutAddMenuEntry( \"Blue Background\", 3 ); glutAddMenuEntry( \"EXIT\", 10 ); glutAttachMenu(GLUT_RIGHT_BUTTON); // Show menu on right-click. } It's possible to have submenus in a menu. I won't discuss the procedure here, but you can look at the sample program glut/ifs-polyhedron-viewer.c for an example of using submenus. In addition to window and event handling, GLUT includes some functions for drawing basic 3D shapes such as spheres, cones, and regular polyhedra. It has two functions for each shape, a \"solid\" version that draws the shape as a solid object, and a wireframe version that draws something that looks like it's made of wire mesh. (The wireframe is produced by drawing just the outlines of the polygons that make up the object.) For example, the function draws a solid sphere with the given radius, centered at the origin. Remember that this is just an approximation of a sphere, made up of polygons. For the approximation, the sphere is divided by lines of longitude, like the slices of an orange, and by lines of latitude, like a stack of disks. The parameters slices and stacks tell how many subdivisions to use. Typical values are 32 and 16, but the number that you need to get a good approximation for a sphere depends on the size of the sphere on the screen. The function glutWireframeSphere has the same parameters but draws only the lines of latitude and longitude. Functions for a cone, a cylinder, and a torus (doughnut) are similar: void glutSolidCone(double base, double height, int slices, int stacks) void glutSolidTorus(double innerRadius, double outerRadius, int slices, int rings) void glutSolidCylinder(double radius, double height, int slices, int stacks) // NOTE: Cylinders are available in FreeGLUT and in Java, // but not in the original GLUT library. For a torus, the innerRadius is the size of the doughnut hole. The function draws a cube of a specified size. There are functions for the other regular polyhedra that have no parameters and draw the object at some fixed size: glutSolidTetrahedron(), glutSolidOctahedron(), glutSolidDodecahedron(), and glutSolidIcosahedron(). There is also glutSolidTeapot(size) that draws a famous object that is often used as an example. Here's what the teapot looks like: Wireframe versions of all of the shapes are also available. For example, glutWireTeapot(size) draws a wireframe teapot. Note that GLUT shapes come with normal vectors that are required for lighting calculations. However, except for the teapot, they do not come with texture coordinates, which are required for applying textures to objects. GLUT also includes some limited support for drawing text in an OpenGL drawing context. I won't discuss that possibility here. You can check the API documentation if you are interested, and you can find an example in the sample program glut/color-cube-of-spheres.c.\n\nJOGL is a framework for using OpenGL in Java programs. It is a large and complex API that supports all versions of OpenGL, but it is fairly easy to use for basic applications. You should use JOGL 2.4 or later. The programs in this book were tested with version 2.4.0. The sample program jogl/JoglStarter.java can be used as a starting point for writing OpenGL programs using JOGL. While it doesn't do anything except open a window, the program contains the framework needed to do OpenGL drawing, including doing animation, responding to mouse and keyboard events, and setting up a menu. The source code contains comments that tell you how to use it. To use JOGL, you will need two .jar files containing the Java classes for JOGL: jogl-all.jar and gluegen-rt.jar. In addition, you will need two native library files. A native library is a collection of routines that can be called from Java but are not written in Java. Routines in a native library will work on only one kind of computer; you need a different native library for each type of computer on which your program is to be used. The native libraries for JOGL are stored in additional .jar files, which are available in several versions for different computers. For example, for 64-bit Linux on Intel or AMD CPUs, you need jogl-all-natives-linux-amd64.jar and gluegen-rt-natives-linux-amd64.jar. It is unfortunate that there are different versions for different platforms, since many people don't know exactly which one they are using. However, if you are in doubt, you can get more than one version; JOGL will figure out which one to use. JOGL software can be found at https://jogamp.org/. You can download the jar files from the most recent release, which can be found near the end of the list at Click on the release name, then click on the jar/ link to see the full list of jar files. Find and download jogl-all.jar and gluegen-rt.jar and the corresponding native library files. I have also made jogl-all.jar and gluegen-rt.jar available on my own web site, along with the native libraries for some of the most common platforms, at JOGL is open-source, and the files are freely redistributable, according to their license. To do JOGL development, you should create a directory somewhere on your computer to hold the jar files. Place the two JOGL jar files in that directory, along with the two native library jar files for your platform. (Having extra native library jar files doesn't hurt, as long as you have the ones that you need.) It is possible to do JOGL development on the command line. You have to tell the javac command where to find the two JOGL jar files. You do that in the classpath (\"-cp\") option to the javac command. For example, if you are working in Linux or MacOS, and if the jar files happen to be in the same directory where you are working, you might say: It's similar for Windows, except that the classpath uses a \";\" instead of a \":\" to separate the items in the list: There is an essential period at the end of the classpath, which makes it possible for Java to find .java files in the current directory. If the jar files are not in the current directory, you can use full path names or relative path names to the files. For example, Running a program with the java command is exactly similar. For example: Note that you don't have to explicitly reference the native library jar files. They just have to be in the same directory with the JOGL jar files. I do most of my Java development using the Eclipse IDE (http://eclipse.org). To do development with JOGL in Eclipse, you will have to configure Eclipse with information about the jar files. To do that, start up Eclipse. You want to create a \"User Library\" to contain the jar files: Open the Eclipse Preferences window, and select \"Java\" / \"Build Path\" / \"User Libraries\" on the left. Click the \"New\" button on the right. Enter \"JOGL\" (or any name you like) as the name of the user library. Make sure that the new user library is selected in the list of libraries, then click the \"Add External Jars\" button. In the file selection box, navigate to the directory that contains the JOGL jar files, and select the two jar files that are needed for JOGL, jogl-all.jar and gluegen-rt.jar. (Again, you do not need to add the native libraries; they just need to be in the same directory as the JOGL jar files.) Click \"Open\". The selected jars will be added to the user library. (You could also add them one at a time, if you don't know how to select multiple files.) It should look something like this: Click \"OK.\" The user library has been created. You will only have to do this once, and then you can use it in all of your JOGL projects. Now, to use OpenGL in a project, create a new Java project as usual in Eclipse. (If you are asked whether you want to create a module-info.java file for the project, say \"Don't Create\". Sample programs for this textbook do not use Java modules.) Right-click the new project in the Project Explorer view, and select \"Build Path\" / \"Configure Build Path\" from the menu. You will see the project Properties dialog, with \"Java Build Path\" selected on the left. (You can also access this through the \"Properties\" command in the \"Project\" menu.) Select the \"Libraries\" tab at the top of the window, and then click on \"Class Path\" in the \"Libraries\" tab to select it. Click the \"Add Library\" button, on the right. In the popup window, select \"User Library\" and click \"Next.\" In the next window, select your JOGL User Library and click \"Finish.\" Finally, click \"Apply and Close\" in the main Properties window. Your project should now be set up to do JOGL development. You should see the JOGL User Library listed as part of the project in the Project Explorer. Any time you want to start a new JOGL project, you can go through the same setup to add the JOGL User Library to the build path in the project. With all that setup out of the way, it's time to talk about actually writing OpenGL programs with Java. With JOGL, we don't have to talk about mouse and keyboard handling or animation, since that can be done in the same way as in any Java Swing program. You will only need to know about a few classes from the JOGL API. First, you need a GUI component on which you can draw using OpenGL. For that, you can use GLJPanel, which is a subclass of JPanel. (GLJPanel is for use in programs based on the Swing API; an alternative is GLCanvas, which is a subclass of the older AWT class Canvas.) The class is defined in the package com.jogamp.opengl.awt. All of the other classes that we will need for basic OpenGL programming are in the package com.jogamp.opengl. JOGL uses Java's event framework to manage OpenGL drawing contexts, and it defines a custom event listener interface, GLEventListener, to manage OpenGL events. To draw on a GLJPanel with OpenGL, you need to create an object that implements the GLEventListener interface, and register that listener with your GLJPanel. The GLEventListener interface defines the following methods: The drawable parameter in these methods tells which OpenGL drawing surface is involved. It will be a reference to the GLJPanel. (GLAutoDrawable is an interface that is implemented by GLJPanel and other OpenGL drawing surfaces.) The init() method is a place to do OpenGL initialization. (According to the documentation, it can actually be called several times, if the OpenGL context needs to be recreated for some reason. So init() should not be used to do initialization that shouldn't be done more than once.) The dispose() method will be called to give you a chance to do any cleanup before the OpenGL drawing context is destroyed. The reshape() method is called when the window first opens and whenever the size of the GLJPanel changes. OpenGL's glViewport() function is called automatically before reshape() is called, so you won't need to do it yourself. Usually, you won't need to write any code in dispose() or reshape(), but they have to be there to satisfy the definition of the GLEventListener interface. The display() method is where the actual drawing is done and where you will do most of your work. It should ordinarily clear the drawing area and completely redraw the scene. Take a minute to study an outline for a minimal JOGL program. It creates a GLJPanel which also serves as the GLEventListener: import com.jogamp.opengl.*; import com.jogamp.opengl.awt.GLJPanel; import java.awt.Dimension; import javax.swing.JFrame; public class JOGLProgram extends GLJPanel implements GLEventListener { public static void main(String[] args) { JFrame window = new JFrame(\"JOGL Program\"); JOGLProgram panel = new JOGLProgram(); window.setContentPane(panel); window.pack(); window.setLocation(50,50); window.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); window.setVisible(true); } public JOGLProgram() { setPreferredSize( new Dimension(500,500) ); addGLEventListener(this); } // --------------- Methods of the GLEventListener interface ----------- public void init(GLAutoDrawable drawable) { // called when the panel is created GL2 gl = drawable.getGL().getGL2(); // Add initialization code here! } public void display(GLAutoDrawable drawable) { // called when the panel needs to be drawn GL2 gl = drawable.getGL().getGL2(); // Add drawing code here! } public void reshape(GLAutoDrawable drawable, int x, int y, int width, int height) { // called when user resizes the window } public void dispose(GLAutoDrawable drawable) { // called when the panel is being disposed } } At this point, the only other thing you need to know is how to use OpenGL functions in the program. In JOGL, the OpenGL 1.1 functions are collected into an object of type GL2. (There are different classes for different versions of OpenGL; GL2 contains OpenGL 1.1 functionality, along with later versions that are compatible with 1.1.) An object of type GL2 is an OpenGL graphics context, in the same way that an object of type Graphics2D is a graphics context for ordinary Java 2D drawing. The statement in the above program obtains the drawing context for the GLAutoDrawable, that is, for the GLJPanel in that program. The name of the variable could, of course, be anything, but gl or gl2 is conventional. For the most part, using OpenGL functions in JOGL is the same as in C, except that the functions are now methods in the object gl. For example, a call to glClearColor(r,g,b,a) becomes The redundant \"gl.gl\" is a little annoying, but you get used to it. OpenGL constants such as GL_TRIANGLES are static members of GL2, so that, for example, GL_TRIANGLES becomes GL2.GL_TRIANGLES in JOGL. Parameter lists for OpenGL functions are the same as in the C API in most cases. One exception is for functions such as glVertex3fv() that take an array/pointer parameter in C. In JOGL, the parameter becomes an ordinary Java array, and an extra integer parameter is added to give the position of the data in the array. Here, for example, is how one might draw a triangle in JOGL, with all the vertex coordinates in one array: float[] coords = { 0,0.5F, -0.5F,-0.5F, 0.5F,-0.5F }; gl.glBegin(GL2.GL_TRIANGLES); gl.glVertex2fv(coords, 0); // first vertex data starts at index 0 gl.glVertex2fv(coords, 2); // second vertex data starts at index 2 gl.glVertex2fv(coords, 4); // third vertex data starts at index 4 gl.glEnd(); The biggest change in the JOGL API is the use of nio buffers instead of arrays in functions such as glVertexPointer. This is discussed in Subsection 3.4.3. We will see in Subsection 4.3.9 that texture images also get special treatment in JOGL. The JOGL API includes a class named GLUT that makes GLUT's shape-drawing functions available in Java. (Since you don't need GLUT's window or event functions in Java, only the shape functions are included.) Class GLUT is defined in the package com.jogamp.opengl.util.gl2. To draw shapes using this class, you need to create an object of type GLUT. It's only necessary to make one of these for use in a program: The methods in this object include all the shape-drawing functions from the GLUT C API, with the same names and parameters. For example: The GLU library is available through the class com.jogamp.opengl.glu.GLU, and it works similarly to GLUT. That is, you have to create an object of type GLU, and the GLU functions will be available as methods in that object. We have encountered GLU only for the functions gluLookAt and gluPerspective, which are discussed in Section 3.3. For example,\n\nThe JavaScript library glsim.js was written to accompany and support this textbook. It implements the subset of OpenGL 1.1 that is discussed in Chapter 3 and Chapter 4, except for display lists (Subsection 3.4.4). It is used in the demos that appear in those chapters. Many of the sample programs that are discussed in those chapters are available in JavaScript versions that use glsim.js. If you would like to experiment with OpenGL 1.1, but don't want to go through the trouble of setting up a C or Java environment that supports OpenGL programming, you can consider writing your programs as web pages using glsim.js. Note that glsim is meant for experimentation and practice only, not for serious applications. The OpenGL API that is implemented by glsim.js is essentially the same as the C API, although some of the details of semantics are different. Of course the techniques for creating a drawing surface and an OpenGL drawing context are specific to JavaScript and differ from those used in GLUT or JOGL. To use glsim.js, you need to create an HTML document with a <canvas> element to serve as the drawing surface. The HTML file has to import the script; if glsim.js is in the same directory as the HTML file, you can do that with To create the OpenGL drawing context, use the JavaScript command where canvas is either a string giving the id of the <canvas> element or is the JavaScript DOM object corresponding to the <canvas> element. Once you have created the drawing context in this way, any OpenGL commands that you give will apply to the canvas. To run the program, you just need to open the HTML document in a web browser that supports WebGL 1.0. The easiest way to get started programming is to modify a program that already exists. The sample program glsim/first-triangle.html, from Subsection 3.1.2 is a very minimal example of using glsim.js. The sample web page glsim/glsim-starter.html can be used as a starting point for writing longer programs that use glsim.js. It provides a framework for doing OpenGL drawing, with support for animation and mouse and keyboard events. The code contains comments that tell you how to use it. Some documentation for the glsim.js library can be found in glsim/glsim-doc.html."
    },
    {
        "link": "https://learnopengl.com/Guest-Articles/2021/Tessellation/Height-map",
        "document": "When terrain (without any caves or overhangs) is being rendered, a mesh can be perturbed based on a height map. The height map is a grayscale image with the texel value corresponding to the distance a vertex should be moved along its normal. In order to have highly detailed terrain it is necessary to have a high resolution mesh.\n\nIn this chapter we will render the corresponding terrain using a static method:\n\nThe next chapter will give us comparable results, greater control & flexibility, and better performance.\n\nBelow is a height map of Iceland used throughout this chapter. The height map was generated using Tangram Heightmapper.\n\nWe will read in the height map data into an array that stores the pixel data.\n\nWe'll now generate a mesh that matches the resolution of our image. The above method will set the variables and to the size of the image and will contain elements. Our mesh will then be an array consisting of x vertices. For the sample height map provided, this will result in a mesh of 1756 x 2624 vertices for a total of 4,607,744 vertices.\n\nWe'll use a ( ) to specify the vertex data of the mesh. Our mesh will be centered at the origin, lie in the XZ-plane, and have a size of x . Each vertex will be one unit apart in model space. The vertex will then be displayed along the surface normal (the Y-axis) based on the corresponding location from the height map. The following image helps visualize how the mesh will be built up by a set of vertices.\n\nWe'll now populate each mesh vertex as follows.\n\nIn the above code, the vector will be storing the (x, y, z) coordinate all of the vertices separately. The vector will ultimately have a size of elements. The two for loops go through each texel in the height map and is then retrieving the ij-th texel from the height map. The height map is grayscale so we'll store the first channel (regardless if the actual texel is comprised of three RGB channels or a single channel) as the value we'll use for the y coordinate, or height, of the vertex on the mesh. We now can calculate the XYZ coordinate of the current vertex in the mesh:\n• = We'll have these range from to . This would correspond to the x dimension our ground would span in our scene.\n• = This is the height of each vertex to give our mesh elevation. The value we get out of our height map is within the range [0, 256]. We use the to serve two purposes: (1) normalize the height map data to be within the range [0.0f, 1.0f] (2) scale it to the desired height we wish to work with. This now puts the values within the range [0.0f, 64.0f]. We finally apply a shift to translate the elevations to our final desired range, in this case [-16.0f, 48.0f]. You can choose the scale and shift you wish to apply based on your application.\n• = We'll have these range from to . This would correspond to the z dimension our ground would span in our scene.\n\nAfter building up the vertex array, we can release the height map from memory.\n\nWe'll ultimately render the mesh as a sequence of triangle strips, so we'll use an ( ) to connect the vertices in to triangles. The mesh will be broken into triangle strips across each row. In the image, each colored triangle strip corresponds to a single triangle strip for row across columns .\n\nEach triangle strip has its vertices ordered by alternating from the top row to the bottom row.\n\nWe can efficiently create a strip by alternating between row and row as we sweep across all columns .\n\nThe indices for each triangle strip is generated by the following tripley nested for loop.\n\nThere are two values we need to know when rendering, so we'll compute these at this time. The first value is the number of strips to be rendered and the second value is the number of vertices per strip. These values directly correlate to the three loops above.\n\nEach strip will be comprised of triangles and our full mesh will contain triangles. The Iceland height map contains 1,755 strips with 5,246 triangles each for a total of 9,206,730 triangles!\n\nWith all of our mesh data now computed, we can set up our ( ) on the GPU.\n\nAnd finally it's time to render the mesh strip by strip.\n\nWhen rendering, we'll pass the y coordinate of our vertex from the vertex shader to the fragment shader. In the fragment shader, we'll then normalize this value (using the reverse shift & scale from above) to convert it into a grayscale value. The resulting terrain is displayed below from two different view points.\n\nBelow is a wireframe displaying the resolution of the mesh.\n\nYou can find the full source code for the CPU terrain height map demo here.\n\nThe above implementation works but has its deficiencies:\n• The mesh generation is time intensive ( O( ) - Refer back to vertex generation and index generation).\n• The mesh storage is memory intensive to store the vertices and indices\n\n ( - almost 72MB in our example).\n• The mesh has a fixed uniform resolution ( vertices and triangles - 4,607,744 vertices and 9,206,730 triangles in our example).\n• The Vertex Shader needs to process a minimum of vertices.\n• To draw the entire mesh, we need to have draw calls.\n\nIn the next chapter, we'll offload the work to the GPU making use of tessellation shaders to improve the performance & memory footprint while also making the rendering adaptive to the necessary level of detail."
    },
    {
        "link": "https://stackoverflow.com/questions/31696401/c-opengl-terrain-generation",
        "document": "Im trying to make a terrain from a grid of vertices and i have a bug and just cant find it.Im stuck with it for 3 hours.Im using c++ and opengl.Im plan to use a blendmap for texturing and a height map later.Anyway here's the code:\n\nHeres how it should look like: http://postimg.org/image/9431kcvy7/\n\nHeres how it looks: http://postimg.org/image/xxsoesqkp/\n\nAs you can see the tringles are separated by a 1 unit rectagle and it look like all the bottom points form a triangle with the point that has coordinates (0,0,0)\n\nI know this problem might seem easy to solve but ive lost already 3 hours trying.Please help:)"
    },
    {
        "link": "https://reddit.com/r/opengl/comments/y0jjr9/rendering_terrains_in_opengl",
        "document": "I'm recently working on Procedural Terrain Generation using Perlin noise in OpenGL. I understand that you first generate a set of positions containing each vertex of the terrain using Perlin, but I'd like getting a general idea about creating triangle meshes for the terrain and computing normals (rendering the terrain)"
    },
    {
        "link": "https://stackoverflow.com/questions/10263732/how-to-create-large-terrain-landscape",
        "document": "I was wandering how it's possible to create a large terrain in opengl. My first idea was using blender and create a plane, subdevide it, create the terrain and export it as .obj. After taking a look at blender I thought this should be possible but soon I realized that my hexacore + 8GB RAM aren't able too keep up the subdeviding in order to support the required precision for a very large terrain.\n\nSo my question is, what is the best way to do this?\n• Maybe trying another 3D rendering software like cinema4d?\n• Creating the terrain step-by-step in blender and put it together later? (might be problematic to maintain the ratio between the segments)\n• Some methods I don't know about?\n\nI could create a large landscape with a random generation algorithm but I don't want a random landscape I need a customized landscape with many details. (heights, depth, paths)\n\nWhat I'll do is:\n• Create 3 different heightmaps (1. cave ground (+maybe half of the wall height), 2. inverted heightmap for cave ceiling, 3. standard surface heightmap)\n• Save them in a obj file or whatever format required\n• do some fine tuning in 3d editing tool (if it's too large to handle I'll create an app with LOD algorithm where I can edit some minor stuff)\n• save it again as whatever is required (maybe do some optimization)\n\nEdit2 The map I'm creating is so big that Photoshop is using all of my 8GB Ram so I have to split all 3 heightmaps in smaller parts and assemble them on the fly when moving over the map."
    },
    {
        "link": "https://reddit.com/r/learnprogramming/comments/szahs2/procedural_terrain_generation_where_to_start_c",
        "document": "I am wondering where to start for procedural terrain generation. I am currently using learnopengl.com , I am in the \"Lighting\" Chapter:)\n\nBut I was wondering myself on how can I create a terrain procedurally? Like I understand the concept of making a grid where its Y coord of grid vertices varies.\n\nBut I d like to have some book which would guide me from the very beginning concepts to advanced stuff.\n\nDo you know such books, sites for c++ and openGL?\n\nI tried some books , but they seemed to me a bit convoluted as they introduced some other concepts as mesh/heightmap...and etc..."
    }
]