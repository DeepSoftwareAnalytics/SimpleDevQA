[
    {
        "link": "https://react.dev/reference/react/useEffect",
        "document": "In this example, a cleanup function is not needed because the class manages only the DOM node that was passed to it. After the React component is removed from the tree, both the DOM node and the class instance will be automatically garbage-collected by the browser JavaScript engine. You can use an Effect to fetch data for your component. Note that if you use a framework, using your framework‚Äôs data fetching mechanism will be a lot more efficient than writing Effects manually. If you want to fetch data from an Effect manually, your code might look like this: Note the variable which is initialized to , and is set to during cleanup. This ensures your code doesn‚Äôt suffer from ‚Äúrace conditions‚Äù: network responses may arrive in a different order than you sent them.\n\nWriting data fetching directly in Effects gets repetitive and makes it difficult to add optimizations like caching and server rendering later. It‚Äôs easier to use a custom Hook‚Äîeither your own or maintained by the community. What are good alternatives to data fetching in Effects? Writing calls inside Effects is a popular way to fetch data, especially in fully client-side apps. This is, however, a very manual approach and it has significant downsides:\n‚Ä¢ Effects don‚Äôt run on the server. This means that the initial server-rendered HTML will only include a loading state with no data. The client computer will have to download all JavaScript and render your app only to discover that now it needs to load the data. This is not very efficient.\n‚Ä¢ Fetching directly in Effects makes it easy to create ‚Äúnetwork waterfalls‚Äù. You render the parent component, it fetches some data, renders the child components, and then they start fetching their data. If the network is not very fast, this is significantly slower than fetching all data in parallel.\n‚Ä¢ Fetching directly in Effects usually means you don‚Äôt preload or cache data. For example, if the component unmounts and then mounts again, it would have to fetch the data again.\n‚Ä¢ It‚Äôs not very ergonomic. There‚Äôs quite a bit of boilerplate code involved when writing calls in a way that doesn‚Äôt suffer from bugs like race conditions. This list of downsides is not specific to React. It applies to fetching data on mount with any library. Like with routing, data fetching is not trivial to do well, so we recommend the following approaches:\n‚Ä¢ If you use a framework, use its built-in data fetching mechanism. Modern React frameworks have integrated data fetching mechanisms that are efficient and don‚Äôt suffer from the above pitfalls.\n‚Ä¢ Otherwise, consider using or building a client-side cache. Popular open source solutions include React Query, useSWR, and React Router 6.4+. You can build your own solution too, in which case you would use Effects under the hood but also add logic for deduplicating requests, caching responses, and avoiding network waterfalls (by preloading data or hoisting data requirements to routes). You can continue fetching data directly in Effects if neither of these approaches suit you. Notice that you can‚Äôt ‚Äúchoose‚Äù the dependencies of your Effect. Every reactive value used by your Effect‚Äôs code must be declared as a dependency. Your Effect‚Äôs dependency list is determined by the surrounding code: If either or change, your Effect will reconnect to the chat using the new values. Reactive values include props and all variables and functions declared directly inside of your component. Since and are reactive values, you can‚Äôt remove them from the dependencies. If you try to omit them and your linter is correctly configured for React, the linter will flag this as a mistake you need to fix: To remove a dependency, you need to ‚Äúprove‚Äù to the linter that it doesn‚Äôt need to be a dependency. For example, you can move out of your component to prove that it‚Äôs not reactive and won‚Äôt change on re-renders: Now that is not a reactive value (and can‚Äôt change on a re-render), it doesn‚Äôt need to be a dependency. If your Effect‚Äôs code doesn‚Äôt use any reactive values, its dependency list should be empty ( ): An Effect with empty dependencies doesn‚Äôt re-run when any of your component‚Äôs props or state change. If you have an existing codebase, you might have some Effects that suppress the linter like this: When dependencies don‚Äôt match the code, there is a high risk of introducing bugs. By suppressing the linter, you ‚Äúlie‚Äù to React about the values your Effect depends on. Instead, prove they‚Äôre unnecessary.\n\nNow that you create the object inside the Effect, the Effect itself only depends on the string. With this fix, typing into the input doesn‚Äôt reconnect the chat. Unlike an object which gets re-created, a string like doesn‚Äôt change unless you set it to another value. Read more about removing dependencies. If your Effect depends on an object or a function created during rendering, it might run too often. For example, this Effect re-connects after every render because the function is different for every render: By itself, creating a function from scratch on every re-render is not a problem. You don‚Äôt need to optimize that. However, if you use it as a dependency of your Effect, it will cause your Effect to re-run after every re-render. Avoid using a function created during rendering as a dependency. Instead, declare it inside the Effect:"
    },
    {
        "link": "https://legacy.reactjs.org/docs/hooks-effect.html",
        "document": "Hooks are a new addition in React 16.8. They let you use state and other React features without writing a class.\n\nThe Effect Hook lets you perform side effects in function components:\n\nThis snippet is based on the counter example from the previous page, but we added a new feature to it: we set the document title to a custom message including the number of clicks.\n\nData fetching, setting up a subscription, and manually changing the DOM in React components are all examples of side effects. Whether or not you‚Äôre used to calling these operations ‚Äúside effects‚Äù (or just ‚Äúeffects‚Äù), you‚Äôve likely performed them in your components before.\n\nThere are two common kinds of side effects in React components: those that don‚Äôt require cleanup, and those that do. Let‚Äôs look at this distinction in more detail.\n\nSometimes, we want to run some additional code after React has updated the DOM. Network requests, manual DOM mutations, and logging are common examples of effects that don‚Äôt require a cleanup. We say that because we can run them and immediately forget about them. Let‚Äôs compare how classes and Hooks let us express such side effects.\n\nIn React class components, the method itself shouldn‚Äôt cause side effects. It would be too early ‚Äî we typically want to perform our effects after React has updated the DOM.\n\nThis is why in React classes, we put side effects into and . Coming back to our example, here is a React counter class component that updates the document title right after React makes changes to the DOM:\n\nNote how we have to duplicate the code between these two lifecycle methods in class.\n\nThis is because in many cases we want to perform the same side effect regardless of whether the component just mounted, or if it has been updated. Conceptually, we want it to happen after every render ‚Äî but React class components don‚Äôt have a method like this. We could extract a separate method but we would still have to call it in two places.\n\nNow let‚Äôs see how we can do the same with the Hook.\n\nWe‚Äôve already seen this example at the top of this page, but let‚Äôs take a closer look at it:\n\nWhat does do? By using this Hook, you tell React that your component needs to do something after render. React will remember the function you passed (we‚Äôll refer to it as our ‚Äúeffect‚Äù), and call it later after performing the DOM updates. In this effect, we set the document title, but we could also perform data fetching or call some other imperative API.\n\nWhy is called inside a component? Placing inside the component lets us access the state variable (or any props) right from the effect. We don‚Äôt need a special API to read it ‚Äî it‚Äôs already in the function scope. Hooks embrace JavaScript closures and avoid introducing React-specific APIs where JavaScript already provides a solution.\n\nDoes run after every render? Yes! By default, it runs both after the first render and after every update. (We will later talk about how to customize this.) Instead of thinking in terms of ‚Äúmounting‚Äù and ‚Äúupdating‚Äù, you might find it easier to think that effects happen ‚Äúafter render‚Äù. React guarantees the DOM has been updated by the time it runs the effects.\n\nNow that we know more about effects, these lines should make sense:\n\nWe declare the state variable, and then we tell React we need to use an effect. We pass a function to the Hook. This function we pass is our effect. Inside our effect, we set the document title using the browser API. We can read the latest inside the effect because it‚Äôs in the scope of our function. When React renders our component, it will remember the effect we used, and then run our effect after updating the DOM. This happens for every render, including the first one.\n\nExperienced JavaScript developers might notice that the function passed to is going to be different on every render. This is intentional. In fact, this is what lets us read the value from inside the effect without worrying about it getting stale. Every time we re-render, we schedule a different effect, replacing the previous one. In a way, this makes the effects behave more like a part of the render result ‚Äî each effect ‚Äúbelongs‚Äù to a particular render. We will see more clearly why this is useful later on this page.\n\nEarlier, we looked at how to express side effects that don‚Äôt require any cleanup. However, some effects do. For example, we might want to set up a subscription to some external data source. In that case, it is important to clean up so that we don‚Äôt introduce a memory leak! Let‚Äôs compare how we can do it with classes and with Hooks.\n\nIn a React class, you would typically set up a subscription in , and clean it up in . For example, let‚Äôs say we have a module that lets us subscribe to a friend‚Äôs online status. Here‚Äôs how we might subscribe and display that status using a class:\n\nNotice how and need to mirror each other. Lifecycle methods force us to split this logic even though conceptually code in both of them is related to the same effect.\n\nLet‚Äôs see how we could write this component with Hooks.\n\nYou might be thinking that we‚Äôd need a separate effect to perform the cleanup. But code for adding and removing a subscription is so tightly related that is designed to keep it together. If your effect returns a function, React will run it when it is time to clean up:\n\nWhy did we return a function from our effect? This is the optional cleanup mechanism for effects. Every effect may return a function that cleans up after it. This lets us keep the logic for adding and removing subscriptions close to each other. They‚Äôre part of the same effect!\n\nWhen exactly does React clean up an effect? React performs the cleanup when the component unmounts. However, as we learned earlier, effects run for every render and not just once. This is why React also cleans up effects from the previous render before running the effects next time. We‚Äôll discuss why this helps avoid bugs and how to opt out of this behavior in case it creates performance issues later below.\n\nWe‚Äôve learned that lets us express different kinds of side effects after a component renders. Some effects might require cleanup so they return a function:\n\nOther effects might not have a cleanup phase, and don‚Äôt return anything.\n\nThe Effect Hook unifies both use cases with a single API.\n\nIf you feel like you have a decent grasp on how the Effect Hook works, or if you feel overwhelmed, you can jump to the next page about Rules of Hooks now.\n\nWe‚Äôll continue this page with an in-depth look at some aspects of that experienced React users will likely be curious about. Don‚Äôt feel obligated to dig into them now. You can always come back to this page to learn more details about the Effect Hook.\n\nOne of the problems we outlined in the Motivation for Hooks is that class lifecycle methods often contain unrelated logic, but related logic gets broken up into several methods. Here is a component that combines the counter and the friend status indicator logic from the previous examples:\n\nNote how the logic that sets is split between and . The subscription logic is also spread between and . And contains code for both tasks.\n\nSo, how can Hooks solve this problem? Just like you can use the State Hook more than once, you can also use several effects. This lets us separate unrelated logic into different effects:\n\nHooks let us split the code based on what it is doing rather than a lifecycle method name. React will apply every effect used by the component, in the order they were specified.\n\nIf you‚Äôre used to classes, you might be wondering why the effect cleanup phase happens after every re-render, and not just once during unmounting. Let‚Äôs look at a practical example to see why this design helps us create components with fewer bugs.\n\nEarlier on this page, we introduced an example component that displays whether a friend is online or not. Our class reads from , subscribes to the friend status after the component mounts, and unsubscribes during unmounting:\n\nBut what happens if the prop changes while the component is on the screen? Our component would continue displaying the online status of a different friend. This is a bug. We would also cause a memory leak or crash when unmounting since the unsubscribe call would use the wrong friend ID.\n\nIn a class component, we would need to add to handle this case:\n\nForgetting to handle properly is a common source of bugs in React applications.\n\nNow consider the version of this component that uses Hooks:\n\nIt doesn‚Äôt suffer from this bug. (But we also didn‚Äôt make any changes to it.)\n\nThere is no special code for handling updates because handles them by default. It cleans up the previous effects before applying the next effects. To illustrate this, here is a sequence of subscribe and unsubscribe calls that this component could produce over time:\n\nThis behavior ensures consistency by default and prevents bugs that are common in class components due to missing update logic.\n\nIn some cases, cleaning up or applying the effect after every render might create a performance problem. In class components, we can solve this by writing an extra comparison with or inside :\n\nThis requirement is common enough that it is built into the Hook API. You can tell React to skip applying an effect if certain values haven‚Äôt changed between re-renders. To do so, pass an array as an optional second argument to :\n\nIn the example above, we pass as the second argument. What does this mean? If the is , and then our component re-renders with still equal to , React will compare from the previous render and from the next render. Because all items in the array are the same ( ), React would skip the effect. That‚Äôs our optimization.\n\nWhen we render with updated to , React will compare the items in the array from the previous render to items in the array from the next render. This time, React will re-apply the effect because . If there are multiple items in the array, React will re-run the effect even if just one of them is different.\n\nThis also works for effects that have a cleanup phase:\n\nIn the future, the second argument might get added automatically by a build-time transformation.\n\nCongratulations! This was a long page, but hopefully by the end most of your questions about effects were answered. You‚Äôve learned both the State Hook and the Effect Hook, and there is a lot you can do with both of them combined. They cover most of the use cases for classes ‚Äî and where they don‚Äôt, you might find the additional Hooks helpful.\n\nWe‚Äôre also starting to see how Hooks solve problems outlined in Motivation. We‚Äôve seen how effect cleanup avoids duplication in and , brings related code closer together, and helps us avoid bugs. We‚Äôve also seen how we can separate effects by their purpose, which is something we couldn‚Äôt do in classes at all.\n\nAt this point you might be questioning how Hooks work. How can React know which call corresponds to which state variable between re-renders? How does React ‚Äúmatch up‚Äù previous and next effects on every update? On the next page we will learn about the Rules of Hooks ‚Äî they‚Äôre essential to making Hooks work."
    },
    {
        "link": "https://w3schools.com/react/react_useeffect.asp",
        "document": "The Hook allows you to perform side effects in your components.\n\nSome examples of side effects are: fetching data, directly updating the DOM, and timers.\n\naccepts two arguments. The second argument is optional.\n\nLet's use a timer as an example.\n\nBut wait!! It keeps counting even though it should only count once!\n\nruns on every render. That means that when the count changes, a render happens, which then triggers another effect.\n\nThis is not what we want. There are several ways to control when side effects run.\n\nWe should always include the second parameter which accepts an array. We can optionally pass dependencies to in this array.\n\nSo, to fix this issue, let's only run this effect on the initial render.\n\nHere is an example of a Hook that is dependent on a variable. If the variable updates, the effect will run again: import { useState, useEffect } from \"react\"; import ReactDOM from \"react-dom/client\"; function Counter() { const [count, setCount] = useState(0); const [calculation, setCalculation] = useState(0); useEffect(() => { setCalculation(() => count * 2); }, [count]); // <- add the count variable here return ( <> <p>Count: {count}</p> <button onClick={() => setCount((c) => c + 1)}>+</button> <p>Calculation: {calculation}</p> </> ); } const root = ReactDOM.createRoot(document.getElementById('root')); root.render(<Counter />);\n\nIf there are multiple dependencies, they should be included in the dependency array.\n\nTimeouts, subscriptions, event listeners, and other effects that are no longer needed should be disposed.\n\nWe do this by including a return function at the end of the Hook."
    },
    {
        "link": "https://maxrozen.com/fetching-data-react-with-useeffect",
        "document": "So you're building a component, and need to fetch some data from an API before rendering your component. You've been told that useEffect is the way for fetching data, but all you can find is discussion about side-effects (particularly in the official useEffect docs).\n\nLet's unpack what side-effects are, and fetch ourselves some data.\n\nTo talk about side-effects, we should probably first talk about pure functions.\n\nA pure function is a function, that when given an input, will always returns the same output. Pure functions also don't modify the arguments passed to them.\n\nWhile you can have pure functions as simple as this:\n\nWe can also have pure functions that return JSX in React:\n\nSide-effects then, are operations that change things outside of your function, making the function impure.\n\nFetching data from an API, communicating with a database, and sending logs to a logging service are all considered side-effects, as it's possible to have a different output for the same input. For example, your request might fail, your database might be unreachable, or your logging service might have reached its quota.\n\nThis is why useEffect is the hook for us - by fetching data, we're making our React component impure, and useEffect provides us a safe place to write impure code.\n\nHere's how to use useEffect to only fetch data (there are a few more steps to make it useful):\n\nYou might notice a few things are missing from this example:\n‚Ä¢ we're not doing anything with the data once we fetch it\n‚Ä¢ we've hardcoded the URL to fetch data from\n\nTo make this useEffect useful, we'll need to:\n‚Ä¢ update our useEffect to pass a prop called to the URL,\n‚Ä¢ use a dependency array, so that we only run this useEffect when changes, and then\n‚Ä¢ use the useState hook to store our data so we can display it later\n\nNow let's build the rest of the component. It needs to:\n‚Ä¢ render part of the data when we do have data\n‚Ä¢ render nothing if we don't have data\n\nFinally, putting our pure React component together with our side-effect:\n\nYou might find fetching data in this way results in quite a bit of repeated code, especially if you're using , and handle error and loading states. To avoid this, a common solution is to write a custom hook.\n\nOne caveat however: this code works fine if you want to fetch data once - but if you attach a button to let users change too quickly, you'll run into a race condition!\n\nYou might also want to read this article about fixing race conditions with useEffect.\n\nIf you also want caching (to avoid requesting the same data twice), I highly recommend looking into one of these data fetching libraries instead."
    },
    {
        "link": "https://legacy.reactjs.org/docs/hooks-overview.html",
        "document": "Hooks are a new addition in React 16.8. They let you use state and other React features without writing a class.\n\nHooks are backwards-compatible. This page provides an overview of Hooks for experienced React users. This is a fast-paced overview. If you get confused, look for a yellow box like this:\n\n‚Üë‚Üë‚Üë Each section ends with a yellow box like this. They link to detailed explanations.\n\nThis example renders a counter. When you click the button, it increments the value:\n\nHere, is a Hook (we‚Äôll talk about what this means in a moment). We call it inside a function component to add some local state to it. React will preserve this state between re-renders. returns a pair: the current state value and a function that lets you update it. You can call this function from an event handler or somewhere else. It‚Äôs similar to in a class, except it doesn‚Äôt merge the old and new state together. (We‚Äôll show an example comparing to in Using the State Hook.)\n\nThe only argument to is the initial state. In the example above, it is because our counter starts from zero. Note that unlike , the state here doesn‚Äôt have to be an object ‚Äî although it can be if you want. The initial state argument is only used during the first render.\n\nYou can use the State Hook more than once in a single component:\n\nThe array destructuring syntax lets us give different names to the state variables we declared by calling . These names aren‚Äôt a part of the API. Instead, React assumes that if you call many times, you do it in the same order during every render. We‚Äôll come back to why this works and when this is useful later.\n\nBut what is a Hook?\n\nHooks are functions that let you ‚Äúhook into‚Äù React state and lifecycle features from function components. Hooks don‚Äôt work inside classes ‚Äî they let you use React without classes. (We don‚Äôt recommend rewriting your existing components overnight but you can start using Hooks in the new ones if you‚Äôd like.)\n\nReact provides a few built-in Hooks like . You can also create your own Hooks to reuse stateful behavior between different components. We‚Äôll look at the built-in Hooks first.\n\nYou‚Äôve likely performed data fetching, subscriptions, or manually changing the DOM from React components before. We call these operations ‚Äúside effects‚Äù (or ‚Äúeffects‚Äù for short) because they can affect other components and can‚Äôt be done during rendering.\n\nThe Effect Hook, , adds the ability to perform side effects from a function component. It serves the same purpose as , , and in React classes, but unified into a single API. (We‚Äôll show examples comparing to these methods in Using the Effect Hook.)\n\nFor example, this component sets the document title after React updates the DOM:\n\nWhen you call , you‚Äôre telling React to run your ‚Äúeffect‚Äù function after flushing changes to the DOM. Effects are declared inside the component so they have access to its props and state. By default, React runs the effects after every render ‚Äî including the first render. (We‚Äôll talk more about how this compares to class lifecycles in Using the Effect Hook.)\n\nEffects may also optionally specify how to ‚Äúclean up‚Äù after them by returning a function. For example, this component uses an effect to subscribe to a friend‚Äôs online status, and cleans up by unsubscribing from it:\n\nIn this example, React would unsubscribe from our when the component unmounts, as well as before re-running the effect due to a subsequent render. (If you want, there‚Äôs a way to tell React to skip re-subscribing if the we passed to didn‚Äôt change.)\n\nJust like with , you can use more than a single effect in a component:\n\nHooks let you organize side effects in a component by what pieces are related (such as adding and removing a subscription), rather than forcing a split based on lifecycle methods.\n\nHooks are JavaScript functions, but they impose two additional rules:\n‚Ä¢ Only call Hooks at the top level. Don‚Äôt call Hooks inside loops, conditions, or nested functions.\n‚Ä¢ Only call Hooks from React function components. Don‚Äôt call Hooks from regular JavaScript functions. (There is just one other valid place to call Hooks ‚Äî your own custom Hooks. We‚Äôll learn about them in a moment.)\n\nWe provide a linter plugin to enforce these rules automatically. We understand these rules might seem limiting or confusing at first, but they are essential to making Hooks work well.\n\nSometimes, we want to reuse some stateful logic between components. Traditionally, there were two popular solutions to this problem: higher-order components and render props. Custom Hooks let you do this, but without adding more components to your tree.\n\nEarlier on this page, we introduced a component that calls the and Hooks to subscribe to a friend‚Äôs online status. Let‚Äôs say we also want to reuse this subscription logic in another component.\n\nFirst, we‚Äôll extract this logic into a custom Hook called :\n\nIt takes as an argument, and returns whether our friend is online.\n\nNow we can use it from both components:\n\nThe state of each component is completely independent. Hooks are a way to reuse stateful logic, not state itself. In fact, each call to a Hook has a completely isolated state ‚Äî so you can even use the same custom Hook twice in one component.\n\nCustom Hooks are more of a convention than a feature. If a function‚Äôs name starts with ‚Äù ‚Äù and it calls other Hooks, we say it is a custom Hook. The naming convention is how our linter plugin is able to find bugs in the code using Hooks.\n\nYou can write custom Hooks that cover a wide range of use cases like form handling, animation, declarative subscriptions, timers, and probably many more we haven‚Äôt considered. We are excited to see what custom Hooks the React community will come up with.\n\nThere are a few less commonly used built-in Hooks that you might find useful. For example, lets you subscribe to React context without introducing nesting:\n\nAnd lets you manage local state of complex components with a reducer:\n\nPhew, that was fast! If some things didn‚Äôt quite make sense or you‚Äôd like to learn more in detail, you can read the next pages, starting with the State Hook documentation.\n\nYou can also check out the Hooks API reference and the Hooks FAQ.\n\nFinally, don‚Äôt miss the introduction page which explains why we‚Äôre adding Hooks and how we‚Äôll start using them side by side with classes ‚Äî without rewriting our apps."
    },
    {
        "link": "https://tradingview.com/charting-library-docs/latest/connecting_data/datafeed-api/required-methods",
        "document": "This article describes the required methods in the Datafeed API. The library calls these methods to initialize the chart, resolve requested symbols, and load data for them. At the end of the article, you can find diagrams illustrating the sequence in which methods are called.\n\nThe library calls the method when the chart is initialized. This method supplies the library with the datafeed configuration data such as supported symbol types, exchanges, time intervals (resolution), currency codes and more. Call the and pass a object as a parameter:\n\nThe following code sample shows the implementation:\n\nThe library calls the method to request symbols that match some user input. Pass the resulting array of symbols as a parameter to .\n\nAs a result, the library gets an array of objects that have the following format:\n\nIf no symbol is found, pass an empty array to .\n\nYou can adjust the frequency of search requests utilizing the property.\n\nThe library calls the method to get symbol information such as the exchange, time zone, trading hours, etc. Specify this information in a object as demonstrated below:\n\nPass symbol information as a parameter to . If the symbol cannot be resolved, call and specify an error message.\n\nIn the object, you can provide both name and ticker as the symbol name. The library behaves differently based on whether these values are the same or different:\n‚Ä¢ If the name and ticker are the same, the library makes a single call.\n‚Ä¢ If the name and ticker differ, the library resolves the symbol twice: once for the entered name (e.g., ) and again for the resolved ticker (e.g., ).\n\nMultiple resolving happens because a single symbol name can correspond to multiple tickers. For example, AAPL might return results for NASDAQ and LSE. By resolving the ticker separately, the library ensures accurate and complete information, as the ticker is expected to be unique and is prioritized for data display.\n\nYou can display the default TradingView icon when error occurs. To do this, specify the error message:\n\nIn this case, the chart shows the following icon and message.\n\nThe library calls to get historical data in a certain range. To transfer the requested data, pass an array of objects to .\n\nThe array of items should be arranged in ascending chronological order, meaning that the timestamps of the bars should be getting bigger for each bar in the array. For example, .\n\nNote that for daily, weekly, and monthly bars, the value should represent the beginning of the trading day at 00:00:00 UTC, not the beginning of the session.\n\nThe library calculates the amount of data that is necessary to fill the chart space and requests it in . You cannot change this amount. Return data to based on the following properties:\n‚Ä¢ ‚Äî Unix timestamp of the leftmost requested bar. The library requires data in the time range.\n‚Ä¢ ‚Äî Unix timestamp of the rightmost requested bar (not inclusive).\n‚Ä¢ ‚Äî the required amount of bars to load.\n\nIt is more important to pass the required number of bars than to match the time range for the following reasons:\n‚Ä¢ The library might miscalculate the value. It may happen if you provide incorrect or values. In this case, the range does not represent the required number of bars.\n‚Ä¢ The library calculates the correct value, but your backend does not contain enough bars in the range. It might happen if the market was opened, but the symbol was not traded.\n\nIn both cases, the library calls multiple times in order to get the missing data. It might cause potential issues. To avoid them, consider the following recommendations:\n‚Ä¢ Your response should always include all the existing data for the requested range.\n‚Ä¢ If the number of bars in the requested range is less than the value, you should include earlier bars until the count is reached. For example, the chart requests 300 bars in the range , and your backend have only 250 bars in the requested period. Return these 250 bars and 50 bars prior to .\n‚Ä¢ In the unlikely case that the number of bars in the requested range is larger than the value, then you should return all the bars in that range instead of truncating it to the length.\n‚Ä¢ If there is no data left (in other words the current response to return an empty array, and there is no older data on the server), set to to prevent further requests.\n\nThe library can request more bars than are visible because some indicators require additional history, for example, Moving Average with the length .\n\nThe following piece of code is just a snippet to begin with. You will have to change it to fit your requirements but copying & pasting the code below should render candles on the chart for a given symbol and nothing for all other symbols. It is also to illustrate the result.\n\nThe library calls to receive real-time updates for a symbol. Call every time you want to update the most recent bar or add a new one. For example, if the chart has loaded data up to 14:00, you can only update the last bar (14:00) or add a newer bar (15:00).\n\nIf you return a bar that has the same value as the most recent bar, the library replaces the most recent bar with the new one.\n\nConsider the following example. The most recent bar (in pseudo-code) is . You call . As the bar with the time already exists, and it is the most recent one, the library replaces the entire bar making the most recent bar .\n\nRefer to the [tutorial][tutorial-subscribe-unsubscribe] to see the example of implementation.\n\nThe library provides a unique subscriber ID as a parameter when it calls and . This subscriber ID allows you to track and manage subscriptions for symbol updates.\n\nThe library can have multiple subscriptions at the same time, for example, when a user switches to another symbol or resolution. You should handle and calls for different resolutions and symbols as independent events. Note that the library can call these methods in any order and with a delay.\n\nWhen you receive an update from the server, you should send the data via the specific callback for the subscriber which has the correct symbol name and resolution.\n\nNote that you should provide updates to all the subscriptions until the library unsubscribes from them. Therefore, you may require multiple connections to your backend server if you have multiple subscriptions.\n\nConsider the following example. The current symbol is , and the resolution is (one day). You switch the resolution to (five minutes). The library separately calls to subscribe for five-minute updates and to unsubscribe from one-day updates (after a short delay). During this period, the library has at least two active subscribers: for five-minute and one-day updates. You should send five-minute updates to the five-minute subscriber and continue to send one-day updates to the one-day subscriber until the library unsubscribes from the resolution.\n\nAssume that the last bar (in pseudo-code) is:\n\nIf the price jumps to , you should send the following bars to the subscribers:\n\nThe library calls to stop receiving updates for the symbol when the user selects another symbol on the chart. The argument contains the same object that was passed to before.\n\nRefer to the tutorial to see the example of implementation.\n\nIn this section, you can find diagrams illustrating the sequence of Datafeed API method calls. Expand the sections below to view the diagrams for the following cases:"
    },
    {
        "link": "https://tradingview.com/charting-library-docs/latest/api",
        "document": "The API is structured as a modular system of types, interfaces, and enumerations. The library's API is divided into three modules, where each module consists of interfaces that define properties and methods specific to its functionality.\n\nThe Charting Library module is designed to manage chart creation, customize the UI appearance, and handle user interactions.\n‚Ä¢ Manage drawings and indicators displayed on the chart.\n\nThe Datafeed module is designed to integrate custom data sources and controlling data flow to the chart.\n‚Ä¢ Handle custom symbology logic to map your backend symbols to TradingView's requirements.\n\nThe Broker module is designed to integrate trading capabilities provided by Trading Platform.\n‚Ä¢ Enable creating market, limit, and other order types directly from the chart interface.\n‚Ä¢ Provide real-time market quotes to power trading features like the Order Ticket, Watchlist, and Depth of Market.\n‚Ä¢ Support multiple account setups for users with diverse trading needs.\n‚Ä¢ Identify the module relevant to your task: creating charts, managing datafeeds, or enabling trading.\n‚Ä¢ Examine the available interfaces within the module. Each interface defines a set of properties and methods relevant to a specific feature or functionality.\n‚Ä¢ Follow type links and explore enumerations. If a property uses a non-primitive type, follow the link to the corresponding type definition. This will reveal additional properties and their relationships.\n‚Ä¢ Get back into the context and use your browser‚Äôs navigation to return to higher-level modules or interfaces when needed.\n\nAlternatively, if you are more comfortable browsing the API through a TypeScript definition file, you can use the following links:"
    },
    {
        "link": "https://klinecharts.com/en-US/guide/data-source",
        "document": "üîî v9 will be maintained until March 2025. It is recommended to migrate to the new version as soon as possible.\n\nThe data required by the chart must be in a fixed format. Use the chart instance APIs applyNewData(dataList, more) , updateData(data) and setLoadMoreDataCallback(callback) to interact with the chart. // Turnover, a non-required field, if you need to display the technical indicators 'EMV' and 'AVP', you need to fill this field with data."
    },
    {
        "link": "https://medium.com/@jonchurch/tradingview-charting-library-js-api-setup-for-crypto-part-1-57e37f5b3d5a",
        "document": "TradingView allows you to use their Charting Library on your own site, with your own source of data.\n\nThere are two ways to get your Data into TradingView, the UDF API and the JS API. The JS API gives you the most control over your data, and in my opinion is much more flexible. Plus it‚Äôs Javascript!\n\nYou can implement the data connection almost however you want, but actual implementation details are pretty fuzzy. The purpose of this tutorial is to show you a working example of using your own data source with TradingView‚Äôs charts to create a basic static chart.\n\nThis guide builds off the React Javascript TradingView Example available here\n\nWhen the chart widget is first loaded, it will call the JS API method with the symbolName for the default pair. In our example is the default pair. You are expected to pass a object to the callback passed into the function by the charting library.\n\nThe whole integration is composed of several parts:\n‚Ä¢ TV Widget Constructor ‚Äî takes widget options object, pass in the datafeed, the default symbol pair to display, user options, chart load/save options\n‚Ä¢ Datafeed ‚Äî Interface between the JS API and your backend\n‚Ä¢ JS API ‚Äî Function signatures required by TV to display your data\n\nPart 1 covers TV Widget Constructor, Datafeed, JS API, and History Provider for creating a single static chart, with a hardcoded symbol pair.\n\nWidget constructor options configures the TradingView Chart widget, and affects which features are enabled when the chart first loads, as well as what options can be set by the user.\n\nHere we set options like the User ID, style settings, language, the symbol pair to load, public path to the charting library, and pass in our JS API Datafeed implementation.\n\nHere is the constructor options we are starting with:\n\nThis configures the widget to show us with candle intervals of 15 minutes, and sets some other customizations (disabled features, default settings to override, what language to use, etc).\n\nOnce loaded, you shouldn‚Äôt need to change any of these options, but the widget exposes methods that can be used to change some settings dynamically. (changing symbols can be done through the symbol search which we will implement in part 3 of the tutorial)\n\nI‚Äôve set my charts up to default to dark mode by setting the .\n\nNow that we have the widget configured and styled how we like, let‚Äôs look at how we are connecting our chart data to the TradingView Charting Library‚Äôs JS API.\n\nThe JS API is really an Object you supply to the TradingView Widget, which exposes the functions that TradingView will call, and in most cases you are expected to pass data to the Callbacks within those functions to get your data working with tradingview.\n\nFor example‚Äôs sake, we are using CryptoCompare‚Äôs historic chart data*, and in part 2, their websocket API to get realtime price updates.\n\nTradingview will call the methods you provide as needed to fill the current chart with data, as well as other lifecycle methods which you must implement.\n\nBelow is the entire JS API object signature that Tradingview expects you to pass to the widget. Some methods are optional, see the docs for more info\n\nWhen the chart first loads, the JS API flow goes like this:\n\n3. is called, pass array of ohlcv objects with UTC time in milliseconds to\n\nLet‚Äôs look at our implementation for each one of these\n\nis called immediately after the chart widget initializes, and we must pass the datafeed config options into the function. The charting library wants this to be executed asynchronously, and suggests wrapping in setTimeout with delay of 0 to force this behavior.\n\nRight now we are only specifying one of the options possible, which tells the charting library which interval choices our datafeed supports for bars. These will be shown to the user, and can be overridden per symbol pair later in . The list we supplied translates to:\n\nLater in the tutorial we will add options to our Datafeed config, as we implement search and realtime charts.\n\nOnce the datafeed is configured, the charting library will call with the property from the widget config object. We are given only a string value, and must return a symbolInfo object that represents the corresponding symbol.\n\nThis is where you configure the individual pair, set the number of decimal places to display, how much it moves per tick (for crypto it‚Äôs almost always going to be 1), and very important and easy to screw up, the ! Because crypto is traded nonstop, we set the session to . Timezone is supposed to be the timezone of the exchange this symbol is traded on, not very important with 24 hour sessions.\n\nAll the documentation for symbolInfo is here, make sure to familiarize yourself with it.\n\nand control showing bar intervals below 1 day. Now here is where I made lots of mistakes: Tradingview can build some bars for you. For example, let‚Äôs pretend our historic data API can only give us data for 1 minute intervals, meaning if we request the past 24 hours of data, we will get 1440 data points, the number of minutes in 24 hours. But what if we want to display 15 minute bars? You can tell tradingview that the our is and only pass it 1 minute bars. The charting library will build the 15 minute bars for you, and display them on the chart.\n\nWe are doing the same for hour bars, telling tradingview we can supply 60 minute bars, and that it should build out our 2 hour and 4 hour bars itself from our 60 minute bars.\n\nTicker is also very important. If set, then the charting library will use ticker internally to refer to this unique pair (ticker value will be sent to resolveSymbol in place of the name field). The name field is what will be displayed to users. I set both and to the same value to make my life easier, and because the names I am using include all the information I need to identify the symbol: exchange, to symbol, and from symbol (e.g. Coinbase:BTC/USD)\n\nPricescale is a little interesting, because different pairs can use different decimal precision. For example, BTC/USD is measured to two decimal places, so but for say TRX/BTC (0.00000771 BTC at time of writing), we measure it to satoshi‚Äôs, 8 decimal places. So for TRX/BTC but for TRX/USD ($0.059432 at time of writing), we are going to 6 decimal places and .\n\nIt is important to understand how symbolInfo affects your chart, so do check out the docs.\n\nNow on to the fun part! Getting chart data from our API source and handing it off to TradingView.\n\nOkay, let‚Äôs break all that code down!\n\nTradingview calls and passes in the symbolInfo object we passed to the resolve callback, resolution (do we need 1 minute bars? 60 minute bars? 1 day?), to and from timestamps, and a boolean marking if this is the first data request for this symbol.\n\nFrom there, we are calling which is code we have written to retrieve historic ohlcv data from Cryptocompare‚Äôs historic price API. We must pass an array of bar data to getBar‚Äôs , that array could look like this for 1 minute bar data:\n\nSo our historyProvider file is responsible for actually making the request to CryptoCompare to get the appropriate data. To make the request with CrytoCompare we need to know the to symbol, from symbol, and the specific exchange we want data from.\n\nBecause we have chosen to put all the relevant information into the symbol name (Coinbase:BTC/USD), we are able to extract those parameters from the string.\n\nTradingView also passes the to getBars, which will inform what API endpoint we request from CryptoCompare, the minute, hour, or day historic data endpoint.\n\nBecause of the limits of CryptoCompare‚Äôs API (we are only able to get 2000 records at a time) we may be passing an incomplete set of the data TradingView has requested. No worries! getBars will be called again, with new to and from timestamps, until all the data it needs to fill the visible part of the chart is obtained."
    },
    {
        "link": "https://klinecharts.com/en-US/api/chart/init",
        "document": "üîî v9 will be maintained until March 2025. It is recommended to migrate to the new version as soon as possible.\n\nWhen calling, you need to wait until the container is ready.\n‚Ä¢ Container, which can be a DOM element or an element id.\n‚Ä¢ Optional configuration item.\n‚Ä¢ Custom layout, an array.\n‚Ä¢ Pane configuration.\n‚Ä¢ Whether the height can be adjusted by dragging.\n‚Ä¢ Axis configuration.\n‚Ä¢ The name of the axis.\n‚Ä¢ Whether it is inside.\n‚Ä¢ Whether to allow scrolling and zooming.\n‚Ä¢ Locale, with built-in support for and .\n‚Ä¢ Timezone name, such as . If not set, the local time zone will be automatically obtained. For a list of time zone names, please refer to the Timezone List .\n‚Ä¢ It can be a style name registered by or . For details about , see Styles. Incremental values ‚Äã‚Äãare supported.\n‚Ä¢ Customize some APIs.\n‚Ä¢ Format big numbers, such as 1000 is converted to 1k, 1000000 is converted to 1M, etc."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
        "document": "A JavaScript date is fundamentally specified as the time in milliseconds that has elapsed since the epoch, which is defined as the midnight at the beginning of January 1, 1970, UTC (equivalent to the UNIX epoch). This timestamp is timezone-agnostic and uniquely defines an instant in history. Note: While the time value at the heart of a Date object is UTC, the basic methods to fetch the date and time or its components all work in the local (i.e. host system) time zone and offset. The maximum timestamp representable by a object is slightly smaller than the maximum safe integer ( , which is 9,007,199,254,740,991). A object can represent a maximum of ¬±8,640,000,000,000,000 milliseconds, or ¬±100,000,000 (one hundred million) days, relative to the epoch. This is the range from April 20, 271821 BC to September 13, 275760 AD. Any attempt to represent a time outside this range results in the object holding a timestamp value of , which is an \"Invalid Date\". There are various methods that allow you to interact with the timestamp stored in the date:\n‚Ä¢ You can interact with the timestamp value directly using the and methods.\n‚Ä¢ The and (when passed ) methods ‚Äî which are automatically called in number coercion ‚Äî return the timestamp, causing objects to behave like their timestamps when used in number contexts.\n‚Ä¢ All static methods ( , , and ) return timestamps instead of objects.\n‚Ä¢ The constructor can be called with a timestamp as the only argument.\n\nA date is represented internally as a single number, the timestamp. When interacting with it, the timestamp needs to be interpreted as a structured date-and-time representation. There are always two ways to interpret a timestamp: as a local time or as a Coordinated Universal Time (UTC), the global standard time defined by the World Time Standard. The local timezone is not stored in the date object, but is determined by the host environment (user's device). Note: UTC should not be confused with the Greenwich Mean Time (GMT), because they are not always equal ‚Äî this is explained in more detail in the linked Wikipedia page. For example, the timestamp 0 represents a unique instant in history, but it can be interpreted in two ways:\n‚Ä¢ As a UTC time, it is midnight at the beginning of January 1, 1970, UTC,\n‚Ä¢ As a local time in New York (UTC-5), it is 19:00:00 on December 31, 1969. The method returns the difference between UTC and the local time in minutes. Note that the timezone offset does not only depend on the current timezone, but also on the time represented by the object, because of daylight saving time and historical changes. In essence, the timezone offset is the offset from UTC time, at the time represented by the object and at the location of the host environment. There are two groups of methods: one group gets and sets various date components by interpreting the timestamp as a local time, while the other uses UTC. The constructor can be called with two or more arguments, in which case they are interpreted as the year, month, day, hour, minute, second, and millisecond, respectively, in local time. works similarly, but it interprets the components as UTC time and also accepts a single argument representing the year. Note: Some methods, including the constructor, , and the deprecated / methods, interpret a two-digit year as a year in the 1900s. For example, is interpreted as June 24, 1999, not June 24, 99. See Interpretation of two-digit years for more information. When a segment overflows or underflows its expected range, it usually \"carries over to\" or \"borrows from\" the higher segment. For example, if the month is set to 12 (months are zero-based, so December is 11), it become the January of the next year. If the day of month is set to 0, it becomes the last day of the previous month. This also applies to dates specified with the date time string format.\n\nThere are many ways to format a date as a string. The JavaScript specification only specifies one format to be universally supported: the date time string format, a simplification of the ISO 8601 calendar date extended format. The format is as follows:\n‚Ä¢ is the year, with four digits ( to ), or as an expanded year of or followed by six digits. The sign is required for expanded years. is explicitly disallowed as a valid year.\n‚Ä¢ is the month, with two digits ( to ). Defaults to .\n‚Ä¢ is the day of the month, with two digits ( to ). Defaults to .\n‚Ä¢ is a literal character, which indicates the beginning of the time part of the string. The is required when specifying the time part.\n‚Ä¢ is the hour, with two digits ( to ). As a special case, is allowed, and is interpreted as midnight at the beginning of the next day. Defaults to .\n‚Ä¢ is the minute, with two digits ( to ). Defaults to .\n‚Ä¢ is the second, with two digits ( to ). Defaults to .\n‚Ä¢ is the millisecond, with three digits ( to ). Defaults to .\n‚Ä¢ is the timezone offset, which can either be the literal character (indicating UTC), or or followed by , the offset in hours and minutes from UTC. Various components can be omitted, so the following are all valid:\n‚Ä¢ Date-time form: one of the above date-only forms, followed by , followed by , , or . Each combination can be followed by a time zone offset. For example, (date-only form), (date-time form), or (date-time form with milliseconds and time zone) are all valid date time strings. When the time zone offset is absent, date-only forms are interpreted as a UTC time and date-time forms are interpreted as a local time. The interpretation as a UTC time is due to a historical spec error that was not consistent with ISO 8601 but could not be changed due to web compatibility. See Broken Parser ‚Äì A Web Reality Issue. and the constructor both accept strings in the date time string format as input. Furthermore, implementations are allowed to support other date formats when the input fails to match this format. The method returns a string representation of the date in the date time string format, with the time zone offset always set to (UTC). Note: You are encouraged to make sure your input conforms to the date time string format above for maximum compatibility, because support for other formats is not guaranteed. However, there are some formats that are supported in all major implementations ‚Äî like RFC 2822 format ‚Äî in which case their usage can be acceptable. Always conduct cross-browser tests to ensure your code works in all target browsers. A library can help if many different formats are to be accommodated. Non-standard strings can be parsed in any way as desired by the implementation, including the time zone ‚Äî most implementations use the local time zone by default. Implementations are not required to return invalid date for out-of-bounds date components, although they usually do. A string may have in-bounds date components (with the bounds defined above), but does not represent a date in reality (for example, \"February 30\"). Implementations behave inconsistently in this case. The page offers more examples about these non-standard cases.\n\nReturns the day of the month ( ‚Äì ) for the specified date according to local time. Returns the day of the week ( ‚Äì ) for the specified date according to local time. Returns the year (4 digits for 4-digit years) of the specified date according to local time. Returns the hour ( ‚Äì ) in the specified date according to local time. Returns the milliseconds ( ‚Äì ) in the specified date according to local time. Returns the minutes ( ‚Äì ) in the specified date according to local time. Returns the month ( ‚Äì ) in the specified date according to local time. Returns the seconds ( ‚Äì ) in the specified date according to local time. Returns the numeric value of the specified date as the number of milliseconds since January 1, 1970 00:00:00 UTC. (Negative values are returned for prior times.) Returns the time-zone offset in minutes for the current locale. Returns the day (date) of the month ( ‚Äì ) in the specified date according to universal time. Returns the day of the week ( ‚Äì ) in the specified date according to universal time. Returns the year (4 digits for 4-digit years) in the specified date according to universal time. Returns the hours ( ‚Äì ) in the specified date according to universal time. Returns the milliseconds ( ‚Äì ) in the specified date according to universal time. Returns the minutes ( ‚Äì ) in the specified date according to universal time. Returns the month ( ‚Äì ) in the specified date according to universal time. Returns the seconds ( ‚Äì ) in the specified date according to universal time. Returns the year (usually 2‚Äì3 digits) in the specified date according to local time. Use instead. Sets the day of the month for a specified date according to local time. Sets the full year (e.g. 4 digits for 4-digit years) for a specified date according to local time. Sets the hours for a specified date according to local time. Sets the milliseconds for a specified date according to local time. Sets the minutes for a specified date according to local time. Sets the month for a specified date according to local time. Sets the seconds for a specified date according to local time. Sets the object to the time represented by the number of milliseconds since January 1, 1970 00:00:00 UTC. Use negative numbers for times prior. Sets the day of the month for a specified date according to universal time. Sets the full year (e.g. 4 digits for 4-digit years) for a specified date according to universal time. Sets the hour for a specified date according to universal time. Sets the milliseconds for a specified date according to universal time. Sets the minutes for a specified date according to universal time. Sets the month for a specified date according to universal time. Sets the seconds for a specified date according to universal time. Sets the year (usually 2‚Äì3 digits) for a specified date according to local time. Use instead. Returns the \"date\" portion of the as a human-readable string like . Converts a date to a string following the ISO 8601 Extended Format. Returns a string representing the using . Intended to be implicitly called by . Returns a string with a locality sensitive representation of the date portion of this date based on system settings. Returns a string with a locality-sensitive representation of this date. Overrides the method. Returns a string with a locality-sensitive representation of the time portion of this date, based on system settings. Returns a string representing the specified object. Overrides the method. Returns a new object with the same value as this date's timestamp. Returns the \"time\" portion of the as a human-readable string. Converts a date to a string using the UTC timezone. Returns the primitive value of a object. Overrides the method. Converts this object to a primitive value.\n\nexhibits legacy undesirable, inconsistent behavior with two-digit year values; specifically, when a call is given a two-digit year value, that year value does not get treated as a literal year and used as-is but instead gets interpreted as a relative offset ‚Äî in some cases as an offset from the year , but in other cases, as an offset from the year . let date = new Date(98, 1); // Sun Feb 01 1998 00:00:00 GMT+0000 (GMT) date = new Date(22, 1); // Wed Feb 01 1922 00:00:00 GMT+0000 (GMT) date = new Date(\"2/1/22\"); // Tue Feb 01 2022 00:00:00 GMT+0000 (GMT) // Legacy method; always interprets two-digit year values as relative to 1900 date.setYear(98); date.toString(); // Sun Feb 01 1998 00:00:00 GMT+0000 (GMT) date.setYear(22); date.toString(); // Wed Feb 01 1922 00:00:00 GMT+0000 (GMT) So, to create and get dates between the years and , instead use the preferred and methods:. // Preferred method; never interprets any value as being a relative offset, // but instead uses the year value as-is date.setFullYear(98); date.getFullYear(); // 98 (not 1998) date.setFullYear(22); date.getFullYear(); // 22 (not 1922, not 2022)\n\nThe following examples show how to determine the elapsed time between two JavaScript dates in milliseconds. Due to the differing lengths of days (due to daylight saving changeover), months, and years, expressing elapsed time in units greater than hours, minutes, and seconds requires addressing a number of issues, and should be thoroughly researched before being attempted. // Using Date objects const start = Date.now(); // The event to time goes here: doSomethingForALongTime(); const end = Date.now(); const elapsed = end - start; // elapsed time in milliseconds // Using built-in methods const start = new Date(); // The event to time goes here: doSomethingForALongTime(); const end = new Date(); const elapsed = end.getTime() - start.getTime(); // elapsed time in milliseconds // To test a function and get back its return function printElapsedTime(testFn) { const startTime = Date.now(); const result = testFn(); const endTime = Date.now(); console.log(`Elapsed time: ${String(endTime - startTime)} milliseconds`); return result; } const yourFunctionReturn = printElapsedTime(yourFunction); Note: In browsers that support the Performance API's high-resolution time feature, can provide more reliable and precise measurements of elapsed time than ."
    },
    {
        "link": "https://stackoverflow.com/questions/53227276/timestamp-intervals-in-javascript",
        "document": "How can I pick a past date that is a Tuesday or Monday, then get timestamps at 2 week intervals in JavaScript? I am using faker.js. I can only get a date in the past in years, 2 and 1 as shown below.\n\nconst releaseStart1 = new Date(faker.date.past(2, new Date(Date.now()))); const releaseEnd1 = new Date(faker.date.past(1, new Date(Date.now())));"
    },
    {
        "link": "https://bugfender.com/blog/javascript-date-and-time",
        "document": "Master JavaScript‚Äôs Date object with this comprehensive guide. Learn to manipulate, format, and compute dates and times effectively, overcoming common challenges and leveraging powerful APIs for robust applications.\n‚Ä¢ Discover methods for getting the current date in various formats.\n‚Ä¢ Gain insights into popular JavaScript libraries for improved date and time handling.\n\nThere are now nearly 9 million apps worldwide, and practically all of them run on an internal clock.\n\nFinancial apps are built on timestamped data. Office apps run on calendars. Social apps are defined by their feeds, timelines and anniversaries.\n\nSo, as devs, we need to know how to compute date and time. JavaScript, the world‚Äôs most popular programming language, has plenty of helpful APIs, but they can throw up complications if you‚Äôve never used them before.\n\nIn this article we‚Äôre going to look into JavaScript , a standard built-in object for computing date and time. We‚Äôll look at the issue of formatting, dive deep into its related aspects, and study the list of Date APIs in detail, so you can become a master in dealing with JavaScript dates.\n\nWe‚Äôll also look at the different use cases for JavaScript dates in programming, so you can see the challenges, as well as the benefits, in action.\n\nBefore we start talking about JavaScript, let‚Äôs have a quick history lesson.\n\nThe term refers to a specific point in time that happened in the past. In JavaScript, this is defined as midnight at the beginning of January 1, 1970, UTC (Coordinated Universal Time).\n\nThis snapshot serves as a reference-point for every single time-stamp in most development languages. In other words, we always refer back to this date as our own ‚ÄòBig Bang‚Äô moment.\n\nThis referral process isn‚Äôt always user-friendly. However, JavaScript Date provides methods and properties to make it simpler.\n\nYou can use JavaScript Date to manipulate, format, and compare dates and times; convert between Date objects and epoch timestamps; and perform various other, more advanced operations.\n\nThe simplest way to create a Date object with today‚Äôs date in JavaScript is by using the keyword.\n\nIn JavaScript, you can create a Date object in several ways, according to your specific use cases.\n\nThe most common way to create a Date object is using the constructor or passing an argument to the constructor.\n\nThis returns the current date and time in the local timezone when you do not pass any argument to it.\n\nThis is the output (taken from my local computer at the moment of execution).\n\nYou can create a Date object by passing individual date and time components (year, month, day, hour, minute, second, and millisecond) as arguments to the constructor.\n\nSo the output will be:\n\nAs the arguments are optional, you must be mindful of how the Date constructor behaves when we omit one or more arguments.\n\nYou can create a object by passing a date and time string as an argument to the constructor. The string should be in a standardized date and time format.\n\nA date-time representation, like the one we‚Äôve used in the example below, is not standardized and it may only work in some of the environments.\n\nYou can create a Date Object by passing a timestamp, representing the total number of seconds (or even milliseconds), since the epoch snapshot (January 1, 1970).\n\nWhen you work with dates, one of the standard requirements is to get the current date.\n\nWithout an argument, we have seen that the constructor returns the current date and time. But it returns a long date-time representation.\n\nThankfully, JavaScript provides multiple other ways to get the current date.\n\nWith the Date Object, we can use methods like , , and to get the current year, month, and date, respectively.\n\nWe can now combine these methods to form the current date representation.\n\nA few things to note here:\n‚Ä¢ You are free to change the date format the way you want. The above example outputs the date in the format . In case you want , you can use:\n‚Ä¢ The month as a single digit may not look great. In fact you probably want the date to look like than . To tackle this, you can use the string method . It adds padding (with another string) to a given string until it reaches a specified length. To put 0 before 9, we have to pad the month string value with a ‚Äú0‚Äù until it reaches length 2 and results in the string .\n\nThe same applies to the date value.\n\nThe static method returns the current timestamp in milliseconds. This is the local time elapsed since the epoch.\n\nWe know that the constructor can create a Date object by passing the timestamp milliseconds as an argument. Hence, we can pass the to the Date constructor to get the current date and time.\n\nIf you are interested only in the date portion of the returned value, you can typecast the value to a string and use the method.\n\nThe method of the Date object returns the current date and time in the . That is .\n\nYou can extract the current date value using the same method we applied before.\n\nThe simplest and most effective method to get the current date into a JavaScript string is using the method from the Date object.\n\nYou can pass the locale as an argument to the method to get a locale-specific date. For example, to get the current date in the German locale, you can pass as the argument.\n\nTo calculate the elapsed time between two dates in JavaScript, you can subtract one Date Object from another to get the difference in milliseconds and then convert that into the desired units (e.g., seconds, minutes, hours, or days).\n\nPlease note: Calculating the elapsed time between two dates in JavaScript, considering daylight saving time (DST), requires a bit more complexity because DST can affect the length of a day. You need an additional code to find the time differences between the two dates.\n\nOne way of calculating it, including the DST, will be like this:\n\nThere are many ways we can do deal with date format in JavaScript.\n\nWe have seen some of them while discussing how to create a Date object. However, the ECMAScript Internationalization(Intl) API provides a more flexible way to handle date-time format in JavaScript.\n\nYou can create language-sensitive (in other words, locale-aware formats) date and time using the API. When you do not specify a locale, the uses the default locale.\n\nThe above code will output ‚Äú17/10/2023‚Äù when you run with en-US locale (language) and time zone IST (UTC+0530). When you need a localized date, you must explicitly pass it to the method.\n\nHere is the output:\n\nPassing an invalid/unsupported locale will fall back to the default locale formatting.\n\nTo give the following output:\n\nThat‚Äôs not all. You can also pass options to the to get the desired formatted output.\n\nCheck out the code snippet below. We have passed the option to obtain the date in a format where a day is a numeric number, and the month name should be a long-formatted numeric year, and a long-formatted weekday. Also, we want this put out in the locale.\n\nPlease feel free to explore this API here.\n\nWhen your JavaScript app goes live and you need to support users worldwide, you might face problems with different time zones or date formats. A remote logging tool can be very helpful in fixing these issues.\n\nMany popular JavaScript-based libraries have built wrappers over the JavaScript Date Object‚Äôs built-in methods to solve critical use cases.\n\nIt is impossible to list them all, but here are the top five versions I‚Äôve used in the last few years.\n‚Ä¢ date-fns: is a modern JavaScript date utility library that provides a wide range of functions for formatting, parsing, manipulating, and comparing dates and times. It emphasizes simplicity and immutability.\n‚Ä¢ Moment.js: was one of the most popular date libraries in the JavaScript ecosystem. It provides a comprehensive set of date manipulation and formatting functions. However, as of September 2020, it has been considered legacy, and its developers recommend using or for new projects.\n‚Ä¢ Luxon: focuses on providing a clean API for parsing, formatting, and manipulating dates, while also considering internationalization and time zone support.\n‚Ä¢ Day.js: is a minimalist JavaScript library for date manipulation and formatting. It aims to be lightweight and easy to use, providing a simple API for common date tasks.\n‚Ä¢ timeago.js: is a lightweight(~2KBs) nano library used to format date and time with statement (e.g.: ‚Äò2 hours ago‚Äô). It has support for React, Python, and plain JavaScript.\n\nYou must have realized by now that the JavaScript Date object is vast. There are a few shortcomings too.\n‚Ä¢ We need more easy-to-use Date and Time APIs\n‚Ä¢ The Date object doesn‚Äôt have support for non-Gregorian calendars.\n‚Ä¢ Parsing a date from the string may not always give reliable results.\n‚Ä¢ Computation for the DST is difficult.\n\nThe API, now in proposal, aims to solve all the problems we have pointed out above. You can read more about this proposal here.\n\nAs the Temporal API is in the experimental stage, it is not yet ready for production usage. If you want to try it out today, please install the polyfill.\n\nThen you can import it into your script file.\n\nAfter that, you can start using the API methods.\n\nThe JavaScript Date Object allows you to manipulate, format, and compare JavaScript dates and times. It is used for converting between Date JS objects and epoch timestamps and performing other advanced operations‚Äã. The most common way to create a Date object in JavaScript is by using the constructor, which returns the current date and time in the local timezone when no argument is passed‚Äã To get the current date, you can use the constructor without passing any arguments. This returns the current date and time in a long date-time representation‚Äã‚Äã. To format a JavaScript date as ‚Äúyyyy-mm-dd‚Äù, you can use the object and extract the year, month, and day components, then concatenate them into a string with the desired format. const date = new Date(); const year = date.getFullYear(); const month = String(date.getMonth() + 1).padStart(2, '0'); // getMonth() returns 0-11, so add 1 const day = String(date.getDate()).padStart(2, '0'); const formattedDate = `${year}-${month}-${day}`; console.log(formattedDate); // outputs date in yyyy-mm-dd format You can use other libraries like Moment.js or date fns, which offer convenient functions to format dates: To compare dates in JavaScript, you can use the method to convert the dates to timestamps and then compare these timestamps. For example: if (date1.getTime() < date2.getTime()) { // date1 is earlier } else if (date1.getTime() > date2.getTime()) { // date2 is earlier } else { // dates are the same } To add days to a JavaScript date, create a object and use the method along with the method. To get the day of the week from a JavaScript you can use the method of a object, which returns a number corresponding to the day of the week (0 for Sunday, 1 for Monday, etc.).\n‚Ä¢ JavaScript Date object has lots to offer. There are plenty of methods to deal with date, time, and their manipulations.\n‚Ä¢ We can create JavaScript Date objects in various ways.\n‚Ä¢ The methods provided to obtain day, month, year, and date are handy. However, the method doesn‚Äôt return the month name directly.\n‚Ä¢ The is a much more precise and effective way to get locale-aware dates.\n‚Ä¢ There are many ways to format date and time in JavaScript. ECMAScript‚Äôs Intl Date APIs provide the most flexible way to handle formatting.\n‚Ä¢ We have popular date-time libraries to get and manipulate dates.\n‚Ä¢ The Temporal Date API is a promising one to explore.\n\nI hope the article was insightful and provided you with enough details to learn and explore the JavaScript Date object.\n\nIf you are interested in JavaScript development, you can also explore the following articles related to JavaScript development:\n‚Ä¢ Unlocking the Magic of JavaScript Asynchronous Programming: Mastering Callbacks, Promises, and Async/Await"
    },
    {
        "link": "https://medium.com/@vitorbritto/mastering-date-an-time-in-javascript-a4c12501aa6a",
        "document": "Dates and time zones are frequently encountered aspects in web applications, yet their complexity can expose challenges when it comes to handling them.\n\nJavaScript handles dates using the object, which is built into the language. The object represents a specific moment in time and provides methods for working with dates, times, and time zones.\n\nEffective date management is of paramount importance in web applications and development for several reasons.\n\nHere‚Äôs an exploration of why handling dates properly is important.\n\nDates are integral to various user interactions within web applications. From displaying post timestamps to scheduling events, ensuring accurate and user-friendly date representations enhances the overall user experience.\n\nProper date management is vital for maintaining data integrity. Inaccurate handling of dates can lead to inconsistencies and errors, affecting the reliability and trustworthiness of the information presented or stored in the application.\n\nMany web applications rely on time-sensitive functionalities, such as scheduling, reminders, or countdowns. Accurate date management is essential for the proper functioning of these features, ensuring they provide value to users.\n\nWeb applications often serve a global audience, leading to diverse time zones and date formats. Effective date management allows applications to cater to users worldwide, offering a seamless experience regardless of geographical location.\n\nSome applications, especially those dealing with financial transactions or sensitive data, must adhere to regulatory standards regarding date and time accuracy. Proper date management is critical for compliance with legal and industry-specific requirements.\n\nIn business and analytics applications, proper date management is essential for accurate data analysis and reporting. Timely and precise reporting depends on the correct interpretation of dates, ensuring insights are reliable and actionable.\n\nWeb applications often interact with external systems and APIs, some of which may have specific date-related requirements. Effective date management facilitates smooth integration with external services, preventing issues related to data inconsistencies.\n\nCode maintenance and debugging become more manageable with clear and consistent date management practices. Well-handled dates contribute to code readability, reducing the likelihood of errors and making it easier for developers to maintain and enhance the application.\n\nWeb applications run on various devices and platforms with different settings. Consistent date management ensures cross-platform compatibility, preventing issues related to date rendering, parsing, or manipulation on different browsers or operating systems.\n\nBefore the release of ECMAScript 2015 (ES6), JavaScript developers had to contend with certain limitations and inconsistencies in the language, especially when it came to date operations. Let‚Äôs take a brief retrospective look at how date operations were handled in JavaScript before ES6.\n\nBefore ES6, creating a Date object required passing a timestamp as the argument. This timestamp was the number of milliseconds elapsed since January 1, 1970, UTC (commonly known as the Unix Epoch).\n\nThis approach was not very intuitive, and developers often had to perform manual calculations to obtain the desired date.\n\nMonths in the Date object were zero-indexed, meaning January was 0, February was 1, and so on. This indexing system led to confusion and off-by-one errors when working with months.\n\nDevelopers had to remember to subtract 1 from the desired month.\n\nDate objects had limited methods for accessing and modifying individual components like year, month, day, etc.\n\nThese methods were not very expressive or chainable, making code less readable and more error-prone.\n\nUnlike other programming languages, JavaScript lacked a literal syntax for creating dates. Developers had to rely on the Date constructor or external libraries for date manipulation.\n\nBefore ES6, formatting dates for display required manual construction of date strings using methods like , , and string concatenation.\n\nThis approach was cumbersome and prone to errors.\n\nJavaScript Date objects were not well-equipped to handle timezones effectively. Timezone-related operations were often challenging, and developers had to resort to external libraries or custom solutions.\n\nECMAScript 2015 (ES6) brought significant improvements to date manipulation in JavaScript, introducing new features and enhancing the capabilities of the object.\n\nES6 introduced a new class that provided a more modern and object-oriented approach to working with dates. The class addressed many of the limitations of the old object, offering a more expressive and consistent API for date manipulation.\n\nDevelopers could now create formatted date strings directly using template literals, reducing the need for manual concatenation and improving code readability.\n\nDevelopers could directly access and modify year, month, day, and other components in a more readable and chainable manner.\n\nDevelopers could now create date instances using a simplified syntax, improving code readability.\n\nThe object introduced in ES6 included features for handling internationalization, including improved timezone support. Developers gained more reliable tools for dealing with timezones, addressing the limitations of the old object.\n\nES6 added several new methods to the class, expanding its functionality. Developers gained access to methods like , , and , which simplified the process of formatting dates for specific locales.\n\nThe JavaScript object, while powerful, has some common issues and pitfalls that developers need to be aware of.\n\nNavigating time zones in the context of international operations presents a myriad of challenges that demand careful consideration. One common problem is the complexity introduced by Daylight Saving Time (DST) changes, which vary globally and can lead to discrepancies in scheduled activities. The lack of standardized time zone identifiers and abbreviations across platforms brings another issue, requiring developers to meticulously handle and interpret time-related data.\n\nHandling , , or invalid values when working with the JavaScript object is also important to ensure robust and error-free date manipulation in applications.\n\nCalculating date differences in JavaScript may lead to inaccurate results. Issues include time zone differences, daylight saving time ambiguity, and precision loss.\n\nUsing libraries that manage time zone transitions and offer higher precision can enhance accuracy in date difference calculations. Vigilance in addressing these considerations is crucial for robust and error-free date-related operations.\n\nThere are some strategies and considerations for dealing with such scenarios.\n\nBefore performing any date-related operations, check if the date variable is or . Also, you can check if a object is valid using the .\n\nProvide default values for date variables when they are or .\n\nUse robust parsing mechanisms and validate the result before using it in the application.\n\nClearly document date-handling practices and expectations in the codebase, especially when dealing with potential edge cases.\n\nMishandling dates in an application can significantly impact performance, leading to various issues that may degrade user experience and system efficiency.\n\nTo mitigate these performance impacts, developers should adopt best practices in date management, leverage built-in browser APIs, optimize date-related operations, and consider caching strategies for repetitive tasks.\n\nRegular profiling and testing of date-related functionalities can help identify and address potential bottlenecks, ensuring a smoother and more efficient application performance.\n\nThe use of external libraries, such as Day.js, can greatly enhance the efficiency and flexibility of date and time handling in JavaScript applications.\n\nDay.js is a lightweight, modern JavaScript library for parsing, validating, manipulating, and formatting dates. It is designed as an alternative to Moment.js, with a focus on simplicity, performance, and a smaller footprint. It also provides a comprehensive set of features for working with dates and times, making it a popular choice for developers seeking a fast and efficient date manipulation library.\n\nSome key features from DayJS are:\n\nTo install Day.js in a project, you can follow these steps:\n\n1. Open your terminal in the root directory of your project.\n\n2. Run the following command to install Day.js using yarn:\n\n3. After the installation is complete, you can import Day.js where needed:\n\nOnce Day.js is installed, you can use it for various date and time operations in your project.\n\nDay.js is agnostic and you can use with any library or framework.\n\nDay.js offers advanced features that can simplify complex date and time-related tasks in JavaScript applications.\n\nDay.js provides a method to represent time in a human-readable relative format.\n\nDay.js allows custom parsing formats, providing flexibility when dealing with diverse date formats.\n\nDay.js introduces and objects for precise handling of time spans and intervals.\n\nDay.js supports localization for date formatting, allowing you to display dates based on different locales.\n\nDay.js allows isolating and extracting specific time components, such as year, month, day, hour, minute, and second.\n\nDay.js supports chaining query and manipulation methods, providing a concise way to perform multiple operations.\n\nDay.js allows advanced difference calculations, including precision up to milliseconds and specifying the unit of measurement.\n\nDay.js can operate in UTC mode, making it easier to handle dates without considering local time zones.\n\nDay.js supports strict mode parsing, helping ensure that only valid date strings are accepted.\n\nWorking with Day.js plugins and extensions allows you to extend the functionality of Day.js to suit specific needs.\n\nHere‚Äôs a guide on how to use Day.js plugins.\n\nSelect a Day.js plugin that matches your requirements. Many plugins are available on the Day.js Plugin Directory.\n\nUse a package manager like npm or yarn to install the Day.js plugin. Replace with the actual name of the plugin.\n\nImport both Day.js and the installed plugin in your JavaScript or TypeScript file.\n\nExtend Day.js by applying the plugin using the method.\n\nOnce the plugin is extended, you can use its features as part of the Day.js API.\n\nChoosing the right strategy for handling dates is a indispensable decision with widespread ramifications for the success of a software project.\n\nIt directly affects user satisfaction, data integrity, functional capabilities, ease of maintenance, and many other key points. It is significantly important to select a method (whether using the , , or a library like Day.js) that harmonizes effectively with the project‚Äôs unique needs, ensuring precise and dependable date operations throughout the application."
    },
    {
        "link": "https://workfall.com/learning/blog/how-to-handle-dates-in-javascript",
        "document": "In this blog, we‚Äôll explore the fascinating realm of JavaScript‚Äôs Date object by showing a step-by-step implementation of how to handle dates in JavaScript. We‚Äôll dig deep into its importance in web development, specifically how it helps manage time on the user‚Äôs device.\n\nInstead of relying on servers, JavaScript‚Äôs Date object allows us to handle dates and times directly within web browsers. Basically, this is a key element in creating interactive and responsive web interfaces. We‚Äôll uncover how it influences various aspects of web development.\n\nWhy Do We Need Javascript Date?\n\nJavaScript‚Äôs `Date` object is essential for several reasons in web development and other programming contexts:\n‚Ä¢ Client-Side Time Handling: JavaScript runs in web browsers, which are primarily used for client-side scripting. It allows you to work with dates and times on the client-side, making it possible to display and manipulate dates without requiring server-side interactions. This is crucial for building dynamic and responsive user interfaces.\n‚Ä¢ User Interaction: JavaScript is commonly used for building interactive web applications. The `Date` object enables developers to manage events and actions related to dates and times, such as date pickers, countdown timers, and scheduling features.\n‚Ä¢ Displaying Dynamic Content: Many websites and web applications display content that changes over time. JavaScript‚Äôs `Date` object allows developers to dynamically update and render time-sensitive data on web pages, such as news articles with publication dates, social media posts with timestamps, and live clocks.\n‚Ä¢ Data Manipulation and Validation: JavaScript‚Äôs `Date` object provides methods for parsing and formatting date strings, making it useful for validating and processing user-inputted dates. It allows you to ensure that dates meet specific criteria and convert them to a consistent format.\n‚Ä¢ Event Scheduling: JavaScript can be used to schedule events and actions to occur at specific times or intervals. This is important for building features like reminders, notifications, and automated tasks.\n‚Ä¢ Time Zone Handling: The `Date` object provides mechanisms for handling time zones, which is crucial when dealing with users from different regions and ensuring that dates and times are displayed accurately and consistently.\n‚Ä¢ Calculations and Comparisons: JavaScript‚Äôs `Date` object allows for date arithmetic, making it possible to calculate durations, find the difference between two dates, and perform comparisons between dates. This is useful for tasks like calculating age, time elapsed, or determining if a date is in the past or future.\n\nHence, the `Date` object in JavaScript is a fundamental tool for working with dates and times, enabling developers to create dynamic and time-sensitive web applications, handle user interactions, and ensure accurate date-related functionality across various use cases.\n\nIn this hands-on, we are going to learn a wide range of functions, each building on what we‚Äôve learned before to give you a solid grasp of working with dates and times. We‚Äôll start by understanding time zones.\n\nThen, we‚Äôll go to the basics, like creating date objects in JavaScript. We‚Äôll learn how to make dates using different pieces of information, like specific arguments, timestamps, or even without any details, giving you the flexibility to handle time-related data.\n\nAs we move forward, we‚Äôll dive into formatting dates, so your date representations look just the way you want them. You‚Äôll also find out how to create custom date formats for specific needs.\n\nComparing dates will be a breeze as we explore ways to figure out how different dates relate to each other. You‚Äôll get the hang of extracting dates from one another and doing date math, like adding or subtracting time.\n\nLastly, we‚Äôll talk about automatic date correction, making sure your date and time data always stays accurate. With each step, you‚Äôll build the skills to confidently work with dates and times in JavaScript, making your web applications more functional and user-friendly.\n\nIn JavaScript, we mainly deal with two time zones: Local Time and Coordinated Universal Time (UTC).\n‚Ä¢ Local Time is the timezone of your computer, where you are currently located.\n‚Ä¢ UTC is similar to Greenwich Mean Time (GMT).\n\nBy default, most JavaScript date methods provide dates and times in your local time zone. You only get UTC time if you specifically ask for it.\n\nNow, let‚Äôs talk about how to create dates.\n\nYou can make a date using `new Date()`. There are four ways to do it:\n\nIn the ‚Äúdate-string‚Äù method, you make a date by giving a date as a string to the new Date function.\n\nWe often prefer using date strings to write dates, which feels natural because we‚Äôve used them for a long time.\n\nBut if I write ‚Äú14-03-2012‚Äù you can easily understand that it means the 14th of March, 2012. However, in JavaScript, if you enter ‚Äú14-03-2012‚Äù as a date, it will show as an ‚ÄúInvalid Date‚Äù.\n\nDate strings can be understood differently in different places. For instance, ‚Äú10-02-2021‚Äù could mean either February 10, 2021 or October 2, 2021. It‚Äôs hard to tell which one it is unless you know the specific date format being used.\n\nWhen using a date string in JavaScript, it‚Äôs important to choose a format that works everywhere. One such widely accepted format is the ISO 8601 Extended format.\n\nHere‚Äôs what those values mean:\n‚Ä¢ YYYY: The year in four digits.\n‚Ä¢ MM: The month is in two digits, where January is 01 and December is 12.\n‚Ä¢ DD: The date is in two digits, from 0 to 31.\n‚Ä¢ -: These are the date separators.\n‚Ä¢ T: It shows the beginning of the time part.\n‚Ä¢ HH: The hour in 24-hour format, from 0 to 23.\n‚Ä¢ :: These are the time separators.\n‚Ä¢ Z: If you see Z, it means the date is in UTC time. If there‚Äôs no Z, it‚Äôs in local time (if time is provided).\n\nYou don‚Äôt have to specify hours, minutes, seconds, or milliseconds when making a date. For example, to create a date for February 10, 2021, you can simply write:\n\nYou can create a date/time in JavaScript by providing up to seven pieces of information:\n‚Ä¢ Month: A number indicating the month of the year (0-11). The first month is represented as 0. If you don‚Äôt specify it, it‚Äôs assumed to be 0.\n‚Ä¢ Day: A number representing the day of the month (1-31). If you don‚Äôt provide this, it‚Äôs set to 1.\n‚Ä¢ Hour: A number indicating the hour of the day (0-23). If you don‚Äôt mention it, it‚Äôs set to 0.\n‚Ä¢ Minutes: A number representing the minutes (0-59). If left out, it‚Äôs considered as 0.\n‚Ä¢ Seconds: A number for the seconds (0-59). If not given, it‚Äôs set to 0.\n‚Ä¢ Milliseconds: A number for the milliseconds (0-999). If not specified, it‚Äôs set to 0.\n\nMany developers sometimes steer clear of the ‚Äúarguments approach‚Äù because it might seem complex at first glance. However, it‚Äôs simpler than it appears.\n\nThink of it like reading numbers from left to right. As you move from left to right, you insert values in decreasing order of importance: year, month, day, hours, minutes, seconds, and milliseconds.\n\nRemember that the month is zero-indexed in JavaScript dates.\n\nHere are some additional examples for you to get to know better:\n\nWhen you create dates using arguments, they are automatically set to your local time, which means the time zone of your computer or device. This can be handy because it avoids confusion between local time and UTC (Coordinated Universal Time). However, if you ever need a date in UTC, you can create one like this:\n\nIn JavaScript, a timestamp measures the time in milliseconds that has passed since a specific date known as the ‚ÄúUnix epoch time,‚Äù which is January 1, 1970. Typically, you don‚Äôt use timestamps to create dates; instead, you use them mainly for comparing different dates, which we‚Äôll discuss more in detail later.\n\nIf you make a date with no arguments, you‚Äôll get a date that shows the current time in your local time zone.\n\nCreating dates in JavaScript is straightforward using the new Date() method.\n\nThere are four ways to do it:\n‚Ä¢ Using a Date String: You can create a date by providing a date string, but it‚Äôs not the recommended method.\n‚Ä¢ Using Arguments: It‚Äôs best to create dates by passing specific arguments like year, month, day, etc. However, remember that in JavaScript, months are zero-indexed.\n‚Ä¢ Using Timestamps: You can also create dates by providing a timestamp.\n‚Ä¢ With No Arguments: If you want the current date and time, simply create a date with no arguments.\n\nAvoid using the date string method and prefer creating dates with arguments. Just keep in mind that months start from 0 in JavaScript.\n\nNext, we‚Äôll learn how to convert a date into a readable string.\n\nMany programming languages offer a handy way to create custom date formats. In PHP, you can use date(‚Äúd M Y‚Äù) to format a date as something like ‚Äú27 Feb 2023.‚Äù\n\nThe native Date object provides seven formatting methods, and each of these methods gives you a particular value.\n\nLet‚Äôs suppose we have a date object as shown in the image below:\n\nLet‚Äôs see each of the methods in action.\n\nTo have a format that‚Äôs just right for you, you‚Äôll have to make it yourself.\n\nSuppose you want a date like ‚ÄúSun, 24 September, 2023‚Äù. To make this, you‚Äôll need to understand and use the built-in date methods that come with the Date object.\n\nTo obtain dates, you can make use of these four methods:\n\n1. getFullYear: It fetches the four-digit year based on your local time.\n\n2. getMonth: This method retrieves the month of the year, using a numbering system from 0 to 11, where January is 0 and December is 11.\n\n3. getDate: It retrieves the day of the month, ranging from 1 to 31, based on your local time.\n\n4. getDay: This method fetches the day of the week, represented from 0 to 6. The week starts with Sunday as 0 and ends with Saturday as 6.\n\nYou can easily obtain ‚Äú24‚Äù and ‚Äú2023‚Äù for ‚ÄúSun, 24 September 2023‚Äù by using the functions getFullYear() and getDate() as shown in the image below.\n\nGetting Sun and September is more challenging.\n\nTo get September, you have to make something that connects all twelve months with their names.\n\nSince months are counted starting from zero, we can use an array to represent them.\n\nTo find out which month is September, follow these steps:\n‚Ä¢ Use ‚ÄúgetMonth()‚Äù to get the month number starting from zero in the date.\n‚Ä¢ Then, match that month number with the month name in the list of months.\n\nTo find the Sun, follow the same steps. This time, you‚Äôll need a list with all seven days of the week.\n\nWe need to get the dayIndex with the getDay() method and use the dayIndex to get the day name as shown in the image below.\n\nNext, we need to bring together all the variables we made to create the formatted string. See the image below.\n\nThe final code will look something like shown in the image below.\n\nWhen you want to make a time look exactly how you want it, you can use these methods:\n‚Ä¢ getHours: It gives you the hours (from 0 to 23) in your local time.\n‚Ä¢ getMinutes: This one gets you the minutes (from 0 to 59) in your local time.\n‚Ä¢ getSeconds: It fetches the seconds (from 0 to 59) in your local time.\n‚Ä¢ getMilliseconds: This one‚Äôs for the milliseconds (from 0 to 999) in your local time.\n\nNow, let‚Äôs move on to comparing dates.\n\nTo find out if one date is earlier or later than another, you can simply use symbols like > (greater than), < (less than), >= (greater than or equal to), and <= (less than or equal to) to compare them.\n\nChecking if two dates occur at precisely the same time can be tricky. Using ‚Äú==‚Äù or ‚Äú===‚Äù for comparison won‚Äôt work in this case.\n\nTo see if the two dates are exactly the same, we can compare their timestamps using the ‚ÄúgetTime()‚Äù method as shown in the image below.\n\nTo see if two dates are on the same day, we can compare their year, month, and day values using ‚ÄúgetFullYear‚Äù, ‚ÄúgetMonth‚Äù, and ‚ÄúgetDate‚Äù as shown in the image below.\n\nGetting a date from another date\n\nThere are two situations where you might need to work with dates based on other dates:\n‚Ä¢ Copying a Date/Time: You want to make one date have the same date and time as another date.\n‚Ä¢ Adjusting by an Amount: You need to change a date by a certain amount, either adding to it or subtracting from it.\n\nYou can change a date or time using these methods:\n\nsetFullYear: Change the year (using 4 digits) in your local time.\n\nsetMonth: Modify the month of the year in your local time.\n\nsetDate: Adjust the day of the month in your local time.\n\nsetHours: Update the hours in your local time.\n\nsetMinutes: Alter the minutes in your local time.\n\nsetSeconds: Change the seconds in your local time.\n\nsetMilliseconds: Adjust the milliseconds in your local time.\n\nFor example, if you want to make a date fall on the 8th day of the month, you can use setDate(8).\n\nTo make the month September, you can use the ‚ÄúsetMonth‚Äù method. Just remember that months start from zero, not one. So, September would be represented as 8, not 9.\n\nAdding or subtracting a delta from another date\n\nA ‚Äúdelta‚Äù simply means a change. When we talk about adding or subtracting a delta from another date, we mean this: you want to figure out a new date that‚Äôs a certain amount different from the original date. This difference could be in years, months, days, or any other unit of time.\n\nTo calculate this difference, you need to know the current date‚Äôs values, which you can find using these methods:\n\ngetFullYear: This gives you the year as a four-digit number, according to your local time.\n\ngetMonth: It tells you the month of the year, ranging from 0 to 11, based on your local time.\n\ngetDate: This provides the day of the month, from 1 to 31, according to your local time.\n\ngetHours: It gives you the hour of the day, from 0 to 23, based on your local time.\n\ngetMinutes: This tells you the minutes, from 0 to 59, according to your local time.\n\ngetSeconds: It gives you the seconds, from 0 to 59, based on your local time.\n\ngetMilliseconds: This provides the milliseconds, from 0 to 999, according to your local time.\n\nNext, we need to figure out what we want to modify. In this case, we‚Äôre changing days, so we can find out the current day using ‚ÄúgetDate()‚Äù.\n\nWe need to find a date that‚Äôs ten days in the future. To do this, we‚Äôll simply add ten days to the current date.\n\nThe final code should look as shown in the image below.\n\nIf you give JavaScript a date that doesn‚Äôt make sense, like September 35, 2023 (there‚Äôs no September 35 on the calendar), JavaScript will fix it for you. In this case, it changes September 35 to October 5 automatically.\n\nYou don‚Äôt have to do the math for minutes, hours, days, or months when creating a time difference. JavaScript takes care of it for you without any extra effort.\n\nIn this hands-on, we‚Äôve explored a wide range of functions related to date objects in JavaScript to give you a strong understanding of working with dates and times.\n\nWe started by understanding time zones, which is crucial when dealing with global applications.\n\nAfterwards, we delved into the basics, like creating date objects in JavaScript. We learned how to make dates using different pieces of information, providing you with flexibility in handling time-related data.\n\nFurthermore, we explored formatting dates, ensuring your date representations match your needs. You also discovered how to create custom date formats for specific requirements.\n\nComparing dates became second nature as we explored ways to figure out how different dates relate to each other. You gained the ability to extract dates from one another and perform date math, like adding or subtracting time.\n\nLastly, we discussed automatic date correction, ensuring your date and time data always stays accurate. With each step, you‚Äôve built the skills to confidently work with dates and times in JavaScript, making your web applications more functional and user-friendly. We will come up with more such use cases in our upcoming blogs.\n\nIf you are an aspiring Frontend developer and want to explore more about the above topics, here are a few of our blogs for your reference:\n‚Ä¢ How to create test cases and start testing the JavaScript code using Mocha?\n‚Ä¢ How to Get the User‚Äôs Location Using Mapbox?\n\nStay tuned to get all the updates about our upcoming blogs on the cloud and the latest technologies.\n\nKeep Exploring -> Keep Learning -> Keep Mastering\n\nAt Workfall, we strive to provide the best tech and pay opportunities to kickass coders around the world. If you‚Äôre looking to work with global clients, build cutting-edge products, and make big bucks doing so, give it a shot at workfall.com/partner today!"
    }
]