[
    {
        "link": "https://docs.gradle.org/current/userguide/more_about_tasks.html",
        "document": ""
    },
    {
        "link": "https://docs.gradle.org/current/userguide/userguide.html",
        "document": "Gradle is a widely used and mature tool with an active community and a strong developer ecosystem.\n‚Ä¢ Gradle is the most popular build system for the JVM and is the default system for Android and Kotlin Multi-Platform projects. It has a rich community plugin ecosystem.\n‚Ä¢ Gradle can automate a wide range of software build scenarios using either its built-in functionality, third-party plugins, or custom build logic.\n‚Ä¢ Gradle provides a high-level, declarative, and expressive build language that makes it easy to read and write build logic.\n‚Ä¢ Gradle is fast, scalable, and can build projects of any size and complexity.\n‚Ä¢ Gradle produces dependable results while benefiting from optimizations such as incremental builds, build caching, and parallel execution.\n\nGradle, Inc. provides a free service called Build Scan¬Æ that provides extensive information and insights about your builds. You can view scans to identify problems or share them for debugging help.\n\nYou can also invoke Gradle via its command-line interface (CLI) in your terminal or through your continuous integration (CI) server."
    },
    {
        "link": "https://docs.gradle.org/current/userguide/tutorial_using_tasks.html",
        "document": "The work that Gradle can do on a project is defined by one or more tasks. A task represents some independent unit of work that a build performs. This might be compiling some classes, creating a JAR, generating Javadoc, or publishing some archives to a repository. When a user runs in the command line, Gradle will execute the task along with any other tasks it depends on.\n\nGradle provides several default tasks for a project, which are listed by running : > Task :tasks ------------------------------------------------------------ Tasks runnable from root project 'myTutorial' ------------------------------------------------------------ Build Setup tasks ----------------- init - Initializes a new Gradle build. wrapper - Generates Gradle wrapper files. Help tasks ---------- buildEnvironment - Displays all buildscript dependencies declared in root project 'myTutorial'. ... Tasks either come from build scripts or plugins. Once we apply a plugin to our project, such as the plugin, additional tasks become available: $ ./gradlew tasks > Task :tasks ------------------------------------------------------------ Tasks runnable from project ':app' ------------------------------------------------------------ Application tasks ----------------- run - Runs this project as a JVM application Build tasks ----------- assemble - Assembles the outputs of this project. build - Assembles and tests this project. Documentation tasks ------------------- javadoc - Generates Javadoc API documentation for the main source code. Other tasks ----------- compileJava - Compiles main Java source. ... Many of these tasks, such as , , and , should be familiar to a developer.\n\nThere are two classes of tasks that can be executed:\n‚Ä¢ Actionable tasks have some action(s) attached to do work in your build: .\n‚Ä¢ Lifecycle tasks are tasks with no actions attached: , . Typically, a lifecycle tasks depends on many actionable tasks, and is used to execute many tasks at once.\n\nLet‚Äôs take a look at a simple \"Hello World\" task in a build script: In the example, the build script registers a single task called using the TaskContainer API, and adds an action to it. If the tasks in the project are listed, the task is available to Gradle: $ ./gradlew app:tasks --all > Task :app:tasks ------------------------------------------------------------ Tasks runnable from project ':app' ------------------------------------------------------------ Other tasks ----------- compileJava - Compiles main Java source. compileTestJava - Compiles test Java source. hello processResources - Processes main resources. processTestResources - Processes test resources. startScripts - Creates OS-specific scripts to run the project as a JVM application. You can execute the task in the build script with : When Gradle executes the task, it executes the action provided. In this case, the action is simply a block containing some code: .\n\nThe task from the previous section can be detailed with a description and assigned to a group with the following update: Once the task is assigned to a group, it will be listed by : To view information about a task, use the command: $./gradlew help --task hello > Task :help Detailed task information for hello Path :app:hello Type Task (org.gradle.api.Task) Options --rerun Causes the task to be re-run even if up-to-date. Description A lovely greeting task. Group Custom As we can see, the task belongs to the group.\n\nYou can declare tasks that depend on other tasks: The dependency of to may be declared before is defined: The task from the previous example is updated to include a dependency: The task now depends on the task, which means that Gradle must execute the task before it can execute the task:\n\nOnce registered, tasks can be accessed via the TaskProvider API for further configuration. For instance, you can use this to add dependencies to a task at runtime dynamically: Or you can add behavior to an existing task: tasks.register('hello') { doLast { println 'Hello Earth' } } tasks.named('hello') { doFirst { println 'Hello Venus' } } tasks.named('hello') { doLast { println 'Hello Mars' } } tasks.named('hello') { doLast { println 'Hello Jupiter' } } $ gradle -q hello Hello Venus Hello Earth Hello Mars Hello Jupiter The calls and can be executed multiple times. They add an action to the beginning or the end of the task‚Äôs actions list. When the task executes, the actions in the action list are executed in order. Here is an example of the method being used to configure a task added by a plugin:\n\nIn the build script, the class is created by extending : // Extend the DefaultTask class to create a HelloTask class abstract class HelloTask : DefaultTask() { @TaskAction fun hello() { println(\"hello from HelloTask\") } } // Register the hello Task with type HelloTask tasks.register<HelloTask>(\"hello\") { group = \"Custom tasks\" description = \"A lovely greeting task.\" } // Extend the DefaultTask class to create a HelloTask class class HelloTask extends DefaultTask { @TaskAction void hello() { println(\"hello from HelloTask\") } } // Register the hello Task with type HelloTask tasks.register(\"hello\", HelloTask) { group = \"Custom tasks\" description = \"A lovely greeting task.\" } The task is registered with the type . $ ./gradlew hello > Task :app:hello hello from HelloTask Now the task is of type instead of type . $ ./gradlew help --task hello > Task :help Detailed task information for hello Path :app:hello Type HelloTask (Build_gradle$HelloTask) Options --rerun Causes the task to be re-run even if up-to-date. Description A lovely greeting task. Group Custom tasks\n\nGradle provides many built-in task types with common and popular functionality, such as copying or deleting files. This example task copies files from the directory to the directory using the built-in task: There are many task types developers can take advantage of, including , , , , , or , which are available in the DSL. Next Step: Learn how to write Tasks >>"
    },
    {
        "link": "https://tomgregory.com/gradle/gradle-task-inputs-and-outputs",
        "document": "Declaring Gradle task inputs and outputs is essential for your build to work properly. By telling Gradle what files or properties your task consumes and produces, the incremental build feature kicks in, improving the performance of your build. You‚Äôll also be following best practices, allowing you to easily create more complex projects.\n\nIn this article, you‚Äôll learn how Gradle task inputs and outputs work, why they‚Äôre important, as well as practically how to implement them in your own projects.\n\nA task represents a unit of work to get done in your Gradle project. That could be compiling code, copying files, publishing an artifact, or whatever action your task needs to accomplish.\n\nYou run tasks on the command line. For example, running compiles your project‚Äôs .java files into .class files.\n\nFor a task to actually do anything useful, it needs some stuff to work on. This is called the task inputs.\n\nYour task normally produces something. This is called the task outputs.\n\nMost official Gradle tasks have inputs and outputs. Can you guess what the inputs and outputs are for the task?\n\nIt‚Äôs actually quite straightforward. The inputs of are the source .java files and the Java version, and the outputs are the compiled .class files.\n\nThe relationship between task inputs and outputs is normally that a change in the inputs creates a change in the outputs. In the case of , if we change the .java files, it makes sense that the compiled .class files would also change.\n\nThe importance of task inputs and outputs#\n\nYou know what task inputs and outputs are now, but so what? Well it turns out that they play a crucial role in at least 3 key areas of Gradle functionality.\n\nGradle‚Äôs incremental build feature helps your build avoid doing the same work more than once. For example, does Gradle really need to recompile your code if nothing‚Äôs changed?\n\nThankfully not. The way Gradle knows if a task should be executed again is using inputs and outputs. Every time a task is executed it takes a fingerprint of the inputs and outputs, and stores the fingerprints ready for next time the task is executed. If an input or output hasn‚Äôt changed, then the calculated fingerprint will be the same.\n\nIf all inputs and all outputs of a task have the same fingerprint as the last execution, the task can be skipped. Or in Gradle terminology the task is marked as .\n\nLet‚Äôs take any Java Gradle project as an example. If we run the task on a clean project (one without a build directory), we get this output.\n\nIf we run the same task again, the output is this.\n\nYou can clearly see that the task is marked as , meaning Gradle skips running it completely. It knows that neither the inputs nor the outputs have changed.\n\nFor this small project, it makes a tiny 1s difference in performance. But for a large project, this incremental build feature can be a game-changer, saving developers a lot of time.\n\nAnother important use is to link the output of one task to the input of another. You can think about this using the producer/consumer analogy. A producer task creates some output that‚Äôs used as an input to a consumer task.\n\nSince outputs can only be files or directories, the input of the consumer task is the same file, directory, or file collection created by the the producer task.\n\nLinking task inputs and outputs like this has some important benefits:\n‚Ä¢ Gradle automatically adds a task dependency from the consumer to producer, so when you run the consumer task the producer task runs first.\n‚Ä¢ When the outputs of the producer task change, the consumer task gets executed again since it‚Äôs no longer up-to-date.\n\nImagine we have a Gradle project which does some very simple string manipulation on movie quotes. üé¨\n\nThere are two tasks\n‚Ä¢ input is a file containing a movie quote e.g. quote.txt containing Bond. James Bond.\n‚Ä¢ output is a file containing the quote in quotation marks e.g. quote-with-quotation-marks.txt containing ‚ÄúBond. James Bond.‚Äù\n‚Ä¢ input a file containing a movie quote in quotation marks i.e. the output of\n‚Ä¢ output is a file containing the movie quote in quotation marks along with the source movie the quote came from e.g. quote-with-source.txt containing ‚ÄúBond. James Bond.‚Äù Dr. No (1963)\n\nWhen we run the task you can see that both tasks are executed, since the inputs of are linked to the outputs of\n\nLinking the output of to the input of is as simple as this.\n\nYou can see the full example build script in this GitHub repository.\n\nIn Gradle a dependency configuration (or just configuration) is a way of grouping dependencies to define their scope. For example, the plugin adds the configuration which is used to generate the compile and runtime classpaths.\n\nOne way configurations can be used is as a producer e.g. I want to add an artifact built by this project to the configuration of any consuming projects.\n\nTask outputs can be used to easily tell Gradle that an artifact produced by a task should be added to a specific configuration. This configuration can then be used to share the artifact between projects.\n\nThis time we have two subprojects:\n\nIn produce-quote we create a custom configuration called quote. We then add the text file output by the addQuotationMarks task to this configuration using the syntax below.\n\nThis means when the consume-quote subproject needs to consume the output file quote-with-quotation-marks.txt, it can do so using the subproject path and configuration name.\n\nThis is in fact Gradle‚Äôs recommended way for sharing inputs and outputs across subprojects.\n\nAssuming the consuming task addQuoteSource has an input of type , you can wire in the artifact dependency like this.\n\nTo see the full example, including how to get the expected file from the , check out the GitHub repository.\n\nHow to declare task inputs and outputs#\n\nTask inputs and outputs are highly configurable using two main approaches:\n‚Ä¢ Create inputs and outputs that always apply to a task inside the task class.\n\nBefore moving onto full implementation details, let‚Äôs quickly explore the full options for what types can be declared as inputs and outputs.\n‚Ä¢ Strings are only supported for task inputs, not outputs. These are normally used for configuration options e.g. of the compileJava task type.\n‚Ä¢ Task outputs can only be files or directories. If you think about a task creating some kind of artifact, this makes sense.\n\nGradle has the concept of lazy configuration, which allows task inputs and outputs to be referenced before they‚Äôre actually set. This is done via a class type.\n\nOne advantages of this mechanism is that you can link the output file of one task to the input file of another, all before the filename has even been decided. The class also knows about which task it‚Äôs linked to, so using inputs and outputs in this way enables Gradle to automatically add the required task dependency.\n\nTo understand how this works, here are some input types and their equivalent property-based type.\n\nIt‚Äôs preferable to use the property-based type, due to the flexibility mentioned above. You‚Äôll see these types used frequently if you read Gradle task code.\n\nLearn more about these different types in the documentation linked at the end of the article.\n\nA good practice is to create a task class for your custom task. The class encapsulates the task action logic, but should also declare any inputs and outputs the task expects. To do this, we use annotations.\n‚Ä¢ For task inputs we can use , , , , , and .\n‚Ä¢ For task outputs we have , , , .\n\nNote that in Kotlin the annotations are prefixed with , so becomes .\n\nHere‚Äôs a simple task class that takes as input two quote files. The output is another file containing the result of joining the values from the input files.\n‚Ä¢ the and annotations mean Gradle knows these properties are inputs and outputs respectively, and treats them accordingly.\n‚Ä¢ the properties are of type , which extends . Since the properties are , Gradle assigns the values automatically.\n‚Ä¢ we call on each property to set a default value\n‚Ä¢ call the function to retrieve the property value in the task action\n\nLet‚Äôs define an instance of the class with .\n\nAfter running multiple times, Gradle knows it‚Äôs up to date.\n\nLet‚Äôs change the quote file quote-part-1.txt, or in other words change the inputs.\n\nNow we‚Äôll see that the task is no longer up-to-date and Gradle executes it again.\n\nFinally, if we execute the task before , or in other words change the outputs, Gradle also knows to execute the task again.\n\nTo try it out for yourself see the example in this GitHub repository.\n\nWorking with other input and output types#\n\nSo you‚Äôve seen how to use the and annotations, create property values, and set defaults, but what about the other input and output types?\n\nWell, here‚Äôs a task which uses all the types, for your reference.\n\nAs with all the examples in this article, you can find the code in this GitHub repository.\n\nWhen we can, it‚Äôs preferable to declare task inputs and outputs in a task class using annotations. That might not always be possible or desirable, for example if we‚Äôre working with a 3rd party task class or we just want to define everything inline without creating a class. In this case, dynamically assign a task‚Äôs inputs and outputs within the build script itself.\n\nTo illustrate this, here‚Äôs a task definition for emphasiseQuote which takes as inputs a quote file and emphasis character, and outputs a file containing the quote with the emphasis character appended on the end.\n\nFor example, if quote.txt contains You‚Äôre gonna need a bigger boat, once we‚Äôve run the output file would contain You‚Äôre gonna need a bigger boat!.\n\nSome notes on this implementation:\n‚Ä¢ define inputs by calling the appropriate function on the task‚Äôs (see )\n‚Ä¢ define outputs by calling the appropriate function on the task‚Äôs (see )\n‚Ä¢ retrieve the inputs or outputs at execution time with or e.g. above\n‚Ä¢ if retrieving inputs by name, declare the input with a name using e.g. above\n\nFeel free to try the full example for yourself.\n\nThere are many possible use cases involving inputs and outputs, so review this list of example projects to see which one covers your scenario.\n‚Ä¢ custom-task-define-inputs-and-outputs-externally: similar to custom-task, but this time we don‚Äôt rely on defaults and define the values of inputs and outputs outside the task class\n‚Ä¢ pre-packaged-task: uses an existing Gradle task class (in this case ) and demonstrates the up-to-date checks working\n‚Ä¢ ad-hoc-task: doesn‚Äôt use a task class, but instead defines an ad-hoc task, dynamically creating inputs and outputs\n‚Ä¢ linking-tasks: demonstrates how to link inputs & outputs between tasks in the same project\n‚Ä¢ sharing-outputs-between-projects: a similar outcome to linking-tasks, but this time we share task outputs between subprojects using dependency configurations\n‚Ä¢ all-types-custom-task: defines a dummy task to illustrate how to use all the different input and output types\n\nYou now have an understanding of what inputs and outputs are, why they‚Äôre important, and how you can start using them in tasks in your own project. There‚Äôs plenty more to learn on this topic, so I recommend the following Gradle documentation.\n‚Ä¢ Authoring tasks: contains the full list of annotations to use with inputs & outputs\n‚Ä¢ Lazy Configuration: goes into a lot more detail on the class discussed in this article\n\nFinally, if you want to learn how to create custom tasks and plugins to help scale your Gradle projects, sign up to the Gradle Hero course today and check out Chapter Five: Organising Gradle Projects Effectively."
    },
    {
        "link": "https://stackoverflow.com/questions/40878923/in-gradle-how-to-print-out-a-message-in-the-console-event-log",
        "document": "I'm trying to verify that my source and target paths are properly setup when I execute a deploy command.\n\nSee the example below:\n\n (copied from: http://eppz.eu/blog/unity-android-plugin-tutorial-2/)\n\nIs there any way to display the above string variable to some sort of console, or the Event Log in Android Studio (assuming that is it's console's name)?"
    },
    {
        "link": "https://stackoverflow.com/questions/28267453/how-to-capture-the-output-of-a-bash-command-into-a-variable-when-using-pipes-and",
        "document": "To capture the output of a command in shell, use command substitution: . Thus:\n‚Ä¢ None When making an assignment in shell, there must be no spaces around the equal sign.\n‚Ä¢ None When defining shell variables for local use, it is best practice to use lower case or mixed case. Variables that are important to the system are defined in upper case and you don't want to accidentally overwrite one of them.\n\nIf the goal is to get the PID of the process, then the and can be combined into a single process:\n\nNote the simple trick that excludes the current process from the output: instead of searching for we search for . The string does not match the regular expression . Hence the current process is removed from the output.\n\nFor the purpose of showing how can replace multiple calls to , consider this scenario: suppose that we want to find lines that contain but that do not contain . With , both conditions can be combined logically:\n\nHere, requires a match with . The symbol means logical \"and\". The before the regex means logical \"not\". Thus, matches only on lines that contain but not ."
    },
    {
        "link": "https://stackoverflow.com/questions/4651437/how-do-i-set-a-variable-to-the-output-of-a-command-in-bash",
        "document": "Some Bash tricks I use to set variables from commands\n\nSorry, there is a loong answer. But as bash is a shell, where the main goal is to run other unix commands and react on result code and/or output ( commands are often piped filter, etc... ), storing command output in variables is something basic and fundamental.\n‚Ä¢ number of variable to set (split or interpret)\n‚Ä¢ repeatability of request (see long running background process, further)\n‚Ä¢ interactivity (considering user input while reading from another input file descriptor)\n‚Ä¢ parallelism (considering many inputs simultaneously, even interactively, see how to run thousand of jobs by running upto N concurrent co-process parallelly and correctly parse all outputs)\n‚Ä¢ having to compute stats, rates, sums, or else, while reading datas\n‚Ä¢ having to track/retrieve handler, then search for them further in same stream (smtp mail server logs)\n\nYou could look at function - a complex sample, parsing output for building: 1 associative array for parsing field, 1 standard array for parsing and storing dates to UNIXEPOCH. (Using a single fork to command for converting two dates together) - In How to determine SSL cert expiration date from a PEM certificate?\n\nFirst simple, old (obsolete), and compatible way\n\nAs nesting could become heavy, parenthesis was implemented for this\n\nUsing backticks in script is to be avoided today.\n\nReading more than one variable (with Bashisms)\n\nIf I just want a used value:\n\nyou could see an array variable:\n\nBut I often use this:\n\n( The first will just drop header line. ) Here, in only one command, you will populate 6 different variables (shown by alphabetical order):\n\n... will work with associative arrays too:\n\ncould produce something like:\n\nOther related sample: Parsing output: and end of Firefox tab by bash in a size of x% of display size? or at AskUbuntu.com Parsing output\n\nThere is an elegent way! In this sample, I will read file:\n\nUsing this way ( ) leave free for other purposes, like user interaction.\n\nThis could be used with static files or even with for ip address or hostname and for port number or with the output of a command:\n\nAnd of course with inline documents:\n\nFirst, you could get RESULT CODE in another variable:\n\nIf you want to store error message in a separate variable, things become a little harder (Note: both standard and error outputs will generate two lines (normally ;-)):\n\nA common problem is to correctly handling filenames (for sample) with special characters like old latin encoding mixed with utf8 of worse (filename containing newline or tabulation).\n\nFor this, command could be run with for separating filenames found by null byte .\n\nTo correctly handle this output with bash, you could:\n\nHandling of special characters by using\n\nFor small amount of entries, you could use (or his sysnonyme: ) in order to create an array, before processing his elements:\n\nThis could by used for splitting specials entries which are separated, like file:\n\nAs this answer is loong enough, for this paragraph, I just will let you refer to this answer to How to parse a CSV file in Bash? , I read a file by using an unnamed fifo, using syntax like:\n\n... But as CSV format could hold multiline fields, things are a little more complex! Using bash loadable CSV module, please have a look on Parsing CSV files under bash, using loadable module\n\nOn my website, you may find the same script, reading as inline document.\n\nNota: line is not required, just for readability.\n\n(Please avoid useless ! So this is just one fork less:\n\nAll pipes ( ) implies forks. Where another process have to be run, accessing disk, libraries calls and so on.\n\nSo using for sample, will limit subprocess to only one fork:\n\nBut for many actions, mostly on small files, Bash could do the job itself:\n\nGoing further about variable splitting...\n\nHave a look at my answer to How do I split a string on a delimiter in Bash?\n\nIn order to prevent multiple forks like\n\nor to obtain system start time and current shell start time, both as UNIX EPOCH, I could do two nested forks:\n\nThis work fine, but running many forks is heavy and slow.\n\nAnd commands like and could make many operations, line by line!!\n\nSo building my two variables: and could be done in one operation:\n\ncould be written on one line:\n\nBut we could use a long running background process to make as many request we need, without having to initiate a new fork for each request.\n\nYou could have a look how reducing forks make Mandelbrot bash, improve from more than eight hours to less than five seconds.\n\nUnder bash, there is a built-in function: :\n\nAs is ready, running in background and I/O are ready too, there is no delay, nothing to load, open, close, before or after operation. Only the operation himself! This become a lot quicker than having to fork to for each operation!\n\nThe little extra: (Little but powerful!) While stay running, they will hold all his registers. So variables or functions could be defined at initialisation step, as first write to , just after starting the task (... or even at any time).\n\nYou may found my function on on my own site (Note on GitHub: there are two files on my site. Function and demo are bundled into one unique file which could be sourced for use or just run for demo.)\n\nThe function lets you use the background task with simple syntax.\n\nFrom there, if you want to end one of background processes, you just have to close its :\n\nwhich is not needed, because all close when the main process finishes."
    },
    {
        "link": "https://reddit.com/r/linuxquestions/comments/135m5sb/best_practice_in_bash_for_assigning_the_output_of",
        "document": "I found this pattern in an old Linux book from 1984, it uses the builtin to assign the output of a command to variables in a shell script.\n\nBut I guess changing the arguments of a script just like that is not up to modern standards.\n\nWhat would be the modern equivalent of this? Maybe ?"
    },
    {
        "link": "https://unix.stackexchange.com/questions/122014/setting-output-of-a-command-to-a-variable",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://sap1ens.com/blog/2017/07/01/bash-scripting-best-practices",
        "document": "I was always afraid of writing shell scripts. Bash seemed to be a programming language that doesn‚Äôt allow a slightest mistake‚Ä¶ Extra space here and there and everything blows up.\n\nLike with every skill, persistence and repetition help. I‚Äôve started writing more and more bash scripts a few years ago. But it‚Äôs important to remember one simple rule - when things become really complex you need to switch to Python/Ruby/scripting language of your choice. Please do!\n\nAnyway, today I want to share some of the very practical conventions, best practices and recommendations I gathered over these years.\n\nIt‚Äôs not an introduction to bash, you should have some background already (ideally some war stories as well).\n\nAlso, I‚Äôm not an expert! It‚Äôs ok to not agree with me. And I‚Äôm pretty sure almost everything I mention can be improved. So please help me and leave some feedback ;-)\n\nSo, first few lines in the bash script are actually the most important lines! This is how I typically start:\n\nFirst line (shebang) tells which interpreter to use. Try to avoid things like because they‚Äôre not portable. More explanations can be found here.\n\nNext, you MUST ALWAYS INCLUDE !!! I don‚Äôt know how to attract your attention more here. It‚Äôs very important to stop the script when an error occurs. Otherwise things can go really catastrophic. Yes, by default bash doesn‚Äôt stop when an error happens!\n\nYou‚Äôd also like to use , because if you don‚Äôt, expressions like will always succeed! It‚Äôs probably not what you want.\n\nA few more instructions you might use:\n‚Ä¢ : detects uninitialised variables in your script (and exits with an error). Generally very useful to have, but it will also reject environment variables, which is a pretty common thing to use, so I don‚Äôt include this option by default\n‚Ä¢ : prints every expression before executing it. Really handy for debugging / build scripts. I usually set it like this: , so it only works when explicitly requested\n\nOne more things to notice: it‚Äôs common to use those instructions in a short form: , , etc. I prefer the longer format, because it‚Äôs more readable and less cryptic, especially for people without a lot of bash experience.\n\nHow do you refer to a variable in your script? Probably something like ?\n\nThis is the most reliable notation: .\n\nQuotes help to prevent issues when variable contains spaces (for example, in filenames).\n\nCurly braces are not needed in this particular example, but help you with more complex situations like:\n\nMore examples can be found here under section.\n\nIt‚Äôs always helpful to separate variables that should be mutable from immutable ones. instruction can help you with that, practically making constants from variables.\n\nIt‚Äôs very simple to use:\n\nFun fact: there is no [normal] way to unset a readonly variable in bash! Make sure to remember this.\n\nShould we use single or double square brackets in conditionals? What‚Äôs the difference between and ?\n\nThey‚Äôre mostly equal, but double square brackets usually provide cleaner syntax and a few more additional features. Compare this:\n\nWith double square brackets you don‚Äôt need to escape parenthesis and unquoted variables work just fine even if they contain spaces (meaning no word splitting or glob expansion).\n\nDouble square brackets are less portable though: is supported by all POSIX shells and only works in bash 2.x+, zsh and some other shells.\n\nUsually you should use double square brackets unless you really know what you‚Äôre doing.\n\nYou can find great detailed explanation here.\n\nNow let‚Äôs look at some functions. Here‚Äôs what I think is a good example of a function:\n\nWhat I like about this function:\n‚Ä¢ is more concise than\n‚Ä¢ function name has an underscore as a prefix. It seems like a good idea to always have a special naming convention for your bash functions to avoid any potential clashes with built-in operators or functions you might include from other files\n‚Ä¢ in bash functions arguments are accessible using index-based variables, first argument is , second is , etc. Of course you can refer to them like that, but when you have 5-6 index-based variables in a 20-30 lines function it can become really hard to keep the mapping in mind. So, you should always name them to make things very explicit. It‚Äôs also applicable to your ‚Äúmain‚Äù function, variables like , , etc. would be strings passed from CLI and it‚Äôs also a great idea to name them\n‚Ä¢ operator restricts the scope of variables, protecting us from leaking those variables to a global namespace. If you only need this variable inside a function - make it !\n\nIn bash you can include (actually execute) external script using command. I‚Äôm still not sure how I feel about this:\n‚Ä¢ It‚Äôs nice to be able to create a file with a set of utility functions that‚Äôs shared across various scripts. I generally support DRY principle. It also can be handy for defining configuration parameters in one concise file and then including that file to an actual script with the business logic\n‚Ä¢ But at the same time I‚Äôm not very happy with the idea of including and executing a file with, potentially, unknown content. Yes, you can‚Äôt always control that and bash doesn‚Äôt give any mechanisms to protect you!\n\nAnyway, if you decide to use for includes, here‚Äôs the right way:\n\nYou make your life easier by always using consistent path for includes, because variable will always be resolved to the actual script location, not the current location.\n\nShellCheck has more than 200 checks and it integrates with your test frameworks and CLI tools. It doesn‚Äôt necessarily follow all the conventions I mentioned here and it definitely has more rules than I can cover.\n\nSo, I think it‚Äôs possible to write readable and reliable bash scripts. It‚Äôs important to remember when not to - some tools should be implemented with more advanced scripting languages. It doesn‚Äôt make any sense to try to squeeze out as much as you can from bash with very exotic syntax or shell commands. You still want your scripts to be simple and straightforward."
    }
]