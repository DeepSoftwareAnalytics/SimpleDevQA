[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API",
        "document": "The Web Audio API involves handling audio operations inside an audio context, and has been designed to allow modular routing. Basic audio operations are performed with audio nodes, which are linked together to form an audio routing graph. Several sources ‚Äî with different types of channel layout ‚Äî are supported even within a single context. This modular design provides the flexibility to create complex audio functions with dynamic effects. Audio nodes are linked into chains and simple webs by their inputs and outputs. They typically start with one or more sources. Sources provide arrays of sound intensities (samples) at very small timeslices, often tens of thousands of them per second. These could be either computed mathematically (such as ), or they can be recordings from sound/video files (like and ) and audio streams ( ). In fact, sound files are just recordings of sound intensities themselves, which come in from microphones or electric instruments, and get mixed down into a single, complicated wave. Outputs of these nodes could be linked to inputs of others, which mix or modify these streams of sound samples into different streams. A common modification is multiplying the samples by a value to make them louder or quieter (as is the case with ). Once the sound has been sufficiently processed for the intended effect, it can be linked to the input of a destination ( ), which sends the sound to the speakers or headphones. This last connection is only necessary if the user is supposed to hear the audio. A simple, typical workflow for web audio would look something like this:\n‚Ä¢ Inside the context, create sources ‚Äî such as , oscillator, stream\n‚Ä¢ Choose final destination of audio, for example your system speakers\n‚Ä¢ Connect the sources up to the effects, and the effects to the destination. Timing is controlled with high precision and low latency, allowing developers to write code that responds accurately to events and is able to target specific samples, even at a high sample rate. So applications such as drum machines and sequencers are well within reach. The Web Audio API also allows us to control how audio is spatialized. Using a system based on a source-listener model, it allows control of the panning model and deals with distance-induced attenuation induced by a moving source (or moving listener). Note: You can read about the theory of the Web Audio API in a lot more detail in our article Basic concepts behind Web Audio API.\n\nThe Web Audio API can seem intimidating to those that aren't familiar with audio or music terms, and as it incorporates a great deal of functionality it can prove difficult to get started if you are a developer. It can be used to incorporate audio into your website or application, by providing atmosphere like futurelibrary.no, or auditory feedback on forms. However, it can also be used to create advanced interactive instruments. With that in mind, it is suitable for both developers and musicians alike. We have a simple introductory tutorial for those that are familiar with programming but need a good introduction to some of the terms and structure of the API. There's also a Basic Concepts Behind Web Audio API article, to help you understand the way digital audio works, specifically in the realm of the API. This also includes a good introduction to some of the concepts the API is built upon. Learning coding is like playing cards ‚Äî you learn the rules, then you play, then you go back and learn the rules again, then you play again. So if some of the theory doesn't quite fit after the first tutorial and article, there's an advanced tutorial which extends the first one to help you practice what you've learnt, and apply some more advanced techniques to build up a step sequencer. We also have other tutorials and comprehensive reference material available that covers all features of the API. See the sidebar on this page for more. If you are more familiar with the musical side of things, are familiar with music theory concepts, want to start building instruments, then you can go ahead and start building things with the advanced tutorial and others as a guide (the above-linked tutorial covers scheduling notes, creating bespoke oscillators and envelopes, as well as an LFO among other things.) If you aren't familiar with the programming basics, you might want to consult some beginner's JavaScript tutorials first and then come back here ‚Äî see our Beginner's JavaScript learning module for a great place to begin.\n\nInterfaces for defining effects that you want to apply to your audio sources. The interface represents a simple low-order filter. It is an that can represent different kinds of filters, tone control devices, or graphic equalizers. A always has exactly one input and one output. The interface is an that performs a Linear Convolution on a given , and is often used to achieve a reverb effect. The interface represents a delay-line; an audio-processing module that causes a delay between the arrival of an input data and its propagation to the output. The interface provides a compression effect, which lowers the volume of the loudest parts of the signal in order to help prevent clipping and distortion that can occur when multiple sounds are played and multiplexed together at once. The interface represents a change in volume. It is an audio-processing module that causes a given gain to be applied to the input data before its propagation to the output. The interface represents a non-linear distorter. It is an that use a curve to apply a waveshaping distortion to the signal. Beside obvious distortion effects, it is often used to add a warm feeling to the signal. Describes a periodic waveform that can be used to shape the output of an . Implements a general infinite impulse response (IIR) filter; this type of filter can be used to implement tone-control devices and graphic equalizers as well.\n\nUsing audio worklets, you can define custom audio nodes written in JavaScript or WebAssembly. Audio worklets implement the interface, a lightweight version of the interface. The interface is available through the object's , and lets you add modules to the audio worklet to be executed off the main thread. The interface represents an that is embedded into an audio graph and can pass messages to the corresponding . The interface represents audio processing code running in a that generates, processes, or analyzes audio directly, and can pass messages to the corresponding . The interface is a -derived object representing a worker context in which an audio processing script is run; it is designed to enable the generation, processing, and analysis of audio data directly using JavaScript in a worklet thread rather than on the main thread. Before audio worklets were defined, the Web Audio API used the for JavaScript-based audio processing. Because the code runs in the main thread, they have bad performance. The is kept for historic reasons but is marked as deprecated. The interface allows the generation, processing, or analyzing of audio using JavaScript. It is an audio-processing module that is linked to two buffers, one containing the current input, one containing the output. An event, implementing the interface, is sent to the object each time the input buffer contains new data, and the event handler terminates when it has filled the output buffer with data. The event is fired when an input buffer of a Web Audio API is ready to be processed. The represents events that occur when a input buffer is ready to be processed."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Advanced_techniques",
        "document": "We're going to be looking at a very simple step sequencer: In practice, this is easier to do with a library ‚Äî the Web Audio API was built to be built upon. If you are about to embark on building something more complex, tone.js would be an excellent place to start. However, we want to demonstrate how to create such a demo from first principles as a learning exercise. The interface consists of master controls, which allow us to play/stop the sequencer, and adjust the BPM (beats per minute) to speed up or slow down the \"music\". Four different sounds, or voices, can be played. Each voice has four buttons, one for each beat in one bar of music. When they are enabled, the note will sound. When the instrument plays, it will move across this set of beats and loop the bar. Each voice also has local controls, allowing you to manipulate the effects or parameters particular to each technique we use to create those voices. The methods we are using are: Note: We didn't create this instrument to sound good but to provide demonstration code. This demonstration represents a very simplified version of such an instrument. The sounds are based on a dial-up modem. If you are unaware of how such a device sounds, you can listen to one here.\n\nNow we can expand our function. We need to add a and connect that through our audio graph to apply amplitude variations to our sound. The gain node has one property: , which is of type . This is useful ‚Äî now we can start to harness the power of the audio param methods on the gain value. We can set a value at a certain time, or we can change it over time with methods such as . As mentioned above, we'll use the method for our attack and release. It takes two parameters ‚Äî the value you want to set the parameter you are changing to (in this case, the gain) and when you want to do this. In our case when is controlled by our inputs. So, in the example below, the gain increases to 1 at a linear rate over the time the attack range input defines. Similarly, for our release, the gain is set to 0 at a linear rate, over the time the release input has been set to.\n\nWe need to create an empty container to put these numbers into, however, one that the Web Audio API understands. This is where objects come in. You can fetch a file and decode it into a buffer (we'll get to that later in the tutorial), or you can create an empty buffer and fill it with your data. For noise, let's do the latter. We first need to calculate the size of our buffer to create it. We can use the property for this: Now we can fill it with random numbers between -1 and 1: // Fill the buffer with noise const data = noiseBuffer.getChannelData(0); for (let i = 0; i < bufferSize; i++) { data[i] = Math.random() * 2 - 1; } Note: Why -1 to 1? When outputting sound to a file or speakers, we need a number representing 0 dB full scale ‚Äî the numerical limit of the fixed point media or DAC. In floating point audio, 1 is a convenient number to map to \"full scale\" for mathematical operations on signals, so oscillators, noise generators, and other sound sources typically output bipolar signals in the range -1 to 1. A browser will clamp values outside this range.\n\nNow we have the audio buffer and have filled it with data; we need a node to add to our graph that can use the buffer as a source. We'll create an for this, and pass in the data we've created: // Create a buffer source for our created data const noise = new AudioBufferSourceNode(audioCtx, { buffer: noiseBuffer, }); When we connect this through our audio graph and play it: You'll notice that it's pretty hissy or tinny. We've created white noise; that's how it should be. Our values are spread from -1 to 1, meaning we have peaks of all frequencies, which are actually quite dramatic and piercing. We could modify the function only spread values from 0.5 to -0.5 or similar to take the peaks off and reduce the discomfort; however, where's the fun in that? Let's route the noise we've created through a filter.\n\nWe want to make sure our file has loaded and been decoded into a buffer before we use it, so let's create an function to allow us to do this: We can then use the operator when calling this function, which ensures that we can only run subsequent code when it has finished executing. Let's create another function to set up the sample ‚Äî we can combine the two async functions in a lovely promise pattern to perform further actions when this file is loaded and buffered: Note: You can easily modify the above function to take an array of files and loop over them to load more than one sample. This technique would be convenient for more complex instruments or gaming. We can now use like so: When the sample is ready to play, the program sets up the UI, so it is ready to go.\n\nA common problem with digital audio applications is getting the sounds to play in time so that the beat remains consistent and things do not slip out of time. We could schedule our voices to play within a loop; however, the biggest problem with this is updating while it is playing, and we've already implemented UI controls to do so. Also, it would be really nice to consider an instrument-wide BPM control. The best way to get our voices to play on the beat is to create a scheduling system, whereby we look ahead at when the notes will play and push them into a queue. We can start them at a precise time with the property and also consider any changes. Note: This is a much stripped down version of Chris Wilson's A Tale Of Two Clocks (2013) article, which goes into this method with much more detail. There's no point repeating it all here, but we highly recommend reading this article and using this method. Much of the code here is taken from his metronome example, which he references in the article. Let's start by setting up our default BPM (beats per minute), which will also be user-controllable via ‚Äî you guessed it ‚Äî another range input. Then we'll create variables to define how far ahead we want to look and how far ahead we want to schedule: const lookahead = 25.0; // How frequently to call scheduling function (in milliseconds) const scheduleAheadTime = 0.1; // How far ahead to schedule audio (sec) Let's create a function that moves the note forwards by one beat and loops back to the first when it reaches the 4th (last) one: let currentNote = 0; let nextNoteTime = 0.0; // when the next note is due. function nextNote() { const secondsPerBeat = 60.0 / tempo; nextNoteTime += secondsPerBeat; // Add beat length to last beat time // Advance the beat number, wrap to zero when reaching 4 currentNote = (currentNote + 1) % 4; } We want to create a reference queue for the notes that are to be played, and the functionality to play them using the functions we've previously created: const notesInQueue = []; function scheduleNote(beatNumber, time) { // Push the note on the queue, even if we're not playing. notesInQueue.push({ note: beatNumber, time }); if (pads[0].querySelectorAll(\"input\")[beatNumber].checked) { playSweep(time); } if (pads[1].querySelectorAll(\"input\")[beatNumber].checked) { playPulse(time); } if (pads[2].querySelectorAll(\"input\")[beatNumber].checked) { playNoise(time); } if (pads[3].querySelectorAll(\"input\")[beatNumber].checked) { playSample(audioCtx, dtmf, time); } } Here we look at the current time and compare it to the time for the following note; when the two match, it will call the previous two functions. object instances have a property, which allows us to retrieve the number of seconds after we first created the context. We will use it for timing within our step sequencer. It's extremely accurate, returning a float value accurate to about 15 decimal places. let timerID; function scheduler() { // While there are notes that will need to play before the next interval, // schedule them and advance the pointer. while (nextNoteTime < audioCtx.currentTime + scheduleAheadTime) { scheduleNote(currentNote, nextNoteTime); nextNote(); } timerID = setTimeout(scheduler, lookahead); } We also need a function to update the UI, so we can see when the beat progresses. let lastNoteDrawn = 3; function draw() { let drawNote = lastNoteDrawn; const currentTime = audioCtx.currentTime; while (notesInQueue.length && notesInQueue[0].time < currentTime) { drawNote = notesInQueue[0].note; notesInQueue.shift(); // Remove note from queue } // We only need to draw if the note has moved. if (lastNoteDrawn !== drawNote) { pads.forEach((pad) => { pad.children[lastNoteDrawn * 2].style.borderColor = \"var(--black)\"; pad.children[drawNote * 2].style.borderColor = \"var(--yellow)\"; }); lastNoteDrawn = drawNote; } // Set up to draw again requestAnimationFrame(draw); }"
    },
    {
        "link": "https://dev.to/rayalva407/creating-an-oscillator-with-the-web-audio-api-5b8m",
        "document": "The awesome thing about coding is that there are infinite possibilities. There is something in coding for everyone. One of my passions before I discovered coding was music. So naturally I have always been curious about how to merge these two things together. Recently I have been reading about the Web Audio API. This is a Javascript API that is used for processing and synthesizing audio in web applications. The purpose of this API is to reproduce the features found in most audio production applications but it can be used for other things like video game audio and sound effects. Today I am going to build a simple oscillator using HTML, CSS and Javascript to show what the Web Audio API can do.\n\nFirst I am just going to create a simple button element inside my HTML‚Äôs body so that we can have something to click on and create a sound. We will also have a slider that will increase and decrease the sound‚Äôs pitch.\n\n\n\nVery simple! Although not necessary I decided to style it a little bit with CSS.\n\n\n\nAfter that code this is what the button and slide will look like.\n\nGreat now to the fun part! In order for us to do anything with the Web Audio API we need to create an instance of the AudioContext in our Javascript. This is what gives us all the features and functionality of the API. We are going to create two variables one to create the audio context and one to grab the oscillator button in our HTML.\n\n\n\nNext we are going to create a function that will make sound for as long as we hold a button. In order to do that we need to create an oscillator inside the function and assign it a waveform type and frequency. There are four waveform types that most synthesizers use to make sound. They are called the ‚Äúsine wave‚Äù, ‚Äútriangle wave‚Äù, ‚Äúsquare/pulse wave‚Äù and ‚Äúsaw wave‚Äù. These waves have different sonic properties. The saw wave has a harsh tone and the sine wave has more of a mellow tone. Read more about oscillator waveforms here. Let‚Äôs go ahead and build this function.\n\n\n\nIn this code I used the sine wave but you can try any other waveform. The standard values are ‚Äúsine‚Äù, ‚Äúsquare‚Äù, ‚Äúsawtooth‚Äù or ‚Äútriangle‚Äù. Try them out so you can hear the difference. I have also used connect method on the oscillator. This connects the oscillator to the destination. Think of this as connecting the oscillator to your computer speakers. Then we start the oscillator sound using the start method and specify that it should start at the current time.\n\nYou might notice that once it is clicked the sound doesn‚Äôt stop. Well we have to create a function that will disconnect the oscillator once the mouse button is lifted. This is a very simple function that looks like this.\n\n\n\nAll done! This is just scratching the surface on what the Web Audio API can do. I will be posting more about the Web Audio API and other audio/programming related things the more I learn about them. Experiment with adding more oscillators! Happy coding!üòÄ"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/OscillatorNode",
        "document": "This feature is well established and works across many devices and browser versions. It‚Äôs been available across browsers since April 2021 .\n\nThe interface represents a periodic waveform, such as a sine wave. It is an audio-processing module that causes a specified frequency of a given wave to be created‚Äîin effect, a constant tone.\n\nCreates a new instance of an object, optionally providing an object specifying default values for the node's properties. As an alternative, you can use the factory method; see Creating an AudioNode.\n\nAlso inherits properties from its parent, . An a-rate representing the frequency of oscillation in hertz (though the returned is read-only, the value it represents is not). The default value is 440 Hz (a standard middle-A note). An a-rate representing detuning of oscillation in cents (though the returned is read-only, the value it represents is not). The default value is 0. A string which specifies the shape of waveform to play; this can be one of a number of standard values, or to use a to describe a custom waveform. Different waves will produce different tones. Standard values are , , , and . The default is .\n\nAlso inherits methods from its parent, . Sets a which describes a periodic waveform to be used instead of one of the standard waveforms; calling this sets the to . Specifies the exact time to start playing the tone. Specifies the time to stop playing the tone.\n\nThe following example shows basic usage of an to create an oscillator node and to start playing a tone on it. For an applied example, check out our Violent Theremin demo (see app.js for relevant code). // create web audio api context const audioCtx = new AudioContext(); // create Oscillator node const oscillator = audioCtx.createOscillator(); oscillator.type = \"square\"; oscillator.frequency.setValueAtTime(440, audioCtx.currentTime); // value in hertz oscillator.connect(audioCtx.destination); oscillator.start();"
    },
    {
        "link": "https://rilling.dev/blog/creating-oscillators-with-javascript",
        "document": "The Web Audio API is a JavaScript API that allows for complex audio operations in JavaScript, such as creating oscillators or applying audio effects. All modern browsers support it.\n\nThis article shows how the Web Audio API can be used to create an oscillator that produces a simple sound. You can try the result on CodePen.\n\nThe following concepts are fundamental to understanding the Web Audio API:\n\nTo use the Web Audio API, we first have to create an . This acts as the audio routing graph.\n\nThen add a basic oscillator node to the context, using the constructor:\n\nBy default, the oscillator is in an ‚Äúoff‚Äù state and does not create any sound. The methods and toggle this.\n\nAt this point, you should be hearing the newly created oscillator play a sound in the key A4 for 3 seconds.\n\nTo control the output volume, we can create a , and insert it between the oscillator, and the audio output.\n\nAll kinds of audio effects can be applied to the audio signal. Here we add a to pan the audio signal to the right stereo channel.\n\nFor a list of all effects see MDNs list of audio effects filters.\n\nSeveral of the parameters defined for the preceding nodes such as the of an oscillator or the of the gain node can be changed dynamically while the audio is playing. However, it is best to not directly write to the corresponding property but to use the methods available for , the underlying interface. These allow for much more control over when and how the values change such as with ."
    },
    {
        "link": "https://jacksongrowson.medium.com/solving-the-fibonacci-sequence-using-javascript-8ef9d3d4123b",
        "document": "The Fibonacci Sequence is a something all programmers should familiarize themselves with. It is a problem that can be solved multiple ways and it can be a great intro to recursive and dynamic programming. In this blog I will solve the problem ‚Äúgiven a number n, find the value of the nth iteration of the Fibonacci Sequence.‚Äù I will use a bottom-up solution, a recursive solution and finally a pretty neat constant time solution. All my solutions will be in JavaScript. You can click on the subject lines below to scroll to the part you‚Äôre most interested in:\n\nThe first instances of the Fibonacci Sequence being used was in India in 200 B.C. The Fibonacci Sequence was later re-discovered by Fibonacci who wrote about it in his book Liber Abaci in 1202. He used the sequence to describe an ideal population of rabbits. A pair of rabbits are put in a field. At one month they can mate and at the end of the second month they produce another pair of rabbits. First month, one pair. Second month, still one pair. Third month, the pair produces another pair, making two pairs. Then on the fourth month, the first pair creates another, but the second pair can‚Äôt produce yet, so there were 3 pairs in total. This pattern is the Fibonacci Sequence. Written out as numbers, it goes: 1, 1, 2, 3, 5, 8, 13, 21,‚Ä¶ etc.\n\nThere are multiple ways to solve the problem of finding the nth value of the Fibonacci Sequence. If you have not solved this problem yet, take a few minutes to try to solve it on your own.\n\nI found one of the most confusing things about this problem was keeping track of what n represented exactly. Was I thinking of the return value as the nth iteration of the Fibonacci Sequence or as an index of an array? For a lot of problems you are fine thinking of the answers as an index to an array (first iteration is n=0 or the 0th index of an array). That is not a helpful way to think of the Fibonacci Sequence. It‚Äôs best to think of your answers as the nth iteration. The 1st iteration (n=1)will return 1. The 2nd (n=2) will also return 1. The third iteration (n=3) returns 2 and so on.\n\nIf you tried to solve this for the first time, you may have chosen to start from the bottom and work your way to n. This is also known as a bottom-up iterative solution.\n\nMy bottom-up solution looked like this:\n\nI start out by setting a variable sum to hold the sum and a previous sum variable prevSum. I also have a temporary storage variable, temp as I cannot just increment sum by prevSum and then set prevSum equal to sum. Since I chose to use a while loop, I also made an iteration variable i.\n\nThen the basis case or most simple scenario is the 1st and 2nd iteration. These will both equal 1. So I set an if condition, checking if n is less than 2 and returning 1 if that‚Äôs the case. This condition is also why I can set sum and prevSum to 1. This is because I am starting from the 3rd iteration.\n\nThen the while loop will check that I have not exceeded n, my number of Fibonacci iterations. I set temp to sum and increment sum by prevSum, then set prevSum equal to temp.\n\nOnce outside of the while loop I return sum.\n\nThis solution is fairly efficient. It has an O(n) runtime and does not use as much memory as a recursive solution.\n\nNow onto recursion. Recursion can be thought of as taking a large problem and breaking it into its basic components. If these basic components are easier to solve then the larger problem, it can be a good time to use recursion.\n\nRecursion for programmers means a function that calls itself. This method takes advantage of something called a stack. You can think about a stack as a tower of blocks.\n\nEach time you run a function and it returns another call of itself, a block is added to the tower. When the calls of the function returns something besides another call(the base case) and no other function calls are que‚Äôd, the function‚Äôs operation is complete. The tower of blocks is then added up by the computer and the sum of blocks returned. In the making of the iterative solution, I found the most simple cases to be any number less than 2. These cases of the 1th iteration and 2nd both return 1.\n\nI wrote the recursive solution as follows:\n\nAs before, I checked if n is less than 2. Otherwise I returned the sum of the last 2 Fibonacci numbers. How do I know the previous Fibonacci numbers? If n is not less than 2, the previous Fibonacci numbers are a sum of its previous 2 Fibonacci numbers, or (n-1)+(n-2). Because of the stack, the computer can add all these up at the end, giving us the correct Fibonacci number.\n\nIn order to visualize a recursive function‚Äôs process, it can be helpful to make a tree. At the start of the tree, the first node is your first call of the function, for example n = 5. Each node can have 2 children nodes. This is because we call fib(n-1) and fib(n-2) each time we call the function. Each ‚Äòleaf‚Äô of the tree or end nodes are either fib(0) or fib(1). These are the base cases.\n\nWhat is the runtime of this function? It can be a bit tricky to figure out. The function does little work besides calling itself. So each function call does O(1) work. That means we can calculate the runtime by counting the number of nodes on the tree we made. The top node of the tree has 2 children. Those children have 2 children, and those children have 2 children and so on. This means for any n, we should get a roughly O(2^n) runtime. It‚Äôs actually about O(1.6^n) but big o notation is only concerned with the upper limit of runtime, so this approximation of O(2^n) is adequate.\n\nAs far as space complexity or memory usage, recursive functions usually use a lot. Each function call adds another function to the stack so this implementation has an O(n) memory depth.\n\nOften problems like this will have a really cool solution. Something that you probably can‚Äôt remember for an interview, but it‚Äôs good to know that it exists. There is such a way to solve the Fibonacci Sequence in constant time or O(1). This means that no matter how large n is, we will always do the same number of operations.\n\nI used Binet‚Äôs Formula to evaluate the Fibonacci Sequence. More info and discussion can be found here and a blog here.\n\nThis is what my function looks like:\n\nThere is a downside to this method. Due to the precision of floating points, we get tiny errors. These errors get larger, the larger n is. You can read more about floating point precision here.\n\nThats all. I hope you enjoyed reading this. It was a lot of fun to write. Did you solve the Fibonacci Sequence slightly differently? Think you have a better solution? Feel free to leave a comment!"
    },
    {
        "link": "https://medium.com/developers-writing/fibonacci-sequence-algorithm-in-javascript-b253dc7e320e",
        "document": "Probably one of the most famous algorithms ever, but still lot of people struggles when trying to find an efficient solution. Let me introduce you to the Fibonacci sequence.\n\nGiven a number N return the index value of the Fibonacci sequence, where the sequence is:\n\nAfter a quick look, you can easily notice that the pattern of the sequence is that each value is the sum of the 2 previous values, that means that for N=5 ‚Üí 2+3 or in maths:\n\nSo let‚Äôs go directly to the first implementation, we are gonna use a simple loop to achieve our solution.\n\nThis is probably the first solution that will come to your mind. The important part here is that we calculate the next number by adding the current number to the old number.\n\nAnd the good news is that has a O(n) time complexity. Fair enough for the first try right? But let‚Äôs try to see some other ways to approach the problem.\n\nNow let‚Äôs see if we can make it look fancier, now we will use recursion to do that.\n\nEasy right? we just solved the problem in 2 lines of code, but let‚Äôs take a deeper look and see what‚Äôs actually happening.\n\nBase case: we just need to check if the value is less than zero for return the 2 firsts cases.\n\nBut now the bad news‚Ä¶ We have increased the time complexity of our algorithm almost to the worst case. If you take a look at the graphic, you will see the orange color (2^N) time complexity, which means that our current implementation is exponential‚Ä¶\n\nFinally, and following the recursive approach we will use memoization to improve our efficiency, but first of all, what‚Äôs memoization? as Wikipedia says:\n\nWhat does that means and why should we take care about that in our implementation? Basically, if we just store the value of each index in a hash, we will avoid the computational time of that value for the next N times.\n\nThis change will increase the space complexity of our new algorithm to O(n) but will dramatically decrease the time complexity to 2N which will resolve to linear time since 2 is a constant.\n\nLet‚Äôs use 50 as an input number and see how it looks like:\n\nI have also created a jsPerf demo with the 3 cases, you can take a look here:\n\nThis was just an example of how to design, improve and analyze an algorithm, in this case it was the Fibonacci sequence, which is simple enough to understand and surprising to see the performance boost we achieved just with some small changes."
    },
    {
        "link": "https://javascript.plainenglish.io/fibonacci-javascript-implementations-comparison-fd09190f5b79",
        "document": "I had some free time and was going through some programming concepts and came across the famous Fibonacci sequence.\n\nAlthough I didn‚Äôt know the exact formula, I knew it was possible to calculate a specific number of the sequence using the golden ratio. While I was searching for this I didn‚Äôt find any computing comparison between that implementation and ‚Äúthe other‚Äù ones. So I decided to spend some time doing it myself. If nothing else, I hope this article helps somebody crack this eternal interview question.\n\nIn this article, I‚Äôm going to explore different implementations and compare their execution time using NodeJS. Those implementation being:\n\nNo Rocket Science here, If you are familiar with recursion this is a quite simple approach. However, once the inputs get bigger JS callstack will start to suffer. Notice, for example, to execute fibonacci(5), the algorithm executes fibonacci(3) 3 times. See the illustration below.\n\nTo mitigate the previous issue we can improve the current solution by adding a simple memory state that prevents calculating the same value twice. A simple cache management.\n\nThis approach improves the executing times but increases the memory usage since we are storing all the previous values in our memory. Once we begin increasing the input the memory allocate will have to increase for a certain threshold we going to start developing memory issues. Notice that we use recursion mechanism so callstack in be impacted as well.\n\nDynamic programming approach is a bit different. It operates using an up-bottom. Dynamic programming because we use a pool of variables and there is no memory increase from the first iteration until the last.\n\nSince the approach is 100% iterative, there is no recursion so callstack won‚Äôt suffer. This approach will work for every input (although we might be restricted by maximum integer value).\n\nGolden Ratio calculation, as the name indicates, allows us to calculate fibonacci sequences for a specific index just using a calculation. These are some websites I used as a source: Fibonacci.com & MathIsFun.com.\n\nThis calculation is linear. We do the same calculation. Although, executing time might very a bit depending on each calculation (remember javascript is not optimised for complex number operations).\n\nA GitHub repo with all this case can be found here.\n\nI used NodeJS process.hrtime() to calculate the execution time for each algorithm. Also exported the results into .csv files so I easily create graphs using a simple google sheet.\n\nAlso create a small test function to guarantee all implementations were correct.\n\nTo improve visibility, I had to create 3 different datasets comparing these implementations:\n\nNotice: All execution time values are in milliseconds.\n\nYou can check the results here\n\nIn this graphic we can see that the simple recursive solution execution time rapidly increases. This was expected. Let‚Äôs see what happens for further bigger inputs.\n\nFor this data set I remove the simple recursive implementation.\n\nYou can check the results here\n\nThere is a massive spike for the memory approach around the 1k input and again when the input reached 7.5k. Another one for the dynamic approach around 10k, I can‚Äôt explain those for now.\n\nBut one thing happened, we started having callstack issues once the input reached 12.5k. This was the threshold limit for my setup. I guess I could increase the stack size to allow executions to proceed but that‚Äôs not ideal.\n\nFor this dataset I only used the dynamic approach and the golden ratio calculation. This is when things start to get interesting. Result data can be found here.\n\nDynamic approach worked fine for 10M. I‚Äôm confident the dynamic approach is going to work as long as we don‚Äôt reach the maximum integer value.\n\nHowever, comparing the executing time from both dynamic(14334768ms) and golden ratio(614ms) we observe a reduction of 23k times!\n‚Ä¢ Simple recursive approach only works for a very limited input;\n‚Ä¢ Recursive approach with cache works a lot better, however call stack issues are going to be there;\n‚Ä¢ Dynamic approach execution time increases linear with the input but is still able to provide results for a massive number\n‚Ä¢ Golden ratio approach provides a solution that is almost linear regarding execution time.\n\nPersonally, I don‚Äôt recommend anybody to do big numbers operations using JS!\n\nIn case you‚Äôre interested, I created a GitHub repo with all the implementations and auxiliary functions to create .csv files, so anybody can play around. Check it out.\n\nMost probably, nobody is going to ask you to develop a fibonacci number calculator. Nevertheless, I won‚Äôt lie, I had some fun exploring this.\n\nHope you found this interesting, in some form."
    },
    {
        "link": "https://stackoverflow.com/questions/7944239/generating-fibonacci-sequence",
        "document": "Can anybody let me know what's wrong?\n\nI'm trying to get to generate a simple Fibonacci Sequence but there no output.\n\nYou have never declared to be an array. Use to solve this. Also, you're never modifying the variable, neither using it. The code below makes more sense, plus, it doesn't create unused variables: var i; var fib = [0, 1]; // Initialize array! for (i = 2; i <= 10; i++) { // Next fibonacci number = previous + one before previous // Translated to JavaScript: fib[i] = fib[i - 2] + fib[i - 1]; console.log(fib[i]); }\n\nYou should've declared the variable to be an array in the first place (such as or ) and I think you're a bit confused about the algorithm.\n\n If you use an array to store the fibonacci sequence, you do not need the other auxiliar variables ( ) : You should consider the recursive method too (note that this is an optimised version) : and then, after you call the fibonacci function, you have all the sequence in the field :\n\nYou're not assigning a value to , so what do you expect to do? Likewise you're never actually reading from the array. It looks like you're trying a combination of two different approaches here... try getting rid of the array entirely, and just use: // Initialization of x and y as before for (i = 2; i <= 10; i++) { alert(x + y); z = x + y; x = y; y = z; } EDIT: The OP changed the code after I'd added this answer. Originally the last line of the loop was - and that makes sense if you've initialized as per my code. If the array is required later, then obviously that needs to be populated still - but otherwise, the code I've given should be fine.\n\nSome answers run into issues when trying to calculate large fibonacci numbers. Others are approximating numbers using phi. This answer will show you how to calculate a precise series of large fibonacci numbers without running into limitations set by JavaScript's floating point implementation. Below, we generate the first 1,000 fibonacci numbers in a few milliseconds. Later, we'll do 100,000! const { fromInt, toString, add } = Bignum const bigfib = function* (n = 0) { let a = fromInt (0) let b = fromInt (1) let _ while (n >= 0) { yield toString (a) _ = a a = b b = add (b, _) n = n - 1 } } console.time ('bigfib') const seq = Array.from (bigfib (1000)) console.timeEnd ('bigfib') // 25 ms console.log (seq.length) // 1001 console.log (seq) // [ 0, 1, 1, 2, 3, ... 995 more elements ] This solution scales quite nicely. We can calculate the first 10,000 fibonacci numbers in under 2 seconds. At this point in the sequence, the numbers are over 2,000 digits long ‚Äì way beyond the capacity of JavaScript's floating point numbers. Still, our result includes precise values without making approximations. Of course all of that magic takes place in , which we will share now. To get an intuition for how we will design , recall how you added big numbers using pen and paper as a child... You add each column, right to left, and when a column overflows into the double digits, remembering to carry the 1 over to the next column... Above, we can see that if we had two 10-digit numbers, it would take approximately 30 simple additions (3 per column) to compute the answer. This is how we will design to work const Bignum = { fromInt: (n = 0) => n < 10 ? [ n ] : [ n % 10, ...Bignum.fromInt (n / 10 >> 0) ] , fromString: (s = \"0\") => Array.from (s, Number) .reverse () , toString: (b) => Array.from (b) .reverse () .join ('') , add: (b1, b2) => { const len = Math.max (b1.length, b2.length) let answer = [] let carry = 0 for (let i = 0; i < len; i = i + 1) { const x = b1[i] || 0 const y = b2[i] || 0 const sum = x + y + carry answer.push (sum % 10) carry = sum / 10 >> 0 } if (carry > 0) answer.push (carry) return answer } } We'll run a quick test to verify our example above And now a complete program demonstration. Expand it to calculate the precise 10,000th fibonacci number in your own browser! Note, the result is the same as the answer provided by wolfram alpha const Bignum = { fromInt: (n = 0) => n < 10 ? [ n ] : [ n % 10, ...Bignum.fromInt (n / 10 >> 0) ] , fromString: (s = \"0\") => Array.from (s, Number) .reverse () , toString: (b) => Array.from (b) .reverse () .join ('') , add: (b1, b2) => { const len = Math.max (b1.length, b2.length) let answer = [] let carry = 0 for (let i = 0; i < len; i = i + 1) { const x = b1[i] || 0 const y = b2[i] || 0 const sum = x + y + carry answer.push (sum % 10) carry = sum / 10 >> 0 } if (carry > 0) answer.push (carry) return answer } } const { fromInt, toString, add } = Bignum const bigfib = function* (n = 0) { let a = fromInt (0) let b = fromInt (1) let _ while (n >= 0) { yield toString (a) _ = a a = b b = add (b, _) n = n - 1 } } console.time ('bigfib') const seq = Array.from (bigfib (10000)) console.timeEnd ('bigfib') // 1877 ms console.log (seq.length) // 10001 console.log (seq [10000] .length) // 2090 console.log (seq [10000]) // 3364476487 ... 2070 more digits ... 9947366875 I was just curious how far this little script could go. It seems like the only limitation is just time and memory. Below, we calculate the first 100,000 fibonacci numbers without approximation. Numbers at this point in the sequence are over 20,000 digits long, wow! It takes 3.18 minutes to complete but the result still matches the answer from wolfram alpha JavaScript now has native support for BigInt. This allows for calculating huge integers very quickly - function* fib (n) { let a = 0n let b = 1n let _ while (n >= 0) { yield a.toString() _ = a a = b b = b + _ n = n - 1 } } console.time(\"fib(1000)\") const result = Array.from(fib(1000)) console.timeEnd(\"fib(1000)\") document.body.textContent = JSON.stringify(result, null, 2)\n\nI like the fact that there are so many ways to create a fibonacci sequence in JS. I will try to reproduce a few of them. The goal is to output a sequence to console (like ) // The IIFE form is purposefully omitted. See below. const fiboGenClosure = () => { let [a, b] = [0, 1]; let n = 0; return (fiboNum = a) => { [a, b] = [b, a + b]; return { n: n++, fiboNum: fiboNum }; }; } // Gets the sequence until given nth number. Always returns a new copy of the main function, so it is possible to generate multiple independent sequences. const generateFiboClosure = n => { const newSequence = fiboGenClosure(); for (let i = 0; i <= n; i++) { console.log(newSequence()); } } generateFiboClosure(21); Similar to the closure pattern above, using the advantages of generator function and for..of loop. // The 'n' argument is a substitute for index. function* fiboGen(n = 0) { let [a, b] = [0, 1]; while (true) { yield [a, n++]; [a, b] = [b, a + b]; } } // Also gives a new sequence every time is invoked. const generateFibonacci = n => { const iterator = fiboGen(); for (let [value, index] of iterator) { console.log({ n: index, fiboNum: value }); if (index >= n) break; } } generateFibonacci(21); This one is a little tricky, because, now in late 2018, TC optimization is still an issue. But honestly ‚Äì if you don't use any smart tricks to allow the default JS engine to use a really big numbers, it will get dizzy and claims that the next fibonacci number is \"Infinity\" by iteration 1477. The stack would probably overflow somewhere around iteration 10 000 (vastly depends on browser, memory etc‚Ä¶). Could be probably padded by try‚Ä¶ catch block or check if \"Infinity\" was reached. It can be written as a one-liner, if we throe away the thing and simply return a number: As I found out reading this mathIsFun article, the fibonacci sequence is valid for negative numbers as well! I tried to implement that in the recursive tail call form above like that:"
    },
    {
        "link": "https://javascript.plainenglish.io/optimize-fibonacci-with-dynamic-programming-2b31e72c5e03",
        "document": "What is the Fibonacci Sequence?\n\nThe Fibonacci sequence is a series of numbers in ascending order. Each number after the first two is a Fibonacci number that must be equivalent to the sum of the previous two numbers before it. For example, take this Fibonacci series of numbers from 0 to 610:\n\nSo you may ask why is this useful? Well, Fibonacci is something that‚Äôs more so applied in the field of mathematics than it is in Programming. Although it is considered a useful tool for teaching things like recursion. It can also be used as a problem for introducing the concept of dynamic programming like we‚Äôll be doing here.\n\nSo, to begin to figure out how to solve the Fibonacci problem with Dynamic Programming, we should first know how to solve it with just plain recursion.\n\nSo this would give us our answer. But why is this not the optimal solution? We know that when using recursion, each function call gets pushed onto the call stack. For this specific problem, we can think of it as a recursion tree with many levels.\n\nAs you can see here we have several overlapping calculations happening from the recursive function calls. This means our solution is doing a lot of unnecessary work. This might be fine when solving for smaller numbers like 1 to 6 but as soon as we scale up to larger numbers it becomes a problem. To further see what I mean let‚Äôs add an incrementer variable to get the number of calculations performed.\n\nNow if we pass in 7 for example we‚Äôll get 13 calculations. But let‚Äôs try a larger number like 20.\n\nWoah! This gives us a whopping 21891 calculations. You might be thinking that can‚Äôt be good for the big O runtime of this solution. You‚Äôd be right! With this solution, we get a time complexity of O(2^n). Not very fast!\n\nSo what is Dynamic Programming first of all? Dynamic Programming is basically just an optimization technique. It‚Äôs commonly used on problems that have overlapping subproblems, just like our Fibonacci problem that is currently solving the same subproblems again and again.\n\nTo optimize our Fibonacci solution we‚Äôre going to use a Dynamic Programming technique called Memoization. This technique works by storing the result of our function calls inside of a data structure such as a hash map and then checking it on each recursive call to see if we‚Äôve already calculated for that specific problem. Let‚Äôs implement this technique with our Fibonacci problem to optimize our solution.\n\nNow you can see we‚Äôve added some extra code but this solution greatly optimizes the previous one bringing the runtime down to O(n). So let‚Äôs go over what we‚Äôre doing here. First, we‚Äôre assigning a hash map to a variable called . This is a good name for it since what we‚Äôre doing is basically caching the result of our function calls. Then on line 4, we‚Äôre utilizing the concept of closure in Javascript by returning a function, this is so we don‚Äôt keep resetting our cache variable on each recursive call. We pass into our nested function and on line 6 we check if we‚Äôve already solved for . We also include our base case on line 8. On lines 12 and 13 is where we perform the calculation, store the result, and return it.\n\nTo run this function we can store the function definition in a variable and call it with any number passed in as an argument.\n\nThis gives us our answer to the Fibonacci problem. Let‚Äôs further prove why this solution is optimal to our previous one by tracking the number of calculations with the variable again.\n\nLet‚Äôs go ahead and pass in the same number as we did with the previous solution so we can compare the two.\n\nWow, we only get 39 calculations here. That‚Äôs a lot less compared to the 21891 calculations from the plain old recursive solution.\n\nTo identify problems where Dynamic Programming can be helpful we should ask ourselves several questions about the problem such as:\n‚Ä¢ Can the problem be divided down into sub-problems?\n\nThis could be a good gauge for identifying problems that can be optimized with Dynamic Programming techniques like Memoization.\n\nIn this article, we went over how to optimize the Fibonacci sequence problem using Dynamic Programming. We utilized the technique of Memoization to get rid of all those extra calculations being made from recursive functions calls.\n\nFor our solution, we used what is considered a top-down approach which is about breaking down a larger problem into smaller ones. The opposite of this approach is a bottom-up approach which starts with the smaller simpler problems and works up to the larger more complex ones. We did not go over the bottom-up approach in this article but you can see a video of how it‚Äôs implemented for Fibonacci here.\n\nHopefully, this article has explained clearly how useful Dynamic Programming can be for optimizing our code so it doesn‚Äôt perform repetitive tasks and unnecessary work. Next time you‚Äôre solving a problem like the Fibonacci sequence, think about how you can optimize with a Dynamic Programming approach."
    }
]