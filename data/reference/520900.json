[
    {
        "link": "https://docs.python.org/3/library/math.html",
        "document": "This module provides access to the mathematical functions defined by the C standard.\n\nThese functions cannot be used with complex numbers; use the functions of the same name from the module if you require support for complex numbers. The distinction between functions which support complex numbers and those which don‚Äôt is made since most users do not want to learn quite as much mathematics as required to understand complex numbers. Receiving an exception instead of a complex result allows earlier detection of the unexpected complex number used as a parameter, so that the programmer can determine how and why it was generated in the first place.\n\nThe following functions are provided by this module. Except when explicitly noted otherwise, all return values are floats.\n\nReturn the number of ways to choose k items from n items without repetition and without order. Evaluates to when and evaluates to zero when . Also called the binomial coefficient because it is equivalent to the coefficient of k-th term in polynomial expansion of . Raises if either of the arguments are not integers. Raises if either of the arguments are negative. Return n factorial as an integer. Raises if n is not integral or is negative. Changed in version 3.10: Floats with integral values (like ) are no longer accepted. Return the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is . without arguments returns . Changed in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported. Return the integer square root of the nonnegative integer n. This is the floor of the exact square root of n, or equivalently the greatest integer a such that a¬≤ ‚â§ n. For some applications, it may be more convenient to have the least integer a such that n ‚â§ a¬≤, or in other words the ceiling of the exact square root of n. For positive n, this can be computed using . Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is . without arguments returns . Return the number of ways to choose k items from n items without repetition and with order. Evaluates to when and evaluates to zero when . If k is not specified or is , then k defaults to n and the function returns . Raises if either of the arguments are not integers. Raises if either of the arguments are negative.\n\nReturn the ceiling of x, the smallest integer greater than or equal to x. If x is not a float, delegates to , which should return an value. Return the absolute value of x. Return the floor of x, the largest integer less than or equal to x. If x is not a float, delegates to , which should return an value. Fused multiply-add operation. Return , computed as though with infinite precision and range followed by a single round to the format. This operation often provides better accuracy than the direct expression . This function follows the specification of the fusedMultiplyAdd operation described in the IEEE 754 standard. The standard leaves one case implementation-defined, namely the result of and . In these cases, returns a NaN, and does not raise any exception. Return the floating-point remainder of , as defined by the platform C library function . Note that the Python expression may not return the same result. The intent of the C standard is that be exactly (mathematically; to infinite precision) equal to for some integer n such that the result has the same sign as x and magnitude less than . Python‚Äôs returns a result with the sign of y instead, and may not be exactly computable for float arguments. For example, is , but the result of Python‚Äôs is , which cannot be represented exactly as a float, and rounds to the surprising . For this reason, function is generally preferred when working with floats, while Python‚Äôs is preferred when working with integers. Return the fractional and integer parts of x. Both results carry the sign of x and are floats. Note that has a different call/return pattern than its C equivalents: it takes a single argument and return a pair of values, rather than returning its second return value through an ‚Äòoutput parameter‚Äô (there is no such thing in Python). Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference , where is the closest integer to the exact value of the quotient . If is exactly halfway between two consecutive integers, the nearest even integer is used for . The remainder thus always satisfies . Special cases follow IEEE 754: in particular, is x for any finite x, and and raise for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating point, the result of this operation is always exactly representable: no rounding error is introduced. Return x with the fractional part removed, leaving the integer part. This rounds toward 0: is equivalent to for positive x, and equivalent to for negative x. If x is not a float, delegates to , which should return an value. For the , , and functions, note that all floating-point numbers of sufficiently large magnitude are exact integers. Python floats typically carry no more than 53 bits of precision (the same as the platform C double type), in which case any float x with necessarily has no fractional bits.\n\nReturn a float with the magnitude (absolute value) of x but the sign of y. On platforms that support signed zeros, returns -1.0. Return the mantissa and exponent of x as the pair . m is a float and e is an integer such that exactly. If x is zero, returns , otherwise . This is used to ‚Äúpick apart‚Äù the internal representation of a float in a portable way. Note that has a different call/return pattern than its C equivalents: it takes a single argument and return a pair of values, rather than returning its second return value through an ‚Äòoutput parameter‚Äô (there is no such thing in Python). Return if the values a and b are close to each other and otherwise. Whether or not two values are considered close is determined according to given absolute and relative tolerances. If no errors occur, the result will be: . rel_tol is the relative tolerance ‚Äì it is the maximum allowed difference between a and b, relative to the larger absolute value of a or b. For example, to set a tolerance of 5%, pass . The default tolerance is , which assures that the two values are the same within about 9 decimal digits. rel_tol must be nonnegative and less than . abs_tol is the absolute tolerance; it defaults to and it must be nonnegative. When comparing to , is computed as , which is for any nonzero and rel_tol less than . So add an appropriate positive abs_tol argument to the call. The IEEE 754 special values of , , and will be handled according to IEEE rules. Specifically, is not considered close to any other value, including . and are only considered close to themselves. Return if x is neither an infinity nor a NaN, and otherwise. (Note that is considered finite.) Return if x is a positive or negative infinity, and otherwise. Return if x is a NaN (not a number), and otherwise. Return . This is essentially the inverse of function . Return the floating-point value steps steps after x towards y. If x is equal to y, return y, unless steps is zero.\n‚Ä¢ None goes up: towards positive infinity.\n‚Ä¢ None goes down: towards minus infinity.\n‚Ä¢ None goes towards zero.\n‚Ä¢ None goes away from zero. Return the value of the least significant bit of the float x:\n‚Ä¢ None If x is a NaN (not a number), return x.\n‚Ä¢ None If x is equal to zero, return the smallest positive denormalized representable float (smaller than the minimum positive normalized float, ).\n‚Ä¢ None If x is equal to the largest positive representable float, return the value of the least significant bit of x, such that the first float smaller than x is .\n‚Ä¢ None Otherwise (x is a positive finite number), return the value of the least significant bit of x, such that the first float bigger than x is . ULP stands for ‚ÄúUnit in the Last Place‚Äù. See also and .\n\nReturn e raised to the power x, where e = 2.718281‚Ä¶ is the base of natural logarithms. This is usually more accurate than or . Return e raised to the power x, minus 1. Here e is the base of natural logarithms. For small floats x, the subtraction in can result in a significant loss of precision; the function provides a way to compute this quantity to full precision: With one argument, return the natural logarithm of x (to base e). With two arguments, return the logarithm of x to the given base, calculated as . Return the natural logarithm of 1+x (base e). The result is calculated in a way which is accurate for x near zero. Return the base-2 logarithm of x. This is usually more accurate than . returns the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros. Return the base-10 logarithm of x. This is usually more accurate than . Return x raised to the power y. Exceptional cases follow the IEEE 754 standard as far as possible. In particular, and always return , even when x is a zero or a NaN. If both x and y are finite, x is negative, and y is not an integer then is undefined, and raises . Unlike the built-in operator, converts both its arguments to type . Use or the built-in function for computing exact integer powers. Changed in version 3.11: The special cases and were changed to return instead of raising , for consistency with IEEE 754.\n\nReturn the Euclidean distance between two points p and q, each given as a sequence (or iterable) of coordinates. The two points must have the same dimension. Return an accurate floating-point sum of values in the iterable. Avoids loss of precision by tracking multiple intermediate partial sums. The algorithm‚Äôs accuracy depends on IEEE-754 arithmetic guarantees and the typical case where the rounding mode is half-even. On some non-Windows builds, the underlying C library uses extended precision addition and may occasionally double-round an intermediate sum causing it to be off in its least significant bit. For further discussion and two alternative approaches, see the ASPN cookbook recipes for accurate floating-point summation. Return the Euclidean norm, . This is the length of the vector from the origin to the point given by the coordinates. For a two dimensional point , this is equivalent to computing the hypotenuse of a right triangle using the Pythagorean theorem, . Changed in version 3.8: Added support for n-dimensional points. Formerly, only the two dimensional case was supported. Changed in version 3.10: Improved the algorithm‚Äôs accuracy so that the maximum error is under 1 ulp (unit in the last place). More typically, the result is almost always correctly rounded to within 1/2 ulp. Calculate the product of all the elements in the input iterable. The default start value for the product is . When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. Return the sum of products of values from two iterables p and q. Raises if the inputs do not have the same length. For float and mixed int/float inputs, the intermediate products and sums are computed with extended precision.\n\nThe mathematical constant œÄ = 3.141592‚Ä¶, to available precision. The mathematical constant e = 2.718281‚Ä¶, to available precision. The mathematical constant œÑ = 6.283185‚Ä¶, to available precision. Tau is a circle constant equal to 2œÄ, the ratio of a circle‚Äôs circumference to its radius. To learn more about Tau, check out Vi Hart‚Äôs video Pi is (still) Wrong, and start celebrating Tau day by eating twice as much pie! A floating-point positive infinity. (For negative infinity, use .) Equivalent to the output of . A floating-point ‚Äúnot a number‚Äù (NaN) value. Equivalent to the output of . Due to the requirements of the IEEE-754 standard, and are not considered to equal to any other numeric value, including themselves. To check whether a number is a NaN, use the function to test for NaNs instead of or . Example: Changed in version 3.11: It is now always available. CPython implementation detail: The module consists mostly of thin wrappers around the platform C math library functions. Behavior in exceptional cases follows Annex F of the C99 standard where appropriate. The current implementation will raise for invalid operations like or (where C99 Annex F recommends signaling invalid operation or divide-by-zero), and for results that overflow (for example, ). A NaN will not be returned from any of the functions above unless one or more of the input arguments was a NaN; in that case, most functions will return a NaN, but (again following C99 Annex F) there are some exceptions to this rule, for example or . Note that Python makes no effort to distinguish signaling NaNs from quiet NaNs, and behavior for signaling NaNs remains unspecified. Typical behavior is to treat all NaNs as though they were quiet. Complex number versions of many of these functions."
    },
    {
        "link": "https://geeksforgeeks.org/python-math-module",
        "document": "Math Module consists of mathematical functions and constants. It is a built-in module made for mathematical tasks.\n\nThe math module provides the math functions to deal with basic operations such as addition(+), subtraction(-), multiplication(*), division(/), and advanced operations like trigonometric, logarithmic, and exponential functions.\n\nIn this article, we learn about the math module from basics to advanced, we will study the functions with the help of good examples.\n\nWhat is a Math Module in Python?\n\nMath Module is an in-built Python library made to simplify mathematical tasks in Python.\n\nIt consists of various mathematical constants and functions that can be used after importing the math module.\n\nAfter importing the math module, you can use various constants and functions, let‚Äôs study some of them\n\nThe Python math module provides various values of various constants like pi, and tau. We can easily write their values with these constants. The constants provided by the math module are :\n\nLet‚Äôs see constants in math module with examples:\n\nExample: This code imports the module and then prints the value of the mathematical constant .\n\nYou all must be familiar with pi. The pi is depicted as either 22/7 or 3.14. math.pi provides a more precise value for the pi.\n\nExample 1: This code imports the module and then prints the value of the mathematical constant .\n\nExample 2: Let‚Äôs find the area of the circle\n\nThe code utilizes the module in Python, defines a radius and the mathematical constant pi, and calculates the area of a circle using the formula‚Äò . It demonstrates the application of mathematical concepts and the usage of the module for numerical calculations\n\nTau is defined as the ratio of the circumference to the radius of a circle. The math.tau constant returns the value tau: 6.283185307179586.\n\nExample: This code imports the module and then prints the value of the mathematical constant ‚Äò .\n\nInfinity basically means something which is never-ending or boundless from both directions i.e. negative and positive. It cannot be depicted by a number. The Python math.inf constant returns of positive infinity. For negative infinity, use -math.inf.\n\nExample 1: This code imports the module and then prints the values of positive and negative infinity.\n\nExample 2: Comparing the values of infinity with the maximum floating point value\n\nThis code imports the module and then compares the values of positive and negative infinity to the values of 10e108 and -10e108, respectively.\n\nThe Python math.nan constant returns a floating-point nan (Not a Number) value. This value is not a legal number. The nan constant is equivalent to float(‚Äúnan‚Äù).\n\nExample: This code imports the module and then prints the value of . represents Not a Number, which is a special value that is used to indicate that a mathematical operation is undefined or the result is not a number.\n\nHere is the list of all mathematical functions in math module, you can use them when you need it in program:\n\nReturns the smallest integral value greater than the number Returns the number with the value of ‚Äòx‚Äô but with the sign of ‚Äòy‚Äô Returns the absolute value of the number Returns the factorial of the number Returns the greatest integral value smaller than the number Returns the remainder when x is divided by y Returns the mantissa and exponent of x as the pair (m, e) Returns the precise floating-point value of sum of elements in an iterable Check whether the value is neither infinity not Nan Check whether the value is infinity or not Returns true if the number is ‚Äúnan‚Äù else returns false Returns the fractional and integer parts of x Returns the truncated integer value of x Returns the value of e raised to the power x(e**x) Returns the value of e raised to the power a (x-1) Returns the logarithmic value of a with base b Returns the natural logarithmic value of 1+x Computes value of log a with base 2 Computes value of log a with base 10 Compute value of x raised to the power y (x**y) Returns the square root of the number Returns the arc cosine of value passed as argument Returns the arc sine of value passed as argument Returns the arc tangent of value passed as argument Returns the cosine of value passed as argument Returns the hypotenuse of the values passed in arguments Returns the sine of value passed as argument Returns the tangent of the value passed as argument Convert argument value from radians to degrees Convert argument value from degrees to radians Returns the inverse hyperbolic cosine of value passed as argument Returns the inverse hyperbolic sine of value passed as argument Returns the inverse hyperbolic tangent of value passed as argument Returns the hyperbolic cosine of value passed as argument Returns the hyperbolic sine of value passed as argument Returns the hyperbolic tangent of value passed as argument Return the gamma function of the argument Return the natural log of the absolute value of the gamma function\n\nIn this section, we will deal with the functions that are used with number theory as well as representation theory such as finding the factorial of a number. We will discuss these numerical functions along with examples and use-cases.\n\n1. Finding the ceiling and the floor value\n\nCeil value means the smallest integral value greater than the number and the floor value means the greatest integral value smaller than the number. This can be easily calculated using the ceil() and floor() method respectively.\n\nThis code imports the module, assigns the value 2.3 to the variable , and then calculates and prints the ceiling and floor of .\n\nThe ceil of 2.3 is : 3\n\nThe floor of 2.3 is : 2\n\n\n\n2. Finding the factorial of the number\n\nUsing the factorial() function we can find the factorial of a number in a single line of the code. An error message is displayed if number is not integral.\n\nExample: This code imports the module, assigns the value 5 to the variable , and then calculates and prints the factorial of .\n\nThe factorial of 5 is : 120\n\n\n\ngcd() function is used to find the greatest common divisor of two numbers passed as the arguments.\n\nExample: This code imports the module, assigns the values 15 and 5 to the variables and , respectively, and then calculates and prints the greatest common divisor (GCD) of and .\n\nThe gcd of 5 and 15 is : 5\n\n\n\nfabs() function returns the absolute value of the number.\n\nExample: This code imports the module, assigns the value -10 to the variable , and then calculates and prints the absolute value of .\n\nThe absolute value of -10 is : 10.0\n\n\n\nRefer to the below article to get detailed information about the numeric functions.\n\nPower functions can be expressed as x^n where n is the power of x whereas logarithmic functions are considered as the inverse of exponential functions.\n\nexp() method is used to calculate the power of e i.e. [Tex]e^y [/Tex] or we can say exponential of y.\n\nExample: This code imports the module and then calculates and prints the exponential values of three different input values: an integer, a negative integer, and a float.\n\npow() function computes x**y. This function first converts its arguments into float and then computes the power.\n\nExample: This code first prints the string ‚ÄúThe value of 3**4 is : ‚Äù to the console. Then, it calculates the value of 3 raised to the power of 4 using the function and prints the result to the console.\n\nThe value of 3**4 is : 81.0\n‚Ä¢ log() function returns the logarithmic value of a with base b. If the base is not mentioned, the computed value is of the natural log.\n‚Ä¢ log2(a) function computes value of log a with base 2. This value is more accurate than the value of the function discussed above.\n‚Ä¢ log10(a) function computes value of log a with base 10. This value is more accurate than the value of the function discussed above.\n\nThis code imports the module and then calculates and prints the logarithms of three different numbers. The module provides several functions for working with logarithms, including , , and .\n\nThe value of log 2 with base 3 is : 0.6309297535714574\n\nThe value of log2 of 16 is : 4.0\n\nThe value of log10 of 10000 is : 4.0\n\n\n\nsqrt() function returns the square root of the number.\n\nExample: This code imports the module and then calculates and prints the square roots of three different numbers: 0, 4, and 3.5. The module provides several functions for working with mathematical operations, including the square root function .\n\nRefer to the below article to get detailed information about the Logarithmic and Power Functions\n\nYou all must know about Trigonometric and how it may become difficult to find the values of sine and cosine values of any angle. Math module provides built-in functions to find such values and even to change the values between degrees and radians.\n\nsin(), cos(), and tan() functions returns the sine, cosine, and tangent of value passed as the argument. The value passed in this function should be in radians.\n\nExample: This code first imports the module, which provides a variety of mathematical functions. Then, it defines a variable and assigns it the value of , where is the mathematical constant representing the ratio of a circle‚Äôs circumference to its diameter.\n\nThe value of sine of pi/6 is : 0.49999999999999994\n\nThe value of cosine of pi/6 is : 0.8660254037844387\n\nThe value of tangent of pi/6 is : 0.5773502691896257\n\n\n\n2. Converting values from degrees to radians and vice versa\n‚Ä¢ degrees() function is used to convert argument value from radians to degrees.\n‚Ä¢ radians() function is used to convert argument value from degrees to radians.\n\nExample: This code imports the module, which provides mathematical functions and constants. It then defines two variables: and . is assigned the value of , which is approximately 0.5235987755982988 radians. is assigned the value 30, which is 30 degrees.\n\nThe converted value from radians to degrees is : 29.999999999999996\n\nThe converted value from degrees to radians is : 0.5235987755982988\n\n\n\nRefer to the below articles to get detailed information about the trigonometric and angular functions.\n\nBesides all the numeric, logarithmic functions we have discussed yet, the math module provides some more useful functions that does not fall under any category discussed above but may become handy at some point while coding.\n\nThe gamma() function is used to return the gamma value of the argument.\n\nExample: This code imports the module, which provides mathematical functions and constants. It then defines a variable and assigns it the value 6. Next, the code calculates and prints the gamma value of using the module‚Äôs function. The function calculates the gamma value of a given argument.\n\nThe gamma value of the given argument is : 120.0\n\n\n\n2. Check if the value is infinity or NaN\n\nisinf() function is used to check whether the value is infinity or not.\n\nExample: This code imports the module and then checks whether the values of , , and are infinite using the function. The function takes a single argument, which is the value to be checked for infinity. It returns if the value is infinite and\n\nisnan() function returns true if the number is ‚ÄúNaN‚Äù else returns false.\n\nExample: This code imports the module and then checks whether the values of , , and are Not a Number (NaN) using the function. The function takes a single argument, which is the value to be checked for NaN. It returns if the value is NaN and .\n\nRefer to the below article to get detailed information about the special functions.\n\nWe have explained math module and it‚Äôs uses with example. Math module is very important mode in Python and every beginner should know how to use it.\n\nIt is used in various basic Python codes, school projects, etc. Hope you understood how to use math module in Python."
    },
    {
        "link": "https://labex.io/tutorials/python-how-to-use-python-s-math-module-for-advanced-math-415478",
        "document": "The module in Python is a built-in library that provides access to the mathematical functions defined by the C standard. This module allows you to perform a wide range of mathematical operations, from basic arithmetic to advanced trigonometric and logarithmic functions.\n\nTo use the module in your Python script, you need to import it. You can do this by adding the following line at the beginning of your code:\n\nOnce you have imported the module, you can access its functions and constants using the dot notation, like this:\n\nThe module provides a variety of functions and constants that you can use in your Python programs. Some of the most commonly used functions include:\n‚Ä¢ : Returns the square root of the given number .\n‚Ä¢ : Returns the smallest integer greater than or equal to .\n‚Ä¢ : Returns the largest integer less than or equal to .\n\nYou can explore the full list of functions and constants available in the module by checking the Python documentation.\n\nUsing the math Module in Code\n\nLet's look at a simple example that demonstrates how to use the module in your Python code:\n\nIn this example, we import the module, use its functions to perform various mathematical operations, and print the results."
    },
    {
        "link": "https://dataquest.io/blog/python-math-module-and-functions",
        "document": "Using The Module in Python\n\nis a built-in module in the Python 3 standard library that provides standard mathematical constants and functions. You can use the module to perform various mathematical calculations, such as numeric, trigonometric, logarithmic, and exponential calculations.\n\nThis tutorial will explore the common constants and functions implemented in the module ‚Äî and how to use them.\n\nThere are several built-in constants in the module. We'll cover some of the most important constants in this section.\n\nThe number ùúã is a mathematical constant, approximately equal to 3.14159. After importing the module, you just need to write to access the ùúã number:\n\nLet‚Äôs use the ùúã number to calculate the area of a circle. The formula for calculating a circle area is as follows:\n\nThe œÑ constant returns an almost precise value of $2\\pi$. Let's print its value:\n\nWe can access the number e (or the Euler‚Äôs number) simply by using the constant:\n\nThe constant stands for Not a Number, and it can initialize those variables that aren't numbers. Technically, the data type of the constant is float; however, it‚Äôs not considered a valid number.\n\nThe constant represents a floating-point positive infinity. It can represent both positive infinity and negative infinity constants, as follows:\n\nThe module provides a wide range of mathematical functions for many different scientific and engineering applications, including the following:\n\nHowever, we will only discuss the most important ones in this section. Let's explore them.\n\nThe method maps a floating-point number to the smallest succeeding integer:\n\nThe method maps a floating-point number to the greatest preceeding integer:\n\nThe method returns the product of all natural numbers less than or equal to , if a positive integer. However, if , it returns . The code below uses the to calculate $5!$:\n\nThe method returns the greatest common denominator for two numbers; we can use it to reduce fractions.\n\nFor example, the GCD for 25 and 120 is 5, so we can divide the numerator and denominator by 5 to get a reduced fraction (e.g., $\\frac{25}{120} = \\frac{5}{24}$). Let's see how it works:\n\nThe method removes the negative sign of a given number, if any, and returns its absolute value as a float:\n\nThe method returns a floating-point value representing the value of x to the power of y $(x^y)$. Let's try the method by forecasting an investment. To do that, we need to know the initial deposit, the annual interest rate, and the number of years that you invest your money in an investment account. Finally, by using the following formula, we can calculate the final amount of the investment:\n\nFor example, consider the following values:\n\nThe code calculates the final amount deposited in the investment account after five years:\n\nThe method always returns a floating-point value, Let's check the data type of the function's return value:\n\nThe method is equal to $e^x$, where $e$ is the Euler's number. We can say the method is equivalent to the statement below:\n\nThe method returns the square root of a number. Let's try it:\n\nThe method accepts two arguments, and , where the default value of base is $e$. So the method returns the natural logarithm of x $(\\log_e x)$ if we only pass one argument. On the other hand, if we provide two arguments, it calculates the logarithm of x to the given base ($\\log_b x$). Let's calculate different logarithms:\n\nThe first line returns the natural logarithm of 10, and the second line returns the logarithm of 10 to the base 3.\n\nAlthough we're able to calculate the logarithm of any number to the base 10 using , the module provides a more accurate method to perform the same calculation. Let's check it out:\n\nThe module also provides some useful methods for doing trigonometry. In this section, we'll learn how to calculate the sine, cosine, and tangent of a given value using the following methods provided in the module.\n\nThe method returns the sine of a given value, where the value must be in radians. The returned value is a floating-point number between -1 and 1:\n\nThe method returns the cosine of a given value, and like the method, the value must be in radians. The returned value is a floating-point number between -1 and 1:\n\nThe method returns a floating-point value representing the tangent of a given value. The value must be in radians. Let's find the tangent of different angles:\n\nThe module provides two useful methods for angular conversion. To convert a given angle from radians to degrees, use the , and to convert a given angle from degrees to radians, use .\n\nThe hyperbolic functions are quite similar to the trigonometric functions; however, there are differences. The module provides all the hyperbolic functions that appear in scientific and engineering applications, as follows:\n\nLet's do some calculations using the hyperbolic functions:\n\nThe built-in module includes a number of constants and methods that support mathematical operations from basic to advanced. We explored some of the most important and widely used constants and methods, including the number, power and logarithmic, trigonometric functions, and more."
    },
    {
        "link": "https://w3schools.com/python/module_math.asp",
        "document": "Python has a built-in module that you can use for mathematical tasks.\n\nThe module has a set of methods and constants."
    },
    {
        "link": "https://realpython.com/python-complex-numbers",
        "document": "Most general-purpose programming languages have either no support or limited support for complex numbers. Your typical options are learning some specialized tool like MATLAB or finding a third-party library. Python is a rare exception because it comes with complex numbers built in.\n\nDespite the name, complex numbers aren‚Äôt complicated! They‚Äôre convenient in tackling practical problems that you‚Äôll get a taste of in this tutorial. You‚Äôll explore vector graphics and sound frequency analysis, but complex numbers can also help in drawing fractals, such as the Mandelbrot set.\n\nIn this tutorial, you‚Äôll learn how to:\n‚Ä¢ Take advantage of the built-in module\n\nIf you need a quick refresher or a gentle introduction to the theory of complex numbers, then you can watch Khan Academy‚Äôs video series. To download the sample code used throughout this tutorial, click the link below:\n\nCreating and manipulating complex numbers in Python isn‚Äôt much different from other built-in data types, particularly numeric types. It‚Äôs possible because the language treats them as first-class citizens. This means you can express mathematical formulas that involve complex numbers with little overhead. Python lets you use complex numbers in arithmetic expressions and call functions on them just like you would with other numbers in Python. It leads to elegant syntax that reads almost like a math textbook. The quickest way to define a complex number in Python is by typing its literal directly in the source code: Although this looks like an algebraic formula, the expression to the right of the equals sign is already a fixed value that needs no further evaluation. When you check its type, you‚Äôll confirm that it‚Äôs indeed a complex number: How is that different from adding two numbers with the plus operator? A clear giveaway is the letter glued to the second number, which completely changes the meaning of the expression. If you removed the letter, you‚Äôd get a familiar integer result instead: By the way, you can use floating-point numbers to create complex numbers, too: Complex number literals in Python mimic the mathematical notation, which is also known as the standard form, the algebraic form, or sometimes the canonical form, of a complex number. In Python, you can use either lowercase or uppercase in those literals. If you learned about complex numbers in math class, you might have seen them expressed using an instead of a . If you‚Äôre curious about why Python uses instead of , then you can expand the collapsible section below to learn more. Why Instead of ?Show/Hide The traditional notation for complex numbers uses the letter instead of since it stands for the imaginary unit. You might feel a slight discomfort with Python‚Äôs convention if you have a mathematical background. However, there are a few reasons that can justify Python‚Äôs controversial choice:\n‚Ä¢ It‚Äôs a convention already adopted by engineers to avoid name collisions with electric current, which is denoted with the letter .\n‚Ä¢ In computing, the letter is often used for the indexing variable in loops.\n‚Ä¢ The letter can be easily confused with or in source code. This was brought up on Python‚Äôs bug tracker over a decade ago, and Python‚Äôs creator, Guido van Rossum himself, closed the issue with this comment: This will not be fixed. For one thing, the letter ‚Äòi‚Äô or upper case ‚ÄòI‚Äô look too much like digits. The way numbers are parsed either by the language parser (in source code) or by the built-in functions (int, float, complex) should not be localizable or configurable in any way; that‚Äôs asking for huge disappointments down the road. If you want to parse complex numbers using ‚Äòi‚Äô instead of ‚Äòj‚Äô, you have plenty of solutions available already. (Source) So there you have it. Unless you want to start using MATLAB, you‚Äôll have to live with using to denote your complex numbers. The algebraic form of a complex number follows the standard rules of algebra, which is convenient in performing arithmetic. For example, addition has a commutative property, which lets you swap the order of the two parts of a complex number literal without changing its value: Similarly, you can substitute addition for subtraction in a complex number literal because the minus sign is just a shorthand notation for an equivalent form: Does a complex number literal in Python always have to comprise two numbers? Can it have more? Are they ordered? To answer these questions, let‚Äôs run some experiments. Unsurprisingly, if you specify only one number, without the letter , then you‚Äôll end up with a regular integer or a floating-point number: On the other hand, appending the letter to a numeric literal will immediately turn it into a complex number: Strictly speaking, from a mathematical standpoint, you‚Äôve just created a pure imaginary number, but Python can‚Äôt represent it as a stand-alone data type. Therefore, without the other part, it‚Äôs just a complex number . How about the opposite? To create a complex number without the imaginary part, you can take advantage of zero and add or subtract it like so: In fact, both parts of the complex number are always there. When you don‚Äôt see one, it means that it has a value of zero. Let‚Äôs check what happens when you try stuffing more terms into the sum than before: This time, your expression is no longer a literal because Python evaluated it into a complex number comprising only two parts. Remember that the basic rules of algebra carry over to complex numbers, so if you group similar terms and apply component-wise addition, then you‚Äôll end up with . Notice how Python displays complex numbers by default. Their textual representation contains an enclosing pair of parentheses, a lowercase letter , and no whitespace. Additionally, the imaginary part comes second. Complex numbers that also happen to be pure imaginary numbers show up without parentheses and only reveal their imaginary part: This helps differentiate imaginary numbers from most complex numbers made up of real and imaginary parts. Python has a built-in function, , that you can use as an alternative to the complex number literal: In this form, it resembles a tuple or an ordered pair of ordinary numbers. The analogy isn‚Äôt that far-fetched. Complex numbers have a geometric interpretation in the Cartesian coordinate system that you‚Äôll explore in a bit. You can think of complex numbers as two-dimensional. Fun fact: In math, complex numbers are traditionally denoted with the letter as it‚Äôs the next letter in the alphabet after and , which commonly represent coordinates. The complex number factory function accepts two numeric parameters. The first one represents the real part, while the second one represents the imaginary part denoted with the letter in the literal you saw earlier: Both parameters are optional, with default values of zero, which makes it less clunky to define complex numbers without the imaginary part or both the real and imaginary parts: The single-argument version can be useful in type casting. For example, you can pass a nonnumeric value like a string literal to obtain a corresponding object. Note that the string can‚Äôt contain any whitespace, though: Later, you‚Äôll find out how to make your classes compatible with this type casting mechanism. Interestingly, when you pass a complex number to , you‚Äôll get the same instance back: That‚Äôs consistent with how other types of numbers in Python work because they‚Äôre all immutable. To make a distinct copy of a complex number, you must call the function with both arguments again or declare another variable with the complex number literal: When you provide two arguments to the function, they must always be numbers, such as , , or . Otherwise, you‚Äôll get a runtime error. Technically speaking, is a subclass of , so it‚Äôll work too: File , line , in : complex() can't take second arg if first is a string Things get seemingly more bizarre when you supply the factory function with complex numbers as arguments. If you provide only the first argument, though, it‚Äôll behave like a proxy as before: However, when two arguments are present and at least one of them is a complex number, you‚Äôll get results that may be difficult to explain at first sight: To get the answers, let‚Äôs take a peek at the factory function‚Äôs docstring or the online documentation, which explain what‚Äôs going on under the hood when you call : Return a complex number with the value real + imag*1j or convert a string or number to a complex number. (Source) In this explanation, and are names of the function arguments. The second argument gets multiplied by the imaginary unit , and the result is added to the first argument. Don‚Äôt worry if it still doesn‚Äôt make any sense. You can come back to this part when you‚Äôve read about complex numbers arithmetic. The rules that you‚Äôll learn about will make this straightforward. When would you want to use the factory function over the literal? It depends, but calling the function may be more convenient when you‚Äôre dealing with dynamically generated data, for example.\n\nGetting to Know Python Complex Numbers In mathematics, complex numbers are a superset of real numbers, which means that every real number is also a complex number whose imaginary part is equal to zero. Python models this relationship through a concept called the numeric tower, described in PEP 3141: The built-in module defines a hierarchy of numeric types through abstract classes that can be used for type checking and classifying numbers. For example, to determine if a value belongs to a specific set of numbers, you can call on it: The floating-point value is a real number that also happens to be a complex number but not an integral one. Note that you can‚Äôt use built-in types directly in such a test: The difference between and is that they belong to separate branches in the numeric type hierarchy tree, and the latter is an abstract base class without any implementation: Abstract base classes, which are denoted in red on the diagram above, can bypass the regular inheritance check mechanism by registering unrelated classes as their virtual subclasses. That‚Äôs why a floating-point value in the example appears to be an instance of but not . To get the real and imaginary parts of a complex number in Python, you can reach for the corresponding and attributes: Both properties are read-only because complex numbers are immutable, so trying to assign a new value to either of them will fail: Since every number in Python is a more specific type of a complex number, attributes and methods defined in are also available in all numeric types, including and : The imaginary part of such numbers is always zero. Python complex numbers have only three public members. Apart from the and properties, they expose the method, which flips the sign of the imaginary part: For numbers whose imaginary part equals zero, it won‚Äôt have any effect: This operation is its own inverse, so calling it twice will get you the original number you started with: While it may seem of little value, the complex conjugate has a few useful arithmetic properties that can help calculate the division of two complex numbers with pen and paper, among many other things.\n\nSince is a native data type in Python, you can plug complex numbers into arithmetic expressions and call many of the built-in functions on them. More advanced functions for complex numbers are defined in the module, which is part of the standard library. You‚Äôll get an introduction to it in a later part of this tutorial. For now, remembering a single rule will let you apply your primary school knowledge of arithmetic to calculate basic operations involving complex numbers. The rule to remember is the definition of the imaginary unit, which satisfies the following equation: It doesn‚Äôt look right when you think of as a real number, but don‚Äôt panic. If you ignore it for a moment and substitute every occurrence of with as if it were a constant, then you‚Äôll be set. Let‚Äôs see how that works. The sum of two or more complex numbers is equivalent to adding their real and imaginary parts component-wise: Earlier, you found out that algebraic expressions composed of real and imaginary numbers follow the standard rules of algebra. When you write it down algebraically, you‚Äôll be able to apply the distributive property and simplify the formula by factoring out and grouping common terms: Python automatically promotes operands to the data type when you add values of mixed numeric types: That is similar to the implicit conversion from to , which you might be more familiar with. Subtracting complex numbers is analogous to adding them, which means you can also apply it element-wise: Unlike the sum, however, the order of operands is significant and yields different results just like with real numbers: You can also use the unary minus operator (-) to make the negative of a complex number: This inverts both the real and the imaginary parts of the complex number. The product of two or more complex numbers gets more interesting: How on Earth did you end up with a negative number out of only positive ones? To answer this question, you have to recall the definition of the imaginary unit and rewrite the expression in terms of real and imaginary parts: The key observation to make is that times gives , which can be replaced with . This inverts the sign of one of the summands, while the rest of the rules stay exactly the same as before. Dividing complex numbers can look intimidating at first encounter: Believe it or not, you‚Äôre able to get the same result using nothing more than a pen and paper! (Okay, a calculator might save you some headaches down the line.) When both numbers are expressed in their standard forms, the trick is to multiply the numerator and the denominator by the conjugate of the latter: The denominator becomes a squared modulus of the divisor. You‚Äôll learn more about the modulus of complex numbers later. When you continue deriving the formula, this is what you‚Äôll get: Note that complex numbers don‚Äôt support floor division, also known as integer division: File , line , in : can't take floor of complex number. File , line , in : can't take floor of complex number. This used to work in Python 2.x but was later removed to avoid ambiguity. You can raise complex numbers to a power using the binary exponentiation operator ( ) or the built-in but not the one defined in the module, which only supports floating-point values: Both the base and the exponent can be of any numeric types, including integer, floating-point, imaginary, or complex: Manual exponentiation of complex numbers becomes very difficult when they‚Äôre expressed in their standard form. It‚Äôs much more convenient to rewrite the number in the trigonometric form and calculate the power using some basic trigonometry. If you‚Äôre interested in the math involved, check out De Moivre‚Äôs formula, which lets you do that.\n\nYou can visualize complex numbers as points or vectors on a Euclidean plane in the Cartesian or rectangular coordinate system: The X-axis on the complex plane, also known as the Gauss plane or Argand diagram, represents the real part of a complex number, while the Y-axis represents its imaginary part. This fact leads to one of the coolest features of the data type in Python, which embodies a rudimentary implementation of a two-dimensional vector for free. While not all operations work the same way in both of them, vectors and complex numbers share many similarities. The Bermuda Triangle is a legendary region known for its paranormal phenomena that spans across the southern tip of Florida, Puerto Rico, and the tiny island of Bermuda. Its vertices are approximately designated by the three major cities whose geographical coordinates are the following: After converting these coordinates to decimal degrees, you‚Äôll end up with two floating-point numbers for each city. You can use the data type to store ordered pairs of numbers. Since the latitude is the vertical coordinate and the longitude is the horizontal one, it might be more convenient to switch them around to follow the traditional order of the Cartesian coordinates: Negative longitude values represent the western hemisphere, while positive latitude values represent the northern hemisphere. Bear in mind that these are spherical coordinates. To correctly project them onto a flat plane, you‚Äôd need to account for the curvature of Earth. One of the first map projections used in cartography was the Mercator projection, which helped sailors navigate their ships. But let‚Äôs ignore all that and assume that values are already expressed in the rectangular coordinate system. When you plot the numbers on a complex plane, you‚Äôll get a rough depiction of the Bermuda Triangle: In the companion materials, you‚Äôll find an interactive Jupyter Notebook that plots the Bermuda Triangle using the Matplotlib library. To download the source code and materials for this tutorial, click the link below: Get Sample Code: Click here to get the sample code you‚Äôll use to learn about complex numbers in Python in this tutorial. If you don‚Äôt like calling the factory function, you can create a type alias with a better-suited name or use the literal form of a complex number to save a few keystrokes: If you needed to pack more attributes on a city, you could use a named tuple or a data class or create a custom class. The magnitude, also known as the modulus or radius of a complex number, is the length of the vector that depicts it on a complex plane: You can calculate it from the Pythagorean theorem by taking the square root of the sum of the squared real part and the squared imaginary part: You would think that Python would let you calculate the length of such a vector with the built-in , but that‚Äôs not the case. To get the magnitude of a complex number, you have to call another global function named , which is typically used for calculating the absolute value of a number: File , line , in : object of type 'complex' has no len() This function removes the sign from integers that you pass in, but for complex numbers, it returns the magnitude or vector length: You might remember from an earlier section that a complex number multiplied by its conjugate produces its magnitude squared. Finding the Distance Between Two Points Let‚Äôs find the Bermuda Triangle‚Äôs geometric center and the distances to it from the three cities that form its boundaries. First, you need to sum all coordinates and divide the result by their count to take the average: This will give you a point located in the Atlantic Ocean, somewhere within the triangle: Now you can create vectors anchored in the cities and directed toward the geometric center of the triangle. Vectors are made by subtracting the source from the target point: Since you subtract complex numbers, every vector is also a complex number made up of two parts. To get your distances, calculate the magnitude of each vector: These vector lengths don‚Äôt reflect meaningful distances but are good approximations for a toy example like this. To represent accurate results in tangible units, you‚Äôd have to convert the coordinates from spherical to rectangular first or calculate the distance using the great circle method instead. It might be bothering you that the triangle appears in the second quadrant of the Cartesian coordinate system. Let‚Äôs move it so that its geometric center aligns with the origin. All three vertices will be translated by the length of the vector indicated by the geometric center but in the opposite direction: Note that you‚Äôre adding two complex numbers together, which performs their element-wise addition. This is an affine transformation since it doesn‚Äôt change the shape of the triangle or the relative placement of its vertices: A mirror reflection of the triangle around the real or imaginary axis requires inverting the respective component in its vertices. For example, to flip it horizontally, you‚Äôll have to use the negative of the real part, which corresponds to the horizontal direction. To flip it vertically, you‚Äôll take the negative of the imaginary part: The latter is essentially the same as calculating a complex number conjugate, so you can call on each vertex directly to do the hard work for you: Naturally, there‚Äôs nothing to stop you from applying the symmetry in either direction or both directions simultaneously. In such a case, you can use the unary minus operator in front of the complex number to flip its real and imaginary parts: Go ahead and fiddle with the different flip combinations using the interactive Jupyter Notebook available in the downloadable materials. Here‚Äôs how the triangle will look when you flip it along both axes: Scaling is similar to translating, but instead of adding an offset, you‚Äôre going to multiply each vertex by a constant factor, which must be a real number: Doing so results in multiplying both components of each complex number by the same amount. It should stretch your Bermuda Triangle, making it look bigger on the plot: Multiplying the triangle‚Äôs vertices by another complex number, on the other hand, has the effect of rotating it around the coordinate system‚Äôs origin. That‚Äôs vastly different from how you‚Äôd typically multiply vectors by each other. For example, a dot product of two vectors will result in a scalar, while their cross product returns a new vector in three-dimensional space, which is perpendicular to the surface they define. Note: The product of two complex numbers doesn‚Äôt represent vector multiplication. Instead, it‚Äôs defined as matrix multiplication in a two-dimensional vector space, with 1 and as the standard basis. Multiplying (x + y ) by (x + y ) corresponds to the following matrix multiplication: This is the rotation matrix on the left, which makes the math work out just fine. When you multiply the vertices by the imaginary unit, it will rotate the triangle 90¬∞ counterclockwise. If you keep repeating it, you‚Äôll eventually arrive where you started: How do you find a specific complex number that will rotate another complex number by any desired angle when both are multiplied? First, take a look at the following table, which summarizes the consecutive rotations by 90¬∞: When you express the repeated multiplication by in terms of positive integer exponents, then a pattern emerges. Notice how raising the imaginary unit to the subsequent powers makes it cycle through the same values repeatedly. You can extrapolate this onto fractional exponents and expect them to correspond to the intermediate angles. For example, the exponent halfway through the first rotation is equal to 0.5 and represents a 45¬∞ angle: So, if you know that a power of one represents the right angle, and anything in between scales proportionally, then you can derive this generic formula for arbitrary rotations: Note that rotation becomes more natural when you express your complex numbers in polar coordinates, which already describe the angle. You can then take advantage of the exponential form to make the calculations more straightforward: There are two ways to rotate a number using polar coordinates: You can sum angles or multiply your complex number by a unit vector. You‚Äôll learn more about those in the next section.\n\nYou‚Äôve already seen that some built-in functions like and accept complex numbers, while others don‚Äôt. For example, you can‚Äôt a complex number because such an operation doesn‚Äôt make sense: Many advanced mathematical functions such as trigonometric, hyperbolic, or logarithmic functions are available in the standard library. Sadly, even if you know everything about the Python module, it won‚Äôt help because none of its functions support complex numbers. You‚Äôll need to combine it with the module, which defines corresponding functions for complex numbers. The module redefines all floating-point constants from so that they‚Äôre at your fingertips without the need to import both modules: Note that is a special value which is never equal to anything else, including itself! That‚Äôs why you‚Äôre seeing a solitary in the output above. In addition to these, provides two complex counterparts for NaN (not a number) and infinity, with both having zero real parts: There are about half as many functions in as there are in the standard module. Most of them mimic the original behavior, but a few are unique to complex numbers. They will let you do the conversion between two coordinate systems that you‚Äôll explore in this section. The fundamental theorem of algebra states that a degree n polynomial with complex coefficients has exactly n complex roots. That is quite significant if you think about it, so let it sink in for a moment. Now, let‚Äôs take the quadratic function x2 + 1 as an example. Visually, this parabola doesn‚Äôt intersect the X-axis because it lies one unit above the origin. The function‚Äôs discriminant is negative, which confirms this observation arithmetically. At the same time, it‚Äôs a polynomial of degree two, so it must have two complex roots, even though it doesn‚Äôt have any real ones! To find those roots, you can rewrite the function as a quadratic equation, then move the constant over to the right and take the square root of both sides: In the domain of real numbers, the square root is only defined for nonnegative input values. Therefore, calling this function in Python will raise an exception with an appropriate error message: However, when you treat ‚àö-1 as a complex number instead and call the relevant function from the module, then you‚Äôll get a more meaningful result: That makes sense. After all, the intermediate form x2 = -1 of the quadratic equation is the very definition of the imaginary unit. But, wait a minute. Where did the other complex root go? What about complex roots of higher-degree polynomials? For example, a fourth-degree polynomial x4 + 1, which can be written as an equation x4 = -1, has these four complex roots: Raising each root to the fourth power results in a complex number equal to -1 + 0 or a real number -1: You‚Äôll notice that the resulting value isn‚Äôt exactly -1 due to the rounding error in floating-point arithmetic. To account for that, you can call whenever you need to tell if two complex numbers are close in value: Unfortunately, you can‚Äôt compute other complex roots with pure Python because regular exponentiation always gives one solution: That‚Äôs only one of the roots listed before. The mathematical formula for finding all complex roots takes advantage of the trigonometric form of complex numbers: The r and œÜ are polar coordinates of the complex number, while n is the polynomial‚Äôs degree, and k is the root‚Äôs index, starting at zero. The good news is you don‚Äôt need to painstakingly calculate those roots yourself. The quickest way to find them is by installing a third-party library such as NumPy and importing it to your project: Knowing about the various complex number forms and their coordinate systems can be useful. As you can see, it helps in solving practical problems like finding complex roots. So, in the next section, you‚Äôll delve into more details. Geometrically, you can look at a complex number twofold. On the one hand, it‚Äôs a point whose horizontal and vertical distances from the origin uniquely identify its location. These are known as rectangular coordinates comprising the real and imaginary parts. On the other hand, you can describe the same point in polar coordinates that also let you find it unambiguously with two distances:\n‚Ä¢ Radial distance is the length of the radius measured from the origin.\n‚Ä¢ Angular distance is the angle measured between the horizontal axis and the radius. The radius, also known as the modulus, corresponds to the complex number‚Äôs magnitude, or the vector‚Äôs length. The angle is commonly referred to as the phase or argument of a complex number. It‚Äôs useful to express the angle in radians rather than degrees when working with trigonometric functions. Here‚Äôs a depiction of a complex number in both coordinate systems: Therefore, a point (3, 2) in the Cartesian coordinate system has a radius of approximately 3.6 and an angle of about 33.7¬∞, or roughly œÄ over 5.4 radians. The conversion between the two coordinate systems is made possible with a couple of functions buried in the module. Specifically, to get the polar coordinates of a complex number, you must pass it to : It will return a tuple, where the first element is the radius and the second element is the angle in radians. Note that the radius has the same value as the magnitude, which you can calculate by calling on your complex number. Conversely, if you were only interested in getting the angle of a complex number, then you could call : # Magnitude is also the radial distance The angle can be obtained using basic trigonometry since the real part, the imaginary part, and the magnitude together form a right triangle: You can use the inverse trigonometric functions, such as arcsine, either from or , but the latter will produce complex values with the imaginary part equal to zero: There‚Äôs one small detail to be careful about when using the arctangent function, though, which led many programming languages to develop an alternative implementation called . Calculating the ratio between the imaginary and the real part can sometimes produce a singularity due to, for instance, division by zero. Moreover, the individual signs of the two values are lost in the process, making it impossible to tell the angle with certainty: Notice how fails to recognize two different points located in the opposite quadrants of the coordinate system. On the other hand, expects two arguments instead of one to preserve the individual signs before dividing one by another and avoids other problems as well. To get degrees instead of radians, you can make the necessary conversion using the module again: Reversing the process‚Äîthat is, converting polar to rectangular coordinates‚Äîrelies on another function. However, you can‚Äôt just pass the same tuple that you got from since expects two separate arguments: It‚Äôs a good idea to unpack the tuple first when doing an assignment and give those elements more descriptive names. Now you can call correctly: You might encounter rounding errors along the way while Python makes the calculations. Behind the scenes, it calls the trigonometric functions to retrieve the real and imaginary parts: Again, it doesn‚Äôt matter whether you use or in this case as the results will be identical. Regardless of the coordinate system, you can express the same complex number in a few mathematically equivalent forms: This list isn‚Äôt exhaustive as there are more representations, such as the matrix representation of complex numbers. Having the choice lets you pick the most convenient one to tackle a given problem. For example, you‚Äôre going to need the exponential form to calculate discrete Fourier transform in an upcoming section. Using this form is also suitable for multiplying and dividing complex numbers. Here‚Äôs a quick rundown of the individual complex number forms and their coordinates: The algebraic form is native to Python when you specify complex numbers using their literals. You can also view them as points on a Euclidean plane in the Cartesian or polar coordinate systems. While there aren‚Äôt separate representations for the trigonometric or exponential form in Python, you can verify if mathematical principles hold. For example, plugging in Euler‚Äôs formula to the trigonometric form will turn it into the exponential one. You can either call the module‚Äôs or raise the constant to a power to get the same result: All forms are indeed different ways of encoding the same number. However, you can‚Äôt compare them directly because of the rounding errors that may occur in the meantime. Use for a safe comparison or the numbers as strings appropriately. You‚Äôll find out how to format such strings in the upcoming section. The explanation of why different forms of a complex number are equivalent requires calculus and goes far beyond the scope of this tutorial. However, if you‚Äôre interested in math, then you‚Äôll find the connections between different fields of mathematics that are exhibited by complex numbers to be fascinating.\n\nYou‚Äôve already learned a bunch about Python complex numbers and have seen preliminary examples. However, before moving further, it‚Äôs worthwhile to cover some final topics. In this section, you‚Äôre going to look into comparing complex numbers, formatting strings that contain them, and more. Mathematically, two complex numbers are equal when they have identical values irrespective of the adopted coordinate system. However, converting between polar and rectangular coordinates typically introduces rounding errors in Python, so you need to watch out for minute differences when comparing them. For example, when you consider a point on a unit circle whose radius is equal to one and is tilted at 60¬∞, then the trigonometry works out nicely, making the conversion with pen and paper straightforward: Even though you know that and are the same point, Python can‚Äôt determine that because of the rounding errors. Fortunately, the PEP 485 document defined functions for approximate equality, which are available in the and modules: Remember to always use them when comparing complex numbers! If the default tolerance isn‚Äôt good enough for your calculations, you can change it by specifying additional arguments. If you‚Äôre familiar with tuples, then you know that Python can sort them: By default, the individual tuples are compared left to right: In the first case, the number is greater than , so the planet names aren‚Äôt considered at all. They can help resolve a tie, though. However, that‚Äôs not the case with complex numbers since they don‚Äôt define a natural ordering relation. For example, you‚Äôll get an error if you try to compare two complex numbers: File , line , in : '<' not supported between instances of 'complex' and 'complex' Should the imaginary dimension have more weight than the real one? Should their magnitudes be compared? It‚Äôs up to you, and the answers will vary. Since you can‚Äôt compare complex numbers directly, you need to tell Python how to sort them by specifying a custom key function, such as : This will sort the complex numbers by their magnitude in descending order. There aren‚Äôt any format codes specific to complex numbers, but you can format their real and imaginary parts separately using standard codes for floating-point numbers. Below, you‚Äôll find a few techniques that demonstrate this. Some of them will actually apply your format specifier to both the real and imaginary parts in one go. Note: String formatting can let you ignore the floating-point representation error and pretend it doesn‚Äôt exist: The letter in the format specifier stands for general format, which rounds your number to the requested precision. The default precision is six significant figures. Let‚Äôs take the following complex number as an example and format it with two decimal places on both parts: A quick way to do this is either by calling with a numeric format specifier or by creating an appropriately formatted f-string: If you want more control, for example, to add extra padding around the plus operator, then the f-string will be a better choice: You can also call on a string object and pass positional or keyword arguments to it: The positional arguments provide a sequence of values, while the keyword arguments let you refer to them by name. Similarly, you can use the string modulo operator ( ) with either a tuple or a dictionary: However, this uses a different placeholder syntax and is slightly old-fashioned. The Python data model defines a set of special methods that you can implement to make your classes compatible with certain built-in types. Say you were working with points and vectors and wanted to get the angle between two bound vectors. You might calculate their dot product and do some trigonometry. Alternatively, you can take advantage of complex numbers. A has the and coordinates, while a connects two points. You might remember , which calculates the angular distance of a complex number. Now, if you treated your vectors as complex numbers and knew their phases, then you could subtract them to obtain the desired angle. To make Python recognize vector instances as complex numbers, you have to supply in the class body: The code inside must always return an instance of the data type, so it typically constructs a new complex number out of your object. Here, you‚Äôre subtracting the initial and terminal points to get the horizontal and vertical displacements, which serve as the real and imaginary parts. The method will run through delegation when you call the global on a vector instance: In some cases, you don‚Äôt have to make this kind of type casting yourself. Let‚Äôs see an example in practice: You‚Äôve got two vectors identified by four distinct points. Next, you pass them directly to , which does the conversion to a complex number for you and returns the phase. The phase difference is the angle between the two vectors. Wasn‚Äôt that beautiful? You‚Äôve saved yourself from typing a lot of error-prone code by piggybacking on the complex numbers and a bit of Python magic.\n\nWhile you can use real numbers to calculate the sine and cosine coefficients of a periodic function‚Äôs frequencies with the Fourier transform, it‚Äôs usually more convenient to deal with only one complex coefficient per frequency. The discrete Fourier transform in the complex domain is given by the following formula: For each frequency bin k, it measures the correlation of the signal and a particular sine wave expressed as a complex number in the exponential form. (Thank you, Leonhard Euler!) The angular frequency of the wave can be calculated by multiplying the round angle, which is 2œÄ radians, by k over the number of discrete samples: Coding this in Python looks quite neat when you take advantage of the data type: This function is a literal transcription of the formulas above. Now you can run a frequency analysis on a sound that you load from an audio file using Python‚Äôs module or that you synthesize from scratch. One of the Jupyter Notebooks accompanying this tutorial lets you play with audio synthesis and analysis interactively. To plot the frequency spectrum with Matplotlib, you must know the sampling frequency, which determines your frequency bin resolution as well as the Nyquist limit: The number of frequency bins in the spectrum is equal to half the samples, while the Nyquist frequency limits the highest frequency you can measure. The transform returns a complex number whose magnitude corresponds to the amplitude of a sine wave at the given frequency, whereas its angle is the phase. Note: To get correct amplitude values, you must double the number and divide the resulting magnitude by the sample count. On the other hand, if you only care about a frequency histogram, then you can normalize magnitudes by their sum or the maximum frequency. Here‚Äôs a sample frequency plot of a sound wave comprising three tones‚Äî440 Hz, 1.5 kHz, and 5 kHz‚Äîhaving equal amplitudes: Note this was a purely academic example since calculating the discrete Fourier transform with nested iterations has O(n2) time complexity, making it unusable in practice. For real-life applications, you want to use the fast Fourier transform (FFT) algorithm best implemented in a C library, such as the FFT in SciPy."
    },
    {
        "link": "https://docs.python.org/3/library/cmath.html",
        "document": "This module provides access to mathematical functions for complex numbers. The functions in this module accept integers, floating-point numbers or complex numbers as arguments. They will also accept any Python object that has either a or a method: these methods are used to convert the object to a complex or floating-point number, respectively, and the function is then applied to the result of the conversion.\n\nFor functions involving branch cuts, we have the problem of deciding how to define those functions on the cut itself. Following Kahan‚Äôs ‚ÄúBranch cuts for complex elementary functions‚Äù paper, as well as Annex G of C99 and later C standards, we use the sign of zero to distinguish one side of the branch cut from the other: for a branch cut along (a portion of) the real axis we look at the sign of the imaginary part, while for a branch cut along the imaginary axis we look at the sign of the real part. For example, the function has a branch cut along the negative real axis. An argument of is treated as though it lies below the branch cut, and so gives a result on the negative imaginary axis: But an argument of is treated as though it lies above the branch cut:\n\nConversions to and from polar coordinates¬∂ A Python complex number is stored internally using rectangular or Cartesian coordinates. It is completely determined by its real part and its imaginary part . Polar coordinates give an alternative way to represent a complex number. In polar coordinates, a complex number z is defined by the modulus r and the phase angle phi. The modulus r is the distance from z to the origin, while the phase phi is the counterclockwise angle, measured in radians, from the positive x-axis to the line segment that joins the origin to z. The following functions can be used to convert from the native rectangular coordinates to polar coordinates and back. Return the phase of x (also known as the argument of x), as a float. is equivalent to . The result lies in the range [-œÄ, œÄ], and the branch cut for this operation lies along the negative real axis. The sign of the result is the same as the sign of , even when is zero: The modulus (absolute value) of a complex number x can be computed using the built-in function. There is no separate module function for this operation. Return the representation of x in polar coordinates. Returns a pair where r is the modulus of x and phi is the phase of x. is equivalent to . Return the complex number x with polar coordinates r and phi. Equivalent to .\n\nReturn if both the real and imaginary parts of x are finite, and otherwise. Return if either the real or the imaginary part of x is an infinity, and otherwise. Return if either the real or the imaginary part of x is a NaN, and otherwise. Return if the values a and b are close to each other and otherwise. Whether or not two values are considered close is determined according to given absolute and relative tolerances. If no errors occur, the result will be: . rel_tol is the relative tolerance ‚Äì it is the maximum allowed difference between a and b, relative to the larger absolute value of a or b. For example, to set a tolerance of 5%, pass . The default tolerance is , which assures that the two values are the same within about 9 decimal digits. rel_tol must be nonnegative and less than . abs_tol is the absolute tolerance; it defaults to and it must be nonnegative. When comparing to , is computed as , which is for any and rel_tol less than . So add an appropriate positive abs_tol argument to the call. The IEEE 754 special values of , , and will be handled according to IEEE rules. Specifically, is not considered close to any other value, including . and are only considered close to themselves.\n\nComplex number with zero real part and positive infinity imaginary part. Equivalent to . Complex number with zero real part and NaN imaginary part. Equivalent to . Note that the selection of functions is similar, but not identical, to that in module . The reason for having two modules is that some users aren‚Äôt interested in complex numbers, and perhaps don‚Äôt even know what they are. They would rather have raise an exception than return a complex number. Also note that the functions defined in always return a complex number, even if the answer can be expressed as a real number (in which case the complex number has an imaginary part of zero). A note on branch cuts: They are curves along which the given function fails to be continuous. They are a necessary feature of many complex functions. It is assumed that if you need to compute with complex functions, you will understand about branch cuts. Consult almost any (not too elementary) book on complex variables for enlightenment. For information of the proper choice of branch cuts for numerical purposes, a good reference should be the following: Kahan, W: Branch cuts for complex elementary functions; or, Much ado about nothing‚Äôs sign bit. In Iserles, A., and Powell, M. (eds.), The state of the art in numerical analysis. Clarendon Press (1987) pp165‚Äì211."
    },
    {
        "link": "https://stackoverflow.com/questions/2912485/computing-complex-math-equations-in-python",
        "document": "Are there any libraries or techniques that simplify computing equations ?\n\nTake the following two examples:\n‚Ä¢ B, a, b, c, d, j are all vectors in the format [ [zone_i, zone_j, cost_of_i_to_j], [..]]\n‚Ä¢ n is the number of zones so P_i would be the sum of all P_i_j for all j and Aj would be sum of all P_j for all i\n\nI'm not sure what I'm looking for, but perhaps a parser for these equations or methods to deal with multiple multiplications and products between vectors?\n\nTo calculate some of the factors, for example A_j, this is what i use\n\nAlthough this works fine, I really feel that it is a brute force / hacking method and unmaintainable in the case we want to add more variables or parameters. Are there any math equation parsers you'd recommend?\n\nSide Note: These equations are used to model travel. Currently I use excel to solve a lot of these equations; and I find that process to be daunting. I'd rather move to python where it pulls the data directly from our database (postgres) and outputs the results into the database. All that is figured out. I'm just struggling with evaluating the equations themselves."
    },
    {
        "link": "https://docs.python.org/3/library/math.html",
        "document": "This module provides access to the mathematical functions defined by the C standard.\n\nThese functions cannot be used with complex numbers; use the functions of the same name from the module if you require support for complex numbers. The distinction between functions which support complex numbers and those which don‚Äôt is made since most users do not want to learn quite as much mathematics as required to understand complex numbers. Receiving an exception instead of a complex result allows earlier detection of the unexpected complex number used as a parameter, so that the programmer can determine how and why it was generated in the first place.\n\nThe following functions are provided by this module. Except when explicitly noted otherwise, all return values are floats.\n\nReturn the number of ways to choose k items from n items without repetition and without order. Evaluates to when and evaluates to zero when . Also called the binomial coefficient because it is equivalent to the coefficient of k-th term in polynomial expansion of . Raises if either of the arguments are not integers. Raises if either of the arguments are negative. Return n factorial as an integer. Raises if n is not integral or is negative. Changed in version 3.10: Floats with integral values (like ) are no longer accepted. Return the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is . without arguments returns . Changed in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported. Return the integer square root of the nonnegative integer n. This is the floor of the exact square root of n, or equivalently the greatest integer a such that a¬≤ ‚â§ n. For some applications, it may be more convenient to have the least integer a such that n ‚â§ a¬≤, or in other words the ceiling of the exact square root of n. For positive n, this can be computed using . Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is . without arguments returns . Return the number of ways to choose k items from n items without repetition and with order. Evaluates to when and evaluates to zero when . If k is not specified or is , then k defaults to n and the function returns . Raises if either of the arguments are not integers. Raises if either of the arguments are negative.\n\nReturn the ceiling of x, the smallest integer greater than or equal to x. If x is not a float, delegates to , which should return an value. Return the absolute value of x. Return the floor of x, the largest integer less than or equal to x. If x is not a float, delegates to , which should return an value. Fused multiply-add operation. Return , computed as though with infinite precision and range followed by a single round to the format. This operation often provides better accuracy than the direct expression . This function follows the specification of the fusedMultiplyAdd operation described in the IEEE 754 standard. The standard leaves one case implementation-defined, namely the result of and . In these cases, returns a NaN, and does not raise any exception. Return the floating-point remainder of , as defined by the platform C library function . Note that the Python expression may not return the same result. The intent of the C standard is that be exactly (mathematically; to infinite precision) equal to for some integer n such that the result has the same sign as x and magnitude less than . Python‚Äôs returns a result with the sign of y instead, and may not be exactly computable for float arguments. For example, is , but the result of Python‚Äôs is , which cannot be represented exactly as a float, and rounds to the surprising . For this reason, function is generally preferred when working with floats, while Python‚Äôs is preferred when working with integers. Return the fractional and integer parts of x. Both results carry the sign of x and are floats. Note that has a different call/return pattern than its C equivalents: it takes a single argument and return a pair of values, rather than returning its second return value through an ‚Äòoutput parameter‚Äô (there is no such thing in Python). Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference , where is the closest integer to the exact value of the quotient . If is exactly halfway between two consecutive integers, the nearest even integer is used for . The remainder thus always satisfies . Special cases follow IEEE 754: in particular, is x for any finite x, and and raise for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating point, the result of this operation is always exactly representable: no rounding error is introduced. Return x with the fractional part removed, leaving the integer part. This rounds toward 0: is equivalent to for positive x, and equivalent to for negative x. If x is not a float, delegates to , which should return an value. For the , , and functions, note that all floating-point numbers of sufficiently large magnitude are exact integers. Python floats typically carry no more than 53 bits of precision (the same as the platform C double type), in which case any float x with necessarily has no fractional bits.\n\nReturn a float with the magnitude (absolute value) of x but the sign of y. On platforms that support signed zeros, returns -1.0. Return the mantissa and exponent of x as the pair . m is a float and e is an integer such that exactly. If x is zero, returns , otherwise . This is used to ‚Äúpick apart‚Äù the internal representation of a float in a portable way. Note that has a different call/return pattern than its C equivalents: it takes a single argument and return a pair of values, rather than returning its second return value through an ‚Äòoutput parameter‚Äô (there is no such thing in Python). Return if the values a and b are close to each other and otherwise. Whether or not two values are considered close is determined according to given absolute and relative tolerances. If no errors occur, the result will be: . rel_tol is the relative tolerance ‚Äì it is the maximum allowed difference between a and b, relative to the larger absolute value of a or b. For example, to set a tolerance of 5%, pass . The default tolerance is , which assures that the two values are the same within about 9 decimal digits. rel_tol must be nonnegative and less than . abs_tol is the absolute tolerance; it defaults to and it must be nonnegative. When comparing to , is computed as , which is for any nonzero and rel_tol less than . So add an appropriate positive abs_tol argument to the call. The IEEE 754 special values of , , and will be handled according to IEEE rules. Specifically, is not considered close to any other value, including . and are only considered close to themselves. Return if x is neither an infinity nor a NaN, and otherwise. (Note that is considered finite.) Return if x is a positive or negative infinity, and otherwise. Return if x is a NaN (not a number), and otherwise. Return . This is essentially the inverse of function . Return the floating-point value steps steps after x towards y. If x is equal to y, return y, unless steps is zero.\n‚Ä¢ None goes up: towards positive infinity.\n‚Ä¢ None goes down: towards minus infinity.\n‚Ä¢ None goes towards zero.\n‚Ä¢ None goes away from zero. Return the value of the least significant bit of the float x:\n‚Ä¢ None If x is a NaN (not a number), return x.\n‚Ä¢ None If x is equal to zero, return the smallest positive denormalized representable float (smaller than the minimum positive normalized float, ).\n‚Ä¢ None If x is equal to the largest positive representable float, return the value of the least significant bit of x, such that the first float smaller than x is .\n‚Ä¢ None Otherwise (x is a positive finite number), return the value of the least significant bit of x, such that the first float bigger than x is . ULP stands for ‚ÄúUnit in the Last Place‚Äù. See also and .\n\nReturn e raised to the power x, where e = 2.718281‚Ä¶ is the base of natural logarithms. This is usually more accurate than or . Return e raised to the power x, minus 1. Here e is the base of natural logarithms. For small floats x, the subtraction in can result in a significant loss of precision; the function provides a way to compute this quantity to full precision: With one argument, return the natural logarithm of x (to base e). With two arguments, return the logarithm of x to the given base, calculated as . Return the natural logarithm of 1+x (base e). The result is calculated in a way which is accurate for x near zero. Return the base-2 logarithm of x. This is usually more accurate than . returns the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros. Return the base-10 logarithm of x. This is usually more accurate than . Return x raised to the power y. Exceptional cases follow the IEEE 754 standard as far as possible. In particular, and always return , even when x is a zero or a NaN. If both x and y are finite, x is negative, and y is not an integer then is undefined, and raises . Unlike the built-in operator, converts both its arguments to type . Use or the built-in function for computing exact integer powers. Changed in version 3.11: The special cases and were changed to return instead of raising , for consistency with IEEE 754.\n\nReturn the Euclidean distance between two points p and q, each given as a sequence (or iterable) of coordinates. The two points must have the same dimension. Return an accurate floating-point sum of values in the iterable. Avoids loss of precision by tracking multiple intermediate partial sums. The algorithm‚Äôs accuracy depends on IEEE-754 arithmetic guarantees and the typical case where the rounding mode is half-even. On some non-Windows builds, the underlying C library uses extended precision addition and may occasionally double-round an intermediate sum causing it to be off in its least significant bit. For further discussion and two alternative approaches, see the ASPN cookbook recipes for accurate floating-point summation. Return the Euclidean norm, . This is the length of the vector from the origin to the point given by the coordinates. For a two dimensional point , this is equivalent to computing the hypotenuse of a right triangle using the Pythagorean theorem, . Changed in version 3.8: Added support for n-dimensional points. Formerly, only the two dimensional case was supported. Changed in version 3.10: Improved the algorithm‚Äôs accuracy so that the maximum error is under 1 ulp (unit in the last place). More typically, the result is almost always correctly rounded to within 1/2 ulp. Calculate the product of all the elements in the input iterable. The default start value for the product is . When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. Return the sum of products of values from two iterables p and q. Raises if the inputs do not have the same length. For float and mixed int/float inputs, the intermediate products and sums are computed with extended precision.\n\nThe mathematical constant œÄ = 3.141592‚Ä¶, to available precision. The mathematical constant e = 2.718281‚Ä¶, to available precision. The mathematical constant œÑ = 6.283185‚Ä¶, to available precision. Tau is a circle constant equal to 2œÄ, the ratio of a circle‚Äôs circumference to its radius. To learn more about Tau, check out Vi Hart‚Äôs video Pi is (still) Wrong, and start celebrating Tau day by eating twice as much pie! A floating-point positive infinity. (For negative infinity, use .) Equivalent to the output of . A floating-point ‚Äúnot a number‚Äù (NaN) value. Equivalent to the output of . Due to the requirements of the IEEE-754 standard, and are not considered to equal to any other numeric value, including themselves. To check whether a number is a NaN, use the function to test for NaNs instead of or . Example: Changed in version 3.11: It is now always available. CPython implementation detail: The module consists mostly of thin wrappers around the platform C math library functions. Behavior in exceptional cases follows Annex F of the C99 standard where appropriate. The current implementation will raise for invalid operations like or (where C99 Annex F recommends signaling invalid operation or divide-by-zero), and for results that overflow (for example, ). A NaN will not be returned from any of the functions above unless one or more of the input arguments was a NaN; in that case, most functions will return a NaN, but (again following C99 Annex F) there are some exceptions to this rule, for example or . Note that Python makes no effort to distinguish signaling NaNs from quiet NaNs, and behavior for signaling NaNs remains unspecified. Typical behavior is to treat all NaNs as though they were quiet. Complex number versions of many of these functions."
    },
    {
        "link": "https://stackoverflow.com/questions/8678428/best-practices-for-coding-simple-mathematical-calculations-in-python",
        "document": "I need to perform simple mathematical calculations in Python 2.7 with sums, subtractions, divisions, multiplications, sums over lists of numbers etc.\n\nI want to write elegant, bullet-proof, and efficient code but I must admit I got confused by several things, for example:\n‚Ä¢ if I have in my equation should I just code or maybe , or any other combination of these?\n‚Ä¢ for division, should I use or with ?\n‚Ä¢ what practices such as \"using for concatenating a list of floats\" are out there?\n‚Ä¢ should I assume that input numbers are float or do the conversion just in case (maybe risking drop of efficiency on many operations)?\n\nSo what are the best practices for writing a code for simple mathematical calculations in Python that is\n‚Ä¢ bullet-proof to issues like uncertainty in exact number type of input data (float vs integer) ?"
    }
]