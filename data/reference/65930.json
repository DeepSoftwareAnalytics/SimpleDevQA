[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/microsoft.graph.iauthenticationprovider?view=graph-core-dotnet",
        "document": "Some information relates to prerelease product that may be substantially modified before it’s released. Microsoft makes no warranties, express or implied, with respect to the information provided here."
    },
    {
        "link": "https://learn.microsoft.com/en-us/java/api/com.microsoft.graph.authentication.iauthenticationprovider?view=graph-core-java",
        "document": "This browser is no longer supported.\n\nUpgrade to Microsoft Edge to take advantage of the latest features, security updates, and technical support."
    },
    {
        "link": "https://learn.microsoft.com/en-us/graph/sdks/choose-authentication-providers",
        "document": "Authentication providers implement the code required to acquire a token using the Microsoft Authentication Library (MSAL), handle some potential errors for cases like incremental consent, expired passwords, and conditional access, and then set the HTTP request authorization header. The following table lists the providers that match the scenarios for different application types.\n\nThe authorization code flow enables native and web apps to obtain tokens in the user's name securely. To learn more, see Microsoft identity platform and OAuth 2.0 authorization code flow.\n\nvar scopes = new[] { \"User.Read\" }; // Multi-tenant apps can use \"common\", // single-tenant apps must use the tenant ID from the Azure portal var tenantId = \"common\"; // Values from app registration var clientId = \"YOUR_CLIENT_ID\"; var clientSecret = \"YOUR_CLIENT_SECRET\"; // For authorization code flow, the user signs into the Microsoft // identity platform, and the browser is redirected back to your app // with an authorization code in the query parameters var authorizationCode = \"AUTH_CODE_FROM_REDIRECT\"; // using Azure.Identity; var options = new AuthorizationCodeCredentialOptions { AuthorityHost = AzureAuthorityHosts.AzurePublicCloud, }; // https://learn.microsoft.com/dotnet/api/azure.identity.authorizationcodecredential var authCodeCredential = new AuthorizationCodeCredential( tenantId, clientId, clientSecret, authorizationCode, options); var graphClient = new GraphServiceClient(authCodeCredential, scopes); The Azure Identity Client Module for Go doesn't support the authorization code flow. final String clientId = \"YOUR_CLIENT_ID\"; final String tenantId = \"YOUR_TENANT_ID\"; // or \"common\" for multi-tenant apps final String clientSecret = \"YOUR_CLIENT_SECRET\"; final String authorizationCode = \"AUTH_CODE_FROM_REDIRECT\"; final String redirectUrl = \"YOUR_REDIRECT_URI\"; final String[] scopes = new String[] { \"User.Read\" }; final AuthorizationCodeCredential credential = new AuthorizationCodeCredentialBuilder() .clientId(clientId).tenantId(tenantId).clientSecret(clientSecret) .authorizationCode(authorizationCode).redirectUrl(redirectUrl).build(); if (null == scopes || null == credential) { throw new Exception(\"Unexpected error\"); } final GraphServiceClient graphClient = new GraphServiceClient(credential, scopes); The Microsoft Graph PHP SDK doesn't use MSAL libraries but custom authentication. In this case, AuthorizationCodeContext(). $scopes = ['User.Read']; // Multi-tenant apps can use \"common\", // single-tenant apps must use the tenant ID from the Azure portal $tenantId = 'common'; // Values from app registration $clientId = 'YOUR_CLIENT_ID'; $clientSecret = 'YOUR_CLIENT_SECRET'; $redirectUri = 'YOUR_REDIRECT_URI'; // For authorization code flow, the user signs into the Microsoft // identity platform, and the browser is redirected back to your app // with an authorization code in the query parameters $authorizationCode = 'AUTH_CODE_FROM_REDIRECT'; // Microsoft\\Kiota\\Authentication\\Oauth\\AuthorizationCodeContext $tokenContext = new AuthorizationCodeContext( $tenantId, $clientId, $clientSecret, $authorizationCode, $redirectUri); $graphClient = new GraphServiceClient($tokenContext, $scopes); In the following example, we're using the asynchronous AuthorizationCodeCredential. You can alternatively use the synchronous version of this credential. scopes = ['User.Read'] # Multi-tenant apps can use \"common\", # single-tenant apps must use the tenant ID from the Azure portal tenant_id = 'common' # Values from app registration client_id = 'YOUR_CLIENT_ID' client_secret = 'YOUR_CLIENT_SECRET' redirect_uri = 'YOUR_REDIRECT_URI' # For authorization code flow, the user signs into the Microsoft # identity platform, and the browser is redirected back to your app # with an authorization code in the query parameters authorization_code = 'AUTH_CODE_FROM_REDIRECT' # azure.identity.aio credential = AuthorizationCodeCredential( tenant_id=tenant_id, client_id=client_id, authorization_code=authorization_code, redirect_uri=redirect_uri, client_secret=client_secret) graph_client = GraphServiceClient(credential, scopes) # type: ignore // @azure/msal-browser const pca = new PublicClientApplication({ auth: { clientId: 'YOUR_CLIENT_ID', authority: `https://login.microsoft.online/${'YOUR_TENANT_ID'}`, redirectUri: 'YOUR_REDIRECT_URI', }, }); // Authenticate to get the user's account const authResult = await pca.acquireTokenPopup({ scopes: ['User.Read'], }); if (!authResult.account) { throw new Error('Could not authenticate'); } // @microsoft/microsoft-graph-client/authProviders/authCodeMsalBrowser const authProvider = new AuthCodeMSALBrowserAuthenticationProvider(pca, { account: authResult.account, interactionType: InteractionType.Popup, scopes: ['User.Read'], }); const graphClient = Client.initWithMiddleware({ authProvider: authProvider });\n\nThe client credential flow enables service applications to run without user interaction. Access is based on the identity of the application. For more information, see Microsoft identity platform and the OAuth 2.0 client credentials flow.\n\nvar scopes = new[] { \"https://graph.microsoft.com/.default\" }; // Values from app registration var clientId = \"YOUR_CLIENT_ID\"; var tenantId = \"YOUR_TENANT_ID\"; var clientCertificate = X509CertificateLoader .LoadCertificateFromFile(\"MyCertificate.pfx\"); // using Azure.Identity; var options = new ClientCertificateCredentialOptions { AuthorityHost = AzureAuthorityHosts.AzurePublicCloud, }; // https://learn.microsoft.com/dotnet/api/azure.identity.clientcertificatecredential var clientCertCredential = new ClientCertificateCredential( tenantId, clientId, clientCertificate, options); var graphClient = new GraphServiceClient(clientCertCredential, scopes); // The client credentials flow requires that you request the // /.default scope, and pre-configure your permissions on the // app registration in Azure. An administrator must grant consent // to those permissions beforehand. var scopes = new[] { \"https://graph.microsoft.com/.default\" }; // Values from app registration var clientId = \"YOUR_CLIENT_ID\"; var tenantId = \"YOUR_TENANT_ID\"; var clientSecret = \"YOUR_CLIENT_SECRET\"; // using Azure.Identity; var options = new ClientSecretCredentialOptions { AuthorityHost = AzureAuthorityHosts.AzurePublicCloud, }; // https://learn.microsoft.com/dotnet/api/azure.identity.clientsecretcredential var clientSecretCredential = new ClientSecretCredential( tenantId, clientId, clientSecret, options); var graphClient = new GraphServiceClient(clientSecretCredential, scopes); final String clientId = \"YOUR_CLIENT_ID\"; final String tenantId = \"YOUR_TENANT_ID\"; final String clientCertificatePath = \"MyCertificate.pem\"; // The client credentials flow requires that you request the // /.default scope, and pre-configure your permissions on the // app registration in Azure. An administrator must grant consent // to those permissions beforehand. final String[] scopes = new String[] {\"https://graph.microsoft.com/.default\"}; final ClientCertificateCredential credential = new ClientCertificateCredentialBuilder() .clientId(clientId).tenantId(tenantId).pemCertificate(clientCertificatePath) .build(); if (null == scopes || null == credential) { throw new Exception(\"Unexpected error\"); } final GraphServiceClient graphClient = new GraphServiceClient(credential, scopes); final String clientId = \"YOUR_CLIENT_ID\"; final String tenantId = \"YOUR_TENANT_ID\"; final String clientSecret = \"YOUR_CLIENT_SECRET\"; // The client credentials flow requires that you request the // /.default scope, and pre-configure your permissions on the // app registration in Azure. An administrator must grant consent // to those permissions beforehand. final String[] scopes = new String[] { \"https://graph.microsoft.com/.default\" }; final ClientSecretCredential credential = new ClientSecretCredentialBuilder() .clientId(clientId).tenantId(tenantId).clientSecret(clientSecret).build(); if (null == scopes || null == credential) { throw new Exception(\"Unexpected error\"); } final GraphServiceClient graphClient = new GraphServiceClient(credential, scopes); The Microsoft Graph PHP SDK doesn't use MSAL libraries but custom authentication. In this case, ClientCredentialContext(). // The client credentials flow requires that you request the // /.default scope, and pre-configure your permissions on the // app registration in Azure. An administrator must grant consent // to those permissions beforehand. $scopes = ['https://graph.microsoft.com/.default']; // Values from app registration $clientId = 'YOUR_CLIENT_ID'; $tenantId = 'YOUR_TENANT_ID'; // Certificate details $certificatePath = 'PATH_TO_CERTIFICATE'; $privateKeyPath = 'PATH_TO_PRIVATE_KEY'; $privateKeyPassphrase = 'PASSPHRASE'; // Microsoft\\Kiota\\Authentication\\Oauth\\ClientCredentialCertificateContext $tokenContext = new ClientCredentialCertificateContext( $tenantId, $clientId, $certificatePath, $privateKeyPath, $privateKeyPassphrase); $graphClient = new GraphServiceClient($tokenContext, $scopes); // The client credentials flow requires that you request the // /.default scope, and pre-configure your permissions on the // app registration in Azure. An administrator must grant consent // to those permissions beforehand. $scopes = ['https://graph.microsoft.com/.default']; // Values from app registration $clientId = 'YOUR_CLIENT_ID'; $tenantId = 'YOUR_TENANT_ID'; $clientSecret = 'YOUR_CLIENT_SECRET'; // Microsoft\\Kiota\\Authentication\\Oauth\\ClientCredentialContext $tokenContext = new ClientCredentialContext( $tenantId, $clientId, $clientSecret); $graphClient = new GraphServiceClient($tokenContext, $scopes); In the following example, we're using the asynchronous CertificateCredential. You can alternatively use the synchronous version of this credential. # The client credentials flow requires that you request the # /.default scope, and pre-configure your permissions on the # app registration in Azure. An administrator must grant consent # to those permissions beforehand. scopes = ['https://graph.microsoft.com/.default'] # Values from app registration tenant_id = 'YOUR_TENANT_ID' client_id = 'YOUR_CLIENT_ID' certificate_path = 'YOUR_CERTIFICATE_PATH' # azure.identity.aio credential = CertificateCredential( tenant_id=tenant_id, client_id=client_id, certificate_path=certificate_path) graph_client = GraphServiceClient(credential, scopes) # type: ignore In the following example, we're using the asynchronous ClientSecretCredential. You can alternatively use the synchronous version of this credential. # The client credentials flow requires that you request the # /.default scope, and pre-configure your permissions on the # app registration in Azure. An administrator must grant consent # to those permissions beforehand. scopes = ['https://graph.microsoft.com/.default'] # Values from app registration tenant_id = 'YOUR_TENANT_ID' client_id = 'YOUR_CLIENT_ID' client_secret = 'YOUR_CLIENT_SECRET' # azure.identity.aio credential = ClientSecretCredential( tenant_id=tenant_id, client_id=client_id, client_secret=client_secret) graph_client = GraphServiceClient(credential, scopes) # type: ignore // @azure/identity const credential = new ClientCertificateCredential( 'YOUR_TENANT_ID', 'YOUR_CLIENT_ID', 'YOUR_CERTIFICATE_PATH', ); // @microsoft/microsoft-graph-client/authProviders/azureTokenCredentials const authProvider = new TokenCredentialAuthenticationProvider(credential, { // The client credentials flow requires that you request the // /.default scope, and pre-configure your permissions on the // app registration in Azure. An administrator must grant consent // to those permissions beforehand. scopes: ['https://graph.microsoft.com/.default'], }); const graphClient = Client.initWithMiddleware({ authProvider: authProvider }); // @azure/identity const credential = new ClientSecretCredential( 'YOUR_TENANT_ID', 'YOUR_CLIENT_ID', 'YOUR_CLIENT_SECRET', ); // @microsoft/microsoft-graph-client/authProviders/azureTokenCredentials const authProvider = new TokenCredentialAuthenticationProvider(credential, { // The client credentials flow requires that you request the // /.default scope, and pre-configure your permissions on the // app registration in Azure. An administrator must grant consent // to those permissions beforehand. scopes: ['https://graph.microsoft.com/.default'], }); const graphClient = Client.initWithMiddleware({ authProvider: authProvider });\n\nThe on-behalf-of flow is applicable when your application calls a service/web API, which calls the Microsoft Graph API. Learn more by reading Microsoft identity platform and OAuth 2.0 On-Behalf-Of flow\n\nImplicit Authentication flow isn't recommended due to its disadvantages. Public clients such as native apps and single-page apps should now use the authorization code flow with the PKCE extension instead. Reference.\n\nThe device code flow enables sign-in to devices through another device. For details, see Microsoft identity platform and the OAuth 2.0 device code flow.\n\nThe integrated Windows flow allows Windows computers to use the Web Account Manager (WAM) to acquire an access token when domain-joined silently.\n\nThe interactive flow is used by mobile applications (Xamarin and UWP) and desktop applications to call Microsoft Graph in the name of a user. For details, see Acquiring tokens interactively.\n\nThe username/password provider allows an application to sign in a user using their username and password.\n• For code samples that show you how to use the Microsoft identity platform to secure different application types, see Microsoft identity platform code samples (v2.0 endpoint).\n• Authentication providers require a client ID. You'll want to register your application after you set up your authentication provider.\n• Let us know if a required OAuth flow isn't currently supported by voting for or opening a Microsoft Graph feature request."
    },
    {
        "link": "https://learn.microsoft.com/en-us/graph/sdks/sdks-overview",
        "document": "The Microsoft Graph software development kits (SDKs) are designed to simplify building high-quality, efficient, resilient applications that access Microsoft Graph. The SDKs include two components: a service library and a core library.\n\nThe service library contains models and request builders generated from Microsoft Graph metadata. The service library provides a rich, strongly typed, and discoverable experience when working with the many datasets available in Microsoft Graph.\n\nThe core library provides features that enhance working with all the Microsoft Graph services. Embedded support for retry handling, secure redirects, transparent authentication, and payload compression improve the quality of your application's interactions with Microsoft Graph with no added complexity while leaving you entirely in control. The core library also supports everyday tasks such as paging through collections and creating batch requests.\n\nSDKs are currently available for the following languages:\n\nA release of an SDK can be in preview status upon debut or a significant update. Don't assume a preview release is always promoted to generally available (GA) status.\n\nIn addition, don't use a preview release of an SDK in production apps, regardless of the version of Microsoft Graph API (v1.0 or beta) it uses.\n\nA release of an SDK in GA status can use the Microsoft Graph API v1.0 endpoint or beta endpoint as specified. Because Microsoft Graph APIs in the beta endpoint are subject to breaking changes, don't use the production apps a GA release of an SDK that accesses the Microsoft Graph API beta endpoint.\n\nIn some cases, it's beneficial to use a Kiota-generated client instead of a Microsoft Graph SDK. For example, a developer that only uses a small subset of the Microsoft Graph APIs and wants to minimize the overall install size of their app can use Kiota to generate a smaller client library. For details, see Generate Microsoft Graph client libraries with Kiota.\n\nMicrosoft Graph SDKs are open-source GitHub projects so if you have an issue with the SDK, submit it with all the needed information on the \"issues\" page. SDK authors and contributors should look into the issue and release a fix accordingly. Microsoft CSS doesn't officially, support SDKs but Microsoft supports the HTTP request of the Microsoft Graph API call you're making.\n• Learn more about the features and capabilities of the SDK in the design requirements documentation.\n• Request or vote on new features at the Microsoft 365 Developer Platform ideas forum.\n• Learn about generating Microsoft Graph client libraries with Kiota as an alternative to using an SDK."
    },
    {
        "link": "https://stackoverflow.com/questions/75604903/delegateauthenticationprovider-not-found-after-updating-microsoft-graph",
        "document": "I haven't figured your issue out because I never used your code before, I just followed this official document to create via on-behalf-of flow. I will try to continue. Here's what I already got and it worked.\n\nJust like what @user2250152 shared,\n\nIn place of the DelegateAuthenticationProvider, custom authentication flows can be done creating an implementation of IAccessTokenProvider, and using with the BaseBearerTokenAuthenticationProvider from the Kiota abstractions as follows\n\nwe can't use any more to use it directly to , if we want to generate the auth_provider to , we have to follow to use . I had a test like below, it can work but seems not meet the requirement for on-behalf-of flow.\n\nJust like you know, the whole flow for O-B-O should be, using an access token A to call the web API which is protected by AAD, then the API code use O-B-O flow to generate a new access token B to do other request, such as calling graph API.\n\nThen the scope or role for token A should look like , and the scope for token B should be graph API scope such as .\n\nIn my test, I used graph client so that I don't need to generate token B, but it still need to authenticate the graph client. I found that when I pass token A with to auth the graph client, I will get error, but when the token A is generated by graph API scope, I will successfully auth the graph client."
    },
    {
        "link": "https://learn.microsoft.com/en-us/entra/msal/dotnet/getting-started/initializing-client-applications",
        "document": "This article describes initializing public client and confidential client applications using the Microsoft Authentication Library for .NET (MSAL.NET). To learn more about the client application types, see Public client and confidential client applications.\n\nWith MSAL.NET 3.x, the recommended way to instantiate an application is by using the application builders: and . They offer a powerful mechanism to configure the application from the code, a configuration file, or even by mixing both approaches.\n\nBefore initializing an application, you first need to register it so that your app can be integrated with the Microsoft identity platform. Refer to the Quickstart: Register an application with the Microsoft identity platform for more information. After registration, you'll need the following information, which can be found in the app registration page in the Microsoft Entra admin center.\n• Directory (tenant) ID - Provides identity and access management (IAM) capabilities to applications and resources used by your organization. It can specify if you're writing a line of business application solely for your organization (also named single-tenant application).\n• The identity provider URL (named the instance) and the sign-in audience for your application. These two parameters are collectively known as the authority.\n• Client credentials - which can take the form of an application secret (client secret string) or certificate (of type ) if it's a confidential client app.\n• For web apps, and sometimes for public client apps (in particular when your app needs to use a broker), you need to set the Redirect URI where the identity provider will contact back your application with the security tokens.\n\nThere are many different ways to instantiate client applications.\n\nThe following code instantiates a public client application, signing-in users in the Microsoft Azure public cloud, with their work, school, or personal Microsoft accounts.\n\nIn the same way, the following code instantiates a confidential application (a Web app located at ) handling tokens from users in the Microsoft Azure public cloud, with their work and school accounts, or their personal Microsoft accounts. The application is identified with the identity provider by sharing a client secret:\n\nIn production however, certificates are recommended as they're more secure than client secrets. They can be created and uploaded to the Microsoft Entra admin center. The code would then be the following:\n\nThe following code instantiates a public client application from a configuration object, which could be filled-in programmatically or read from a configuration file:\n\nThe same kind of pattern applies to confidential client applications. You can also add other parameters using modifiers. This example uses .\n\nIn the code snippets using application builders, many methods can be applied as modifiers (for example, and ).\n\nThe modifiers you can set on a public client or confidential client application builder can be found in the class. The different methods can be found in the Azure SDK for .NET documentation.\n\nThe modifiers specific to a confidential client application builder can be found in the class. The different methods can be found in the Azure SDK for .NET documentation.\n\nModifiers such as and are mutually exclusive. If you provide both, MSAL throws a meaningful exception.\n\nExample of usage of modifiers\n\nLet's assume that your application is a line-of-business application, which is only for your organization. Then you can write:\n\nProgramming for national clouds has simplified, so if you want your application to be a multi-tenant application in a national cloud, you could write, for instance:\n\nThere's also an override for ADFS (MSAL.NET only supports ADFS 2019 or later):\n\nFinally, if you're an Azure AD B2C developer, you can specify your tenant like this:\n\nAfter you've initialized the client application, your next task is to add support for user sign-in, authorized API access, or both.\n\nOur application scenario documentation provides guidance for signing in a user and acquiring an access token to access an API on behalf of that user:\n• Web app that signs in users: Sign-in and sign-out"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/microsoft.identity.client.confidentialclientapplicationbuilder?view=msal-dotnet-latest",
        "document": "MSAL maintains a token cache internally in memory. By default, this cache object is part of each instance of PublicClientApplication or ConfidentialClientApplication. This method allows customization of the in-memory token cache of MSAL. MSAL's memory cache is different than token cache serialization. Cache serialization pulls the tokens from a cache (e.g. Redis, Cosmos, or a file on disk), where they are stored in JSON format, into MSAL's internal memory cache. Memory cache operations do not involve JSON operations. External cache serialization remains the recommended way to handle desktop apps, web site and web APIs, as it provides persistence. These options do not currently control external cache serialization. Detailed guidance for each application type and platform: https://aka.ms/msal-net-token-cache-serialization (Inherited from AbstractApplicationBuilder<T>)\n\nSets the certificate associated with the application. Applicable to first-party applications only, this method also allows to specify if the x5c claim should be sent to Azure AD. Sending the x5c enables application developers to achieve easy certificate roll-over in Azure AD: this method will send the certificate chain to Azure AD along with the token request, so that Azure AD can use it to validate the subject name based on a trusted issuer policy. This saves the application admin from the need to explicitly manage the certificate rollover (either via portal or PowerShell/CLI operation). For details see https://aka.ms/msal-net-sni\n\nSets the application client assertion. See https://aka.ms/msal-net-client-assertion. This will create an assertion that will be held within the client application's memory for the duration of the client. You can use WithClientAssertion(Func<String>) to set a delegate that will be executed for each authentication request. This will allow you to update the client assertion used by the client application once the assertion expires."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/microsoft.identity.client.confidentialclientapplication.acquiretokenforclient?view=msal-dotnet-latest",
        "document": "Some information relates to prerelease product that may be substantially modified before it’s released. Microsoft makes no warranties, express or implied, with respect to the information provided here.\n\nAcquires a token from the authority configured in the app, for the confidential client itself (in the name of no user) using the client credentials flow. See https://aka.ms/msal-net-client-credentials.\n\nscopes requested to access a protected API. For this flow (client credentials), the scopes of Microsoft APIs protected with AAD tokens are of the form \"{ResourceIdUri/.default}\". For example or, for Microsoft Graph, . The requested scopes are defined statically with the application registration in the portal, and cannot be overridden in the application.\n\nA builder enabling you to add optional parameters before executing the token request\n\nYou can also chain the following optional parameters: WithForceRefresh(Boolean)Microsoft.Identity.Client.AbstractAcquireTokenParameterBuilder`1.WithExtraQueryParameters(System.Collections.Generic.Dictionary{System.String,System.String})"
    },
    {
        "link": "https://learn.microsoft.com/en-us/entra/msal/dotnet/acquiring-tokens/web-apps-apis/authorization-codes",
        "document": "Using MSAL.NET to get tokens by authorization code (for web sites)\n\nWhen users login to Web applications (web sites) using OpenID Connect, the web application receives an authorization code which it can redeem to acquire a token to call Web APIs. In ASP.NET and ASP.NET Core web apps, the only goal of is to add a token to the token cache, so that it can then be used by the application (usually in the controllers) which just get a token for an API using .\n\nIf you are building a web app on ASP.NET Core, the recommendation is to use\n\nYou need to register a Reply URI so that Microsoft Entra ID gets the authorization code and the token back to your application.\n\nYou should also register your application secrets either through the interactive experience in the Azure portal, or using command-line tools (like PowerShell)\n\nThe management of client credentials happens in the certificates & secrets page for an application:\n• The application secret (also named client secret) is generated by Microsoft Entra ID during the registration of the confidential client application when you select New client secret. At that point, you must copy the secret string in the clipboard for use in your app, before selecting Save. This string won't be presented any longer.\n• The certificate is uploaded in the application registration using the Upload certificate button\n\nThe active-directory-dotnetcore-daemon-v2 sample shows how to register an application secret or a certificate with a Microsoft Entra application:\n• For details on how to register an application secret, see AppCreationScripts/Configure.ps1\n• For details on how to register a certificate with the application, see AppCreationScripts-withCert/Configure.ps1\n\nThis flow is only available in the confidential client flow; therefore the protected Web API provides client credentials (client secret or certificate) to the ConfidentialClientApplicationBuilder via the or the or methods respectively.\n\nGetting tokens by authorization code in MSAL.NET\n\nTo redeem an authorization code and get a token, and cache it, the contains a method called :\n\nThis principle is illustrated below the code performing the application initialization located in the file, and, to add authentication with the Microsoft identity platform, you'll need to add the following code (The comments in the code should be self-explanatory):\n\nIn ASP.NET Core, building the confidential client application leverages information that is in the , which, in particular contains the URL for the Web site, which helps building the .\n\nThe web app should also implement token cache serialization. This is explained in Token cache serialization in MSAL.NET.\n\nA guest user in a tenant is a user account that was not originally created in that tenant, but in some other tenant. When acquiring tokens in MSAL, in order for home account ID to show the correct home tenant of the user, certain set up has to be done in ASP.NET Core and ASP.NET OWIN. Microsoft.Identity.Web simplifies logging in guest users for both of those platforms. See OWIN sample app for details.\n• None The code is usable only once to redeem a token. should not be called several times with the same authorization code (it's explicitly prohibited by the protocol standard spec). If you redeem the code several times, consciously, or because you are not aware that a framework also does it for you, you'll get an error: 'invalid_grant', 'AADSTS70002: Error validating credentials. AADSTS54005: OAuth2 Authorization code was already redeemed, please retry with a new valid code or use an existing refresh token\n• None In particular, if you are writing an ASP.NET / ASP.NET Core application, this might happen if you don't tell the ASP.NET/Core framework that you have already redeemed the code. For this you need to call part of the event handler.\n• None Finally, avoid sharing the access token with ASP.NET otherwise this might prevent incremental consent happening correctly, (for details see issue #693).\n\nThis very operation will add a token to the token cache, and therefore the controllers that need a token later will be able to acquire a token silently, as does the SendMail() method of the HomeController.cs#L55-L76\n\nFor details about the protocol, see v2.0 Protocols - OAuth 2.0 authorization code flow\n\nSee Acquiring tokens with authorization codes on web apps."
    },
    {
        "link": "https://learn.microsoft.com/en-us/entra/msal/dotnet/acquiring-tokens/overview",
        "document": "As explained in Scenarios, there are many ways of acquiring a token with MSAL.NET. Some require interaction and others are completely transparent to the user. The approach used to acquire a token is different depending on whether the developer is building a public client (desktop or mobile) or a confidential client application (web app, web API, or daemon like a Windows service). Public clients generally require user interaction while confidential clients rely on pre-provisioned credentials, like certificates and secrets.\n\nFor both public and confidential client applications, MSAL.NET supports adding a token cache that preserves authentication and refresh tokens, as well as proactively refreshes those on an as-needed basis. For details, see Token cache serialization in MSAL.NET.\n\nFor .NET desktop applications (.NET, .NET Framework, and .NET Core) the application needs to handle the token cache serialization and storage directly; however, helper classes are available to help simplify the process.\n• Will often acquire token interactively, having the user sign-in.\n• It's also possible for a desktop application running on a Windows machine joined to a domain or to Microsoft Entra ID to use Integrated Windows Authentication (IWA/Kerberos) to acquire a token silently.\n• Keep in mind that the IWA approach is not recommended. A more secure approach using the Web Account Manager (WAM) is available.\n• For .NET Framework desktop applications, in limited scenarios it's possible to get a token with a username and password. Due to security considerations, this approach is not recommended.\n• In applications running on devices which don't have a web browser, a token can be acquired with the help of the device code flow, which provides the application user with a URL and a code. The user will subsequently go to a web browser on another device, enter the code, and sign in. The authenticating device will then poll Microsoft Entra ID services until it receives confirmation of a successful sign in and an access token.\n\nThe following table summarizes the available approaches to acquire tokens in public client applications:\n• Acquires token for the application itself, not for a user. Token acquisition is done with the help of client credentials. This flow is useful for syncing tools or tools which process data or user information without a specific identity attached to it.\n• For web APIs calling an API on behalf of a user, developers can use On Behalf Of flow. The application itself will use client credentials to acquire a token based on a user assertion (e.g., SAML or a JWT). This flow can be used for applications which need to access resources of a particular user in service-to-service calls.\n• For web apps, token acquisition is done using an authorization code after signing the user in through the authorization request URL. This is typically the mechanism used by an application which lets the user sign-in using OpenID Connect and then accesses web APIs on behalf of this particular user.\n\nThe following table summarizes the ways to acquire tokens in confidential client applications:\n\nAll the Acquire Token methods in MSAL.NET have the following pattern:\n• From the application, you call the AcquireTokenXXX method corresponding to the flow you want to use, passing the mandatory parameters for this flow (in general flow)\n• This returns a command builder, on which you can add optional parameters using .WithYYY methods\n• Then you call ExecuteAsync() to get your authentication result.\n\nHere is the pattern:\n\nIn all cases above, methods to acquire tokens return an (or in the case of the async methods a .\n• for the Web API to access resources. This is a string, usually a base64 encoded JWT but the client should never look inside the access token. The format isn't guaranteed to remain stable, and it can be encrypted for the resource. People writing code depending on access token content on the client is one of the biggest sources of errors and client logic breaks\n• for the user (this is a JWT)\n• tells the date/time when the token expires\n• contains the tenant in which the user was found. Note that in the case of guest users (Microsoft Entra B2B scenarios), the TenantId is the guest tenant, not the unique tenant. When the token is delivered in the name of a user, also contains information about this user. For confidential client flows where tokens are requested with no user (for the application), this User information is null.\n• The for which the token was issued (See Scopes not resources)\n• The unique Id for the user.\n\nMSAL.NET defines the notion of Account (through the interface). This breaking change provides the right semantics: the fact that the same user can have several accounts, in different Microsoft Entra directories. Also MSAL.NET provides better information in the case of guest scenarios, as home account information is provided. The following diagram shows the structure of the interface:\n\nThe class identifies an account in a specific tenant. It has the following properties:\n\nThe interface represents information about a single account. The same user can be present in different tenants, that is, a user can have multiple accounts. Its members are:"
    }
]