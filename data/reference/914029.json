[
    {
        "link": "https://discourse.nixos.org/t/good-example-of-embedding-a-custom-derivation-within-a-nix-flake/32297",
        "document": "Hi all! I am experimenting with nix flakes and adopted the following flake structure:\n\nSay that I have a custom derivation like this:\n\nNote: this dirivation is copied from docs, and it might also contain errors, as I have not been able to test it yet.\n\nHow do I use this as a package within ?\n\nI think I am just missing some fundamental part of how flakes work and can‚Äôt seem to find a good example.\n\nI tried the following things:\n‚Ä¢ naively adding this to the in\n‚Ä¢ attempted to add an custom package like this in\n‚Ä¢ serveral variations of the above two using the overlay/pkgs structure taken from GitHub - Misterio77/nix-starter-configs: Simple and documented config templates to help you get started with NixOS + home-manager + flakes. All the boilerplate you need! (great resource btw!)\n\nIf somebody could point me in the right direction, I would be very grateful!\n\nI would be happy to contribute a working example back to the documentation, just point me where to add it."
    },
    {
        "link": "https://nix.dev/concepts/flakes.html",
        "document": "What is usually referred to as ‚Äúflakes‚Äù is:\n‚Ä¢ None An experimental feature in Nix, implementing that policy and supporting functionality.\n\nTechnically, a flake is a file system tree that contains a file named in its root directory. Flakes add the following behavior to Nix:\n‚Ä¢ \n‚Ä¢ None Other flakes are referenced as dependencies providing Nix language code or other files.\n‚Ä¢ None The values produced by the Nix expressions in are structured according to pre-defined use cases.\n‚Ä¢ None References to other flakes can be specified using a dedicated URL-like syntax. A flake registry allows using symbolic identifiers for further brevity. References can be automatically locked to their current specific version and later updated programmatically.\n‚Ä¢ None A new command line interface, implemented as a separate experimental feature, leverages flakes by accepting flake references in order to build, run, or deploy software defined as a flake. Nix handles flakes differently than regular Nix files in the following ways:\n‚Ä¢ None The file is checked for schema validity. In particular, the metadata fields cannot be arbitrary Nix expressions. This is to prevent complex, possibly non-terminating computations while querying the metadata.\n‚Ä¢ None The entire flake directory is copied to Nix store before evaluation. This allows for effective evaluation caching, which is relevant for large expressions such as Nixpkgs, but also requires copying the entire flake directory again on each change.\n‚Ä¢ None No external variables, parameters, or impure language values are allowed. It means full reproducibility of a Nix expression, and, by extension, the resulting build instructions by default, but also prohibits parameterisation of results by consumers.\n\nShould I use flakes in my project?# You have to judge for yourself based on your needs. Flakes emphasize reproducible artifacts and convenience for their consumers, while classic Nix tools center around composable building blocks and customisation options for developers. Both paradigms have their own set of unique concepts and support tooling that have to be learned, with varying ease of use, implementation quality, and support status. At the moment, neither the stable nor the experimental interface is clearly superior to the other in all aspects. Flakes and the command suite bring multiple improvements that are relevant for both software users and package authors:\n‚Ä¢ None The new command-line interface, together with flakes, makes dealing with existing packages significantly more convenient in many cases.\n‚Ä¢ None The constraints imposed on flakes strengthen reproducibility by default, and enable some performance improvements when interacting with a large Nix package repository like Nixpkgs.\n‚Ä¢ None Flake references allow for easier handling of version upgrades for existing packages or project dependencies.\n‚Ä¢ None The flake schema helps with composing Nix projects from multiple sources in an orderly fashion. At the same time, flakes have fundamental architectural issues and a number of problems with the implementation, and there is no coordinated effort to resolve them systematically. There are also still many open design questions around the command line interface, some of which are currently being worked on. While flakes reduce complexity in some regards, they also introduce some with additional mechanisms. You will have to learn more about the system to fully understand how it works. Other than that, and below the surface of the flake schema, Nix and the Nix language work exactly the same in both cases. In principle, the same level of reproducibility can be achieved with or without flakes. In particular, the process of adding software to Nixpkgs or maintaining NixOS modules and configurations is not affected by flakes at all. There is also no evidence that flakes could help solving the scalability challenges of either. Finally, there are downsides to relying on experimental features in general:\n‚Ä¢ None Interfaces and behavior of experimental features could still be changed by Nix developers. This may require you to adapt your code at some point in the future, which will be more effort when it has grown in complexity. Currently there is no concrete timeline for stabilising flakes. In contrast, stable features in Nix can be considered stable indefinitely.\n‚Ä¢ None The Nix maintainer team focuses on fixing bugs and regressions in stable interfaces, supporting well-understood use cases, as well as improving the internal design and overall contributor experience in order to ease future development. Improvements to experimental features have low priority.\n‚Ä¢ None The Nix documentation team focuses on improving documentation and learning materials for stable features and common principles. When using flakes, you will have to rely more heavily on user-to-user support, third-party documentation, and the source code."
    },
    {
        "link": "https://discourse.nixos.org/t/using-a-custom-derivation-in-nixos-flake/42632",
        "document": "Hello, I have a Nix Flake that I use for configuring my NixOS laptop, MacBook and right now I‚Äôm writing a configuration that I plan to use on my VPS. I host my personal website/blog using Hugo and I made a derivation for it, that looks like this: It‚Äôs my understanding that a derivation is basically a package that I can use. However I don‚Äôt know how to use it in my current server configuration that looks like this: { config, pkgs, ... }: { system.stateVersion = \"23.11\"; # Don't touch this imports = [ # ./hardware-configuration.nix ]; boot.loader.systemd-boot.enable = true; boot.loader.efi.canTouchEfiVariables = true; networking.hostName = \"server\"; time.timeZone = \"Europe/Frankfurt\"; i18n.defaultLocale = \"en_US.UTF-8\"; nix.settings.experimental-features = [\"nix-command\" \"flakes\"]; networking.firewall.enable = true; networking.firewall.allowedTCPPorts = [ 50000 80 443 25 587 993 ]; virtualisation.vmVariant.virtualisation = { graphics = false; forwardPorts = [ { from = \"host\"; host.port = 50000; guest.port = 50000; } { from = \"host\"; host.port = 8080; guest.port = 80; } ]; }; users = { users.mateja = { isNormalUser = true; description = \"Mateja\"; extraGroups = [ \"wheel\" ]; openssh.authorizedKeys.keys = [ \"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAINMZcuz2OPjpUGNPIE3/7UUwUIVBztmx478LFUahQaMm mail@matejamaric.com\" ]; initialHashedPassword = \"$y$j9T$WwsIfZwdnLm84jjd9Q9wV1$fhDEn.TrvZVSaV6VNKpH0RWiPKAvaOhR.3oCkDlETO7\"; }; }; environment.systemPackages = with pkgs; [ git tmux php83 php83Packages.composer php83Extensions.mbstring php83Extensions.xml php83Extensions.bcmath gitolite opensmtpd dovecot rspamd redis # (callPackage ./blog {}) ]; services.openssh = { enable = true; ports = [ 50000 ]; settings.PasswordAuthentication = false; settings.KbdInteractiveAuthentication = false; settings.PermitRootLogin = \"no\"; }; programs.gnupg.agent = { enable = true; enableSSHSupport = true; }; services.nginx.enable = true; services.nginx.virtualHosts = { \"matejamaric.com\" = { enableACME = true; addSSL = true; # forceSSL = true; root = \"/var/www/matejamaric.com\"; }; \"mail.matejamaric.com\" = { enableACME = true; addSSL = true; # forceSSL = true; root = \"/var/www/mail.matejamaric.com\"; }; # \"git.matejamaric.com\" = { ... }; \"yota.yu1srs.org.rs\" = { enableACME = true; forceSSL = true; root = \"/var/www/yota.yu1srs.org.rs\"; locations.\"~ \\\\.php$\".extraConfig = '' fastcgi_pass unix:${config.services.phpfpm.pools.yotapool.socket}; fastcgi_index index.php; ''; }; }; security.acme = { acceptTerms = true; defaults.email = \"matejamaricz@gmail.com\"; }; services.mysql = { enable = true; package = pkgs.mariadb; }; services.phpfpm.pools.yotapool = { user = \"nobody\"; settings = { \"pm\" = \"dynamic\"; \"listen.owner\" = config.services.nginx.user; \"pm.max_children\" = 5; \"pm.start_servers\" = 2; \"pm.min_spare_servers\" = 1; \"pm.max_spare_servers\" = 3; \"pm.max_requests\" = 500; }; }; } My blog derivation and server configuration are all in the same repository (that I use for configuration). I don‚Äôt know if that‚Äôs okay or should I move the derivation to my blog repository? If I understood correctly, people often make a Flake that contains only the derivation and then they specify it only as input in their configuration Flake, what are the benefits of that?\n\n I‚Äôm quite new to Nix and especially the more involved stuff, all answer/explanations are more then welcome!\n\nI don‚Äôt know if that‚Äôs okay or should I move the derivation to my blog repository? Either option is correct, but I‚Äôd recommend placing it in the blog repo if you own it, and expose it in your flake‚Äôs packages section. As far as the derivation goes, I‚Äôd suggest changing the first two lines as follows: Using anywhere is considered bad practice (pinning is better). Also, instead of using , I‚Äôd recommend adding it as a flake input. It makes versioning easier, and you always know where to look. I don‚Äôt know how to use it in my current server configuration To build your derivation, you need to use somewhere. In that NixOS configuration, it would look as follows: { config, pkgs, ... }: let blog = pkgs.callPackage path/to/blog {}; in { system.stateVersion = \"23.11\"; # Don't touch this ... } You could also make it available directly in your instance via overlays (that‚Äôs what I‚Äôd usually do). people often make a Flake that contains only the derivation and then they specify it only as input in their configuration Flake, what are the benefits of that? I guess it depends on the use case. Exposing the derivation in your flake‚Äôs package as part of the same repository is usually what most people do. Exposing a derivation on a specific repo makes sense if you want to share it with other flakes.\n\nHey @gvolpe, thanks! That helped me a lot! \n\n I changed my derivation to this: And added line to my configuration inside of: Here‚Äôs the commit if somebody finds it easier to look at the diff.\n\n Everything builds without an error, although I thought that when the derivation is installed, Nix is going to link the built package on root ( ) using it‚Äôs output structure. In other word, I thought was going to be linked to the same path in my derivation output, which is not the case. How can I achieve this? You could also make it available directly in your instance via overlays (that‚Äôs what I‚Äôd usually do). I‚Äôm interested, can you show me an example?\n\nI also made a Flake in my blog repository. Somebody might find it as an useful example, so here it is: { description = \"Nix Flake package for my blog\"; inputs.nixpkgs.url = \"nixpkgs/nixos-23.11\"; outputs = { self, nixpkgs }: let pkgName = \"matejasblog\"; supportedSystems = [ \"x86_64-linux\" \"x86_64-darwin\" \"aarch64-linux\" \"aarch64-darwin\" ]; forAllSystems = nixpkgs.lib.genAttrs supportedSystems; nixpkgsFor = forAllSystems (system: import nixpkgs { inherit system; }); in { packages = forAllSystems (system: let pkgs = nixpkgsFor.${system}; in { ${pkgName} = pkgs.stdenv.mkDerivation { name = pkgName; src = ./.; buildInputs = [ pkgs.hugo ]; buildPhase = '' hugo ''; installPhase = '' mkdir -p $out/var/www cp -r public $out/var/www/matejamaric.com ''; }; } ); devShells = forAllSystems (system: let pkgs = nixpkgsFor.${system}; in { default = pkgs.mkShell { buildInputs = with pkgs; [ git rsync hugo ]; }; } ); defaultPackage = forAllSystems (system: self.packages.${system}.${pkgName}); }; } With it, I can use and when working on my blog.\n\nIn other word, I thought was going to be linked to the same path in my derivation output, which is not the case. How can I achieve this? Your derivation is under , where would translate into some path; it will never be under any root path. In general, that‚Äôs not something you‚Äôd want to do. Instead, you may look into making your blog a service via or a standalone server where any dependency can find where the actual is in your nix store."
    },
    {
        "link": "https://nixos.wiki/wiki/Flakes",
        "document": ""
    },
    {
        "link": "https://dev.to/arnu515/getting-started-with-nix-and-nix-flakes-mml",
        "document": "Let's get started with Nix! This article guides you into setting up the Nix package manager, along with flakes, and demonstrates some cool things it can do.\n\nFor a quick intro to what Nix is, check out this article I posted, which introduces Nix, and this series of articles to you. This article demonstrates an overview of the Nix package manager, more Nix concepts will be covered in future articles of this series.\n\nThe Nix package manager can be installed on both Linux and Mac, and is also available as a Docker image for you to try out without installing it on bare metal. Windows users will have to use WSL2 to install Nix on their systems (if they're not using Docker).\n\nThe Nix website's download page guides you into using their installer to install Nix on your system. However, this article will use [Determinate Systems' Nix installer] instead, since it lets you easily undo all changes their Nix installer makes (i.e. uninstall) with one command, and it also enables Nix flakes by default, which you'd have to enable on your own if you were using the official Nix installer instead.\n\nTheir guide, Zero-to-Nix has detailed installation instructions using the Determinate installer, but in essence, it just boils down to running:\n\n\n\nin a terminal and following the prompts the installer asks. You can check Zero-to-Nix's page for more instructions, or the Determinate installer's README for detailed options. This method will work both on Linux and Mac.\n\nObligatory disclaimer: Nix flakes, and nix experimental commands (like and , which will be covered later) are experimental and may have breaking changes anytime in the future, hence, they are gated by a config option when using the default installer. But these two features have stayed experimental for many years with little-to-no breaking changes, and are thus considered de facto stable by much of the Nix community, and not using them is just giving yourself a handicap for no reason.\n\nUsing the official installer?\n\nIf you've opted to use the official Nix installer instead, you'll have to manually enable flakes for your user by editing , or for all users by editing and adding the following line to the end of the file:\n\n\n\nIf you're using a systemd-less distro, like Artix or Void, you can install Nix from their repositories, since it will come preconfigured with whatever init system you'd be using on those distros. The Determinate installer only works on distros with systemd (for a multi-user installation, which is what you want).\n\nIf you wish, you can install Nix from your distro's repositories too, instead of using the Determinate installer. I've done this on Alpine, Artix, and Arch. Just make sure the Nix package is not extremely out of date, like in Void's case. You can check if the package is out of date by comparing the version in your repos to the version on NixOS's repos\n\nNow that you have the Nix package manager installed, you can use it to install any package from the vast library of 120k+ Nix packages on your system, while ensuring that none of your other packages, even those installed by Nix itself, will break due to dependency conflicts.\n\nLet's install the lolcat package. Well, Nix actually allows us to try out the package without installing it first! It downloads the package (or compiles it if the binary isn't availabe in the build cache) and drops you into a shell session containing the requested package in your .\n\nLet's try it out! Run and Nix will download the latest commit of nixpkgs, a collection of lots of Nix packages, find the package, get its binary from NixOS's binary cache, download it and put it in your .\n\nNix will create you a new shell session where will be available.\n\n‚ú®ü™Ñ Magic! Open a new terminal window, try running , and see that the command doesn't exist! Let's see what Nix added to our to make available:\n\n\n\nNix downloaded and placed it in a folder in the Nix store ( by default). The Nix store contains all packages, even multiple versions of the same package that were ever fetched by Nix. My system, about a month old, has close to 34k items in the store! Some of these are packages, some are built derivations (more on those later!). This can be cleaned using the command.\n\nWe'll learn more about the nix store in further articles, but for a quick rundown, the Nix store is a read-only filesystem which stores things like downloaded and built packages, any packages you create yourself, and anything else included in a nix package like downloaded or locally available source code. All packages are treated as a pure function, and their built output is stored in the store.\n\nNotice the name of the directory where was downloaded. It contains the hash of the derivation, ensuring integrity of the package, then the name of the package itself, and finally, the version, which in this case is . When you're trying out these commands for yourself, you may have a different hash and/or version of the package.\n\nis specified to the command as . This is termed as an installable, and in this case, is a flake reference (more about that later). is actually a URL with path , and fragment, i.e. the part after the , . is an alias which resolves to the branch of the Nixpkgs GitHub repository, a vast collection of Nix packages. There are other stable branches of nixpkgs, like , the latest one as of writing. There are quite a few other aliases too, Nix downloads the list from this JSON file. If you omit the URL host, it defaults to the current directory ( ).\n\nFrom the JSON file, the alias for appears to be:\n\n\n\nThe object at is one type of flake reference. It can also be written in a URL form like so: . We'll take a look at various types of flake references later.\n\nThe fragment of the URL, , refers to one of the packages exported by the flake. Omitting it defaults to the package, i.e., literally a package called . We'll talk more about flakes later.\n\nHaving in a local shell isn't really useful. Let's install using Nix so that it can be accessed from any shell (that has the Nix profile in !).\n\nA nix profile is a set of packages that are installed independently from each other. Nix profiles are versioned, so you can roll back to a previous state of your profile at any time!\n\nTo install into your profile, you can run:\n\n\n\nNow will be available in any shell! To remove it, run:\n\n\n\nwill no longer be available in path, but it will still remain in the Nix store. If you wish to use again, maybe in a temporary shell, it will not have to be downloaded/built again, since it'll already be available in the Nix store.\n\nFinally, let's demonstrate profile versioning. Run to see the versions of your profile:\n\n\n\nDon't worry about for now, that'll be covered later. Just notice that the first history version installed , and the second history version removed it. Let's roll back to the first version with:\n\n\n\nAnd is back! If we make a change while we're in this version, Nix'll create a new version for us, without deleting version , so you can roll back to any point! For now, let's stick to the same slate, and go back to version . I'd leave it as an exercise for you to do the same.\n\nThis article will not teach you the Nix language, since there are much better places to learn that from, such as:\n\nIt is highly recommended to learn this language before proceeding to the next section. If you know the language, you'll not be troubled with the syntax when you make your own flakes.\n\nNix Flakes are an opinionated way to structure a nix expression made up of packages, OS configurations, development shells, modules, images, overlays, etc. If you've read the series introduction, you'll know that every file is just a Nix expression.\n\nBefore flakes were a thing, you'd have to create separate nix files for development shells ( ), packages ( ), OS configurations ( ), etc., which may get annoying, but is just a small hindrance. The real advantage of flakes is flake inputs, which let you easily fetch nix packages from anywhere using many methods (\"fetchers\"), and the experimental commands, which are built to work with flakes.\n\nWhen you create a file in a directory, that directory becomes a flake, so it can be used as a path in the URL passed to commands. Open an empty directory on your computer, and create a blank file called in it. That directory has now become a flake!\n\nWe can run the simplest command to verify that, evaluates a Nix expression and prints it to stdout. Without any arguments, it evaluates the default package exported by the flake. Notice the emphasis on evaluates, not runs or installs, i.e. the command just prints the package derivation out to the screen. Some things are lazily evaluated, meaning they aren't evaluated until they're required. A package in a flake is not evaluated when you're just using the flake's development shell. It is only evaluated when you use the package, i.e. when you install it, or use it in another flake.\n\nRunning on an empty however, will give you a syntax error, well obviously, since an empty file is not a valid nix expression. A flake is an attrset which has a few fields as described here, notably , a set of other flakes your flake uses, and , a function returning a set of things your flake exposes (which can be used by other flakes!). The declared flakes in will be fetched by Nix, evaluated (lazily), and passed to the function, along with a special parameter , which is just a reference to the set returned by , so you can reference your own flake in itself. The power of lazy evaluation!\n\nLet's start with a simple flake. Create in an empty directory on the machine you installed Nix in, and write the following code:\n\n\n\nThis is how a nix flake looks like. It looks quite a lot like JSON, but with semicolons instead of commas, but don't be fooled, Nix is a proper functional language with programming constructs and everything! The attribute set (attrset) declares a set of flakes your flake depends on. In this case, this flake depends on the flake, a collection of 120k+ nix packages. The flake's source code is hosted on GitHub at nixos/nixpkgs, which is what is specified in the flake input. The part after the last is the branch of the repository. Nixpkgs releases a stable branch every six months, in May ( ), and November ( , which is what we're using) every year. You can use if you want the latest packages instead.\n\nThe function shows one such construct. Nix attrsets can be condensed with dots, so is actually , similarly with .\n\nThe function syntax of Nix is: . Nix functions can take in only one parameter, so multiple parameter functions are actually multiple functions with one parameter each, like so: . Nix has support for attrset destructuring, so means that the parameter to is actually an attrset, and we extract the property , which matches the input property from it. The means to ignore any extra properties passed. If it isn't specified, nix will error if properties other than are passed! We know that is another property passed to output, hence is needed.\n\nFinally, in the outputs, we define a single package named for 64-bit linux systems (which is what I have), which is just set to the package declared by for 64-bit linux systems. Note that the in doesn't actually mean that these packages are legacy (see this for an explanation [TLDR; makes the command not evaluate the package, apart from that, they're functionally identical]). You should change and to your own system's architecture and OS, if they differ from these.\n\nNow running tells us that there's no default package, which is true, since we created a package named , not one named . We could rename to , or we could also ask to evaluate the program, since it takes an as an argument:\n\n\n\nWe get a derivation! Nix saw that our flake exports the package or legacyPackage, saw that it is supposed to fetch the package from the flakes, fetches that flake if reqiured, and returns the derivation to us.\n\nWe can also build and run this package:\n\n\n\nThe executable is actually GNU hello, that in true GNU fashion is an overly complicated program with a seventeen page manual that prints something to the screen, defaulting to . Nix would build this program using its derivation from scratch, if it wasn't available in the build cache, which most packages usually are, so it downloads the program from there instead. The derivation and built (or downloaded) output is stored in the Nix store, as we saw earlier. The symlink also links to a folder in the store.\n\nThe folder is actually a symlink, which links to the built folder in the nix store:\n\n\n\nThis was a super quick introduction to the Nix package manager and nix flakes. Stay tuned for more articles in the series, the next one lined up is about development shells with flakes. You wouldn't want to miss this one!\n\nIf you really liked this article and would like to support me, here are some ways:\n\nThank you so much!"
    },
    {
        "link": "https://discourse.nixos.org/t/using-git-to-handle-and-manage-configuration-nix/38337",
        "document": "Git Push NixOS Machines. Contribute to nlewo/comin development by creating an account on GitHub."
    },
    {
        "link": "https://discourse.nixos.org/t/tips-tricks-for-nixos-desktop/28488",
        "document": "It‚Äôs often said that git is a poor VCS, but a good VCS Construction Kit. NixOS can feel similar at\n\n times ‚Äî is very powerful, and there are amazing things you can do if you know nuts&bolts of\n\n it. However, for a casual user, the sheer amount of possibilities can feel overwhelming, and it\n\n might be hard to see what‚Äôs most useful in the space of possible. Over the years, I‚Äôve accumulated a bunch of tricks I wish I knew earlier. I want to share them here,\n\n and learn some knew ones, please feel free to add yours!\n\nWhen starting with NixOS, I picked the stable channel, but soon realized that, for the applications I use daily, I‚Äôd rather have more up-to-date versions. So I created a complex setup where most things are from stable, and select apps are from unstable. Some years later, I realized that a better approach for me is to just use NixOS-unstable. Unstable is a misnomer ‚Äì it‚Äôs just a rolling, continuous release, which is gated by a test suite and is pretty stable in practice. What‚Äôs more, even if something break‚Äôs, its trivial to boot the previous generation. NixOS mitigates major drawbacks of a rolling release model, making it a reasonable\n\n boring default to use on a desktop. Speaking of rollbacks, is not the best way to do that. It rolls you back from a currently broken configuration, which requires you to boot the broken config and do some mental gimnastics to calculate how far to rollback. Instead, boot into the configuration you want to rollback to, and issue Use https://search.nixos.org/packages to look for packages I‚Äôve spent a lot of time looking for a good way to search for nix packages on the command line (eg, using utility). But it looks like using NixOS Search is a better default (would love a cli frontend for that though). Look for options before packages Many larger things, like or , have both a package and an option. Most of the time, you want the , as it enables additional integration with the system (eg, starts systemd daemon or what not). More generally, whatever you want to do with NixOS, start with looking for an , chances are the thing has first-class support in NixOS. NixOS has two ways to install the packages. Declaring a package in installs is ‚Äúglobally‚Äù, such that it is available to all users. Using / installs the package for the current user. Originally, I used to install most packages, and only gradually moved ‚Äúimportant‚Äù ones to . This seemed ‚Äúreasonable‚Äù, but just made the state of the system less reproducible. These days, I don‚Äôt use at all. If I need a one-off utility, I use to temporary get it. For anything which I need more than a couple of times, I add it\n\n to my system-wide configuration. As an aside, this reasoning makes me hesitant to try home manager. HM manages user-specific packages, but for my single-user install I don‚Äôt want to have user-specific packages in the first\n\n place. Use to run unmodified binaries on NixOS NixOS has a problem with running random binaries from the internet, because it doesn‚Äôt have expected things like dynamic linker in a usual place. One way to solve this is to use to modify the binaries. A different approach is to create a lightweight container around the binary, which sets up a ‚Äúusual‚Äù environment. NixOS has a tool for that, , but it might get tricky to use. Here‚Äôs how I set it up: environment.systemPackages = [ (let base = pkgs.appimageTools.defaultFhsEnvArgs; in pkgs.buildFHSUserEnv (base // { name = \"fhs\"; targetPkgs = pkgs: (base.targetPkgs pkgs) ++ [pkgs.pkg-config]; profile = \"export FHS=1\"; runScript = \"fish\"; extraOutputsToInstall = [\"dev\"]; })) ‚Ä¶ ] # Get random binary from the Internet $ wget 'https://code.visualstudio.com/sha/download?build=stable&os=linux-x64' -O code.tar.gz $ aunpack code.tar.gz && cd VSCode-linux-x64 # Running stuff directly fails $ ./bin/code ./bin/code: line 62: ./bin/../code: cannot execute: required file not found # Activating FHS drops me in a shell which looks like a \"normal\" Linux $ fhs (fhs) $ ls /usr/bin (fhs) $ ./bin/code Some details on the invocation.\n‚Ä¢ By default, it doesn‚Äôt include any packages.\n\n Building your own env with X and whatnot would be chore. So, I base my FHS on appimage one, using\n\n as a base\n‚Ä¢ would end up being the name of the binary I use to drop into env\n‚Ä¢ In , I add my own packages.\n‚Ä¢ is just for me to be able to add to the shell prompt.\n‚Ä¢ to run my shell, rather than .\n‚Ä¢ , like , I\n\n need to be able to compile stuff (dont‚Äô remeber details at this point).\n\nAs an aside, this reasoning makes me hesitant to try home manager. HM manages user-specific packages, but for my single-user install I don‚Äôt want to have user-specific packages in the first\n\n place. If it‚Äôs a single user system you don‚Äôt really care either way, the packages just need to be present for your user in some way.\n\n On multi-user system this would make more sense because with home-manager you would then have to apply the config to multiple users on the system.\n\n However an additional bonus to home-manager is a lot of options which aren‚Äôt part of nixpgks.\n\n In addition if you use home-manager it‚Äôs easier to share your configuration with a non-NixOS system.\n\n E.g. if your company uses another distro, etc. With this I don‚Äôt agree at all, especially for new users. If someone is comfortable with NixOS sure then go ahead but at that point they should know how to fix problems.\n\n The nice thing about NixOS is that you easily can install packages from unstable if you need them.\n\n Once you setup the unstable-overlay it‚Äôs not really that complicated to install a package with . An important thing to keep in mind here is that switching back to an earlier generation doesn‚Äôt rollback the state. So if you have an application that uses a database to store its data and the schema changes between updates your data might be unusable in the previous generation.\n\n Happened to me with Telegram and Signal for example.\n\n Therefore it‚Äôs still very important to have backups of your data matching to your generations. Use to run unmodified binaries on NixOS Good advice, as a quick and dirty solution for people with plenty of disk space might still be the easier option.\n\nIn your NixOS configuration, it is possible to apply an unmerged pull request. The way this works is that in there‚Äôs a function to apply a to its own source code and return a fresh copy of . So, if you run an upgrade, and then see that something‚Äôs broken, in addition to reverting to an earlier version what you can do is to check if there‚Äôs a pull request already fixing the issue, and then ‚Äúcherry-pick‚Äù it. This is how I do it in my flake-based config: # My flake.nix { inputs = { nixpkgs.url = \"github:NixOS/nixpkgs/nixos-unstable\"; }; # Use `inputs@` to be able to \"shadow\" nixpkgs input. outputs = inputs@{ self }: # The list of patches. I don't know the proper way to know the hash for the diff, so, # when adding a new patch I add a dummy value and read the error message. let patches = [ { url = \"https://patch-diff.githubusercontent.com/raw/NixOS/nixpkgs/pull/292148.diff\"; sha256 = \"sha256-gaH4UxKi2s7auoaTmbBwo0t4HuT7MwBuNvC/z2vvugE=\"; } ]; # First we get the pristine nixpkgs, to get at its `applyPatches` nix function from `pkgs`. originPkgs = inputs.nixpkgs.legacyPackages.\"x86_64-linux\"; # Then, we get our patched nixpkgs by calling that function with the list of our patches. nixpkgs = originPkgs.applyPatches { name = \"nixpkgs-patched\"; src = inputs.nixpkgs; patches = map originPkgs.fetchpatch patches; }; # Finally we get patched `nixosSystem` nixosSystem = import (nixpkgs + \"/nixos/lib/eval-config.nix\"); # If you want to quick disable patches, uncomment: # nixosSystem = inputs.nixpkgs.lib.nixosSystem; in { nixosConfigurations = { Ishmael = nixosSystem { system = \"x86_64-linux\"; modules =[ ./hosts/Ishmael.nix ]; }; }; }; } As a bonus, when the PR is merged and gets to , the patch will to apply, so you‚Äôll notice when it you can remove it!"
    },
    {
        "link": "https://reddit.com/r/NixOS/comments/1gpyj37/nixos_best_practices",
        "document": "when is it best to install packages as flakes vs env packages and whether install via home manager vs the etc config what is the best way to go?"
    },
    {
        "link": "https://reddit.com/r/NixOS/comments/ywpcof/the_perfect_way_to_handle_projectspecific",
        "document": "I am trying to find the optimal way to have the development config (editor, editor plugins, etc.) for a given project be pinned to the project. Hopefully this post will start a discussion.\n\nWhat I am trying to achieve is the following: Suppose I work on a project now, and then abandon it for 5 years. Then, if I want to work on it again, it should be as easy as running nix-shell, and I get back the exact same setup including editor configuration that I had the last time I worked on it.\n\nOne colleague of mine (non NixOS user) actually leaves the physical laptop he used untouched in a box when he stops working on a project, in case he needs to revisit it after a long time. I want the same guarantee with Nix, without having to use a different laptop for every project.\n\nHere are some requirements for the solution:\n‚Ä¢ When revisiting a project, the developer config should by default be identical to the configuration the last time I worked on the project.\n‚Ä¢ There should be an easy way to integrate changes to the developer config across several projects, but in order to avoid violating the first requirement, the propagation must be done manually for each project (i.e. after the changes have been tested for the project).\n‚Ä¢ The solution should allow several developers to work on the same project, while allowing each developer to have their own personal developer config.\n\nHere are some alternatives:\n\n1) Have the developer config in the global configuration.nix\n\nThis is perhaps the most common workflow, and satisfies requirement 2 and 3, but not 1.\n\n2) Have the developer config in the shell.nix for each project\n\nThis solution satisfies requirement 1, but not 2 and 3.\n\n3) Have one dedicated git-repository for my developer config. Each project's shell.nix has a dependency on a pinned version of this repo.\n\nThis solution satisfies requirement 1 and 2, but not 3. This can be a viable solution for the project where I am the only developer. If some projects need incompatible configs, I would need to fork the config-repo. To minimize the risk of forking, I could split the config into smaller domain-specific configs that each project can pick and choose from (one for Haskell projects, one for Python/Jupyter projects etc.).\n\n4) Have one dedicated git-repository for my developer config, and have a super-repo for each project, with both the project repo and developer config repo as sub-repos.\n\nThis is a modification of solution 3 that satisfies all three requirements.\n\nI am currently thinking about implementing solution 3 for my own projects. If I decide to include other developers later, I can trivially convert solution 3 to solution 4 by removing the dependency on the config-repo from the project-repo and creating a super-repo.\n\nI would love to see thoughts, experiences, links to relevant blog posts/git-repos etc. I am particularly interested in how to modularise the config-repo (how to modularise, how to combine them for a project, overlays?), and how (and if) flakes fit in the picture."
    },
    {
        "link": "https://dev.to/raymondgh/day-5-syncing-nix-config-across-laptop-and-desktop-1i41",
        "document": "In my last post, I finally got NixOS dualbooting successfully on my Macbook Pro alongside macOS. In this post, I'll set up my desktop to dualboot NixOS and Windows 10. I'll also configure a github repository to track and sync my NixOS configuration for both of my devices.\n\nMy desktop PC is an aging mini-itx gaming machine with parts matching this pcpartpicker list. Needless to say, the config will be slightly different for this pc than my macbook pro. Let's see how the magic of Nix makes it easy to manage both with the same code.\n\nI imagine the organization of my nix config will continue to evolve over time, but since it's all code and I'll be using version control, I feel pretty happy to experiment. The structure I'll be implementing today is pictured below and the actual configuration can be seen in the v0.2.0 tag on my github repo.\n\n\n\nI use the Github desktop client. I admit it. I like it. I love it. I hate command line git. Sourcetree confuses me. I will grow one day. But today, I'm getting stuff done, not fighting for street cred.\n\nI boot into the my Plasma NixOS environment that I set up for my Macbook Pro (as detailed in the previous post) and log in with my user account. I open from the start-like menu and run\n\n\n\nI scroll toward the bottom and add two system packages, so that my systemPackages config looks like this:\n\n\n\nThere's some explanation of how this works in my Day 2 Post and it's kind of easy to understand, so I won't go into details in this post. With that, I do a quick and boom I've got VSCode with Nix syntax highlighting as well as Github desktop installed. I'm ready to do this.\n\nOne does not simply initialize a git repo in . This is a protected area, where changes require root access. From what I can see there are a couple popular options for handling this:\n‚Ä¢ Use sudo commands & git cli to manage repo in\n‚Ä¢ Configure nix to load config from another location\n‚Ä¢ Putting symlink(s) in that point to another location\n\nThese are probably the best ways to do it right now. I also explored using multiple branches and worktrees but that got cumbersome fast. Ultimately, I just want something easy. To do that, I'll use one symlink and a repo in my home directory.\n\nFirst, what is a symlink? A symlink is a symbolic link and differs from a hard link. Simply stated, a hard link is a reference to data and a symbolic link is a reference to a reference. It can get pretty technical if you look much deeper than that. But essentially, if I replace the file with a symlink of the same name which targets the config file in my home directory repo, Nix will follow that path and evaluate the config files in my repo instead of .\n\nFirst, I cloned my existing repository to using Github desktop. Then I moved my current working files into that repo.\n\n\n\nNext, I deleted everything in \n\n\n\nThat created a new result file (actually another symlink!) which I added to my gitignore.\n\nSince I'm not collaborating with anyone and I hope to be careful about my changes, I'll be working directly out of the main branch w/o pull requests. This is a little iffy because it means it's very easy to make quick changes to my device's active config. Ideally I could have the ease of Github desktop's git action UX and diff highlighting as well as some kind of confirmation for when I update the config that's actually in use by the computer. Perhaps someone can comment with advice! In any case, it's time to move on.\n\nMy current config is essentially the NixOS default. The contents for my laptop are pinned in a release here.:\n\n\n\nTo adapt to the new structure, I'll create a file which is accessed by each device as well as a dedicated directory for and for each device. For each device, 1 symlink will be created pointing to . I'll try to keep as much config in the common file as possible.\n\nFirst, I'm creating the new file structure and leaving the common file empty. Nothing changing besides locations. That means removing the symlink I just built and creating a new one with\n\n\n\nOnce I get that working, I create the common file as an \"empty\" config:\n\n\n\nNext I update my imports in \n\n\n\nThe reference to the common file goes up to the root of my git repo and the reference to the hardware config looks in the same host directory. Lastly, the third part pulls in some firmware stuff we need for the macbook.\n\nNow I'm going through the rest of the config file and moving anything that I think should be in the common config file. I end up with just 4 \"uncommon\" things:\n\nNext, I'm going to duplicate this file and add it to a new directory for my desktop computer. Normally I'd do this with the GUI, but here's the CLI command:\n\n\n\nMaybe I'm learning linux after all. Anyway, I open that new file in VSCode and remove the firmware import, the wifi firmware, and the touchpad entry. I change the hostname and my file looks like this:\n\n\n\nNow I think I'm ready to install on the PC!\n\nNow there's no reason to make this difficult. I downloaded the GNOME 64-bit graphical installer from the Nix site, flashed an 8GB drive with Balena Etcher I downloaded onto my Windows 10 system and spammed F12 when booting back up.\n\nI clicked 3 times, entered a name and password, clicked next 2 more times, checked , clicked next, chose my 12 year old SSD, selected with Swap (with Hibernate), clicked next, clicked install, waited a bit, checked a box to reboot, and hit done.\n\nBooting up, I smashed F12 again and chose \"Linux Boot Manager (P2: OCZ Agility3) and there I was, staring down the login screen with my name on it.\n\nNow I need to do a few things to get in sync with my laptop environment.\n‚Ä¢ Move my hardware-configuration.nix into it\n‚Ä¢ Replace my configuration.nix with a symlink to the repo file\n\nTo do that, I'll temporarily install git with\n\n\n\nand I'll clone the repo into place:\n\n\n\nMoving the hardware config into the repo:\n\n\n\nAnd then replacing it with the symlink:\n\n\n\nOne last thing to do that I learned the hard way -- grant my user ownership of the directory I cloned with root\n\n\n\nAnd we should be good to rebuild!\n\n\n\nand with that done, I ran:\n\n\n\nNow that our desktop has everything in place, it's time to give back. Opening Github desktop, I choose \"add local repository\" and select my directory. It's instantly set up and all I need to do is commit and push to origin.\n\nAnd with that, I've got two machines running nearly identical operating systems with a single codebase under version control managing their features.\n\nWhenever I install something, I'll ask myself \"Is this for both of my machines, or just one?\" and put that new or changed nix expression in either the common-configuration.nix file or the HOSTNAME/configuration.nix file accordingly. Then when I log on to the other machine, I'll pull the latest from the repo, do a and enjoy being totally in sync. Pretty snazzy!\n\nNow I've really got my foundation landed. I should try to get something productive done. My next updates might be more quality of life (like getting sound to work on the laptop or making my desktop nicer) or functional (getting a software dev environment set up). At least from what I've read, once I get around to nix flakes or home manager, I'll have more challenges to figure out. As always, thanks for reading and let me know what you think!"
    }
]