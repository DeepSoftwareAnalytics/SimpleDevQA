[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.security.cryptography.aes?view=net-9.0",
        "document": "The following example demonstrates how to encrypt and decrypt sample data by using the Aes class."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.security.cryptography.aescryptoserviceprovider?view=net-9.0",
        "document": "The following example demonstrates how to encrypt and decrypt sample data using the AesCryptoServiceProvider class."
    },
    {
        "link": "https://medium.com/@adarsh-d/aes-encryption-and-decryption-using-cbc-mode-in-c-4403d7fb6bfc",
        "document": "Here is an example of an AES encryption and decryption function using .NET Core C#:\n\nusing System;\n\nusing System.Security.Cryptography;\n\nusing System.Text;\n\nusing System.IO;\n\n\n\npublic class Program\n\n{\n\n public static void Main()\n\n {\n\n string secret = \"\"; //encryption secret\n\n byte[] key = Encoding.UTF8.GetBytes(secret);\n\n byte[] iv = new byte[16]; // 16-byte initialization vector\n\n new Random().NextBytes(iv); // randomize the IV\n\n\n\n string plainText = \"\"; //Text to encode\n\n byte[] plainBytes = Encoding.UTF8.GetBytes(plainText);\n\n\n\n byte[] cipherBytes = Encrypt(plainBytes, key, iv);\n\n string cipherText = Convert.ToBase64String(cipherBytes);\n\n Console.WriteLine(\"Cipher Text: \" +cipherText);\n\n Console.WriteLine(\"Key: \" + Convert.ToBase64String(key));\n\n Console.WriteLine(\"IV: \" + Convert.ToBase64String(iv));\n\n\n\n byte[] decryptedBytes = Decrypt(cipherBytes, key, iv);\n\n string decryptedText = Encoding.UTF8.GetString(decryptedBytes);\n\n Console.WriteLine(\"Decrypted Text: \" + decryptedText);\n\n\n\n Console.ReadLine();\n\n }\n\n\n\n static byte[] Encrypt(byte[] plainBytes, byte[] key, byte[] iv)\n\n {\n\n byte[] encryptedBytes = null;\n\n\n\n // Set up the encryption objects\n\n using (Aes aes = Aes.Create())\n\n {\n\n aes.Key = key;\n\n aes.IV = iv;\n\n aes.Mode = CipherMode.CBC;\n\n aes.Padding = PaddingMode.PKCS7;\n\n\n\n // Encrypt the input plaintext using the AES algorithm\n\n using (ICryptoTransform encryptor = aes.CreateEncryptor())\n\n {\n\n encryptedBytes = encryptor.TransformFinalBlock(plainBytes, 0, plainBytes.Length);\n\n }\n\n }\n\n\n\n return encryptedBytes;\n\n }\n\n\n\n static byte[] Decrypt(byte[] cipherBytes, byte[] key, byte[] iv)\n\n {\n\n byte[] decryptedBytes = null;\n\n\n\n // Set up the encryption objects\n\n using (Aes aes = Aes.Create())\n\n {\n\n aes.Key = key;\n\n aes.IV = iv;\n\n aes.Mode = CipherMode.CBC;\n\n aes.Padding = PaddingMode.PKCS7;\n\n\n\n // Decrypt the input ciphertext using the AES algorithm\n\n using (ICryptoTransform decryptor = aes.CreateDecryptor())\n\n {\n\n decryptedBytes = decryptor.TransformFinalBlock(cipherBytes, 0, cipherBytes.Length);\n\n }\n\n }\n\n\n\n return decryptedBytes;\n\n }\n\n}\n\nIn the next part, I’ll demonstrate how to consume the encrypted string and decrypt the cipher in JS using CryptoJS"
    },
    {
        "link": "https://stackoverflow.com/questions/273452/using-aes-encryption-in-c-sharp",
        "document": "Does anyone have some sample code?\n\nI can't seem to find a nice clean example of using AES 128 bit encryption.\n\n. This question and its answers are locked because the question is off-topic but has historical significance. It is not currently accepting new answers or interactions.\n\nIf you just want to use the built-in crypto provider RijndaelManaged, check out the following help article (it also has a simple code sample): And just in case you need the sample in a hurry, here it is in all its plagiarized glory: using System; using System.IO; using System.Security.Cryptography; namespace RijndaelManaged_Example { class RijndaelExample { public static void Main() { try { string original = \"Here is some data to encrypt!\"; // Create a new instance of the RijndaelManaged // class. This generates a new key and initialization // vector (IV). using (RijndaelManaged myRijndael = new RijndaelManaged()) { myRijndael.GenerateKey(); myRijndael.GenerateIV(); // Encrypt the string to an array of bytes. byte[] encrypted = EncryptStringToBytes(original, myRijndael.Key, myRijndael.IV); // Decrypt the bytes to a string. string roundtrip = DecryptStringFromBytes(encrypted, myRijndael.Key, myRijndael.IV); //Display the original data and the decrypted data. Console.WriteLine(\"Original: {0}\", original); Console.WriteLine(\"Round Trip: {0}\", roundtrip); } } catch (Exception e) { Console.WriteLine(\"Error: {0}\", e.Message); } } static byte[] EncryptStringToBytes(string plainText, byte[] Key, byte[] IV) { // Check arguments. if (plainText == null || plainText.Length <= 0) throw new ArgumentNullException(\"plainText\"); if (Key == null || Key.Length <= 0) throw new ArgumentNullException(\"Key\"); if (IV == null || IV.Length <= 0) throw new ArgumentNullException(\"IV\"); byte[] encrypted; // Create an RijndaelManaged object // with the specified key and IV. using (RijndaelManaged rijAlg = new RijndaelManaged()) { rijAlg.Key = Key; rijAlg.IV = IV; // Create a decryptor to perform the stream transform. ICryptoTransform encryptor = rijAlg.CreateEncryptor(rijAlg.Key, rijAlg.IV); // Create the streams used for encryption. using (MemoryStream msEncrypt = new MemoryStream()) { using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write)) { using (StreamWriter swEncrypt = new StreamWriter(csEncrypt)) { //Write all data to the stream. swEncrypt.Write(plainText); } encrypted = msEncrypt.ToArray(); } } } // Return the encrypted bytes from the memory stream. return encrypted; } static string DecryptStringFromBytes(byte[] cipherText, byte[] Key, byte[] IV) { // Check arguments. if (cipherText == null || cipherText.Length <= 0) throw new ArgumentNullException(\"cipherText\"); if (Key == null || Key.Length <= 0) throw new ArgumentNullException(\"Key\"); if (IV == null || IV.Length <= 0) throw new ArgumentNullException(\"IV\"); // Declare the string used to hold // the decrypted text. string plaintext = null; // Create an RijndaelManaged object // with the specified key and IV. using (RijndaelManaged rijAlg = new RijndaelManaged()) { rijAlg.Key = Key; rijAlg.IV = IV; // Create a decrytor to perform the stream transform. ICryptoTransform decryptor = rijAlg.CreateDecryptor(rijAlg.Key, rijAlg.IV); // Create the streams used for decryption. using (MemoryStream msDecrypt = new MemoryStream(cipherText)) { using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read)) { using (StreamReader srDecrypt = new StreamReader(csDecrypt)) { // Read the decrypted bytes from the decrypting stream // and place them in a string. plaintext = srDecrypt.ReadToEnd(); } } } } return plaintext; } } }\n\nI've recently had to bump up against this again in my own project - and wanted to share the somewhat simpler code that I've been using, as this question and series of answers kept coming up in my searches. I'm not going to get into the security concerns around how often to update things like your Salt and Initialization Vector - that's a topic for a security forum, and there are some great resources out there to look at. This is simply a block of code to implement in C#. using System; using System.IO; using System.Security.Cryptography; using System.Text; namespace Your.Namespace.Security { public static class Cryptography { #region Settings private static int _iterations = 2; private static int _keySize = 256; private static string _hash = \"SHA1\"; private static string _salt = \"aselrias38490a32\"; // Random private static string _vector = \"8947az34awl34kjq\"; // Random #endregion public static string Encrypt(string value, string password) { return Encrypt<AesManaged>(value, password); } public static string Encrypt<T>(string value, string password) where T : SymmetricAlgorithm, new() { byte[] vectorBytes = GetBytes<ASCIIEncoding>(_vector); byte[] saltBytes = GetBytes<ASCIIEncoding>(_salt); byte[] valueBytes = GetBytes<UTF8Encoding>(value); byte[] encrypted; using (T cipher = new T()) { PasswordDeriveBytes _passwordBytes = new PasswordDeriveBytes(password, saltBytes, _hash, _iterations); byte[] keyBytes = _passwordBytes.GetBytes(_keySize / 8); cipher.Mode = CipherMode.CBC; using (ICryptoTransform encryptor = cipher.CreateEncryptor(keyBytes, vectorBytes)) { using (MemoryStream to = new MemoryStream()) { using (CryptoStream writer = new CryptoStream(to, encryptor, CryptoStreamMode.Write)) { writer.Write(valueBytes, 0, valueBytes.Length); writer.FlushFinalBlock(); encrypted = to.ToArray(); } } } cipher.Clear(); } return Convert.ToBase64String(encrypted); } public static string Decrypt(string value, string password) { return Decrypt<AesManaged>(value, password); } public static string Decrypt<T>(string value, string password) where T : SymmetricAlgorithm, new() { byte[] vectorBytes = GetBytes<ASCIIEncoding>(_vector); byte[] saltBytes = GetBytes<ASCIIEncoding>(_salt); byte[] valueBytes = Convert.FromBase64String(value); byte[] decrypted; int decryptedByteCount = 0; using (T cipher = new T()) { PasswordDeriveBytes _passwordBytes = new PasswordDeriveBytes(password, saltBytes, _hash, _iterations); byte[] keyBytes = _passwordBytes.GetBytes(_keySize / 8); cipher.Mode = CipherMode.CBC; try { using (ICryptoTransform decryptor = cipher.CreateDecryptor(keyBytes, vectorBytes)) { using (MemoryStream from = new MemoryStream(valueBytes)) { using (CryptoStream reader = new CryptoStream(from, decryptor, CryptoStreamMode.Read)) { decrypted = new byte[valueBytes.Length]; decryptedByteCount = reader.Read(decrypted, 0, decrypted.Length); } } } } catch (Exception ex) { return String.Empty; } cipher.Clear(); } return Encoding.UTF8.GetString(decrypted, 0, decryptedByteCount); } } } The code is very simple to use. It literally just requires the following: By default, the implementation uses AesManaged - but you could actually also insert any other . A list of the available inheritors for .NET 4.5 can be found at: As of the time of this post, the current list includes: To use with the code above, as an example, you would use: I hope this is helpful to someone out there.\n\nThe example on MSDN does not run normally (an error occurs) because there is no initial value of Initial Vector(iv) and Key. I add 2 line code and now work normally. using System.Windows.Forms; using System; using System.Text; using System.IO; using System.Security.Cryptography; namespace AES_TESTER { public partial class Form1 : Form { public Form1() { InitializeComponent(); } private void Form1_Load(object sender, EventArgs e) { try { string original = \"Here is some data to encrypt!\"; MessageBox.Show(\"Original: \" + original); // Create a new instance of the RijndaelManaged // class. This generates a new key and initialization // vector (IV). using (RijndaelManaged myRijndael = new RijndaelManaged()) { myRijndael.GenerateKey(); myRijndael.GenerateIV(); // Encrypt the string to an array of bytes. byte[] encrypted = EncryptStringToBytes(original, myRijndael.Key, myRijndael.IV); StringBuilder s = new StringBuilder(); foreach (byte item in encrypted) { s.Append(item.ToString(\"X2\") + \" \"); } MessageBox.Show(\"Encrypted: \" + s); // Decrypt the bytes to a string. string decrypted = DecryptStringFromBytes(encrypted, myRijndael.Key, myRijndael.IV); //Display the original data and the decrypted data. MessageBox.Show(\"Decrypted: \" + decrypted); } } catch (Exception ex) { MessageBox.Show(\"Error: {0}\", ex.Message); } } static byte[] EncryptStringToBytes(string plainText, byte[] Key, byte[] IV) { // Check arguments. if (plainText == null || plainText.Length <= 0) throw new ArgumentNullException(\"plainText\"); if (Key == null || Key.Length <= 0) throw new ArgumentNullException(\"Key\"); if (IV == null || IV.Length <= 0) throw new ArgumentNullException(\"Key\"); byte[] encrypted; // Create an RijndaelManaged object // with the specified key and IV. using (RijndaelManaged rijAlg = new RijndaelManaged()) { rijAlg.Key = Key; rijAlg.IV = IV; rijAlg.Mode = CipherMode.CBC; rijAlg.Padding = PaddingMode.Zeros; // Create a decrytor to perform the stream transform. ICryptoTransform encryptor = rijAlg.CreateEncryptor(rijAlg.Key, rijAlg.IV); // Create the streams used for encryption. using (MemoryStream msEncrypt = new MemoryStream()) { using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write)) { using (StreamWriter swEncrypt = new StreamWriter(csEncrypt)) { //Write all data to the stream. swEncrypt.Write(plainText); } encrypted = msEncrypt.ToArray(); } } } // Return the encrypted bytes from the memory stream. return encrypted; } static string DecryptStringFromBytes(byte[] cipherText, byte[] Key, byte[] IV) { // Check arguments. if (cipherText == null || cipherText.Length <= 0) throw new ArgumentNullException(\"cipherText\"); if (Key == null || Key.Length <= 0) throw new ArgumentNullException(\"Key\"); if (IV == null || IV.Length <= 0) throw new ArgumentNullException(\"Key\"); // Declare the string used to hold // the decrypted text. string plaintext = null; // Create an RijndaelManaged object // with the specified key and IV. using (RijndaelManaged rijAlg = new RijndaelManaged()) { rijAlg.Key = Key; rijAlg.IV = IV; rijAlg.Mode = CipherMode.CBC; rijAlg.Padding = PaddingMode.Zeros; // Create a decrytor to perform the stream transform. ICryptoTransform decryptor = rijAlg.CreateDecryptor(rijAlg.Key, rijAlg.IV); // Create the streams used for decryption. using (MemoryStream msDecrypt = new MemoryStream(cipherText)) { using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read)) { using (StreamReader srDecrypt = new StreamReader(csDecrypt)) { // Read the decrypted bytes from the decrypting stream // and place them in a string. plaintext = srDecrypt.ReadToEnd(); } } } } return plaintext; } } }\n\n//Code to encrypt Data : public byte[] encryptdata(byte[] bytearraytoencrypt, string key, string iv) { AesCryptoServiceProvider dataencrypt = new AesCryptoServiceProvider(); //Block size : Gets or sets the block size, in bits, of the cryptographic operation. dataencrypt.BlockSize = 128; //KeySize: Gets or sets the size, in bits, of the secret key dataencrypt.KeySize = 128; //Key: Gets or sets the symmetric key that is used for encryption and decryption. dataencrypt.Key = System.Text.Encoding.UTF8.GetBytes(key); //IV : Gets or sets the initialization vector (IV) for the symmetric algorithm dataencrypt.IV = System.Text.Encoding.UTF8.GetBytes(iv); //Padding: Gets or sets the padding mode used in the symmetric algorithm dataencrypt.Padding = PaddingMode.PKCS7; //Mode: Gets or sets the mode for operation of the symmetric algorithm dataencrypt.Mode = CipherMode.CBC; //Creates a symmetric AES encryptor object using the current key and initialization vector (IV). ICryptoTransform crypto1 = dataencrypt.CreateEncryptor(dataencrypt.Key, dataencrypt.IV); //TransformFinalBlock is a special function for transforming the last block or a partial block in the stream. //It returns a new array that contains the remaining transformed bytes. A new array is returned, because the amount of //information returned at the end might be larger than a single block when padding is added. byte[] encrypteddata = crypto1.TransformFinalBlock(bytearraytoencrypt, 0, bytearraytoencrypt.Length); crypto1.Dispose(); //return the encrypted data return encrypteddata; } //code to decrypt data private byte[] decryptdata(byte[] bytearraytodecrypt, string key, string iv) { AesCryptoServiceProvider keydecrypt = new AesCryptoServiceProvider(); keydecrypt.BlockSize = 128; keydecrypt.KeySize = 128; keydecrypt.Key = System.Text.Encoding.UTF8.GetBytes(key); keydecrypt.IV = System.Text.Encoding.UTF8.GetBytes(iv); keydecrypt.Padding = PaddingMode.PKCS7; keydecrypt.Mode = CipherMode.CBC; ICryptoTransform crypto1 = keydecrypt.CreateDecryptor(keydecrypt.Key, keydecrypt.IV); byte[] returnbytearray = crypto1.TransformFinalBlock(bytearraytodecrypt, 0, bytearraytodecrypt.Length); crypto1.Dispose(); return returnbytearray; }\n\nTry this code, maybe useful.\n\n 1.Create New C# Project and add follows code to Form1: using System; using System.Windows.Forms; using System.Security.Cryptography; namespace ExampleCrypto { public partial class Form1 : Form { public Form1() { InitializeComponent(); } private void Form1_Load(object sender, EventArgs e) { string strOriginalData = string.Empty; string strEncryptedData = string.Empty; string strDecryptedData = string.Empty; strOriginalData = \"this is original data 1234567890\"; // your original data in here MessageBox.Show(\"ORIGINAL DATA:\\r\n\n\" + strOriginalData); clsCrypto aes = new clsCrypto(); aes.IV = \"this is your IV\"; // your IV aes.KEY = \"this is your KEY\"; // your KEY strEncryptedData = aes.Encrypt(strOriginalData, CipherMode.CBC); // your cipher mode MessageBox.Show(\"ENCRYPTED DATA:\\r\n\n\" + strEncryptedData); strDecryptedData = aes.Decrypt(strEncryptedData, CipherMode.CBC); MessageBox.Show(\"DECRYPTED DATA:\\r\n\n\" + strDecryptedData); } } } 2.Create clsCrypto.cs and copy paste follows code in your class and run your code. I used MD5 to generated Initial Vector(IV) and KEY of AES. using System; using System.Security.Cryptography; using System.Text; using System.Windows.Forms; using System.IO; using System.Runtime.Remoting.Metadata.W3cXsd2001; namespace ExampleCrypto { public class clsCrypto { private string _KEY = string.Empty; protected internal string KEY { get { return _KEY; } set { if (!string.IsNullOrEmpty(value)) { _KEY = value; } } } private string _IV = string.Empty; protected internal string IV { get { return _IV; } set { if (!string.IsNullOrEmpty(value)) { _IV = value; } } } private string CalcMD5(string strInput) { string strOutput = string.Empty; if (!string.IsNullOrEmpty(strInput)) { try { StringBuilder strHex = new StringBuilder(); using (MD5 md5 = MD5.Create()) { byte[] bytArText = Encoding.Default.GetBytes(strInput); byte[] bytArHash = md5.ComputeHash(bytArText); for (int i = 0; i < bytArHash.Length; i++) { strHex.Append(bytArHash[i].ToString(\"X2\")); } strOutput = strHex.ToString(); } } catch (Exception ex) { MessageBox.Show(ex.Message); } } return strOutput; } private byte[] GetBytesFromHexString(string strInput) { byte[] bytArOutput = new byte[] { }; if ((!string.IsNullOrEmpty(strInput)) && strInput.Length % 2 == 0) { SoapHexBinary hexBinary = null; try { hexBinary = SoapHexBinary.Parse(strInput); } catch (Exception ex) { MessageBox.Show(ex.Message); } bytArOutput = hexBinary.Value; } return bytArOutput; } private byte[] GenerateIV() { byte[] bytArOutput = new byte[] { }; try { string strIV = CalcMD5(IV); bytArOutput = GetBytesFromHexString(strIV); } catch (Exception ex) { MessageBox.Show(ex.Message); } return bytArOutput; } private byte[] GenerateKey() { byte[] bytArOutput = new byte[] { }; try { string strKey = CalcMD5(KEY); bytArOutput = GetBytesFromHexString(strKey); } catch (Exception ex) { MessageBox.Show(ex.Message); } return bytArOutput; } protected internal string Encrypt(string strInput, CipherMode cipherMode) { string strOutput = string.Empty; if (!string.IsNullOrEmpty(strInput)) { try { byte[] bytePlainText = Encoding.Default.GetBytes(strInput); using (RijndaelManaged rijManaged = new RijndaelManaged()) { rijManaged.Mode = cipherMode; rijManaged.BlockSize = 128; rijManaged.KeySize = 128; rijManaged.IV = GenerateIV(); rijManaged.Key = GenerateKey(); rijManaged.Padding = PaddingMode.Zeros; ICryptoTransform icpoTransform = rijManaged.CreateEncryptor(rijManaged.Key, rijManaged.IV); using (MemoryStream memStream = new MemoryStream()) { using (CryptoStream cpoStream = new CryptoStream(memStream, icpoTransform, CryptoStreamMode.Write)) { cpoStream.Write(bytePlainText, 0, bytePlainText.Length); cpoStream.FlushFinalBlock(); } strOutput = Encoding.Default.GetString(memStream.ToArray()); } } } catch (Exception ex) { MessageBox.Show(ex.Message); } } return strOutput; } protected internal string Decrypt(string strInput, CipherMode cipherMode) { string strOutput = string.Empty; if (!string.IsNullOrEmpty(strInput)) { try { byte[] byteCipherText = Encoding.Default.GetBytes(strInput); byte[] byteBuffer = new byte[strInput.Length]; using (RijndaelManaged rijManaged = new RijndaelManaged()) { rijManaged.Mode = cipherMode; rijManaged.BlockSize = 128; rijManaged.KeySize = 128; rijManaged.IV = GenerateIV(); rijManaged.Key = GenerateKey(); rijManaged.Padding = PaddingMode.Zeros; ICryptoTransform icpoTransform = rijManaged.CreateDecryptor(rijManaged.Key, rijManaged.IV); using (MemoryStream memStream = new MemoryStream(byteCipherText)) { using (CryptoStream cpoStream = new CryptoStream(memStream, icpoTransform, CryptoStreamMode.Read)) { cpoStream.Read(byteBuffer, 0, byteBuffer.Length); } strOutput = Encoding.Default.GetString(byteBuffer); } } } catch (Exception ex) { MessageBox.Show(ex.Message); } } return strOutput; } } }\n\nhere is a neat and clean code to understand AES 256 algorithm implemented in C# call Encrypt function as public class Crypt { public string Encrypt(string passtext, string passPhrase, string saltV, string hashstring, int Iterations, string initVect, int keysize) { string functionReturnValue = null; // Convert strings into byte arrays. // Let us assume that strings only contain ASCII codes. // If strings include Unicode characters, use Unicode, UTF7, or UTF8 // encoding. byte[] initVectorBytes = null; initVectorBytes = Encoding.ASCII.GetBytes(initVect); byte[] saltValueBytes = null; saltValueBytes = Encoding.ASCII.GetBytes(saltV); // Convert our plaintext into a byte array. // Let us assume that plaintext contains UTF8-encoded characters. byte[] plainTextBytes = null; plainTextBytes = Encoding.UTF8.GetBytes(passtext); // First, we must create a password, from which the key will be derived. // This password will be generated from the specified passphrase and // salt value. The password will be created using the specified hash // algorithm. Password creation can be done in several iterations. PasswordDeriveBytes password = default(PasswordDeriveBytes); password = new PasswordDeriveBytes(passPhrase, saltValueBytes, hashstring, Iterations); // Use the password to generate pseudo-random bytes for the encryption // key. Specify the size of the key in bytes (instead of bits). byte[] keyBytes = null; keyBytes = password.GetBytes(keysize/8); // Create uninitialized Rijndael encryption object. RijndaelManaged symmetricKey = default(RijndaelManaged); symmetricKey = new RijndaelManaged(); // It is reasonable to set encryption mode to Cipher Block Chaining // (CBC). Use default options for other symmetric key parameters. symmetricKey.Mode = CipherMode.CBC; // Generate encryptor from the existing key bytes and initialization // vector. Key size will be defined based on the number of the key // bytes. ICryptoTransform encryptor = default(ICryptoTransform); encryptor = symmetricKey.CreateEncryptor(keyBytes, initVectorBytes); // Define memory stream which will be used to hold encrypted data. MemoryStream memoryStream = default(MemoryStream); memoryStream = new MemoryStream(); // Define cryptographic stream (always use Write mode for encryption). CryptoStream cryptoStream = default(CryptoStream); cryptoStream = new CryptoStream(memoryStream, encryptor, CryptoStreamMode.Write); // Start encrypting. cryptoStream.Write(plainTextBytes, 0, plainTextBytes.Length); // Finish encrypting. cryptoStream.FlushFinalBlock(); // Convert our encrypted data from a memory stream into a byte array. byte[] cipherTextBytes = null; cipherTextBytes = memoryStream.ToArray(); // Close both streams. memoryStream.Close(); cryptoStream.Close(); // Convert encrypted data into a base64-encoded string. string cipherText = null; cipherText = Convert.ToBase64String(cipherTextBytes); functionReturnValue = cipherText; return functionReturnValue; } public string Decrypt(string cipherText, string passPhrase, string saltValue, string hashAlgorithm, int passwordIterations, string initVector, int keySize) { string functionReturnValue = null; // Convert strings defining encryption key characteristics into byte // arrays. Let us assume that strings only contain ASCII codes. // If strings include Unicode characters, use Unicode, UTF7, or UTF8 // encoding. byte[] initVectorBytes = null; initVectorBytes = Encoding.ASCII.GetBytes(initVector); byte[] saltValueBytes = null; saltValueBytes = Encoding.ASCII.GetBytes(saltValue); // Convert our ciphertext into a byte array. byte[] cipherTextBytes = null; cipherTextBytes = Convert.FromBase64String(cipherText); // First, we must create a password, from which the key will be // derived. This password will be generated from the specified // passphrase and salt value. The password will be created using // the specified hash algorithm. Password creation can be done in // several iterations. PasswordDeriveBytes password = default(PasswordDeriveBytes); password = new PasswordDeriveBytes(passPhrase, saltValueBytes, hashAlgorithm, passwordIterations); // Use the password to generate pseudo-random bytes for the encryption // key. Specify the size of the key in bytes (instead of bits). byte[] keyBytes = null; keyBytes = password.GetBytes(keySize / 8); // Create uninitialized Rijndael encryption object. RijndaelManaged symmetricKey = default(RijndaelManaged); symmetricKey = new RijndaelManaged(); // It is reasonable to set encryption mode to Cipher Block Chaining // (CBC). Use default options for other symmetric key parameters. symmetricKey.Mode = CipherMode.CBC; // Generate decryptor from the existing key bytes and initialization // vector. Key size will be defined based on the number of the key // bytes. ICryptoTransform decryptor = default(ICryptoTransform); decryptor = symmetricKey.CreateDecryptor(keyBytes, initVectorBytes); // Define memory stream which will be used to hold encrypted data. MemoryStream memoryStream = default(MemoryStream); memoryStream = new MemoryStream(cipherTextBytes); // Define memory stream which will be used to hold encrypted data. CryptoStream cryptoStream = default(CryptoStream); cryptoStream = new CryptoStream(memoryStream, decryptor, CryptoStreamMode.Read); // Since at this point we don't know what the size of decrypted data // will be, allocate the buffer long enough to hold ciphertext; // plaintext is never longer than ciphertext. byte[] plainTextBytes = null; plainTextBytes = new byte[cipherTextBytes.Length + 1]; // Start decrypting. int decryptedByteCount = 0; decryptedByteCount = cryptoStream.Read(plainTextBytes, 0, plainTextBytes.Length); // Close both streams. memoryStream.Close(); cryptoStream.Close(); // Convert decrypted data into a string. // Let us assume that the original plaintext string was UTF8-encoded. string plainText = null; plainText = Encoding.UTF8.GetString(plainTextBytes, 0, decryptedByteCount); // Return decrypted string. functionReturnValue = plainText; return functionReturnValue; } }"
    },
    {
        "link": "https://stackoverflow.com/questions/7400884/c-sharp-example-of-aes256-encryption-using-system-security-cryptography-aes",
        "document": "I need to implement AES 256 encryption /decryption and I haven't been able to find an example that works correctly.\n\nMSDN suggests that I should use the AES class.\n\nThe Rijndael class is the predecessor of the Aes algorithm. You should use the Aes algorithm instead of Rijndael. For more information, see the entry The Differences Between Rijndael and AES in the .NET Security blog.\n\nCould anyone point me in the direction of a good example using the AES class for AES256?\n\nTo add a little more clarity:\n\nI have a cipher file that contains the shared key and a string of encrypted text. I need to decrypt the text and then validate it.\n\nAll the examples I've seen expect at least 2 parameters to perform the encryption/decryption.\n\nShould I be able to infer the Initialisation vector and the key from the text in the cipher file?\n\nThis is an example of the text held in my cipher file:"
    },
    {
        "link": "https://stackoverflow.com/questions/50904384/c-sharp-generate-unique-secure-random-strings-gradually",
        "document": "I want to generate unique and secure strings randomly and I want to do it over time. I want to choose the shortest possible length for my use (Big enough so that random tries fail with good chance). I Also want the process to be fast. Using the following code and testing it for uniqueness, duplicates occur sooner than I expected. I'm not sure if there is any problem.\n\nP.S.: Is it secure to use a pool for generated numbers?\n\nP.P.S: I prefer not to add '-' and '_' to the alphabet. Is it worth removing it?"
    },
    {
        "link": "https://stackoverflow.com/questions/4616685/how-to-generate-a-random-string-and-specify-the-length-you-want-or-better-gene",
        "document": "A library for generating random strings wouldn't be very useful. It would either be too simple, so that you often need to replace it anyway, or too complex in order to be able to cover any possible situation, that you replace it because it's to complicated to use.\n\nCreating random strings is quite easy by using the random geneator for numbers, given the exact details of your needs. It's just more efficient to write the code specifically for each situation.\n\nIf you want a unique string, there is two possibilities. You can either keep every random string that is created, so that you can check for uniqueness, or you can make it really long so that it's incredibly unlikely that there would be duplicates. A GUID does the latter (which explains why it's so long), so there is already an implementation for that."
    },
    {
        "link": "https://medium.com/@neer.s/generate-6-or-8-digit-alpha-numeric-code-using-best-performance-in-c-83f930d244e3",
        "document": "Generating a 6 or 8-digit alphanumeric code in C# involves creating a string consisting of random letters and numbers. Here is a C# example using best practices and focusing on performance:\n• Cache the character array to avoid creating it repeatedly.\n\nusing System;\n\nusing System.Security.Cryptography;\n\nusing System.Text;\n\n\n\npublic class AlphaNumericCodeGenerator\n\n{\n\n private static readonly char[] chars =\n\n \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\".ToCharArray();\n\n\n\n public static string GenerateCode(int length)\n\n {\n\n if (length != 6 && length != 8)\n\n {\n\n throw new ArgumentException(\"Code length must be either 6 or 8.\", nameof(length));\n\n }\n\n\n\n using (var rng = RandomNumberGenerator.Create())\n\n {\n\n var bytes = new byte[length];\n\n rng.GetBytes(bytes);\n\n\n\n var result = new StringBuilder(length);\n\n foreach (var byteValue in bytes)\n\n {\n\n result.Append(chars[byteValue % chars.Length]);\n\n }\n\n\n\n return result.ToString();\n\n }\n\n }\n\n\n\n public static void Main()\n\n {\n\n string code6 = GenerateCode(6);\n\n Console.WriteLine($\"6-digit code: {code6}\");\n\n\n\n string code8 = GenerateCode(8);\n\n Console.WriteLine($\"8-digit code: {code8}\");\n\n }\n\n}\n• Character Array: A cached array of characters (both upper and lower case letters and digits) to avoid creating it repeatedly.\n• Random Number Generator: is used for better randomness and security compared to .\n• Argument Validation: Ensures the length is either 6 or 8.\n• Random Bytes: Generates random bytes and maps each byte to a character in the array.\n• Modulo Operation: Maps each byte to a valid index in the array.\n\nThis code ensures the generated string is both secure and efficient."
    },
    {
        "link": "https://dev.to/moh_moh701/exploring-randomness-in-net-8-and-c-12-randomsharedshuffle-and-randomnumbergeneratorgetstring-1a42",
        "document": "In .NET 8 and C# 12, handling randomness has become more efficient and robust. The introduction of methods like Random.Shared.Shuffle and RandomNumberGenerator.GetString offers developers convenient and secure options for generating random data, whether it's shuffling an array or creating random strings. This article explores these methods with practical examples, highlighting their benefits. The full code sample is provided in the first comment.\n\nThe ability to shuffle an array efficiently can be crucial in many applications, such as gaming or data analysis. Previously, developers often had to implement their own shuffle algorithms. Now, simplifies this task significantly.\n\nThis code snippet demonstrates how to shuffle an array using . The is a thread-safe, shared instance of the class provided by .NET, suitable for most general purposes.\n\nGenerating cryptographically secure random strings is essential for creating secure passwords, tokens, and identifiers. allows developers to generate such strings from a specified character set.\n\nHere, is used to generate a 20-character random string from a specified set of characters. This method ensures the randomness is suitable for security-sensitive applications, which is crucial for avoiding vulnerabilities related to predictable random strings.\n\nWhen to Use These Features\n• : Ideal for shuffling arrays in scenarios requiring random order, such as in randomized trials or gaming.\n• : Best used when cryptographically secure random strings are needed, such as for passwords, authentication tokens, or other security-sensitive functions.\n\n.NET 8 and C# 12 introduce robust features like and that enhance the ease and security of working with random data. These improvements not only streamline the development process but also bolster the security and reliability of applications that depend on randomness.\n\nEmbrace these new capabilities in your .NET projects to simplify your code and enhance application security."
    },
    {
        "link": "https://security.stackexchange.com/questions/160767/are-outputs-of-this-random-string-generating-software-safe-to-use-as-strong-pass",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    }
]