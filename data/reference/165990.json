[
    {
        "link": "https://docs.python-telegram-bot.org",
        "document": "We have made you a wrapper you can‚Äôt refuse\n\nWe have a vibrant community of developers helping each other in our Telegram group. Join us!\n\nStay tuned for library updates and new releases on our Telegram Channel.\n\nYou can install or upgrade via To install a pre-release, use the flag in addition. You can also install from source, though this is usually not necessary. To enable you to verify that a release file that you downloaded was indeed provided by the team, we have taken the following measures. Starting with v21.4, all releases are signed via sigstore. The corresponding signature files are uploaded to the GitHub releases page. To verify the signature, please install the sigstore Python client and follow the instructions for verifying signatures from GitHub Actions. As input for the parameter, please use the value . Earlier releases are signed with a GPG key. The signatures are uploaded to both the GitHub releases page and the PyPI project and end with a suffix . Please find the public keys here. The keys are named in the format . In addition, the GitHub release page also contains the sha1 hashes of the release files in the files with the suffix . tries to use as few 3rd party dependencies as possible. However, for some features using a 3rd party library is more sane than implementing the functionality again. As these features are optional, the corresponding 3rd party dependencies are not installed by default. Instead, they are listed as optional dependencies. This allows to avoid unnecessary dependency conflicts for users who don‚Äôt need the optional features. The only required dependency is httpx ~= 0.27 for , the default networking backend. is most useful when used along with additional libraries. To minimize dependency conflicts, we try to be liberal in terms of version requirements on the (optional) dependencies. On the other hand, we have to ensure stability of , which is why we do apply version bounds. If you encounter dependency conflicts due to these bounds, feel free to reach out. PTB can be installed with optional dependencies:\n‚Ä¢ None installs the cryptography>=39.0.1 library. Use this, if you want to use Telegram Passport related functionality.\n‚Ä¢ None installs httpx[socks]. Use this, if you want to work behind a Socks5 server.\n‚Ä¢ None installs httpx[http2]. Use this, if you want to use HTTP/2.\n‚Ä¢ None installs aiolimiter~=1.1,<1.3. Use this, if you want to use .\n‚Ä¢ None installs the tornado~=6.4 library. Use this, if you want to use / .\n‚Ä¢ None installs the cachetools>=5.3.3,<5.6.0 library. Use this, if you want to use arbitrary callback_data.\n‚Ä¢ None installs the APScheduler>=3.10.4,<3.12.0 library. Use this, if you want to use the . To install multiple optional dependencies, separate them by commas, e.g. .\n‚Ä¢ None installs all optional dependencies that are related to , i.e. .\n\nOnce you have installed the library, you can begin working with it - so let‚Äôs get started! Our Wiki contains an Introduction to the API explaining how the pure Bot API can be accessed via . Moreover, the Tutorial: Your first Bot gives an introduction on how chatbots can be easily programmed with the help of the module.\n‚Ä¢ None The package documentation is the technical reference for . It contains descriptions of all available classes, modules, methods and arguments as well as the changelog.\n‚Ä¢ None The wiki is home to number of more elaborate introductions of the different features of and other useful resources that go beyond the technical documentation.\n‚Ä¢ None Our examples section contains several examples that showcase the different features of both the Bot API and . Even if it is not your approach for learning, please take a look at . It is the de facto base for most of the bots out there. The code for these examples is released to the public domain, so you can start by grabbing the code and building on top of it.\n‚Ä¢ None The official Telegram Bot API documentation is of course always worth a read. If the resources mentioned above don‚Äôt answer your questions or simply overwhelm you, there are several ways of getting help.\n‚Ä¢ None We have a vibrant community of developers helping each other in our Telegram group. Join us! Asking a question here is often the quickest way to get a pointer in the right direction.\n‚Ä¢ None You can even ask for help on Stack Overflow using the python-telegram-bot tag. Since v20.0, is built on top of Pythons module. Because is in general single-threaded, does currently not aim to be thread-safe. Noteworthy parts of API that are likely to cause issues (e.g. race conditions) when used in a multi-threaded setting include:\n‚Ä¢ None all classes in the module that allow to add/remove allowed users/chats at runtime\n\nOccasionally we are asked if we accept donations to support the development. While we appreciate the thought, maintaining PTB is our hobby, and we have almost no running costs for it. We therefore have nothing set up to accept donations. If you still want to donate, we kindly ask you to donate to another open source project/initiative of your choice instead.\n\nYou may copy, distribute and modify the software provided that modifications are described and licensed for free under LGPL-3. Derivative works (including modifications or anything statically linked to the library) can only be redistributed under LGPL-3, but applications that use the library don‚Äôt have to be."
    },
    {
        "link": "https://freecodecamp.org/news/how-to-create-a-telegram-bot-using-python",
        "document": "Automated chatbots are quite useful for stimulating interactions. We can create chatbots for Slack, Discord, and other platforms.\n\nIn this article, I'll teach you how to build a Telegram chatbot that will tell you your horoscope. So, let‚Äôs get started!\n\nHow to Get Your Bot Token\n\nTo set up a new bot, you will need to talk to BotFather. No, he‚Äôs not a person ‚Äì he‚Äôs also a bot, and he's the boss of all the Telegram bots.\n‚Ä¢ Start a conversation with BotFather by clicking on the Start button.\n‚Ä¢ Type , and follow the prompts to set up a new bot. The BotFather will give you a token that you will use to authenticate your bot and grant it access to the Telegram API.\n\nNote: Make sure you store the token securely. Anyone with your token access can easily manipulate your bot.\n\nHow to Set Up Your Coding Environment\n\nLet‚Äôs set up the coding environment. While there are various libraries available to create a Telegram bot, we‚Äôll use the pyTelegramBotAPI library. It is a simple but extensible Python implementation for the Telegram Bot API with both synchronous and asynchronous capabilities.\n\nNext, open your favorite code editor and create a file to store your token as below:\n\nAfter that, run the command to read the environment variables from the file.\n\nHow to Create Your First Bot\n\nAll the API implementations are stored in a single class called . It offers many ways to listen for incoming messages as well as functions like , , and others to send messages.\n\nCreate a new file and paste the following code there:\n\nIn the above code, we use the library in order to read the environment variables stored in our system.\n\nIf you remember, we exported an environment variable called in the previous step. The value of is read in a variable called . Further, we use the class to create a bot instance and passed the to it.\n\nWe then need to register message handlers. These message handlers contain filters that a message must pass. If a message passes the filter, the decorated function is called and the incoming message is supplied as an argument.\n\nAny name is acceptable for a function that is decorated by a message handler, but it can only have one parameter (the message).\n\nLet‚Äôs add another handler that echoes all incoming text messages back to the sender.\n\nThe above code uses a expression to test a message. Since we need to echo all the messages, we always return from the function.\n\nYou now have a simple bot that responds to the and commands with a static message and echoes all the other sent messages. Add the following to the end of your file to launch the bot:\n\nThat‚Äôs it! We have a Telegram bot ready. Let‚Äôs run the Python file and go to Telegram to test the bot.\n\nSearch for the bot using its username if you‚Äôre unable to find it. You can test it by sending the commands like and and other random texts.\n\nNote: All the message handlers are tested in the order in which they were declared in the source file.\n\nFor more information on using the pyTelegramBotAPI library, you can refer to their documentation.\n\nHow to Code the Horoscope Bot\n\nLet‚Äôs shift our attention to building our Horoscope Bot now. We will use message chaining in the bot. The bot will first ask for your zodiac sign, and then the day, and then it will respond with the horoscope for that particular day.\n\nUnder the hood, the bot interacts with an API to get the horoscope data.\n\nWe are going to use the Horoscope API that I built in another tutorial. If you wish to learn how to build one, you can go through this tutorial. Make sure you explore the APIs here before getting started.\n\nHow to fetch the horoscope data\n\nLet‚Äôs create a utility function to fetch the horoscope data for a particular day.\n\nIn the above Python code, we created a function that accepts two string arguments ‚Äì and ‚Äì and returns JSON data. We send a GET request on the API URL and pass and as the query parameters.\n\nIf you test the function, you will get an output similar to below:\n\nNote: You can explore more about the library in Python in this tutorial.\n\nNow that we have a function that returns the horoscope data, let‚Äôs create a message handler in our bot that asks for the zodiac sign of the user.\n\nThe above function is a bit different from the other functions we defined earlier. The bot‚Äôs horoscope functionality will be invoked by the command. We are sending a text message to the user, but notice that we have set the to Markdown while sending the message.\n\nSince we‚Äôll use message chaining, we used the method. This method accepts two parameters: the message sent by the user and the callback function which should be called after the message. Thus, we pass the variable and a new function that we‚Äôll define next.\n\nLet‚Äôs define the function that accepts the message.\n\nWe fetch the zodiac sign from the attribute. Similar to the previous function, it also asks the day for which you want to know the horoscope.\n\nIn the end, we use the same method and pass the , the callback function, and the .\n\nLet‚Äôs now define the function that accepts the message and the sign.\n\nThis is the final function where we get the sign from the function parameter and the day from the attribute.\n\nNext, we fetch the horoscope using the function and construct our message. In the end, we send the message with the horoscope data.\n\nOnce you run the Python file, you can test this functionality. Here‚Äôs the demo:\n\nAs of now, the bot stops working as soon as we stop our Python application. In order to make it run always, you can deploy the bot on platforms like Heroku, Render, and so on.\n\nHere's a link to the GitHub repo for this project - feel free to check it out.\n\nYou can also add more functionalities to the bot by exploring the Telegram APIs.\n\nThanks for reading! You can follow me on Twitter."
    },
    {
        "link": "https://medium.com/@moraneus/building-telegram-bot-with-python-telegram-bot-a-comprehensive-guide-7e33f014dc79",
        "document": "Creating a Telegram bot can significantly extend the functionality of your messaging experience, allowing for everything from automated responses to sophisticated interactions. This comprehensive guide will walk you through the process of building a basic Telegram bot with Python, incorporating user commands, message handling, and custom keyboards. We‚Äôll use the library for its simplicity and powerful features.\n\nIn this article, I will demonstrate a very simple Car Sales Listing Bot that is designed to streamline the process of gathering some necessary information from users wishing to list their cars for sale. By engaging in a structured conversation, the bot collects details such as the car‚Äôs type, color, and mileage, and even allows for photo uploads, culminating in a summary that confirms the listing‚Äôs details.\n‚Ä¢ Ability to upload a photo of the car.\n‚Ä¢ Summary of the listing details for confirmation.\n‚Ä¢ Create Your Bot: Open Telegram and search for the ‚ÄúBotFather‚Äù account. Start a conversation and use the command to create a new bot. Follow the prompts to set up your bot's name and username. BotFather will then give you a token, which is crucial for accessing the Telegram Bot API. Keep this token secure and do not share it.\n\nNow, let‚Äôs dive into coding your bot. Please create a new Python file, e.g., and open it in your favorite text editor. Then, follow these steps to write your bot.\n\nStart by importing necessary modules and setting up logging to help with debugging:\n\nStates in a Telegram bot, especially when using a conversation handler, serve as a framework to manage the flow of interaction between the bot and the user. They are essentially markers or checkpoints that define what part of the conversation the user is currently engaged with and determine what the bot should do next based on the user‚Äôs input. Here‚Äôs a more general overview of the role and functionality of states in managing bot conversations. The purpose and functionality of states in the Telegram bot are:\n‚Ä¢ Sequential Flow Management: States allow the bot to manage a sequential flow of conversation. By moving from one state to another, the bot can guide the user through a series of steps, questions, or options in a logical order.\n‚Ä¢ Context Awareness: They help the bot maintain context in a conversation. By knowing the current state, the bot understands what information has been provided by the user and what information is still needed, enabling it to respond appropriately.\n‚Ä¢ User Input Processing: Based on the current state, the bot can process user inputs differently. For example, an input in the ‚ÄúCAR_TYPE‚Äù state would be understood as the user specifying the type of car they‚Äôre selling, while the same input in the ‚ÄúCAR_COLOR‚Äù state would be interpreted as the color of the car.\n‚Ä¢ Conditional Logic Implementation: States allow for the implementation of conditional logic in the conversation. Depending on user responses or choices, the bot can decide to skip certain states, repeat them, or take the user down a different conversational path.\n‚Ä¢ Error Handling and Repetition: They facilitate error handling and the repetition of questions if the user provides unexpected or invalid responses. By keeping track of the current state, the bot can re-prompt the user for information correctly.\n‚Ä¢ State Persistence: In more complex bots, states can be stored and persisted across sessions, allowing users to pick up the conversation where they left off, even if they temporarily leave the chat or if the bot restarts.\n\nLet‚Äôs enumerate the states for our bot to manage the flow:\n\nConversation handlers in Telegram bots, particularly when using libraries like , are powerful tools that manage the flow of conversations based on user inputs and predefined states. They are crucial for developing bots that require a sequence of interactions, such as collecting information, guiding users through menus, or executing commands in a specific order. Here's a closer look at how conversation handlers work and their role in bot development:\n‚Ä¢ Managing Conversational States: Conversation handlers keep track of the current state of the dialogue with each user. They determine what the bot should do next based on the user‚Äôs input and the current state, allowing for a smooth and logical progression through different stages of interaction.\n‚Ä¢ Routing User Inputs: They route user inputs to different callback functions based on the current state. This means that the same input can lead to different outcomes depending on where the user is in the conversation flow.\n‚Ä¢ Handling Commands and Text: Conversation handlers can differentiate between commands (like or ) and regular text messages, allowing developers to specify distinct responses or actions for each type of input.\n‚Ä¢ Integrating with Keyboards and Buttons: They work seamlessly with custom keyboards and inline buttons, enabling developers to create interactive and user-friendly interfaces within the conversation. Users can select options or navigate through the bot‚Äôs features using these UI elements.\n‚Ä¢ Fallbacks and Timeouts: Conversation handlers support fallback functions, which can be triggered when the user sends unexpected input or when the conversation needs to be reset. They can also handle timeouts, ending a conversation automatically after a period of inactivity.\n‚Ä¢ Entry Points: These are triggers that start the conversation. Commonly, the command is used as an entry point, but you can define multiple entry points for different conversation flows.\n‚Ä¢ States: As discussed, states represent different points in the conversation. Each state is associated with one or more callback functions that define the bot‚Äôs behavior at that stage. Developers map states to these callbacks, dictating the flow of the conversation.\n‚Ä¢ Fallbacks: Fallback functions are defined to handle unexpected situations or to provide a way to exit or reset the conversation. A common fallback is a command that allows users to stop the conversation at any point.\n\nFollowing, is the handler function initiates the conversation (entry point), presenting the user with a selection of car types:\n\nHere you can find the rest of the handlers:\n\n\n\nasync def car_type(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Stores the user's car type.\"\"\"\n\n user = update.message.from_user\n\n context.user_data['car_type'] = update.message.text\n\n cars = {\"Sedan\": \"üöó\", \"SUV\": \"üöô\", \"Sport\": \"üèéÔ∏è\", \"Electric\": \"‚ö°\"}\n\n logger.info('Car type of %s: %s', user.first_name, update.message.text)\n\n await update.message.reply_text(\n\n f'<b>You selected {update.message.text} car {cars[update.message.text]}.\n\n'\n\n f'What color your car is?</b>',\n\n parse_mode='HTML',\n\n reply_markup=ReplyKeyboardRemove(),\n\n )\n\n\n\n # Define inline buttons for car color selection\n\n keyboard = [\n\n [InlineKeyboardButton('Red', callback_data='Red')],\n\n [InlineKeyboardButton('Blue', callback_data='Blue')],\n\n [InlineKeyboardButton('Black', callback_data='Black')],\n\n [InlineKeyboardButton('White', callback_data='White')],\n\n ]\n\n reply_markup = InlineKeyboardMarkup(keyboard)\n\n await update.message.reply_text('<b>Please choose:</b>', parse_mode='HTML', reply_markup=reply_markup)\n\n\n\n return CAR_COLOR\n\n\n\n\n\nasync def car_color(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Stores the user's car color.\"\"\"\n\n query = update.callback_query\n\n await query.answer()\n\n context.user_data['car_color'] = query.data\n\n await query.edit_message_text(\n\n text=f'<b>You selected {query.data} color.\n\n'\n\n f'Would you like to fill in the mileage for your car?</b>',\n\n parse_mode='HTML'\n\n )\n\n\n\n # Define inline buttons for mileage decision\n\n keyboard = [\n\n [InlineKeyboardButton('Fill', callback_data='Fill')],\n\n [InlineKeyboardButton('Skip', callback_data='Skip')],\n\n ]\n\n reply_markup = InlineKeyboardMarkup(keyboard)\n\n await query.message.reply_text('<b>Choose an option:</b>', parse_mode='HTML', reply_markup=reply_markup)\n\n\n\n return CAR_MILEAGE_DECISION\n\n\n\n\n\nasync def car_mileage_decision(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Asks the user to fill in the mileage or skip.\"\"\"\n\n query = update.callback_query\n\n await query.answer()\n\n decision = query.data\n\n\n\n if decision == 'Fill':\n\n await query.edit_message_text(text='<b>Please type in the mileage (e.g., 50000):</b>', parse_mode='HTML')\n\n return CAR_MILEAGE\n\n else:\n\n await query.edit_message_text(text='<b>Mileage step skipped.</b>', parse_mode='HTML')\n\n return await skip_mileage(update, context)\n\n\n\n\n\nasync def car_mileage(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Stores the car mileage.\"\"\"\n\n context.user_data['car_mileage'] = update.message.text\n\n await update.message.reply_text('<b>Mileage noted.\n\n'\n\n 'Please upload a photo of your car üì∑, or send /skip.</b>',\n\n parse_mode='HTML')\n\n return PHOTO\n\n\n\n\n\nasync def skip_mileage(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Skips the mileage input.\"\"\"\n\n context.user_data['car_mileage'] = 'Not provided'\n\n\n\n text = '<b>Please upload a photo of your car üì∑, or send /skip.</b>'\n\n\n\n # Determine the correct way to send a reply based on the update type\n\n if update.callback_query:\n\n # If called from a callback query, use the callback_query's message\n\n chat_id = update.callback_query.message.chat_id\n\n await context.bot.send_message(chat_id=chat_id, text=text, parse_mode='HTML')\n\n # Optionally, you might want to acknowledge the callback query\n\n await update.callback_query.answer()\n\n elif update.message:\n\n # If called from a direct message\n\n await update.message.reply_text(text)\n\n else:\n\n # Handle other cases or log an error/warning\n\n logger.warning('skip_mileage was called without a message or callback_query context.')\n\n\n\n return PHOTO\n\n\n\n\n\nasync def photo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Stores the photo.\"\"\"\n\n photo_file = await update.message.photo[-1].get_file()\n\n # Correctly store the file_id of the uploaded photo for later use\n\n context.user_data['car_photo'] = photo_file.file_id # Preserve this line\n\n\n\n # Inform user and transition to summary\n\n await update.message.reply_text('<b>Photo uploaded successfully.\n\n'\n\n 'Let\\'s summarize your selections.</b>',\n\n parse_mode='HTML'\n\n )\n\n await summary(update, context) # Proceed to summary\n\n\n\n\n\nasync def skip_photo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Skips the photo upload.\"\"\"\n\n await update.message.reply_text('<b>No photo uploaded.\n\n'\n\n 'Let\\'s summarize your selections.</b>',\n\n parse_mode='HTML')\n\n await summary(update, context)\n\n\n\n\n\nasync def summary(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Summarizes the user's selections and ends the conversation, including the uploaded image.\"\"\"\n\n selections = context.user_data\n\n # Construct the summary text\n\n summary_text = (f\"<b>Here's what you told me about your car:\n\n</b>\"\n\n f\"<b>Car Type:</b> {selections.get('car_type')}\n\n\"\n\n f\"<b>Color:</b> {selections.get('car_color')}\n\n\"\n\n f\"<b>Mileage:</b> {selections.get('car_mileage')}\n\n\"\n\n f\"<b>Photo:</b> {'Uploaded' if 'car_photo' in selections else 'Not provided'}\")\n\n\n\n chat_id = update.effective_chat.id\n\n\n\n # If a photo was uploaded, send it back with the summary as the caption\n\n if 'car_photo' in selections and selections['car_photo'] != 'Not provided':\n\n await context.bot.send_photo(chat_id=chat_id, photo=selections['car_photo'], caption=summary_text, parse_mode='HTML')\n\n else:\n\n # If no photo was uploaded, just send the summary text\n\n await context.bot.send_message(chat_id=chat_id, text=summary_text, parse_mode='HTML')\n\n\n\n return ConversationHandler.END\n\n\n\n\n\nasync def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Cancels and ends the conversation.\"\"\"\n\n await update.message.reply_text('Bye! Hope to talk to you again soon.', reply_markup=ReplyKeyboardRemove())\n\n return ConversationHandler.END\n\nIn the function, set up the and , including entry points, states, and fallbacks. Start the bot with polling to listen for updates:\n\nComplete your script with a call to the function. Run your bot by executing the Python script in your terminal.\n\nHere you can find the whole code:\n\nimport logging\n\nfrom telegram import (ReplyKeyboardMarkup, ReplyKeyboardRemove, Update,\n\n InlineKeyboardButton, InlineKeyboardMarkup)\n\nfrom telegram.ext import (Application, CallbackQueryHandler, CommandHandler,\n\n ContextTypes, ConversationHandler, MessageHandler, filters)\n\n\n\n# Enable logging\n\nlogging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n\n level=logging.INFO)\n\n\n\nlogger = logging.getLogger(__name__)\n\n\n\n# Define states\n\nCAR_TYPE, CAR_COLOR, CAR_MILEAGE_DECISION, CAR_MILEAGE, PHOTO, SUMMARY = range(6)\n\n\n\n\n\nasync def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Starts the conversation and asks the user about their preferred car type.\"\"\"\n\n reply_keyboard = [['Sedan', 'SUV', 'Sports', 'Electric']]\n\n\n\n await update.message.reply_text(\n\n '<b>Welcome to the Car Sales Listing Bot!\n\n'\n\n 'Let\\'s get some details about the car you\\'re selling.\n\n'\n\n 'What is your car type?</b>',\n\n parse_mode='HTML',\n\n reply_markup=ReplyKeyboardMarkup(reply_keyboard, one_time_keyboard=True, resize_keyboard=True),\n\n )\n\n\n\n return CAR_TYPE\n\n\n\n\n\nasync def car_type(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Stores the user's car type.\"\"\"\n\n user = update.message.from_user\n\n context.user_data['car_type'] = update.message.text\n\n cars = {\"Sedan\": \"üöó\", \"SUV\": \"üöô\", \"Sports\": \"üèéÔ∏è\", \"Electric\": \"‚ö°\"}\n\n logger.info('Car type of %s: %s', user.first_name, update.message.text)\n\n await update.message.reply_text(\n\n f'<b>You selected {update.message.text} car {cars[update.message.text]}.\n\n'\n\n f'What color your car is?</b>',\n\n parse_mode='HTML',\n\n reply_markup=ReplyKeyboardRemove(),\n\n )\n\n\n\n # Define inline buttons for car color selection\n\n keyboard = [\n\n [InlineKeyboardButton('Red', callback_data='Red')],\n\n [InlineKeyboardButton('Blue', callback_data='Blue')],\n\n [InlineKeyboardButton('Black', callback_data='Black')],\n\n [InlineKeyboardButton('White', callback_data='White')],\n\n ]\n\n reply_markup = InlineKeyboardMarkup(keyboard)\n\n await update.message.reply_text('<b>Please choose:</b>', parse_mode='HTML', reply_markup=reply_markup)\n\n\n\n return CAR_COLOR\n\n\n\n\n\nasync def car_color(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Stores the user's car color.\"\"\"\n\n query = update.callback_query\n\n await query.answer()\n\n context.user_data['car_color'] = query.data\n\n await query.edit_message_text(\n\n text=f'<b>You selected {query.data} color.\n\n'\n\n f'Would you like to fill in the mileage for your car?</b>',\n\n parse_mode='HTML'\n\n )\n\n\n\n # Define inline buttons for mileage decision\n\n keyboard = [\n\n [InlineKeyboardButton('Fill', callback_data='Fill')],\n\n [InlineKeyboardButton('Skip', callback_data='Skip')],\n\n ]\n\n reply_markup = InlineKeyboardMarkup(keyboard)\n\n await query.message.reply_text('<b>Choose an option:</b>', parse_mode='HTML', reply_markup=reply_markup)\n\n\n\n return CAR_MILEAGE_DECISION\n\n\n\n\n\nasync def car_mileage_decision(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Asks the user to fill in the mileage or skip.\"\"\"\n\n query = update.callback_query\n\n await query.answer()\n\n decision = query.data\n\n\n\n if decision == 'Fill':\n\n await query.edit_message_text(text='<b>Please type in the mileage (e.g., 50000):</b>', parse_mode='HTML')\n\n return CAR_MILEAGE\n\n else:\n\n await query.edit_message_text(text='<b>Mileage step skipped.</b>', parse_mode='HTML')\n\n return await skip_mileage(update, context)\n\n\n\n\n\nasync def car_mileage(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Stores the car mileage.\"\"\"\n\n context.user_data['car_mileage'] = update.message.text\n\n await update.message.reply_text('<b>Mileage noted.\n\n'\n\n 'Please upload a photo of your car üì∑, or send /skip.</b>',\n\n parse_mode='HTML')\n\n return PHOTO\n\n\n\n\n\nasync def skip_mileage(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Skips the mileage input.\"\"\"\n\n context.user_data['car_mileage'] = 'Not provided'\n\n\n\n text = '<b>Please upload a photo of your car üì∑, or send /skip.</b>'\n\n\n\n # Determine the correct way to send a reply based on the update type\n\n if update.callback_query:\n\n # If called from a callback query, use the callback_query's message\n\n chat_id = update.callback_query.message.chat_id\n\n await context.bot.send_message(chat_id=chat_id, text=text, parse_mode='HTML')\n\n # Optionally, you might want to acknowledge the callback query\n\n await update.callback_query.answer()\n\n elif update.message:\n\n # If called from a direct message\n\n await update.message.reply_text(text)\n\n else:\n\n # Handle other cases or log an error/warning\n\n logger.warning('skip_mileage was called without a message or callback_query context.')\n\n\n\n return PHOTO\n\n\n\n\n\nasync def photo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Stores the photo.\"\"\"\n\n photo_file = await update.message.photo[-1].get_file()\n\n # Correctly store the file_id of the uploaded photo for later use\n\n context.user_data['car_photo'] = photo_file.file_id # Preserve this line\n\n\n\n # Inform user and transition to summary\n\n await update.message.reply_text('<b>Photo uploaded successfully.\n\n'\n\n 'Let\\'s summarize your selections.</b>',\n\n parse_mode='HTML'\n\n )\n\n await summary(update, context) # Proceed to summary\n\n\n\n\n\nasync def skip_photo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Skips the photo upload.\"\"\"\n\n await update.message.reply_text('<b>No photo uploaded.\n\n'\n\n 'Let\\'s summarize your selections.</b>',\n\n parse_mode='HTML')\n\n await summary(update, context)\n\n\n\n\n\nasync def summary(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Summarizes the user's selections and ends the conversation, including the uploaded image.\"\"\"\n\n selections = context.user_data\n\n # Construct the summary text\n\n summary_text = (f\"<b>Here's what you told me about your car:\n\n</b>\"\n\n f\"<b>Car Type:</b> {selections.get('car_type')}\n\n\"\n\n f\"<b>Color:</b> {selections.get('car_color')}\n\n\"\n\n f\"<b>Mileage:</b> {selections.get('car_mileage')}\n\n\"\n\n f\"<b>Photo:</b> {'Uploaded' if 'car_photo' in selections else 'Not provided'}\")\n\n\n\n chat_id = update.effective_chat.id\n\n\n\n # If a photo was uploaded, send it back with the summary as the caption\n\n if 'car_photo' in selections and selections['car_photo'] != 'Not provided':\n\n await context.bot.send_photo(chat_id=chat_id, photo=selections['car_photo'], caption=summary_text, parse_mode='HTML')\n\n else:\n\n # If no photo was uploaded, just send the summary text\n\n await context.bot.send_message(chat_id=chat_id, text=summary_text, parse_mode='HTML')\n\n\n\n return ConversationHandler.END\n\n\n\n\n\nasync def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:\n\n \"\"\"Cancels and ends the conversation.\"\"\"\n\n await update.message.reply_text('Bye! Hope to talk to you again soon.', reply_markup=ReplyKeyboardRemove())\n\n return ConversationHandler.END\n\n\n\n\n\ndef main() -> None:\n\n \"\"\"Run the bot.\"\"\"\n\n application = Application.builder().token(\"YOUR TOKEN HERE\").build()\n\n\n\n conv_handler = ConversationHandler(\n\n entry_points=[CommandHandler('start', start)],\n\n states={\n\n CAR_TYPE: [MessageHandler(filters.TEXT & ~filters.COMMAND, car_type)],\n\n CAR_COLOR: [CallbackQueryHandler(car_color)],\n\n CAR_MILEAGE_DECISION: [CallbackQueryHandler(car_mileage_decision)],\n\n CAR_MILEAGE: [MessageHandler(filters.TEXT & ~filters.COMMAND, car_mileage)],\n\n PHOTO: [\n\n MessageHandler(filters.PHOTO, photo),\n\n CommandHandler('skip', skip_photo)\n\n ],\n\n SUMMARY: [MessageHandler(filters.ALL, summary)]\n\n },\n\n fallbacks=[CommandHandler('cancel', cancel)],\n\n )\n\n\n\n application.add_handler(conv_handler)\n\n\n\n # Handle the case when a user sends /start but they're not in a conversation\n\n application.add_handler(CommandHandler('start', start))\n\n\n\n application.run_polling()\n\n\n\n\n\nif __name__ == '__main__':\n\n main()\n\nStep 3: Testing and Interacting with Your Bot\n\nAfter running your script, find your bot on Telegram and start interacting with it. You should now be able to use the command to start a conversation, which will guide you through listing a car for sale."
    },
    {
        "link": "https://python-telegram-bot.org",
        "document": ""
    },
    {
        "link": "https://github.com/python-telegram-bot/python-telegram-bot",
        "document": "We have made you a wrapper you can't refuse\n\nWe have a vibrant community of developers helping each other in our Telegram group. Join us!\n\nStay tuned for library updates and new releases on our Telegram Channel.\n\nThis library provides a pure Python, asynchronous interface for the Telegram Bot API. It's compatible with Python versions 3.9+.\n\nIn addition to the pure API implementation, this library features several convenience methods and shortcuts as well as a number of high-level classes to make the development of bots easy and straightforward. These classes are contained in the submodule.\n\nAfter installing the library, be sure to check out the section on working with PTB.\n\nAll types and methods of the Telegram Bot API 8.3 are natively supported by this library. In addition, Bot API functionality not yet natively included can still be used as described in our wiki.\n\nYou can install or upgrade via\n\nTo install a pre-release, use the flag in addition.\n\nYou can also install from source, though this is usually not necessary.\n\nTo enable you to verify that a release file that you downloaded was indeed provided by the team, we have taken the following measures.\n\nStarting with v21.4, all releases are signed via sigstore. The corresponding signature files are uploaded to the GitHub releases page. To verify the signature, please install the sigstore Python client and follow the instructions for verifying signatures from GitHub Actions. As input for the parameter, please use the value .\n\nEarlier releases are signed with a GPG key. The signatures are uploaded to both the GitHub releases page and the PyPI project and end with a suffix . Please find the public keys here. The keys are named in the format .\n\nIn addition, the GitHub release page also contains the sha1 hashes of the release files in the files with the suffix .\n\ntries to use as few 3rd party dependencies as possible. However, for some features using a 3rd party library is more sane than implementing the functionality again. As these features are optional, the corresponding 3rd party dependencies are not installed by default. Instead, they are listed as optional dependencies. This allows to avoid unnecessary dependency conflicts for users who don't need the optional features.\n\nThe only required dependency is httpx ~= 0.27 for , the default networking backend.\n\nis most useful when used along with additional libraries. To minimize dependency conflicts, we try to be liberal in terms of version requirements on the (optional) dependencies. On the other hand, we have to ensure stability of , which is why we do apply version bounds. If you encounter dependency conflicts due to these bounds, feel free to reach out.\n\nPTB can be installed with optional dependencies:\n‚Ä¢ installs the cryptography>=39.0.1 library. Use this, if you want to use Telegram Passport related functionality.\n‚Ä¢ installs httpx[socks]. Use this, if you want to work behind a Socks5 server.\n‚Ä¢ installs httpx[http2]. Use this, if you want to use HTTP/2.\n‚Ä¢ installs aiolimiter~=1.1,<1.3. Use this, if you want to use .\n‚Ä¢ installs the tornado~=6.4 library. Use this, if you want to use / .\n‚Ä¢ installs the cachetools>=5.3.3,<5.6.0 library. Use this, if you want to use arbitrary callback_data.\n‚Ä¢ installs the APScheduler>=3.10.4,<3.12.0 library. Use this, if you want to use the .\n\nTo install multiple optional dependencies, separate them by commas, e.g. .\n‚Ä¢ installs all optional dependencies that are related to , i.e. .\n\nOnce you have installed the library, you can begin working with it - so let's get started!\n\nOur Wiki contains an Introduction to the API explaining how the pure Bot API can be accessed via . Moreover, the Tutorial: Your first Bot gives an introduction on how chatbots can be easily programmed with the help of the module.\n‚Ä¢ The package documentation is the technical reference for . It contains descriptions of all available classes, modules, methods and arguments as well as the changelog.\n‚Ä¢ The wiki is home to number of more elaborate introductions of the different features of and other useful resources that go beyond the technical documentation.\n‚Ä¢ Our examples section contains several examples that showcase the different features of both the Bot API and . Even if it is not your approach for learning, please take a look at . It is the de facto base for most of the bots out there. The code for these examples is released to the public domain, so you can start by grabbing the code and building on top of it.\n‚Ä¢ The official Telegram Bot API documentation is of course always worth a read.\n\nIf the resources mentioned above don't answer your questions or simply overwhelm you, there are several ways of getting help.\n‚Ä¢ We have a vibrant community of developers helping each other in our Telegram group. Join us! Asking a question here is often the quickest way to get a pointer in the right direction.\n‚Ä¢ You can even ask for help on Stack Overflow using the python-telegram-bot tag.\n\nSince v20.0, is built on top of Pythons module. Because is in general single-threaded, does currently not aim to be thread-safe. Noteworthy parts of API that are likely to cause issues (e.g. race conditions) when used in a multi-threaded setting include:\n‚Ä¢ all classes in the module that allow to add/remove allowed users/chats at runtime\n\nContributions of all sizes are welcome. Please review our contribution guidelines to get started. You can also help by reporting bugs or feature requests.\n\nOccasionally we are asked if we accept donations to support the development. While we appreciate the thought, maintaining PTB is our hobby, and we have almost no running costs for it. We therefore have nothing set up to accept donations. If you still want to donate, we kindly ask you to donate to another open source project/initiative of your choice instead.\n\nYou may copy, distribute and modify the software provided that modifications are described and licensed for free under LGPL-3. Derivative works (including modifications or anything statically linked to the library) can only be redistributed under LGPL-3, but applications that use the library don't have to be."
    },
    {
        "link": "https://activestate.com/blog/top-10-python-packages-for-finance-and-financial-modeling",
        "document": "The popularity of the Python programming language is due, at least in part, to the versatility that it offers. In addition to the vast number of use cases in web and app development, Python provides the tools for building and implementing any type of scientific or mathematical model, regardless of the origin or type of data. This versatility is enabled by the extensive standard library that offers a range of facilities intended to enhance the functionality and portability of the language. For more specific applications, the Python Package Index (PyPI) provides additional packages that extend the capabilities of Python to fit the needs of each domain.\n\nFor these reasons, Python has proven to be a formidable tool in developing novel financial technologies. From crunching the raw numbers to creating aesthetically pleasing, yet intuitive Graphical User Interfaces (GUIs), a myriad of packages exist to help users build their own financial models. In this article, I‚Äôll highlight my top 10 packages for finance and financial modeling with a few basic examples. All of these packages (except quantlib) are available on the ActiveState Platform for inclusion in your runtime environment.\n\nThe Most Useful Python Packages for Finance\n\nThe field of financial technologies is vast, encompassing everything from insurance, lending and trading, to e-banking and other payment services. This article focuses on applications specific to quantitative finance, which require programming tasks such as data importation and transformation, time series and risk analysis, trading and backtesting, excel integration, and data visualization. I sample a few of the best packages for accomplishing each task.\n\nAt base, all financial models rely on crunching numbers. The first few packages I have in the list provide the framework to do so. The first is NumPy. NumPy is the most essential package for scientific and mathematical computing in Python. Not only does it introduce n-dimensional arrays and matrices into Python, but also contains some basic mathematical functions to manipulate these data structures. Most of the higher-level Python packages for finance mentioned later in this list depend on NumPy.\n\nFor example, to create two 2√ó2 complex matrices and print the sum:\n\nAnd to take the complex conjugate of one of them:\n\nMore information about how NumPy is used can be found here.\n\nThe NumPy package provides basic mathematical structures for manipulating and storing data. But in order to build sophisticated models based on this data, a repository of more advanced statistical tools and operations is needed. Enter SciPy. This package provides functions and algorithms critical to the advanced scientific computations needed to build any statistical model. These include algorithms for interpolation, optimization, clustering, transformation, and integration of data. These operations are essential when performing any type of data analysis, or building any type of predictive model.\n\nTo demonstrate interpolation, I first use NumPy to create some data points with an arbitrary function, then compare different interpolation methods:\n\nNumPy and SciPy lay the mathematical groundwork. The panda‚Äôs package, on the other hand, establishes an intuitive and easy-to-use data structure, a DataFrame, specifically designed for analysis and model building. It is based on the arrays that NumPy introduces, and is optimized for tabular, multidimensional, and heterogeneous data. The most common manipulations, such as groupby, joining, merging, or filling, replacing and imputing null values, can be executed in a single line. In addition, the package provides functions for importing data from a variety of standard formats, and others for rapid plotting, retrieving basic statistics, or outputting data.\n\nAnd to concatenate two dataframes together:\n\nTo perform a simple filtering operation, extracting the row that meets the logical condition:\n\nFurther examples can be found in the documentation here.\n\nSciPy provides a library of statistical tools that allow users to construct a model, and pandas makes it easy to implement. The statsmodels package builds on these packages by implementing more advanced testing of different statistical models. An extensive list of result statistics and diagnostics for each estimator is available for any given model, with the goal of providing the user with a full picture of model performance. The results are tested against existing statistical packages to ensure that they are correct.\n\nAs an example, I import a built-in dataset:\n\nAnd to fit the dataset with a Poisson model:\n\nThe output should look something like this:\n\nMore information can be found here.\n\nUp to now, the packages I have listed are impartial to the type of data being considered. Of course, when considering financial models, we need financial data. This is where Quandl comes to the rescue. The Quandl Python module gives users access to the vast collection of economic, financial, and market data collected from central banks, governments, multinational organizations and many other sources. Most of the raw datasets are free to access upon sign up (you need an API key), with more advanced and in-depth datasets available at a cost.\n\nThe package documentation can be found here.\n\nZipline is a package that ties the statistics, the data structures, and the data sources all together. It is a formidable algorithmic trading library for Python, evident by the fact that it powers Quantopian, a free platform for building and executing trading strategies. Data from Quandl is easily imported, and custom algorithms easily designed, tested, and implemented. This includes backtesting of algorithms and live trading. A basic algorithm looks like this:\n\nWe import the order, record, and symbol functions from zipline, to build an algorithm that records the stock price of Apple. For more examples of algorithms, see the documentation.\n\nAfter designing and testing an algorithm in zipline, the pyfolio package provides an easy way to generate a tearsheet containing performance statistics. These statistics include annual/monthly returns, return quantiles, rolling beta/Sharpe ratios, portfolio turnover, and a few more. To generate a sample tearsheet on a single stock:\n\nThe output will be a series of tables and plots containing the performance metrics.\n\nThe documentation has a few more examples that go into further detail.\n\nThe next two packages are alternatives to using zipline and pyfolio. The first is the Technical Analysis Library, or TA-Lib for short. The project is written in C++, but a wrapper for Python exists. Like zipline, TA-Lib provides common financial tools such as overlap studies, momentum indicators, volume indicators, volatility indicators, price transformations, cycle indicators, pattern recognition, and pure statistical functions.\n\nA full list of the capabilities can be found here.\n\nThe second alternative to zipline and pyfolio is QuantLib. Similar to TA-Lib, QuantLib is written in C++ and then exported to Python. The QuantLib project aims to create a free, open-source library for modeling, trading, and risk management. The package contains tools to design and implement advanced algorithms that include features such as market conventions, yield curve models, solvers, PDEs, Monte Carlo, and others.\n\nThe project has been around for almost 20 years, and there is extensive documentation.\n\nThe aforementioned python packages for finance establish financial data sources, optimal data structures for financial data, as well as statistical models and evaluation mechanisms. But none provide one of the most important Python tools for financial modeling: data visualization (all the visualizations in this article are powered by matplotlib).\n\nNot only is visualization important for understanding trends within financial data, but also for conveying insights to non-technical personnel. There are more than a few data visualization packages within Python, each with positives and negatives (see my article here), but the easiest to implement for financial modeling is matplotlib. This is mainly due to the fact that many of the packages in this list already rely on matplotlib. Additionally, the documentation is plentiful, and the syntax simple and straightforward.\n\nIn this article, I‚Äôve picked out the top 10 most useful python packages for finance. It‚Äôs interesting to note that since the last time ActiveState did a roundup of Python packages for finance (2010), many of the top packages have changed but numpy, scipy and matplotlib remain key.\n\nTo get started with the packages on this list, create a free ActiveState Platform account and then download our ‚ÄúTop 10 Finance Packages‚Äù build. The build contains a version of Python 3.8 and most of the packages listed in this post so you can test them out for yourself.\n\nThe simplest way to install the environment is to first install the ActiveState Platform‚Äôs command line interface (CLI), the State Tool.\n‚Ä¢ If you‚Äôre on Linux , you can use curl to install the State Tool:\n\n\n\nOnce the State Tool is installed, just run the following command to download the build and automatically install it into a virtual environment:\n\n\n\nAll of these packages (except quantlib) are available on the ActiveState Platform for inclusion in your runtime environment. One of the key advantages of the ActiveState Platform is it‚Äôs ‚Äúbuild environment on demand‚Äù capabilities, allowing you to build packages that contain C code from source without the need to set up your own environment or source your own compiler. If code provenance is of value to your organization, the ActiveState platform can help lower the time and resources you spend sourcing and building your runtimes."
    },
    {
        "link": "https://dataspoof.info/post/top-financial-data-analysis",
        "document": "As a financial data scientist, you‚Äôre no stranger to the complexities of navigating vast financial datasets. However, Python‚Äôs versatile libraries have revolutionized this process, making it more streamlined and efficient. Python stands out among other programming languages like R, thanks to its extensive offerings for data analysis, manipulation, visualization, and modeling.\n\nPython‚Äôs vibrant community continually contributes to the expansion of its language libraries, ensuring there‚Äôs a Python library for every need. This is evident when browsing Github, a renowned platform for code hosting. In this article, we‚Äôll delve into the top Python libraries for financial data analysis. From Pandas, the go-to for data manipulation, to TensorFlow, the powerhouse for predictive modeling, we‚Äôll help you unlock the potential of your financial data with Python.\n\nUnleashing the Power of Python in Financial Data Analysis\n\nFinancial technology is a broad topic that includes everything from e-banking and other payment services to insurance, lending, and trading. The main subject of this article focuses on the applications of quantitative finance, which involves programming activities such as time series and risk analysis, trading and backtesting, data importation and transformation, excel integration, and data visualization.\n‚Ä¢ \n‚Ä¢ NumPY ‚Äì One of the foundational Python libraries for scientific computing is NumPY. It offers a potent N-dimensional array object for manipulating and storing numerical data which has its wider use in academia, finance, and industry. NumPY also introduces n-dimensional arrays and matrices for performing calculations that includes generating random numbers, linear algebra, and the Fourier transform.\n‚Ä¢ \n‚Ä¢ SciPY- Enter SciPY, when you require a reservoir of increasingly sophisticated statistical tools and operations to create a complex model using the data. SciPY supplements a very well-known Numeric module, NumPY. This package offers the necessary algorithms and routines for statistical models. They include data integration, grouping, transformation, and interpolation methods. These processes are very important when carrying out any kind of data analysis or creating any kind of predictive model.\n‚Ä¢ \n‚Ä¢ Pandas ‚Äì The Pandas package is the easy-to-use data structure and a DataFrame, which is specifically been designed for Model building and Analysis. It is a strong library for data analysis and manipulation. The data structure enables the effective management of big datasets. Pandas are usually been designed for tabular, multidimensional, and heterogeneous data and are built on NumPy‚Äôs arrays. Data from a variety of sources, including CSV, Excel, SQL, and more, can be read by Pandas. Data cleaning, data processing, and data visualization are among its useful applications.\n‚Ä¢ \n‚Ä¢ Quand DSL ‚Äì A domain-specific language called Quandl DSL is primarily used to express derivative instruments in finance quantitative analytics and trading. A foundation for establishing and modifying financial contracts is provided by this functional programming language. With the great degree of flexibility and expressiveness that this method offers, it is feasible to design a variety of financial instruments, such as options, futures, swaps, and more. Additionally, it has a variety of features created to assist financial analysts‚Äô and traders‚Äô practical needs. These include tools for analysing and displaying contract behaviour as well as support for other forms of market data, such as interest rates and currency rates.\n‚Ä¢ \n‚Ä¢ Statistics- It is one of the built-in libraries that provides functions for statistical analysis. It enables users to compute descriptive statistics for numerical data included in a list, tuple, or any object, such as mean, median, mode, variance, and standard deviation. Without the need to install any additional third-party libraries, the statistics package in Python is a helpful tool for doing simple statistical studies.\n‚Ä¢ \n‚Ä¢ Pyfin ‚Äì Pyfin offers a variety of functions and tools for financial analysis and modeling. It has routines for computing popular financial metrics, including Internal Rate of Return (IRR), Net Present Value (NPV), and numerous forms of returns (e.g. simple, logarithmic, and compounded). It is known for providing basic options pricing in Python.\n‚Ä¢ \n‚Ä¢ vollib ‚Äì Option pricing and volatility calculations are done by using vollib in Python library. Many models, including Black-Scholes, Binomial, and Monte Carlo simulations, are supported by their functionalities.\n‚Ä¢ \n‚Ä¢ QuantPy ‚Äì It is one of the quantitative finance libraries for Python which is mainly used for the purpose of financial analysis, risk management, and portfolio optimization. Many statistical models and techniques for financial analysis are supported by QuantPy and it also has tools for valuing derivatives, predicting asset values, and assessing risk in a portfolio.\n‚Ä¢ \n‚Ä¢ Financial Functions for Python (ffn) ‚Äì For those who are working in quantitative finance, this library contains many useful functions. This lies on the shoulders of giants (Pandas, , Scipy, Numpy, etc.). ffn offers a wide range of utilities, starting from performance assessment and evaluation to graphing and common data transformations\n‚Ä¢ \n‚Ä¢ PyNance ‚Äì This is a Python package, to assemble and analyze financial data. PyNance also supports other versions of Python and Python packages. It also contains specific tools for getting financial data from a variety of websites, including Google Finance and Yahoo Financial.\n‚Ä¢ \n‚Ä¢ TIA- (Toolkit for Integration and Analysis)TIA is a toolkit that offers access to Bloomberg data, simpler pdf production, backtesting, technical analysis, return analysis, and a few Windows utilities. This can be used by first installing the package with pip and then importing it with the following line of code. The package‚Äôs many functions and classes can be used to load, modify, and analyze financial data, including stock prices and economic indicators after you‚Äôve imported it. TIA also offers assistance with creating reports based on your data analysis and backtesting trading techniques.\n‚Ä¢ \n‚Ä¢ QuantSoftware Toolkit ‚Äì It is one of the Python packages for backtesting trading strategies and quantitative finance. It features tools for downloading financial data, processing and displaying financial data and testing trading strategies against historical data. Additionally, QSTK supports the development of personalized portfolios and the evaluation of portfolio effectiveness.\n‚Ä¢ \n‚Ä¢ TA-Lib ‚Äì TA-Lib (Technical Analysis Library), this package is used when developers need to perform technical analysis on data from the financial markets. It has a Python open-source API. TA-Lib supports working with candlestick charts and other types of financial charting. You may use it by first installing the package with pip and then importing it with the following line of code. Once the package has been imported, you can use its many functions and techniques to generate a variety of technical indicators, including volatility measurements, momentum indicators, and moving averages.\n‚Ä¢ \n‚Ä¢ Zipline ‚Äì A Python library for back-testing trading algorithms. It contains instruments for absorbing monetary data, simulating deals, and assessing trading tactics using past data. It acts appropriately for both production and research use cases as it is scalable by design. Zipline can also be customized and has the great benefit to stimulate a large number of trading scenarios. It is found to be a very useful tool for researchers, investors, and traders in the financial industry. Zipline is highly customizable and can be used to simulate a wide range of trading scenarios, making it a valuable tool for traders, investors, and researchers in the financial industry.\n‚Ä¢ \n‚Ä¢ Quantitative ‚ÄìAnyone working in finance will benefit greatly from the dynamic Python module known as Quantitative. You almost have a personal finance lab at your disposal! You may put your trading techniques to the test, evaluate how they work in various settings, and adjust them for the best outcomes thanks to their adaptability and event-driven nature. However, it goes beyond merely backtesting. You may evaluate the effectiveness of your tactics using quantitative data, which gives you important information you can use to make wise decisions. Quantitative makes the complicated world of finance much more approachable and interesting, regardless of whether you are an experienced trader or a novice!\n‚Ä¢ \n‚Ä¢ Analyzer ‚Äì Analyzer provides a simulated trading floor where you may practice your trading methods in real-time. You may back-test your trading methods and do financial research as market circumstances are changing using this Python framework, which functions as a high-tech financial sandbox. You can foresee probable consequences of your choices before you make them, much like if you had a financial crystal ball. With Analyzer, you actively shape the financial future rather than merely making predictions about it.\n‚Ä¢ \n‚Ä¢ Flexible Backtesting for Python (bt) ‚Äì This framework is mainly used to test quantitative trading strategies. In this process, a given data is been tested. This framework makes it simpler to develop strategies that combine different algos.\n‚Ä¢ \n‚Ä¢ Back trader ‚Äì An open-source Python package known as backtrader. By using back trader live trading, strategy visualization, and backtesting is performed.\n‚Ä¢ \n‚Ä¢ tradingWithPython ‚Äì This library is known for its codes that can be reused for developing quantitative trading methods in daily work.\n‚Ä¢ \n‚Ä¢ pandas_talib ‚Äì This is a technical analysis library that is used to implement analysis on technical indicators by the use of Python Pandas.\n‚Ä¢ \n‚Ä¢ algobroker ‚Äì This library is known as the algo trading execution engine. The working plan for the Python server is to receive requests from clients and then send them to the Broker API.\n‚Ä¢ \n‚Ä¢ Finmarketpy ‚Äì This Python library enables backtesting trading strategies by the use of pre-built templates and an API that is easy to use. It also allows you to examine market data.\n‚Ä¢ \n‚Ä¢ pyfolio ‚Äì This is a Python library that mainly offers measurements of many risks and performances and tools which are used for producing tear sheets and visualization of outcomes. It functions well with the free Zipline backtesting library.\n‚Ä¢ \n‚Ä¢ empyrical ‚Äì For financial data scientists, Empyrical functions much like a Swiss Army knife. A variety of financial and statistical measurements, including the Sharpe Ratio, Sortino Ratio, Maximum Drawdown, and others, are available in this Python package. It works nicely with other well-known libraries like NumPy and Pandas, and Zipline and Pyfolio also utilise it.\n‚Ä¢ \n‚Ä¢ finance ‚Äì You should always use Python‚Äôs Finance library to calculate financial risk. It simplifies the challenging work of financial risk analysis by using user-friendly classes and operator overload.\n‚Ä¢ \n‚Ä¢ qfrm ‚Äì Your personal risk management adviser is a Python package called QFRM (Quantitative Financial Risk Management). For portfolios and particular assets, it offers tools for calculating anticipated shortfall (ES), value-at-risk (VaR), and other risk metrics. It is a well-liked option for risk management applications in the banking industry and comes with features for stress- and back-testing financial models.\n‚Ä¢ \n‚Ä¢ Visualize-wealth ‚Äì A Python module called Visualize-wealth enables you to view the performance of your investment portfolio in a whole new way. It offers instruments for developing, backtesting, examining, and rating portfolios and related benchmarks. It provides a number of tools for making interactive plots and charts thanks to its simple interface with libraries like Pandas and NumPy.\n‚Ä¢ \n‚Ä¢ VisualPortfolio ‚Äì Your financial portfolios come to life with the help of the Python library VisualPortfolio. You may utilise its many capabilities to build interesting portfolio visualisations including pie charts, bar charts, and risk-return plots after a quick installation and import procedure. You can really see the results of your investments with VisualPortfolio.\n‚Ä¢ \n‚Ä¢ ARCH ‚Äì Autoregressive conditional heteroskedasticity (ARCH), this package is used to analyze and model down univariate and multivariate time series data with these models. This can be used by installing package by using pip and with the first line code and using the second line to import it after that. After importing the package, you can use its numerous methods and classes to estimate parameters, fit ARCH models to your time series data, and run statistical tests. A variety of ARCH models, including the GARCH, EGARCH, and TARCH models, as well as tools for modelling data and predicting future values, are included in the package.\n‚Ä¢ \n‚Ä¢ stats models ‚Äì The Python module stat models is a supplement to Scipy for statistical calculations, these include descriptive statistics and estimation and inference for statistical models.\n\nBy going through the well-known Computer Python programming language, you must be now aware of all the Python libraries that have been an important tool for many popular Data Scientists for financial purposes. As the libraries also permit data analysis that is quick and effective as well as modeling and visualization. The Python library such as Visual Portfolio, Statsmodels, and ARCH are a few of them that are used for these.\n\nLibraries such as Visual Portfolio are well known, as it has helped users to create plots and charts for a better understanding of their investment strategy. One such tool is the stats model that is used to carry out a good range of data visualization and statistical studies, whereas to analyze and model the time series ARCH is much more suitable with autoregressive heteroskedasticity models that are conditional.\n\nPandas, Numpy, Scikit-learn, Keras, and Tensor flow are Python libraries that are very well-known which are flexible to use, and easily adaptable. For Data Scientists working in the financial industry, Python is a language that has become the most preferred language as compared to many others. This way it has helped Data Scientists to analyze, and develop, a huge amount of data in a simpler manner. If you have any doubt feel free to drop the comments. Happy learning!\n\nIf you like the article and would like to support me, make sure to:\n‚Ä¢ üëè Like for this article and subscribe to our newsletter\n‚Ä¢ üì∞ View more content on my DataSpoof website"
    },
    {
        "link": "https://github.com/wilsonfreitas/awesome-quant",
        "document": "A curated list of insanely awesome libraries, packages and resources for Quants (Quantitative Finance).\n‚Ä¢ numpy - NumPy is the fundamental package for scientific computing with Python.\n‚Ä¢ scipy - SciPy (pronounced ‚ÄúSigh Pie‚Äù) is a Python-based ecosystem of open-source software for mathematics, science, and engineering.\n‚Ä¢ pandas - pandas is an open source, BSD-licensed library providing high-performance, easy-to-use data structures and data analysis tools for the Python programming language.\n‚Ä¢ quantdsl - Domain specific language for quantitative analytics in finance and trading.\n‚Ä¢ pymc3 - Probabilistic Programming in Python: Bayesian Modeling and Probabilistic Machine Learning with Theano.\n‚Ä¢ modelx - Python reimagination of spreadsheets as formula-centric objects that are interoperable with pandas.\n‚Ä¢ OpenBB Terminal - Terminal for investment research for everyone.\n‚Ä¢ Fincept Terminal - Advance Data Based A.I Terminal for all Types of Financial Asset Research.\n‚Ä¢ vollib - vollib is a python library for calculating option prices, implied volatility and greeks.\n‚Ä¢ pynance - Lightweight Python library for assembling and analyzing financial data.\n‚Ä¢ hasura/base-python-dash - Hasura quick start to deploy Dash framework. Written on top of Flask, Plotly.js, and React.js, Dash is ideal for building data visualization apps with highly custom user interfaces in pure Python.\n‚Ä¢ FinancePy - A Python Finance Library that focuses on the pricing and risk-management of Financial Derivatives, including fixed-income, equity, FX and credit derivatives.\n‚Ä¢ willowtree - Robust and flexible Python implementation of the willow tree lattice for derivatives pricing.\n‚Ä¢ financial-engineering - Applications of Monte Carlo methods to financial engineering projects, in Python.\n‚Ä¢ optlib - A library for financial options pricing written in Python.\n‚Ä¢ Quantsbin - Tools for pricing and plotting of vanilla option prices, greeks and various other analysis around them.\n‚Ä¢ finoptions - Complete python implementation of R package fOptions with partial implementation of fExoticOptions for pricing various options.\n‚Ä¢ AbsBox - A Python based library to model cashflow for structured product like Asset-backed securities (ABS) and Mortgage-backed securities (MBS).\n‚Ä¢ Intrinsic-Value-Calculator - A Python tool for quick calculations of a stock's fair value using Discounted Cash Flow analysis.\n‚Ä¢ Kelly-Criterion - Kelly Criterion implemented in Python to size portfolios based on J. L. Kelly Jr's formula.\n‚Ä¢ rateslib - A fixed income library for pricing bonds and bond futures, and derivatives such as IRS, cross-currency and FX swaps.\n‚Ä¢ fypy - Vanilla and exotic option pricing library to support quantitative R&D. Focus on pricing interesting/useful models and contracts (including and beyond Black-Scholes), as well as calibration of financial models to market data.\n‚Ä¢ skfolio - Python library for portfolio optimization built on top of scikit-learn. It provides a unified interface and sklearn compatible tools to build, tune and cross-validate portfolio models.\n‚Ä¢ analyzer - Python framework for real-time financial and backtesting trading strategies.\n‚Ä¢ pybacktest - Vectorized backtesting framework in Python / pandas, designed to make your backtesting easier.\n‚Ä¢ basana - A Python async and event driven framework for algorithmic trading, with a focus on crypto currencies.\n‚Ä¢ tradingWithPython - A collection of functions and classes for Quantitative trading.\n‚Ä¢ Pandas TA - Pandas TA is an easy to use Python 3 Pandas Extension with 115+ Indicators. Easily build Custom Strategies.\n‚Ä¢ algobroker - This is an execution engine for algo trading.\n‚Ä¢ finmarketpy - Python library for backtesting trading strategies and analyzing financial markets.\n‚Ä¢ fooltrader - the project using big-data technology to provide an uniform way to analyze the whole market.\n‚Ä¢ zvt - the project using sql, pandas to provide an uniform and extendable way to record data, computing factors, select securities, backtesting, realtime trading and it could show all of them in clearly charts in realtime.\n‚Ä¢ moonshot - Vectorized backtester and trading engine for QuantRocket based on Pandas.\n‚Ä¢ PyPortfolioOpt - Financial portfolio optimization in python, including classical efficient frontier and advanced methods.\n‚Ä¢ Eiten - Eiten is an open source toolkit by Tradytics that implements various statistical and algorithmic investing strategies such as Eigen Portfolios, Minimum Variance Portfolios, Maximum Sharpe Ratio Portfolios, and Genetic Algorithms based Portfolios.\n‚Ä¢ riskparity.py - fast and scalable design of risk parity portfolios with TensorFlow 2.0\n‚Ä¢ mlfinlab - Implementations regarding \"Advances in Financial Machine Learning\" by Marcos Lopez de Prado. (Feature Engineering, Financial Data Structures, Meta-Labeling)\n‚Ä¢ NowTrade - Python library for backtesting technical/mechanical strategies in the stock and currency markets.\n‚Ä¢ catalyst - An Algorithmic Trading Library for Crypto-Assets in Python\n‚Ä¢ algorithmic-trading-with-python - Free and resources for trading simulation, backtesting, and machine learning on financial data.\n‚Ä¢ Qlib - An AI-oriented Quantitative Investment Platform by Microsoft. Full ML pipeline of data processing, model training, back-testing; and covers the entire chain of quantitative investment: alpha seeking, risk modeling, portfolio optimization, and order execution.\n‚Ä¢ machine-learning-for-trading - Code and resources for Machine Learning for Algorithmic Trading\n‚Ä¢ OctoBot - Open source cryptocurrency trading bot for high frequency, arbitrage, TA and social trading with an advanced web interface.\n‚Ä¢ bta-lib - Technical Analysis library in pandas for backtesting algotrading and quantitative analysis.\n‚Ä¢ Stock-Prediction-Models - Gathers machine learning and deep learning models for Stock forecasting including trading bots and simulations.\n‚Ä¢ TuneTA - TuneTA optimizes technical indicators using a distance correlation measure to a user defined target feature such as next day return.\n‚Ä¢ AutoTrader - A Python-based development platform for automated trading systems - from backtesting to optimization to livetrading.\n‚Ä¢ fast-trade - A library built with backtest portability and performance in mind for backtest trading strategies.\n‚Ä¢ qf-lib - QF-Lib is a Python library that provides high quality tools for quantitative finance.\n‚Ä¢ tda-api - Gather data and trade equities, options, and ETFs via TDAmeritrade.\n‚Ä¢ vectorbt - Find your trading edge, using a powerful toolkit for backtesting, algorithmic trading, and research.\n‚Ä¢ pysystemtrade - pysystemtrade is the open source version of Robert Carver's backtesting and trading engine that implements systems according to the framework outlined in his book \"Systematic Trading\", which is further developed on his blog.\n‚Ä¢ OctoBot Script - A quant framework to create cryptocurrencies strategies - from backtesting to optimization to livetrading.\n‚Ä¢ hftbacktest - A high-frequency trading and market-making backtesting tool accounts for limit orders, queue positions, and latencies, utilizing full tick data for trades and order books.\n‚Ä¢ Intelligent Trading Bot - Automatically generating signals and trading based on machine learning and feature engineering\n‚Ä¢ fastquant - fastquant allows you to easily backtest investment strategies with as few as 3 lines of python code.\n‚Ä¢ Trading Strategy - TradingStrategy.ai is a market data, backtesting, live trading and investor management framework for decentralised finance\n‚Ä¢ Hikyuu - A base on Python/C++ open source high-performance quant framework for faster analysis and backtesting, contains the complete trading system components for reuse and combination.\n‚Ä¢ fecon235 - Computational tools for financial economics include: Gaussian Mixture model of leptokurtotic risk, adaptive Boltzmann portfolios.\n‚Ä¢ finance - Financial Risk Calculations. Optimized for ease of use through class construction and operator overload.\n‚Ä¢ qfrm - Quantitative Financial Risk Management: awesome OOP tools for measuring, managing and visualizing risk of financial instruments and portfolios.\n‚Ä¢ VisualPortfolio - This tool is used to visualize the performance of a portfolio.\n‚Ä¢ FinQuant - A program for financial portfolio management, analysis and optimization.\n‚Ä¢ risktools - Risk tools for use within the crude and crude products trading space with partial implementation of R's PerformanceAnalytics.\n‚Ä¢ Asset News Sentiment Analyzer - Sentiment analysis and report generation package for financial assets and securities utilizing GPT models.\n‚Ä¢ Jupyter Quant - A dockerized Jupyter quant research environment with preloaded tools for quant analysis, statsmodels, pymc, arch, py_vollib, zipline-reloaded, PyPortfolioOpt, etc.\n‚Ä¢ statsmodels - Python module that allows users to explore data, estimate statistical models, and perform statistical tests.\n‚Ä¢ PyFlux - Python library for timeseries modelling and inference (frequentist and Bayesian) on models.\n‚Ä¢ Facebook Prophet - Tool for producing high quality forecasts for time series data that has multiple seasonality with linear or non-linear growth.\n‚Ä¢ tsmoothie - A python library for time-series smoothing and outlier detection in a vectorized way.\n‚Ä¢ pmdarima - A statistical library designed to fill the void in Python's time series analysis capabilities, including the equivalent of R's auto.arima function.\n‚Ä¢ functime - Time-series machine learning at scale. Built with Polars for embarrassingly parallel feature extraction and forecasts on panel data.\n‚Ä¢ pandas_market_calendars - Exchange calendars to use with pandas for trading applications.\n‚Ä¢ findatapy - Python library to download market data via Bloomberg, Quandl, Yahoo etc.\n‚Ä¢ googlefinance - Python module to get real-time stock data from Google Finance API.\n‚Ä¢ yahoo-finance - Python module to get stock data from Yahoo! Finance.\n‚Ä¢ pandas-datareader - Python module to get data from various sources (Google Finance, Yahoo Finance, FRED, OECD, Fama/French, World Bank, Eurostat...) into Pandas datastructures such as DataFrame, Panel with a caching mechanism.\n‚Ä¢ pandas-finance - High level API for access to and analysis of financial data.\n‚Ä¢ pyhoofinance - Rapidly queries Yahoo Finance for multiple tickers and returns typed data for analysis.\n‚Ä¢ yql-finance - yql-finance is simple and fast. API returns stock closing prices for current period of time and current stock ticker (i.e. APPL, GOOGL).\n‚Ä¢ finsymbols - Obtains stock symbols and relating information for SP500, AMEX, NYSE, and NASDAQ.\n‚Ä¢ tushare - A utility for crawling historical and Real-time Quotes data of China stocks.\n‚Ä¢ cn_stock_src - Utility for retrieving basic China stock data from different sources.\n‚Ä¢ after-hours - Obtain pre market and after hours stock prices for a given symbol.\n‚Ä¢ pytdx - Python Interface for retrieving chinese stock realtime quote data from TongDaXin Nodes.\n‚Ä¢ pdblp - A simple interface to integrate pandas and the Bloomberg Open API.\n‚Ä¢ tiingo - Python interface for daily composite prices/OHLC/Volume + Real-time News Feeds, powered by the Tiingo Data Platform.\n‚Ä¢ iexfinance - Python Interface for retrieving real-time and historical prices and equities data from The Investor's Exchange.\n‚Ä¢ pyEX - Python interface to IEX with emphasis on pandas, support for streaming data, premium data, points data (economic, rates, commodities), and technical indicators.\n‚Ä¢ alpaca-trade-api - Python interface for retrieving real-time and historical prices from Alpaca API as well as trade execution.\n‚Ä¢ akshare - AkShare is an elegant and simple financial data interface library for Python, built for human beings! https://akshare.readthedocs.io\n‚Ä¢ investpy - Financial Data Extraction from Investing.com with Python! https://investpy.readthedocs.io/\n‚Ä¢ bbgbridge - Easy to use Bloomberg Desktop API wrapper for Python.\n‚Ä¢ alpha_vantage - A python wrapper for Alpha Vantage API for financial data.\n‚Ä¢ FinanceDataReader - Open Source Financial data reader for U.S, Korean, Japanese, Chinese, Vietnamese Stocks\n‚Ä¢ pystlouisfed - Python client for Federal Reserve Bank of St. Louis API - FRED, ALFRED, GeoFRED and FRASER.\n‚Ä¢ market-prices - Create meaningful OHLCV datasets from knowledge of exchange-calendars (works out-the-box with data from Yahoo Finance).\n‚Ä¢ tessa - simple, hassle-free access to price information of financial assets (currently based on yfinance and pycoingecko), including search and a symbol class.\n‚Ä¢ pandaSDMX - Python package that implements SDMX 2.1 (ISO 17369:2013), a format for exchange of statistical data and metadata used by national statistical agencies, central banks, and international organisations.\n‚Ä¢ cif - Python package that include few composite indicators, which summarize multidimensional relationships between individual economic indicators.\n‚Ä¢ finagg - finagg is a Python package that provides implementations of popular and free financial APIs, tools for aggregating historical data from those APIs into SQL databases, and tools for transforming aggregated data into features useful for analysis and AI/ML.\n‚Ä¢ FinanceDatabase - This is a database of 300.000+ symbols containing Equities, ETFs, Funds, Indices, Currencies, Cryptocurrencies and Money Markets.\n‚Ä¢ xlrd - Library for developers to extract data from Microsoft Excel spreadsheet files.\n‚Ä¢ xlwt - Library to create spreadsheet files compatible with MS Excel 97/2000/XP/2003 XLS files, on any platform.\n‚Ä¢ DataNitro - DataNitro also offers full-featured Python-Excel integration, including UDFs. Trial downloads are available, but users must purchase a license.\n‚Ä¢ xlloop - XLLoop is an open source framework for implementing Excel user-defined functions (UDFs) on a centralised server (a function server).\n‚Ä¢ expy - The ExPy add-in allows easy use of Python directly from within an Microsoft Excel spreadsheet, both to execute arbitrary code and to define new Excel functions.\n‚Ä¢ pyxll - PyXLL is an Excel add-in that enables you to extend Excel using nothing but Python code.\n‚Ä¢ mplfinance - matplotlib utilities for the visualization, and visual analysis, of financial data.\n‚Ä¢ market-analy - Analysis and interactive charting using market-prices and bqplot.\n‚Ä¢ QuantInvestStrats - Quantitative Investment Strategies (QIS) package implements Python analytics for visualisation of financial data, performance reporting, analysis of quantitative strategies.\n‚Ä¢ xts - eXtensible Time Series: Provide for uniform handling of R's different time-based data classes by extending zoo, maximizing native format information preservation and allowing for user level customization and extension, while simplifying cross-class interoperability.\n‚Ä¢ data.table - Extension of data.frame: Fast aggregation of large data (e.g. 100GB in RAM), fast ordered joins, fast add/modify/delete of columns by group using no copies at all, list columns and a fast file reader (fread). Offers a natural and flexible syntax, for faster development.\n‚Ä¢ tis - Functions and S3 classes for time indexes and time indexed series, which are compatible with FAME frequencies.\n‚Ä¢ tfplot - Utilities for simple manipulation and quick plotting of time series data.\n‚Ä¢ tframe - A kernel of functions for programming time series methods in a way that is relatively independently of the representation of time.\n‚Ä¢ Rblpapi - An R Interface to 'Bloomberg' is provided via the 'Blp API'.\n‚Ä¢ Quandl - Get Financial Data Directly Into R.\n‚Ä¢ GetTDData - Downloads and aggregates data for Brazilian government issued bonds directly from the website of Tesouro Direto.\n‚Ä¢ GetHFData - Downloads and aggregates high frequency trading data for Brazilian instruments directly from Bovespa ftp site.\n‚Ä¢ Reddit WallstreetBets API - Provides daily top 50 stocks from reddit (subreddit) Wallstreetbets and their sentiments via the API.\n‚Ä¢ td - Interfaces the 'twelvedata' API for stocks and (digital and standard) currencies.\n‚Ä¢ rb3 - A bunch of downloaders and parsers for data delivered from B3.\n‚Ä¢ tidyfinance - Tidy Finance helper functions to download financial data and process the raw data into a structured Format (tidy data), including date conversion, scaling factor values, and filtering by the specified date.\n‚Ä¢ Rmetrics - The premier open source software solution for teaching and training quantitative finance.\n‚Ä¢ YieldCurve - Modelling and estimation of the yield curve.\n‚Ä¢ SmithWilsonYieldCurve - Constructs a yield curve by the Smith-Wilson method from a table of LIBOR and SWAP rates.\n‚Ä¢ AmericanCallOpt - This package includes pricing function for selected American call options with underlying assets that generate payouts.\n‚Ä¢ OptHedging - Estimation of value and hedging strategy of call and put options.\n‚Ä¢ FinCal - Package for time value of money calculation, time series analysis and computational finance.\n‚Ä¢ options.studies - options trading studies functions for use with options.data package and shiny.\n‚Ä¢ blotter - Transaction infrastructure for defining instruments, transactions, portfolios and accounts for trading systems and simulation. Provides portfolio support for multi-asset class and multi-currency portfolios. Actively maintained and developed.\n‚Ä¢ quantstrat - Transaction-oriented infrastructure for constructing trading systems and simulation. Provides support for multi-asset class and multi-currency portfolios for backtesting and other financial research.\n‚Ä¢ FactorAnalytics - The FactorAnalytics package contains fitting and analysis methods for the three main types of factor models used in conjunction with portfolio construction, optimization and risk management, namely fundamental factor models, time series factor models and statistical factor models.\n‚Ä¢ Expected Returns - Solutions for enhancing portfolio diversification and replications of seminal papers with R, most of which are discussed in one of the best investment references of the recent decade, Expected Returns: An Investors Guide to Harvesting Market Rewards by Antti Ilmanen.\n‚Ä¢ tidyquant - Bringing financial analysis to the tidyverse.\n‚Ä¢ timetk - A toolkit for working with time series in R.\n‚Ä¢ tibbletime - Built on top of the tidyverse, tibbletime is an extension that allows for the creation of time aware tibbles through the setting of a time index.\n‚Ä¢ matrixprofile - Time series data mining library built on top of the novel Matrix Profile data structure and algorithms.\n‚Ä¢ Indicators.jl - Financial market technical analysis & indicators on top of Temporal.\n‚Ä¢ MarketTechnicals.jl - Technical analysis of financial time series on top of TimeSeries.\n‚Ä¢ TSFrames.jl - Handle timeseries data on top of the powerful and mature DataFrames.jl\n‚Ä¢ Strata - Modern open-source analytics and market risk library designed and written in Java.\n‚Ä¢ JQuantLib - JQuantLib is a free, open-source, comprehensive framework for quantitative finance, written in 100% Java.\n‚Ä¢ finmath.net - Java library with algorithms and methodologies related to mathematical finance.\n‚Ä¢ portfolio-allocation - PortfolioAllocation is a JavaScript library designed to help constructing financial portfolios made of several assets: bonds, commodities, cryptocurrencies, currencies, exchange traded funds (ETFs), mutual funds, stocks...\n‚Ä¢ Ghostfolio - Wealth management software to keep track of financial assets like stocks, ETFs or cryptocurrencies and make solid, data-driven investment decisions.\n‚Ä¢ IndicatorTS - Indicator is a TypeScript module providing various stock technical analysis indicators, strategies, and a backtest framework for trading.\n‚Ä¢ ccxt - A JavaScript / Python / PHP cryptocurrency trading API with support for more than 100 bitcoin/altcoin exchanges.\n‚Ä¢ PENDAX - Javascript SDK for Trading/Data API and Websockets for FTX, FTXUS, OKX, Bybit, & More.\n‚Ä¢ Scala Quant - Scala library for working with stock data from IFTTT recipes or Google Finance.\n‚Ä¢ Workbench - From Idea to Execution - Manage your trading operation across a globally distributed cluster\n‚Ä¢ Prop - An open and opinionated trading platform using productive & familiar open source libraries and tools for strategy research, execution and operation.\n‚Ä¢ Kelp - Kelp is an open-source Golang algorithmic cryptocurrency trading bot that runs on centralized exchanges and Stellar DEX (command-line usage and desktop GUI).\n‚Ä¢ IndicatorGo - IndicatorGo is a Golang module providing various stock technical analysis indicators, strategies, and a backtest framework for trading.\n‚Ä¢ QuantLib - The QuantLib project is aimed at providing a comprehensive software framework for quantitative finance.\n‚Ä¢ QuantLibRisks - Fast risks with QuantLib in C++\n‚Ä¢ TradeFrame - C++ 17 based framework/library (with sample applications) for testing options based automated trading ideas using DTN IQ real time data feed and Interactive Brokers (TWS API) for trade execution. Comes with built-in Option Greeks/IV calculation library.\n‚Ä¢ Hikyuu - A base on Python/C++ open source high-performance quant framework for faster analysis and backtesting, contains the complete trading system components for reuse and combination. You can use python or c++ freely.\n‚Ä¢ QuantLib - The QuantLib project is aimed at providing a comprehensive software framework for quantitative finance.\n‚Ä¢ QuantLibRisks - Fast risks with QuantLib in Python and C++\n‚Ä¢ XAD - Automatic Differentiation (AAD) Library in Python and C++\n‚Ä¢ QuantLib-Python Documentation - Documentation for the Python bindings for the QuantLib library\n‚Ä¢ Portfolio Optimizer - Portfolio Optimizer is a Web API for portfolio analysis and optimization.\n‚Ä¢ XAD: Automatic Differentation (AAD) Library for Python and C++\n‚Ä¢ QuantConnect - Lean Engine is an open-source fully managed C# algorithmic trading engine built for desktop and cloud usage.\n‚Ä¢ StockSharp - Algorithmic trading and quantitative trading open source platform to develop trading robots (stock markets, forex, crypto, bitcoins, and options).\n‚Ä¢ TDAmeritrade.DotNetCore - Free, open-source .NET Client for the TD Ameritrade Trading Platform. Helps developers integrate TD Ameritrade API into custom trading solutions.\n‚Ä¢ QuantMath - Financial maths library for risk-neutral pricing and risk\n‚Ä¢ LFEST - Simulated perpetual futures exchange to trade your strategy against.\n‚Ä¢ quant - Quantitative Finance and Algorithmic Trading exhaust; mostly ipython notebooks based on Quantopian, Zipline, or Pandas.\n‚Ä¢ fecon235 - Open source project for software tools in financial economics. Many jupyter notebook to verify theoretical ideas and practical methods interactively.\n‚Ä¢ Quantitative-Notebooks - Educational notebooks on quantitative finance, algorithmic trading, financial modelling and investment strategy\n‚Ä¢ Python_Option_Pricing - An library to price financial options written in Python. Includes: Black Scholes, Black 76, Implied Volatility, American, European, Asian, Spread Options.\n‚Ä¢ Stock_Analysis_For_Quant - Different Types of Stock Analysis in Excel, Matlab, Power BI, Python, R, and Tableau.\n‚Ä¢ algorithmic-trading-with-python - Source code for Algorithmic Trading with Python (2020) by Chris Conlan.\n‚Ä¢ MEDIUM_NoteBook - Repository containing notebooks of cerlymarco's posts on Medium.\n‚Ä¢ IPythonScripts - Tutorials about Quantitative Finance in Python and QuantLib: Pricing, xVAs, Hedging, Portfolio Optimisation, Machine Learning and Deep Learning.\n‚Ä¢ Computational-Finance-Course - Materials for the course of Computational Finance.\n‚Ä¢ Machine-Learning-for-Asset-Managers - Implementation of code snippets, exercises and application to live data from Machine Learning for Asset Managers (Elements in Quantitative Finance) written by Prof. Marcos L√≥pez de Prado.\n‚Ä¢ NMOF - Functions, examples and data from the first and the second edition of \"Numerical Methods and Optimization in Finance\" by M. Gilli, D. Maringer and E. Schumann (2019, ISBN:978-0128150658).\n‚Ä¢ py4fi2nd - Jupyter Notebooks and code for Python for Finance (2nd ed., O'Reilly) by Yves Hilpisch.\n‚Ä¢ aiif - Jupyter Notebooks and code for the book Artificial Intelligence in Finance (O'Reilly) by Yves Hilpisch.\n‚Ä¢ py4at - Jupyter Notebooks and code for the book Python for Algorithmic Trading (O'Reilly) by Yves Hilpisch.\n‚Ä¢ dawp - Jupyter Notebooks and code for Derivatives Analytics with Python (Wiley Finance) by Yves Hilpisch.\n‚Ä¢ dx - DX Analytics | Financial and Derivatives Analytics with Python.\n‚Ä¢ frh-fx - A python implementation of the fast-reversion Heston model of Mechkov for FX purposes.\n‚Ä¢ Value Investing Studies - A collection of data analysis studies that examine the performance and characteristics of value investing over long periods of time.\n‚Ä¢ Deep Learning Machine Learning Stock - Deep Learning and Machine Learning stocks represent a promising long-term or short-term opportunity for investors and traders.\n‚Ä¢ Technical Analysis and Feature Engineering - Feature Engineering and Feature Importance of Machine Learning in Financial Market.\n‚Ä¢ Differential Machine Learning and Axes that matter by Brian Huge and Antoine Savine - Implement, demonstrate, reproduce and extend the results of the Risk articles 'Differential Machine Learning' (2020) and 'PCA with a Difference' (2021) by Huge and Savine, and cover implementation details left out from the papers.\n‚Ä¢ systematictradingexamples - Examples of code related to book Systematic Trading and blog\n‚Ä¢ ML_Finance_Codes - Machine Learning in Finance: From Theory to Practice Book\n‚Ä¢ Hands-On Machine Learning for Algorithmic Trading - Hands-On Machine Learning for Algorithmic Trading, published by Packt\n‚Ä¢ Quant-Finance-With-Python-Code - Repo for code examples in Quantitative Finance with Python by Chris Kelliher\n‚Ä¢ QuantFinanceTraining - This repository contains codes that were executed during my training in the CQF (Certificate in Quantitative Finance). The codes are organized by class, facilitating navigation and reference.\n‚Ä¢ Statistical-Learning-based-Portfolio-Optimization - This R Shiny App utilizes the Hierarchical Equal Risk Contribution (HERC) approach, a modern portfolio optimization method developed by Raffinot (2018).\n‚Ä¢ Finance - 150+ quantitative finance Python programs to help you gather, manipulate, and analyze stock market data.\n‚Ä¢ Tidy Finance - An opinionated approach to empirical research in financial economics - a fully transparent, open-source code base in multiple programming languages (Python and R) to enable the reproducible implementation of financial research projects for students and practitioners.\n‚Ä¢ AFML - All the answers for exercises from Advances in Financial Machine Learning by Dr Marco Lopez de Parodo."
    },
    {
        "link": "https://reddit.com/r/Python/comments/1c92iom/introducing_stockdex_a_superior_python_package",
        "document": "I've previously introduced my Python package in this post. Since then, I've significantly enhanced its performance and expanded its capabilities.\n\nWhat My Project Does\n\nA lightweight python package designed for the efficient retrieval of financial data from various sources like Yahoo Finance, Nasdaq, Digrin and JustETF websites (somewhat similar to yfinance). This tool provides functionality akin to yfinance but with broader data access.\n‚Ä¢ Fresh data: Yahoo Finance often delays updates to financial data by several days while Nasdaq and other sources typically update on the day reports are released. Stockdex enables access to this fresher data, such as quarterly earnings.\n‚Ä¢ Broader Data Sources: Unlike yfinance which relies solely on the Yahoo Finance API, Stockdex aggregates data from multiple platforms including Digrin, JustETF, Nasdaq, and Yahoo Finance. For specific examples of data retrieval, refer to this readme.\n‚Ä¢ Access to Historical Data: Yahoo Finance limits access to the most recent five annual or four quarterly reports. Stockdex, however, taps into sources that maintain extensive historical archives not available through Yahoo Finance.\n\nThe package is targeted at people who are interested in financial analysis using python."
    },
    {
        "link": "https://blog.quantinsti.com/python-trading-library",
        "document": "Pre-requisites for learning from this blog:\n\nHere is a table with the Python libraries for a quick look.\n\nPython is widely used to develop trading algorithms due to its extensive ecosystem of libraries tailored to finance and trading.\n\nIn this article, we cover a few widely used Python libraries for quantitative trading, categorized by their functionality. Here are the Python libraries that we will discuss in this blog:\n\nyfinance (Yahoo Finance) is a Python library used to fetch financial data, historical price data, fundamental data, real-time market information, etc. directly from Yahoo Finance. It provides traders, investors, and researchers an easy way to access and analyze financial market data.\n\nAlpha Vantage is another Python library that helps obtain historical price and fundamental data through the Alpha Vantage API. You need an API key to use it. Sign up on their official website to get a free API key. An additional bonus is that it offers technical indicator data such as SMA, EMA, MACD, and Bollinger Bands.\n\nPandas-DataReader allows you to extract Federal Reserve Economic Data, Fama French Data, World Bank Development Indicators, etc. You can access the list of the data sources here.\n\nIBridgePy is an easy-to-use Python library that can be used to trade with Interactive Brokers. It is a wrapper, specifically a Python wrapper, that provides a user-friendly interface to interact with the Interactive Brokers API, providing a simple solution while hiding IB‚Äôs complexities. IBridgePy helps Python to call IB‚Äôs C++ API directly as it acts as a wrapper. Here is an example of how to download the data.\n\nThe following libraries are primarily used for math and data operations.\n\nNumPy (Numerical Python) is an open-source Python library that provides efficient operations for numerical computing. It handles large datasets, performs mathematical operations, and works with multi-dimensional arrays and matrices. Key features of this library include:\n\nThe Pandas library is widely used for data manipulation and analysis, especially with structured data. It provides easy-to-use data structures like DataFrame and Series for handling various data formats. Below are the key features of the Pandas library:\n\nTA-Lib is an open-source library used to perform technical analysis on financial data using technical indicators such as RSI (Relative Strength Index), Bollinger bands, MACD, etc. These indicators help the algorithmic trader to create a strategy based on the findings.\n\nMatplotlib is a Python library that plots 2D structures like graphs, charts, histograms, scatter plots, etc. A few of the functions of matplotlib include-\n‚Ä¢ Colorbar (to add a color bar to the plot) etc.\n\nPlotly is a Python library that interactively helps in data visualization. Plotly was created to add to the features of matplotlib. It helps to make the data more meaningful by having interactive charts and plots.\n\nThe Plotly Python library consists of the following packages:\n\nplotly: Main package that contains all the functionality.\n\ngraph_objs: Contains objects or templates of figures used for visualizing.\n\nCufflinks provides a bridge between Pandas DataFrames and Plotly, enabling seamless plotting.\n\nMake sure cufflinks library is installed using ‚Äú!pip install cufflinks‚Äù\n\nAs you can see from the figure below, there are various tools (marked in red) namely; zoom, hover, pan, autoscale reset axes, etc to make y our plots more interactive and user-friendly.\n\nWe backtest Python trading algorithms using historical market data to assess their performance and validate their effectiveness before deploying them in live trading environments. Backtesting helps traders optimize parameters, mitigate risks, and refine their trading strategies over time. The following Python libraries can be used in trading for backtesting.\n\nBacktrader is an open-source Python library that you can use for backtesting, strategy visualization, and live-trading. Although it is quite possible to backtest your algorithmic trading strategy in Python without using any special library, Backtrader provides many features that facilitate this process. Every complex component of ordinary backtesting can be created with a single line of code by calling special functions.\n\nFor those exploring algo trading, tools like Backtrader simplify backtesting and strategy development, making it easier to experiment and refine trading strategies effectively.\n\nvectorbt is a Python library designed for backtesting, optimizing, and analyzing trading strategies. It leverages the power of NumPy and Pandas for highly efficient computation, making it suitable for large-scale financial data and complex strategies. It is particularly useful for quantitative trading, offering a lightweight yet robust framework.\n\nScikit-learn is a machine learning library built upon the SciPy library that consists of various algorithms, including classification, clustering, and regression, that can be used along with other Python libraries like NumPy and SciPy for scientific and numerical computations. Some of its classes and functions are:\n\nTensorFlow is an open-source software library for high-performance numerical computations and machine learning applications, such as neural networks. Due to its flexible architecture, TensorFlow allows easy computation deployment across various platforms, such as CPUs, GPUs, TPUs, etc.\n\nKeras is a deep learning library to develop neural networks and other deep learning models. Furthermore, Keras can be installed on your system and built on top of TensorFlow, or Microsoft Cognitive Toolkit, which focuses on being modular and extensible. It consists of the elements used to build neural networks such as layers, objectives, optimizers, etc. This library can be used in trading for stock price prediction using Artificial Neural Networks.\n\nTo recap all the key points we've discussed, please refer to the table below for a comprehensive overview.\n\nThe landscape of Python trading libraries offers powerful tools for investors and algorithmic traders. From data analysis with Pandas to machine learning capabilities in scikit-learn, and specialized financial libraries like IbridgePy and Backtraderr, developers have robust frameworks to build sophisticated trading strategies. The key is selecting libraries that align with your specific trading goals, whether quantitative analysis, backtesting, live trading, or complex algorithmic approaches.\n\nNote: The original post has been revamped on 29th Jan 2025 for recentness, and accuracy.\n\nAll investments and trading in the stock market involve risk. Any decision to place trades in the financial markets, including trading in stock or options or other financial instruments is a personal decision that should only be made after thorough research, including a personal risk and financial assessment and the engagement of professional assistance to the extent you believe necessary. The trading strategies or related information mentioned in this article is for informational purposes only."
    }
]