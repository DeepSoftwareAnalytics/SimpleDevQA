[
    {
        "link": "https://refine.dev/blog/react-memo-guide",
        "document": "This article was last updated on September 19, 2024, to add sections on Deep vs Shallow Comparison in Memoization, Profiling Components in DevTools, and Best Practices for Using .\n\nThis post introduces the React Memoization Series and demonstrates the usage of the API. memoizes a functional component and its props. Doing so helps prevent unnecessary re-renderings that originate from the re-renderings of the component's parent / ancestors.\n\nThis is the first post of a three-part series hosted on Refine blog on the use of memoization in React.\n\nThe other two posts in the series cover the usage of React and hooks.\n\nSteps we'll cover in this post:\n‚Ä¢ Best Practices for Using\n‚Ä¢ You can Profile Components in DevTools\n\nMemoization is an performance optimization technique that allows us to minimize the use of memory and time while executing a resource-intensive function. It works by storing the last computed value or object from the function. Memoization lets us bypass the function's costly computations when the function is called with the same parameters repeatedly.\n\nMemoization plays a crucial role in enhancing the performance of a React component. It addresses following shortcomings in React:\n\nReact is all about re/rendering components in the virtual DOM prior to updating the actual Document Object Model in the browser. Re-render in an ancestor component, by default, triggers a re-render in a descendent component.\n\nFor example, a local state update in a parent component causes it to re-render. This, in turn, causes its children to re-render.\n\nSuch behavior in React causes a lot of memory and time to be wasted on useless renderings of the descendent components. Excessive re-renderings, therefore impact a React app's performance negatively.\n\nIn addition, resource intensive functions such as utilities used in data processing, transformation and manipulation lower a React app's performance. Functions used for sorting, filtering and mapping traverse large sets of data and therefore slows down an application.\n\nPerformance of a React app is also adversely effected due to callback functions passed from a parent component to a child. This happens because a new function object from the callback is created in memory every time the child re-renders. So, multiple copies of the same callback function are spun off in runtime and they consume resources unnecessarily.\n\nUsing memoization the right way in React helps in mitigating these drawbacks and facilitates better use of computing resources in a React app.\n\nMemoization can be used in a number of ways for optimizing the performance of a React app. React components can be memoized to prevent unnecessary component re-renders originating from ancestors participating in the component hierarchy. In functional React, component memoization is done using the API.\n\nCaching values of expensive utility functions and memoizing callbacks are two common ways of boosting a React app's performance. Caching function values is done using hook. And callback functions are memoized with the hook.\n\nThe React Memoization Series is a three part guide on how to implement memoization in a React app. Each part demonstrates in the browser console how memoization contributes to performance optimization.\n\nThe three parts are:\n\nIn the first post, we implement memoizing a React component with and demonstrate how unnecessary re-renders coming from ancestor state updates are prevented. The second post covers how caching the value of an expensive utility function with stops repetitive invocations of data heavy computations that slow down a React app. In the third part, we get an idea on how memoization of callbacks passed to child components helps reduce application memory consumption.\n\nWe will begin with an example that involves memoizing a functional component with . In the subsequent posts, we will gradually extend it to include use cases for the and hooks.\n\nThis series is a demo rather than a step-by-step coding tutorial. It is intended to demonstrate how memoization contributes to performance optimization in a React app. We've made the code available here.\n\nAll the components have been already coded. We'll be showing how memoization is implemented using , and APIs by examining relevant code snippets and highlighting lines on the existing components.\n\nWe'll follow the impact of memoization mainly from the browser's console.\n\nIn order to properly follow this tutorial, we recommend you run the app in a browser - since we will be visiting the console to investigate the impact of memoization on our React app.\n\nFor this to happen, please follow the below steps as outlined here:\n‚Ä¢ Open it in your code editor and install the packages:\n‚Ä¢ Use + + on Ubuntu or + + on Mac to inspect the webpage and open browser's console.\n\nIf you look at the project folder in your code editor, you'll find that is created using .\n\nThe app is based on the idea of a list of posts on a blog. There are several components involving a user presented the latest posts and a list of the user's posts. Allow yourself some time to understand the components individually, their relationships, their state changes, and how props are passed through. It is crucial to pay close attention to how the change of a parent's state triggers re-render of its descendants.\n\nLet's dig into the components and check out what's happening.\n\nTo begin with, we have an component that houses .\n\nIf we look inside , we can see that we're storing a state with hook. We also have a toggler function that alters the value of :\n\nIn the JSX, we pass to .\n\nLooking inside , it fetches a list of posts with a click on the button and sets the state:\n\nWe can see that the are sorted with the utility and the first item from the sorted array is then passed to component along with .\n\nThen coming to , it nests the component, which we are going to memoize with .\n\nLet's quickly run through to see what it does:\n\nWe can see that changes its local state of every 3 seconds in the hook. Because of this, should re-render every 3 seconds. So should as a consequence of being a child of :\n\nLet's now focus on . It receives and as props and displays the content of :\n\nNotice we are logging to the console the event when gets rendered:\n\nWhen we check the console, we can expect to see that is re-rendered with a change in from . This would be happening even though does not depend on .\n\nIf we examine closely, we can see that this is indeed the case: we have rendering again and again following an interval:\n\nNotice, rendering is accompanied by at 3 seconds interval, so it is consistent that 's re-renders are happening due to state changes in . That is, they are coming at intervals from 's hook.\n\nAll these re-renders are futile for and costly for the app. So we are going to prevent them using component memoization.\n\nNow, if we memoize with , the re-renders should stop.\n\nSo, in , let's update the component export with the highlighted code:\n\nLooking at the console, we can see that is no longer re-rendered at 3s intervals:\n\nIt is clear that memoizing reduces the number of re-renders. In a real app, this is a huge blessing because re-renders due to frequent likes turn out to be very costly for a social media app's performance.\n\nBut what exactly happened?\n\nWell, with , we produced a new component that re-renders only when its props and internal state is changed.\n\nis a Higher Order Component (HOC) that memoizes the passed in component along with the value of its props. Doing so helps in optimizing its performance by preventing unnecessary re-renders due to changes it does not depend on, e.g. the unrelated state changes in ancestor components.\n\ndoes this by memoizing the component function itself and the accepted props. When the values of the props change, the component re-renders.\n\nWe can see that receives and props.\n\nNow, unlike with , depends on and . And React memo caches these props and checks for incoming changes in them. Incoming changes to them triggers a re-render. So, altering any of or re-renders .\n\nIf we look back inside , we see that originated from there and gets relayed via and to as props. We have a button in the navbar that toggles the value of :\n\nIn the browser, let's try toggling its value to see the effect on memoized .\n\nAdd the following console log statement to in order to log the value of to the console:\n\nWhen we click on the button in the navbar, we can see in the console that re-renders after :\n\nThis is now because React memo caches the props passed to the component and checks for incoming changes. Notice the Boolean value of printed to the console. A change in 's state renews the memoization and a re-render of the component is triggered.\n\nI wanted to share a few best practices for using with some code examples. These can help improve the performance of our React components:\n\nIf a component is being re-rendered unnecessarily due to its parent re-rendering, can help. For example, if we have a component like this:\n\nWe can prevent unnecessary re-renders by wrapping it with :\n\nNow, this component will only re-render if its or props change.\n\nIt‚Äôs important not to use everywhere. If a component‚Äôs props change frequently, memoization can add more overhead than improvement. Use it only when the props don't change often.\n\nBy default, performs a shallow comparison of props. If you‚Äôre passing complex objects or arrays, you might need to write a custom comparison function. For example:\n\nIn this example, we are only checking if the has changed. The component will only re-render if the prop changes, even if changes.\n\nIf a component is static or doesn‚Äôt receive changing props, there‚Äôs no need to use . For example, this component doesn‚Äôt benefit from memoization:\n\nBy following these best practices and using in the right situations, we can optimize performance without adding extra overhead.\n\nThis is actually what we want. Because we don't want to re-render when we don't need it to, and we want to re-render it when we need it to.\n\nIf value of never changed, we know will never be re-rendered because of . In that case, caching doesn't do us any favor.\n\nSo, typically we should use when we want to prevent re-renderings due to state changes that do not concern our component and only allow re-renderings due to prop changes that happen often or are driven by an event.\n\nIn our example, had we resorted to solely to retain the value of and not to prevent re-renders due to changes in or , we would not get much performance benefit.\n\nInstead, we would be bringing the comparison function into the scene for no reason, which adds to the performance cost. So, it is not recommended to memoize a component if its prop values don't change often.\n\nIt is therefore important to figure out the performance gains by measuring and analyzing runtime performance using browser utilities like Chrome DevTools.\n\nReact memo checks for changes between the previous and current values for a given prop passed to the component. The default function carries out a shallow comparison on each passed in prop. It checks for equality of incoming values with the existing ones.\n\nIn our memo, the current states of and are checked for equality to their incoming states. If both values for each prop are equal, the memoized value is retained and re-render prevented. If they are not equal, the new value is cached and re-renders.\n\nIt is possible to customize the comparison by passing in a comparator function to the HOC as a second argument:\n\nFor example, we can specify dependencies for and choose to compare only the props we want to:\n\nHere, we are omitting from the comparison by including only . Now, if we click on button, is not being re-rendered:\n\nThis is because, our checks for equality of incoming values of only and excludes from the comparison.\n\nI wanted to share some tips on Profiling Components in DevTools to help us identify and fix performance bottlenecks in our React app.\n‚Ä¢ Install the React Developer Tools extension for Chrome or Firefox.\n‚Ä¢ Open DevTools ( or ), go to the Profiler tab, and click \"Record\" before interacting with the app.\n\nInteract with the app while recording (e.g., clicking buttons, changing state). The Profiler will track which components re-render and how long each takes.\n\nAfter recording, view the timeline to inspect:\n‚Ä¢ Render Time: Time taken for each component render.\n\nIf a component (e.g., ) is re-rendering unnecessarily, wrap it in to prevent it from re-rendering when props haven't changed.\n\nEnable \"Highlight Updates\" in the React tab to visually see components that re-render, making it easier to spot unnecessary updates.\n\nUsing the Profiler, we can quickly identify and optimize slow re-renders.\n\nI wanted to go over deep vs shallow comparison in memoization and how that affects performance optimization in React, especially when using and other memoization techniques.\n\nBy default, React does shallow comparison to check if a component‚Äôs props have changed to decide whether to re-render it. Shallow comparison means React checks for changes only at the top level of an object or array and doesn't go into nested properties.\n\nEven though and have the same data, during a shallow comparison, they are considered different because the reference is compared, not the content.\n\nIf the and props are primitives (like strings or numbers), the shallow comparison works as expected. But if they are objects or arrays, even a slight change in the reference (e.g., creating a new object) will trigger a re-render.\n\nA deep comparison goes beyond top-level properties and checks all nested properties. It's a bit heavier since every level of the object or array has to be checked.\n\nReact doesn't perform deep comparisons by default in because it can be slow, especially with deeply nested objects or large arrays.\n\nIf shallow comparison isn‚Äôt enough (for example, when passing complex objects as props), we can provide a custom comparator function in to implement deep comparison.\n\nHere, we‚Äôre using 's function to deep compare the entire object. This helps avoid unnecessary re-renders when only the reference changes, but the data inside remains the same.\n‚Ä¢ Complex Data Structures: When passing large or deeply nested objects as props, and you don‚Äôt want to re-render components unnecessarily.\n‚Ä¢ Performance Trade-offs: Deep comparison might be slower than a shallow comparison, so it‚Äôs important to measure and ensure that the performance gain from avoiding re-renders outweighs the cost of deep comparison.\n‚Ä¢ Use shallow comparison whenever possible to keep performance high.\n‚Ä¢ Only use deep comparison when you‚Äôre sure the props involve deeply nested objects that don‚Äôt change often.\n‚Ä¢ Use libraries like or for effective deep comparisons.\n\nIn this post, we acknowledged what memoization is and why it is important in React. We learned about the use of , and APIs for implementing memoization in a React app.\n\nBy investigating a demo blog post app, we observed in the browser console that is very useful in preventing unnecessary, frequent re-renders of a component due to ancestor state changes that it does not depend on. A good example involves a component that accepts props whose values change often and/or on demand. With a custom comparator function, we can choose to specify only the props we want to track for triggering a re-render of our component.\n\nIn the next article, we will turn our attention to the component and memoize a sorting function with hook."
    },
    {
        "link": "https://hygraph.com/blog/react-memo",
        "document": "One of the benefits of using React is its improved performance, which allows your web applications to load faster and allows you to navigate from one page to another without waiting a lot. There are scenarios where we can further improve React‚Äôs native performance, and in this article, we will see how to use to improve performance.\n\nReact Memo allows us to memoize our component code and avoid unnecessary re-renders when the same props are passed to our components, thereby enhancing the performance of our React application.\n\nComponents in React are designed to re-render whenever the state or props value changes. Also, when a parent component re-renders, so do all of its child components. This can impact our application performance because, even if the change is only intended to affect the parent component, all child components attached to the parent component will be re-rendered. Ideally, child components should only re-render if their state or the props passed to them change.\n\nReact Memo is a higher-order component that wraps around a component to memoize the rendered output and avoid unnecessary renderings in cases where the props passed to the child component are the same. This improves performance because it memoizes the result and skips rendering to reuse the last rendered result.\n\nThere are two ways to use :\n\nWe can wrap the actual component directly using memo:\n\nAnother option is to create a new variable to store the memoized component and then export the new variable:\n\nIn the example above, outputs the same content as , but the difference between both is that MemoizedComponent‚Äôs render is . This means that this component will only re-render when the change.\n\n# How to use React Memo\n\nLet us understand React Memo with a Todo List example. We have a simple React-Typescript component here.\n\nIn the component above, we are using state to hold all the todo items in an array, there is an input for adding a new todo to the array. Notice that at the beginning of the component, a console.log() statement will be executed when our component is rendered. The component is a child component of the component and we are passing the todo item list as a prop to it.\n\nIn the code above, a console.log() statement will log a text to show when the Todo component renders. The component receives the todo item list, iterates over it, and passes each todo item as a prop further to a component.\n\nThe component above also has a console.log statement to help us understand when it renders. When we run our application and check the console, we can notice that all three components render.\n\nWe see four logs, one for the parent component (App.js), one for the Todo component, and finally, the TodoItem component renders twice because the initial todo list contains two elements. This is normal for the initial render.\n\nNow, when we change something in the parent component that doesn‚Äôt affect the child components, only the parent component should be re-rendered. For example, when we type anything in the text field, the state of App component changes and it re-renders. This leads to unnecessary renders of the child Todo and TodoList components, even though typing in the App component should not affect the children components.\n\nLet us now memoize some of the children components so that they only render when there is a change in props. The first component that would be memoized is the component. It is important to stop re-renders whenever a user types in the text field.\n\nWe can do this by wrapping the Todo component with memo()\n\nNow that the Todo component is memoized, only the component will re-render whenever its state changes. The component will only re-render when the list prop passed to it changes. Let us now take this a step further to avoid unnecessary re-rendering whenever an item is added to the todo array.\n\nWhen the todo state changes, it affects the list prop, and all existing components on the screen will render for each item added. We want a situation where only the new item added be rendered not the existing ones. We can achieve this by memoizing the component:\n\nHow to use custom comparison function with React Memo\n\nReact Memo makes a shallow comparison and might not function as you wish in some scenarios. If we want to have control over the comparison, we can provide a custom comparison function as the second argument.\n\nFor example, if we are passing an object containing user details as a prop to a component:\n\nThe memoized Profile component will always render even when the user object does not change. Ideally, in this case, we should use in the parent component to fix the object passed to the Profile component. However, to understand a custom comparison function, we will implement that approach for now.\n\nReact Memo doesn't work because it only performs a shallow comparison of the component's properties. Every time the app is updated, the user variable is re-declared. We can use the second argument of the memo and provide a custom comparison function.\n\n# When to use React Memo\n\nWe now understand what it means to memoize a component and the advantages of optimization. This doesn‚Äôt mean that we should memoize all our components to ensure maximum performance optimization of performance üôÉ.\n\nIt is important to know when and where to memoize your component else it will not fulfill its purpose.\n\nFor example, React Memo is used to avoid unnecessary re-renders due to the same props being passed but if the state and content of your component will ALWAYS change, React Memo becomes useless.\n\nAlso, when we need to remember the values of a function or an object, we should hooks like and .\n\nHere are points when we should consider using memo:\n‚Ä¢ The component is medium to big size (contains a decent amount of UI elements) to have props equality check, not very simple and small. We don‚Äôt want to optimize where optimization is more costly than re-rendering.\n‚Ä¢ Component renders with the same props often and its state/context doesn‚Äôt change quite often.\n\nFinally, please note that memo is just a performance optimization. We should NOT rely on it for our component logic to work properly.\n\nIn this article, we have understood what React Memo is and its usage, why, and when to use React Memo. We have also learned that using React Memo correctly prevents unnecessary re-renderings when the next props are equal to the previous ones."
    },
    {
        "link": "https://react.dev/reference/react/memo",
        "document": "You should only rely on as a performance optimization. If your code doesn‚Äôt work without it, find the underlying problem and fix it first. Then you may add to improve performance. Should you add memo everywhere? If your app is like this site, and most interactions are coarse (like replacing a page or an entire section), memoization is usually unnecessary. On the other hand, if your app is more like a drawing editor, and most interactions are granular (like moving shapes), then you might find memoization very helpful. Optimizing with is only valuable when your component re-renders often with the same exact props, and its re-rendering logic is expensive. If there is no perceptible lag when your component re-renders, is unnecessary. Keep in mind that is completely useless if the props passed to your component are always different, such as if you pass an object or a plain function defined during rendering. This is why you will often need and together with . There is no benefit to wrapping a component in in other cases. There is no significant harm to doing that either, so some teams choose to not think about individual cases, and memoize as much as possible. The downside of this approach is that code becomes less readable. Also, not all memoization is effective: a single value that‚Äôs ‚Äúalways new‚Äù is enough to break memoization for an entire component. In practice, you can make a lot of memoization unnecessary by following a few principles:\n‚Ä¢ When a component visually wraps other components, let it accept JSX as children. This way, when the wrapper component updates its own state, React knows that its children don‚Äôt need to re-render.\n‚Ä¢ Prefer local state and don‚Äôt lift state up any further than necessary. For example, don‚Äôt keep transient state like forms and whether an item is hovered at the top of your tree or in a global state library.\n‚Ä¢ Keep your rendering logic pure. If re-rendering a component causes a problem or produces some noticeable visual artifact, it‚Äôs a bug in your component! Fix the bug instead of adding memoization.\n‚Ä¢ Avoid unnecessary Effects that update state. Most performance problems in React apps are caused by chains of updates originating from Effects that cause your components to render over and over.\n‚Ä¢ Try to remove unnecessary dependencies from your Effects. For example, instead of memoization, it‚Äôs often simpler to move some object or a function inside an Effect or outside the component. If a specific interaction still feels laggy, use the React Developer Tools profiler to see which components would benefit the most from memoization, and add memoization where needed. These principles make your components easier to debug and understand, so it‚Äôs good to follow them in any case. In the long term, we‚Äôre researching doing granular memoization automatically to solve this once and for all. Even when a component is memoized, it will still re-render when its own state changes. Memoization only has to do with props that are passed to the component from its parent.\n\nIf you set a state variable to its current value, React will skip re-rendering your component even without . You may still see your component function being called an extra time, but the result will be discarded. Even when a component is memoized, it will still re-render when a context that it‚Äôs using changes. Memoization only has to do with props that are passed to the component from its parent.\n\nTo make your component re-render only when a part of some context changes, split your component in two. Read what you need from the context in the outer component, and pass it down to a memoized child as a prop. When you use , your component re-renders whenever any prop is not shallowly equal to what it was previously. This means that React compares every prop in your component with its previous value using the comparison. Note that is , but is . To get the most out of , minimize the times that the props change. For example, if the prop is an object, prevent the parent component from re-creating that object every time by using : A better way to minimize props changes is to make sure the component accepts the minimum necessary information in its props. For example, it could accept individual values instead of a whole object: Even individual values can sometimes be projected to ones that change less frequently. For example, here a component accepts a boolean indicating the presence of a value rather than the value itself: When you need to pass a function to memoized component, either declare it outside your component so that it never changes, or to cache its definition between re-renders. In rare cases it may be infeasible to minimize the props changes of a memoized component. In that case, you can provide a custom comparison function, which React will use to compare the old and new props instead of using shallow equality. This function is passed as a second argument to . It should return only if the new props would result in the same output as the old props; otherwise it should return . If you do this, use the Performance panel in your browser developer tools to make sure that your comparison function is actually faster than re-rendering the component. You might be surprised. When you do performance measurements, make sure that React is running in the production mode. If you provide a custom implementation, you must compare every prop, including functions. Functions often close over the props and state of parent components. If you return when , your component will keep ‚Äúseeing‚Äù the props and state from a previous render inside its handler, leading to very confusing bugs. Avoid doing deep equality checks inside unless you are 100% sure that the data structure you‚Äôre working with has a known limited depth. Deep equality checks can become incredibly slow and can freeze your app for many seconds if someone changes the data structure later. My component re-renders when a prop is an object, array, or function React compares old and new props by shallow equality: that is, it considers whether each new prop is reference-equal to the old prop. If you create a new object or array each time the parent is re-rendered, even if the individual elements are each the same, React will still consider it to be changed. Similarly, if you create a new function when rendering the parent component, React will consider it to have changed even if the function has the same definition. To avoid this, simplify props or memoize props in the parent component."
    },
    {
        "link": "https://medium.com/@amalhan43/react-memo-optimize-react-functional-components-0e42f91e6579",
        "document": "React.memo is a function that allows you to memoize the result of a functional component‚Äôs rendering. It works by caching the rendered output of the component and only re-rendering it if the inputs (props) to the component change. This can significantly reduce the number of unnecessary re-renders, especially when dealing with complex components or large data sets.\n\nLet‚Äôs consider a simple example where we have a functional component called ‚ÄúUserList‚Äù that renders a list of users. The list of users is passed as a prop to the component. Without using React.memo, any change in the parent component would result in a complete re-render of the ‚ÄúUserList‚Äù component, even if the user list remains the same.\n\nTo optimize the rendering of the ‚ÄúUserList‚Äù component, we can wrap it with React.memo:\n\nNow, if the parent component re-renders but the user list remains the same, React.memo will prevent the ‚ÄúUserList‚Äù component from re-rendering. It will only re-render if the users prop changes."
    },
    {
        "link": "https://dev.to/codeofrelevancy/optimize-react-component-performance-with-memoization-using-reactmemo-3chp",
        "document": "In this article, we will discuss what the function is, how it works, and when to use it in your React apps. Initiating our adventure..\n\nWhat is the React.memo() function?\n\nReact components are programmed to re-render upon the modification of state or props value. Although, this feature may hamper your app's performance as it causes all child components associated with the parent component to also re-render, even if the alteration was meant only for the parent component. The parent component's re-rendering triggers the re-rendering of all its children components as well.\n\nThe function is a higher-order component (HOC) provided by React. It is used to memoize a component, which means that it caches the output of a component and returns it when the input props remain the same. The memoized component will only be re-rendered if its props have changed.\n\nThe function is similar to the lifecycle method, which is used to control when a component should be re-rendered. is a simpler and more efficient way to achieve this, as it does not require you to implement the method.\n\nHow does the React.memo() function work?\n\nWhen you use the function to wrap a component, React will automatically compare the new props with the previous props. If the props are the same, React will use the cached output of the component and will not re-render it. If the props have changed, React will re-render the component and update the cached output.\n\nTo show you what I mean..\n\ncomponent is memoized using the function. This means that if the title and text props remain the same, the component will not be re-rendered.\n\nTo implement the function on a component at the export level, you can use an alternative approach:\n\nMemoization caches the results of expensive functions to prevent repetitive computation and avoid redundant calls. This technique saves time and resources by storing the calculated results for future use.\n\nWhen to use the React.memo() function?\n\nThe function should be used when you have a component that receives props that do not change frequently. Memoizing such a component can improve performance by preventing unnecessary re-renders.\n\nNotice this also, it is important to note that memoizing a component may not always improve performance. If a component receives props that change frequently, memoizing it may actually degrade performance, as React will spend more time checking for prop changes and updating the cached output.\n\nIt is also worth noting that memoizing a component is not a silver bullet for improving performance. There are other techniques, such as using the hook, that can also be used to optimize React components.\n\nIn the upcoming days, I plan to create a well-crafted article that will delve into the functionality of the hook.\n\nWhat is difference between React.memo function and useMomo() hook?\n\nand are both optimization techniques provided by React, but they serve different purposes. Let's see how..\n\nThe main purpose of is to optimize the rendering of a component by caching its output based on its props. It's a higher-order component that you can use to wrap a component and enable this optimization.\n\nOn the otherside, the hook is used to optimize the performance of expensive computations within a component. It allows you to memoize the result of a function call and use the cached result in subsequent renders, as long as the dependencies of the function have not changed. The hook returns the cached result of the function call, which you can use in your component.\n\nTo show you what I mean..\n\nTo wrap things up, the function is a powerful tool that can help you optimize your React components. It allows you to memoize a component and cache its output, which can improve performance by preventing unnecessary re-renders. Even so, it should be used with care and only when it is appropriate for your specific use case..\n\nPlease consider following and supporting us by subscribing to our channel. Your support is greatly appreciated and will help us continue creating content for you to enjoy. Thank you in advance for your support!"
    },
    {
        "link": "https://day.js.org/docs/en/plugin/utc",
        "document": "UTC adds APIs to parse or display in UTC.\n\nBy default, Day.js parses and displays in local time.\n\nIf you want to parse or display in UTC, you can use instead of .\n\nReturns a cloned object with a flag to use UTC time.\n\nReturns a cloned object with a flag to use local time.\n\nReturns a indicating current object is in UTC mode or not."
    },
    {
        "link": "https://day.js.org/docs/en/parse/utc",
        "document": "By default, Day.js parses and displays in local time.\n\nIf you want to parse or display a date-time in UTC, you can use instead of .\n\nWhile in UTC mode, all display methods will display in UTC time instead of local time.\n\nAdditionally, while in UTC mode, all getters and setters will internally use the and methods instead of the and methods.\n\nTo switch from UTC to local time, you can use dayjs#utc or dayjs#local."
    },
    {
        "link": "https://freecodecamp.org/news/javascript-date-time-dayjs",
        "document": "When it comes to handling dates and times in JavaScript, developers often find themselves grappling with the complexities of the built-in object.\n\nWhile vanilla JavaScript provides fundamental functionality, it can be quite cumbersome to work with, especially when dealing with parsing, formatting, and manipulating dates.\n\nThis is where external libraries like DayJS come into play, offering a plethora of advantages that make working with dates and times a breeze.\n\nIn this article I am going to introduce you to DayJS and how this tiny library can hugely improve your code base and productivity.\n‚Ä¢ How to install the DayJS library\n‚Ä¢ How to work with dates and time within JavaScript\n‚Ä¢ How you can utilise the DayJS library to make these functions easier, more concise, and more readable\n‚Ä¢ Comparisons between executing functionality in both vanilla JS and DayJS\n‚Ä¢ Useful functions available within the DayJS library\n‚Ä¢ Quick Intro to the Date Object in JavaScript\n‚Ä¢ How to Install the DayJS Library\n‚Ä¢ How to Add to or Subtract from Date and Time\n‚Ä¢ How to Compare Dates in DayJS\n‚Ä¢ How to Get the Difference Between Two Dates\n‚Ä¢ How to Get the Start or End of a Time Period\n‚Ä¢ How to Combine Functions in DayJS\n\nYou can use the object in JavaScript to work with dates and periods of time. But sometimes working with the object can be cumbersome, and the date / time can be hard to manipulate.\n\nLet's look at how to get today's date within JavaScript:\n\nEasy enough right? This will give us an ISO date (this is a universal date format) which ouputs like this:\n\nSo you can see that in , the marks the point in which the Time part of the Date begins. Then the following numbers are . The at the end means there is no timezone specified and should utilise UTC timezone (it's pronounced \"Zulu\").\n\nYou can read more about this format here.\n\nNow, I'm not saying the other methods of working with dates and time are wrong, but due to their complexity, for me, they just don't seem worth the hassle.\n\nWhen dealing with date and time in code, I want an easy to use, out of the box solution that adds readability to my code and offers flexibility.\n\nThis is where DayJS comes into play. It's an alternate way to handle dates and time in JavaScript, in the form of a libary.\n\nThis library, unlike others, is extremely small in size. For example there is another common libary used by some developers called , but its file size is very large. Moment.js itself is 280.9kb, and this increases to 467.6kb after including the timezone library (allowing you to set default timezones, and manipulate dates based on specific timezones).\n\nLarge imports and library files are something we really want to avoid when developing for both the web and mobile to help increase loading speeds and bundle sizes.\n\nDayJs comes in at a impressive 2kb ‚Äì that's an extremely small file size, especially considering its capabilities and functionality.\n\nHow to Install the DayJS Library\n\nIn order to learn the most from this tutorial, I highly reccommend installing DayJS so you can follow along with the examples and points made.\n\nDayJS is easily installed via the yarn or npm package managers using the following commands\n\nTo use DayJS in your file, simply import it using the regular import syntax:\n\nWorking with dates and times in vanilla JavaScript often involves multiple method calls and calculations. This makes the code too verbose and challenging to read.\n\nThe DayJS library addresses this issue by providing a much more intuitive and streamlined API, which greatly simplifies date and time manipulation.\n\nConsider the task of formatting a date into a specific format, such as \"YYYY-MM-DD HH:mm:ss\", (year-month-date 24Hour:minutes:seconds).\n\nHere's how you could do it using vanilla JavaScript's Date object:\n\nThe above code utilises the built-in functions to gather various parts of the date object.\n‚Ä¢ ‚Äì gets the current hour in 24hr format\n\nIt then builds a complex interpolated string variable containing all the required parts as we'd expect to see them, that is with leading 0's for single digit months / days / minutes / seconds, (which is what the function is doing).\n\nAs you can see, this is highly unreadable ‚Äì and we could refactor this to make it more readable. But the concept still stands.\n\nLet's take the example below. Here we're creating a function that will take in a JS object, and return a formatted date using the format:\n\nYou may be asking why we had to add 1 to the month. As I tried to explain in the comments, is zero-based. This means that January equals 0, so to get the correct month number, we need to add 1 to all the months. This means that now January would become 1.\n\nSo, in the above code we've got the relevant parts of the Date object we need (day, month, year). Now we've got do some formatting to these parts, to make them fit our expected outcome of 2 digits for day and month.\n\nSo if we were to put it all together, we'd get the following code:\n\nNow that's a combination of 19 lines of code, 6 object-based functions, and 1 utility function ‚Äì and it's also highly inflexible.\n\nHow can DayJS help make this easier?\n\nLet's see how we could accomplish this in DayJS:\n\nThat's it! In 3 lines of code, we've retrieved the current date and time using the function, formatted it to the provided dateTime format using a string parameter, and logged out the ouput.\n\nIn the above code we're using the utility function. This function allows us to pass our preferred date format, based on a common JS format syntax.\n\n= numeric year = numeric month of the year as 2 digits = numeric date as 2 digits = 24hour clock for hours = 2 digit minutes = 2 digit seconds\n\nAll seperated with hyphens and colons.\n\nFor a list of all possible formats, see the DayJS documentation format options here.\n\nI think we can all agree that 3 lines of readable code are far superior to 19 lines of convoluted code.\n\nThe DayJS library offers a modular design that allows developers to include only the specific functionalities they need.\n\nThis modularity not only enhances the library's flexibility but also helps in optimising the size of your application bundle. Here's a closer look at how DayJS achieves modularity and its implications for application size.\n\nDayJS is designed as a set of individual plugins that provide various features. These plugins can be included or excluded based on your project's requirements.\n\nSome of the available plugins cover features like timezone support, duration calculations, custom parsing, and more advanced formatting options.\n\nThis modular structure ensures that you only load the parts of the library that you'll actually use, preventing unnecessary bloat in your application.\n\nHere's a simplified example of how you can leverage modularity in DayJS:\n\nAbove, as you can see in the comments, we are simply importing DayJS, as well as the module. We then simply create a new object and set the timezone to New York America. This means that the date and time will be current date/time in New York, rather than the DayJS default UTC.\n\nThe modularity of the DayJS library provides developers with the flexibility to tailor their date and time handling to specific project needs. This not only keeps your codebase clean and focused but also optimizes the size of your application bundle.\n\nBy including only the required functionalities, you can enhance the performance of your application, particularly in terms of loading times for users.\n\nThis is a complete contrast to vanilla JavaScript's object which, because it is baked into the JavaScript language, it cannot be overwritten, extended, or have particular elements removed.\n\nWait, what does mutability mean?\n\nMutability refers to the ability of an object's state to change after it's created.\n\nIn programming, a mutable object can be modified. That is, its properties or values can be altered after its initial creation. This can lead to unexpected changes and side effects, potentially affecting the behavior of the program.\n\nThis is especially true when dealing with dates and times. Vanilla JavaScript's Date object is mutable, meaning that altering one instance can inadvertently affect others.\n\nThis is why the object has methods on the object itself. So when calling these methods, it affects the object itself.\n\nMaybe an example will help:\n\nHere we have used the command to initialise a new date object. This object is mutable, and to get an updated value, we have to mutate the orginal object because its mutable. We do this using the function.\n\nWhen using JavaScript's built in Date functionality you have to be careful how you are utilising and modifying the date objects. You can become entangled in a web of unexpected outcomes if you begin modifying the original date object too much.\n\nIn contrast, immutability means that an object's state cannot change once it's created, as it doesn't make \"changing\" actions on the actual object itself.\n\nWhen working with immutable objects, you create a new instance with modified values instead of altering the original. This helps ensure that your data remains consistent and predictable throughout your program.\n\nImmutable data structures are often favored in functional programming and can lead to more robust, easier-to-maintain code.\n\nWhen you perform operations on a DayJS object, such as adding or subtracting time, the library returns a new instance with the modified value, leaving the original instance unchanged.\n\nThis approach prevents unexpected changes to your data and reduces the risk of introducing errors that can be hard to trace.\n\nConsider the following example using DayJS:\n\nUsing DayJS you can modify the original date object as much as you want using the various available functions, without discarding the original value. This means that it can be used / accessed at any time.\n‚Ä¢ None Predictability: Immutability ensures that once a date or time object is created (set), it won't change unexpectedly throughout your code. This makes it easier to reason about your program's behavior.\n‚Ä¢ None Debugging: Mutable objects can lead to difficult-to-trace bugs when their values change unexpectedly. With immutability, you can be confident that a date or time won't change without your explicit intent.\n‚Ä¢ None Parallel Processing: In multithreaded or parallel programming environments, immutable data structures are inherently thread-safe. This can prevent race conditions and synchronization issues.\n\nNote: You can achieve an \"immutable\" like work around by cloning the original object like so:\n\nThis code creates a clone function, which takes the original date, and then creates a new date from the original and returns it. This allows you to keep the original date, but make some modifications to a replica of that date, without modifying the original.\n\nThe downside to this is more memory usage, and the complexity overhead.\n\nParsing date strings can be a real challenge in vanilla JavaScript, particularly when handling non-standard formats.\n\nDayJS offers an extensive set of parsing options, making it much more versatile when dealing with a wide range of input formats. This feature proves especially valuable when working with data from diverse sources or APIs that might have different date representations.\n‚Ä¢ None User Input: When dealing with user input, such as dates from forms, users might enter dates in various formats. DayJS's parsing capabilities enable you to handle these inputs accurately and consistently.\n‚Ä¢ None Database Interaction: Databases might store dates in different formats or time zones. DayJS's parsing can assist in correctly interpreting these dates for use within your application.\n‚Ä¢ None API Responses: APIs often return date and time data in standardized formats like ISO 8601, but they can also vary. DayJS enables you to parse API responses easily, ensuring correct data representation in your application.\n\nHow this Compares with Vanilla JavaScript:\n\nVanilla JavaScript's Date object lacks the same level of parsing flexibility. While it can handle some standard formats (ISO8601 / RFC2822) and a few other variations, handling non-standard or diverse formats can be challenging. You often need to manually split the date string and perform calculations to create a valid Date object.\n\nLet's say we had a en-GB date, (day/month/year). By default the object doesn't cater for this. Meaning we have to parse it ourselves by splitting the string into parts, and passing these to the call.\n\nIf you tried to pass directly to the call you would get an error, however in en-US format (month/date/year) it works fine.\n\nHere, you can see that knowledge of how the object works is necessary. If this were in an actual application, testing would be necessary to ensure we don't get any errors when parsing from multiple sources.\n\nDayJS builds on 's core functionality, and for me adds one of the best parsing options for developers. It allows you to pass any date string to the function, along with the format of that string.\n\nNote: This does require adding the plugin from DayJS ‚Äì this can be imported very easily.\n\nThis means that when dealing with multiple sources, you can tell DayJS to parse the date string according to how the source is presenting it.\n\nNormally I'd say store all dates (where you have control over such thing) as UTC ISO8601 date strings, as then you have a solid baseline, and can convert these to the relevant timezone when needed.\n\nBreaking down the function, we can see it can receive multiple parameters. These are:\n‚Ä¢ None string (string) ‚Äì this is the string representation of the date you'd like to create.\n‚Ä¢ None format (string) ‚Äì this is the format of the string you're passing in (in the same way we did with the function).\n‚Ä¢ None timezone / locale (string) ‚Äì Locale key to use when parsing.\n‚Ä¢ None strict parsing (boolean) ‚Äì Strict parsing requires that the format and the input match exactly including delimiters.\n\nSo what does all this mean? Well, it means we have a lot more control over our parsing / creating of dates.\n\nHopefully you can see that DayJS makes parsing and working with dates a lot easier. It offers a multitude of different and flexible ways to parse various dates, making working with multiple sources far easier than simply using the built in object.\n\nWhat Else Can DayJS Do?\n\nMany times I've been asked to calculate a date in the future by adding a number of days to the current date, or subtracting a number of hours from the time.\n\nHow to do this in Vanilla JavaScript:\n\nUsing JavaScript's object we can do this by using the functions. We do this by:\n‚Ä¢ Getting the number of days to add (5 days)\n‚Ä¢ Using the function on the object by obtaining the date portion of the Date object, and adding on 5 days,\n\nSo for example, could return 16, so we're resetting the date portion to 16 + 5 = 21. So then the date would be the 21st rather than the 16th.\n\nor condensed (if lines of code are a concern) to:\n\nAlthough concise, it loses its readability somewhat.\n\nHow to do this in DayJS:\n\nDayJS has a naming convention that is more readable for its functions. This means when reading through your code, you can see what it is doing more clearly.\n\nFor example taking the same example as above and writing it in DayJS would look something like this:\n\nHere we are maximising the usage of function chaining amd calling on the returned dayjs object. We're passing in a number we want to add, as well as a time period to add (in this case ). The DayJS library will then take care of adding 5 days to our current date. Then it returns this date in the format of an ISO string.\n\nThis can also be done with subtracting days as follows:\n\nOnce again the clarity of the DayJS library allows for the user to read it more like plain English: \"Subtract 5 days from this DayJS object and return as an ISO string.\"\n\nWhen working with dates, there will often be times where you need to compare date objects ‚Äì for example checking whether one date is before or after another specific date.\n\nWith the JavaScript object, you'd usually do this using the (>) or (<) operators.\n\nBut it can often be confusing which way around these operators should be used. This is because to apply the operators to dates, the dates are converted to timestamps under the hood, and then compared chronologically.\n\nAlthough this seems very simple to read and work with, DayJS offers a great API for dealing with date comparison, which can be a little easier to read straight away.\n\nNow say we want to check if date1 is before date2 ‚Äì we can use the API function. I and many other developers find it far clearer as to what the code is actually doing, rather than having to think about which operator the code is using.\n\nYou can also use acheieve a similar outcome with the function, checking if date1 is after date2.\n\nOne API function I find much more reliable is the function. As many JavaScript developers will know, when checking the equality of objects, especially developers new to the language, it can be confusing when to use vs .\n\nDayJS removes this unknown, and gives a clear / readable function to do this for you.\n\nSay we want to check that a date falls in between two ranges. Again, DayJS makes this easier, with the function. Using the function gives us several other benefits:\n‚Ä¢ None Easy Date Range Checking: Instead of manually comparing dates and performing arithmetic operations, you can use to easily check if a date is within a specified range.\n‚Ä¢ None Readability and Maintainability: Using makes your code more readable and understandable. It clearly conveys the intent of checking whether a date falls within a certain range.\n‚Ä¢ None Support for Inclusive and Exclusive Ranges: The function in DayJS allows you to specify whether the start and end dates are included or excluded from the range. This gives you flexibility in defining your date intervals.\n\nAs you can see, the functions , , , and make it clearer what the code is checking.\n\nHaving such verbose names shows a clear intent of what the function is doing (as opposed to JavaScript's built in methods using operators, or mathmatical conversions). The clear and concise nature of the API functions may be helpful for junior developers, or when simply skimming through code.\n\nThis is certainly more apparent with DayJS functions like:\n\nThe function makes obtaining the difference between two dates so simple. Much easier than with the standard object!\n\nWhen would we want to do this, though? Say you were building a user portal and you wished to display the number of days or hours since your last visit. Or a countdown app, that can show us how many days, weeks, hours until a particular date and time. You could do all this using the function.\n\nLet's take a look at the function:\n\nBut milliseconds isn't always useful for UI elements, where we may want to display days, weeks, or months.\n\nFortunately for us, DayJS allows us to specify the denonmiation of time we'd like to return the difference as.\n\nGoing back to our example of user UI, we could have a toggle which could switch between multiple denominations of time. This would show the user multiple timeframes since their last login, or how many days or hours they've spent completing a game etc.\n\nBy default, will truncate the result to zero decimal places, returning an integer. If you want a floating point number, pass true as the third argument, which will give you a more accurate difference.\n\nOk, but why is this so much better than using the object in JavaScript? Well let's look at how we'd do this with .\n\nOff the bat, we've had to hard code the function to only return . To allow for the same variations as we get in the library we would have to write our own extension function, which would handle each combination of conversion needed.\n\nFor example, getting the difference in months could be calculated slightly differently:\n\nBut again, it's just more and more complex code to do something that a tiny library could do in a maximum of 3 lines of code. It's just not as flexible and easy to use as DayJS is.\n\nHow to Get the Start or End of a Time Period\n\nand are two more great functions within the DayJS library. They allow you to easily return the start and end of a date period.\n\nFor example you could get the start / end of the day, week, month, or year. This could be handy when needing to calculate how many days are left in a month. Some months have more days than others, but we don't want to have to calculate / keep track of this somewhere in our code.\n\nLet's look at how you can use it:\n\nIf we wanted to accomplish the same thing with vanilla JavaScript, we would have to do something like this:\n\nAs you can see, DayJS makes handling beginning and end of time periods far easier than using pure JavaScript. JavaScript tends to require more code, because you would need to write your own implementation of each of these methods.\n\nHow to Combine Functions in DayJS\n\nAs already discussed, DayJS allows for chaining of functions, making it a highly powerful tool.\n\nTake a scenario where we have a user portal and we want to know if the time between today and the end of the month is greater than 7 days to determine what UI element to display (for example \"expiring soon\" or \"keep going\").\n\nYou can do this in fewer than 5 lines of code with DayJS like so:\n\nWhat is it doing?\n‚Ä¢ Getting the current date and time\n‚Ä¢ Using function chaining and immutability to: a. get the end of the current month b. get the difference between the current end of month and current date and time.\n‚Ä¢ Checking if the is less than or equal to 7\n‚Ä¢ If so, displaying an message.\n\n\"Oh come on we could do this in JavaScript still\" I hear you saying. Well, yes ‚Äì like all the other examples, you could do it in JS. But again, it would take more effort and code which needs to be maintained. Here's what it would look like:\n\nIn essence, the end goal of this article was to highlight a helpful library that makes working with dates and times far easier. The code is much more concise and easier to read than the standard built in Date object within JavaScript.\n\nI'm not saying that any of usages of object in this tutorial are wrong or bad. I'm just pointing out that you don't always need to write cumbersome, over-complicated code when there is a free libary available. Especially when it's extrememly small (negligible) in size. It'll also have miniscule impact on your code's bundling or running, and it offers you so much in terms of benefits.\n\nGo check it out and add it to your next or existing project. Give it a try, and let me know what you think via twitter.\n\nYou can find out more about DayJS and take advantage of all its capabilities here on their website."
    },
    {
        "link": "https://github.com/iamkun/dayjs/issues/1284",
        "document": "Describe the bug\n\n I want to format UTC date (comes from backend) with current timezone. Can't find a way to do it. But formats a relative string, keeping in mind current timezone.\n\nExpected behavior\n\n It's a bit inconsistent that relative formatting of UTC date respects current timezone and absolute doesn't.\n\nThe only problem here is to format utc time with current timezone. I can't find any flag such as , so absolute date is formatted relative to current timezone."
    },
    {
        "link": "https://stackoverflow.com/questions/72513328/dayjs-creating-date-in-specific-timezone",
        "document": "I was developing a timetable using dayjs. I would like to set the timetable to show something likes UTC-9 date regardless of user's local time. I tried with dayjs's timezone and utc mode. Both change the time to the correct time but not the date. If I set PC time to other date, dayjs still showing that date instead of UTC-9 date. Thanks."
    },
    {
        "link": "https://dev.to/wdp/best-practices-for-usestate-and-useeffect-in-react-4aea",
        "document": "This article cover image was created with the assistance of DALL¬∑E 3\n\nWelcome to the world of React! A place where creating dynamic web pages is fun, exciting, and quite confusing sometimes. You've probably heard of and hooks. These are like tools in a toolbox, each with a special purpose. Let's make sense of when and how to use them, especially focusing on avoiding common mix-ups.\n\nThink of as a notebook where you jot down important things that your web page needs to remember. It's perfect for keeping track of things like user input, or calculations based on that input.\n\nWhen to use\n‚Ä¢ Remembering values: Use for things your component needs to remember and change, like a user's name or a to-do list item.\n‚Ä¢ Calculating on the fly: When you have a value that needs to be updated based on other things you‚Äôre remembering (like adding up prices in a shopping cart), is perfect. That‚Äôs called a derived state.\n\nAnother powerful aspect of is initializing state based on . This approach is particularly useful when your component needs to start with a predefined value, which can then be updated based on user interactions or other changes within your component.\n\nIn the example below, the component receives as a prop and uses it to set the initial state for . This state can later be updated, for example, in response to user actions.\n\n\n\nNow, let's talk about . It's like a helper who does tasks outside of what's on the screen, like fetching data from the internet, setting up subscriptions, or doing things after your component shows up on the page.\n\nWhen to use\n‚Ä¢ Fetching data: If you need to grab data from somewhere else (like a server), is your go-to.\n‚Ä¢ Listening to events: Setting up things like timers or subscriptions is what excels at.\n‚Ä¢ Cleaning up: can also clean up after itself, which is handy for things like removing event listeners.\n\nLet's explore scenarios that demonstrate the strength of .\n\nFetching data from an API is a classic use case for .\n\n\n\nIn this case, is ideal because data fetching is asynchronous and doesn't directly involve rendering the UI. The effect runs after rendering, ensuring that fetching data doesn't block the initial rendering of the component.\n\nListening to the browser's window resizing and adjusting the component is a great use of . This is a side effect because it involves interacting with the browser's API and needs to be set up and cleaned up properly, which handles elegantly.\n\n\n\nA common mix-up is using for tasks that can handle more efficiently, like deriving data directly from other state or props. Let's clarify this with an example.\n\nImagine you have a list of fruits and you want to show only the ones that match what the user types in a search box. You might think about using like this:\n\n\n\nIn this example, we're using to update every time changes. This approach, however, isn't ideal. Why?\n‚Ä¢ Unnecessary Complexity: introduces an additional layer of complexity. It requires tracking and updating another state ( ) which depends on .\n‚Ä¢ Risk of Errors: With , you run the risk of creating bugs or performance issues, especially if your effect interacts with other states or props in complex ways.\n‚Ä¢ Delayed Update: Since effects run after render, there can be a slight delay in updating , potentially leading to a brief mismatch in what the user sees.\n\nBetter way: using useState for derived state\n\nA simpler and more effective approach is to calculate the filtered list directly using , like this:\n\n\n\nIn this approach, is recalculated immediately whenever changes. This ensures the filtered list is always in sync with the user's input, without the extra step and delay of . It's simpler, more efficient, and reduces the chance of errors related to state synchronization.\n\nOther common pitfalls and best practices\n\nForgetting dependencies in useEffect: A typical mistake is not correctly specifying the dependency array, leading to unexpected behavior.\n\nAn example of that would be omitting in the dependency array of the example above, which could prevent the component from updating when the user changes.\n\nIncorrect state updates: In , ensure to use the functional update form when the new state depends on the previous one.\n\n\n\nUsing the functional update form in , like , ensures that you always have the most recent state value, especially important in scenarios where the state might change rapidly or in quick succession, such as in fast user interactions.\n\nIn React, and serve distinct purposes. is your go-to for tracking and reacting to changes within your component, ideal for direct state management and calculations based on state. On the other hand, is perfect for handling external operations and side effects, like fetching data or interacting with browser APIs. Understanding when to use each will greatly improve the efficiency and reliability of your React components."
    },
    {
        "link": "https://freecodecamp.org/news/how-to-use-the-usestate-and-useeffect-hooks-in-your-project",
        "document": "Hooks allow function components to have access to state and other React features, such as lifecycle methods. These Hook features were introduced to React version 16.8.\n\nOne of the interesting things about the Hook features is that they let you use React without classes. This, in turn, helps simplify your codebase and helps you write cleaner and more intuitive code.\n\nIn this article, you will learn how to make use of the common Hooks in your project.\n\nLet's go over some of the reasons why you might want to use Hooks in your project:\n‚Ä¢ None Easy to use and understand: With Hooks, you can write more straightforward code. These Hook commands can only be written inside a functional component.\n‚Ä¢ None Reusable code: Hooks allow you to reuse a particular logic used in one component across multiple other components.\n‚Ä¢ None Better optimization performance: Hooks offer a more efficient approach to utilizing React functionalities like state and lifecycle functions, resulting in improved performance as compared to class components in some situations.\n\nThe React Hook features are of different types, ranging from the , , , , and so on.\n\nThere are a few important rules when it comes to the React Hook features that should be strictly followed. Let's go over them in the following sections.\n\nHooks should not be used inside a class component ‚Äì they can and should only be called inside the React function.\n\nThis first rule essentially specifies that a Hook component should not be found in a class component, but in a functional component.\n\nHere is the wrong way of implementing the Hook feature:\n\nAnd here is the correct way of implementing the Hook feature:\n\nThe code example above shows a proper way of using a Hook feature.\n\nIf you use a Hook feature in a class component, just like in the first example, your code will raise an error. Therefore, you can only implement a Hook inside a function component.\n\nHooks can only be called at the top level of a component\n\nYou can only implement/call a React Hook at the top level of a component before any other code.\n\nUsing the code from the previous section as an example, you can see that immediately after .\n\nThe next thing that comes is the Hook command ‚Äì in that example we used the Hook. That is what the second rule is all about.\n\nHooks cannot be used in a conditional statement\n\nWe have different types of conditional statements/rendering ranging from , , and so on.\n\nThe above rule means that conditionals cannot be applied directly to Hooks. This is the case because Hooks are called in the same order on every render of a functional component.\n\nYou can conditionally run Hooks within a functional component, but for this to work, this condition must be determined by top-level logic and should not be nested within any other blocks or components.\n\nThe reason for this is because Hooks need to be invoked at the highest level of the component, rather than under conditions, loops, or nested functions.\n\nHere is an example:\n\nFrom the example above, the hook is executed conditionally dependent on the value of the state variable.\n\nClicking the button causes the value of to alternate, either activating or deactivating the effect depending on the updated value.\n\nThis is deemed appropriate because the Hook is invoked at the highest level of the component and its condition is determined by the overarching logic within the component.\n\nHow to Use the useState Hook\n\nThe React Hook enables you to have state variables in functional components.\n\nTo make use of the state Hook, you must first import it into your project by using the command.\n\nThe way works is that it gives us two variables. The first variable is known as the value of the state, and the second variable is a function used to update the state.\n\nHere is an example of how to go about this:\n\nFrom the code example above, you can see that the state Hook was used in a functional component and not a class component.\n\nand are the two variables of the state Hook, where is the current value of the state and is used to update the value of the state. Therefore, whenever the button is clicked, will update the value of the count.\n\nHow to Use the useEffect Hook\n\nThe hook in React is like a handy tool for functional components. It helps manage tasks that aren't directly related to showing stuff on the screen, like fetching data from the internet, retrieving data from API endpoints, or setting up timers. It can be used to update components even after they've been shown, making your app more dynamic.\n\nHere's a basic example of how is used to fetch data from an API endpoint:\n\nIn the code example above, is a functional component which utilizes React hooks, specifically and , to handle state management and execute side effects. The hook is used to initialize a state variable called . This variable will store the data retrieved from an API endpoint.\n\nThe hook is used to request data from the API endpoint once the component initially renders. Within the , an asynchronous function is defined to fetch JSON data from the specified API endpoint using the fetch API.\n\nIf the data fetching is successful, the returned JSON data is saved in the data state variable using the function supplied by the hook.\n\nThe hook also optionally returns a cleaning function, which is currently empty but can be used for any necessary cleanup logic.\n\nIn the component's JSX, the fetched data is conditionally rendered. If the data is not null, a list is produced using items extracted from the data array using map.\n\nFinally, the function is exported as the default export from the module, allowing it to be imported and utilized in other sections.\n\nAs a developer, React Hooks are a very useful and powerful tool for functional components that make your work easy.\n\nI believe that at this point you now know what a React Hook is and how to use the most popular ones.\n\nThanks for reading, and happy coding!"
    },
    {
        "link": "https://stackoverflow.com/questions/66267135/understanding-react-hook-useeffect-best-practice",
        "document": "You mentioned best practice so I'll just cover what occurs to me. There's actually a lot of cool things at play here.\n\nAs others have mentioned runs after every render, including the first. It's effectively both and .\n\nRender is running twice because the is changing react state after the first render.\n‚Ä¢ React runs render again to deal with the new state of\n\nThe simplest fix would be to set the first as a default during the first render. This way it won't have to change during the effect.\n\nThen move the code to set inside the interval with .\n\nYou can actually do better, though, because just by putting the time of day in react state you're breaking the minimal essential state principle, which is fairly important in declarative programming. (note: I just made up that term. I don't think there's a good term for it yet.) What I mean by this is that is entirely derived from , which is already in react state, so there is no reason (besides performance issues) to have both held in react state. Anytime this happens you should consider eliminating the redundant state. In this case this would involve deleting the state and just writing\n\nAs far as I can tell, the only reason to ever hold onto as state is if your were expensive and if rendering happened more often than once a second, but even in that case you would just want to use reacts memoization. That would look like\n\nLooks similar, right? It's basically the same, but it only runs during the render, and therefore can't cause the double render issue you're having. Specifically, will run during the first render, but then will only rerun on any subsequent render if has changed; otherwise it will return the previous that was used.\n\nOne last thing worth mentioning. You pass into your , but this is actually wrong. It will work, but it's not the intended use case. That array is used to tell react what state the effect function is reading from to cause its side-effects, but you're not reading from date, so you don't need to rerun the effect when changes. What you really want is to pass in ‚Äîno state. That way react knows that you side-effect doesn't depend on anything, and should only run once during the first render. Right now your use of an interval rather than a timeout is kind-of pointless, as react is canceling and reestablishing the interval on every render.\n\nWith all the changes I've described so far your component would look like.\n\nI also switched to string templating, which I think is nicer, but that's more of an opinion."
    },
    {
        "link": "https://selcuk00.medium.com/common-mistakes-and-best-practices-with-reacts-usestate-hook-cd25ce2991ee",
        "document": "React‚Äôs useState hook is a powerful tool for managing state in functional components. However, its simplicity can sometimes lead to misuse. Let‚Äôs dive deeper into common mistakes and best practices to help you write more efficient and bug-free React code.\n\nReact‚Äôs state is immutable and should never be modified directly. When you use useState, React expects you to treat the state as read-only and use the setter function to update it.\n\nDirect modifications don‚Äôt trigger re-renders and can lead to unexpected behavior. Always use the setter function and create a new object or array when updating state.\n\nWhen your new state depends on the previous state, using the current state value directly in the setter function can lead to race conditions, especially in scenarios with multiple rapid updates.\n\nThe functional update form ensures you‚Äôre always working with the most recent state value.\n\nInitializing state with props can lead to stale data if the props change but the state doesn‚Äôt update to reflect those changes.\n\nUsing useEffect allows you to update the state when the prop changes. Alternatively, using a key prop forces a component remount when the key changes.\n\nWhile useState is flexible, overusing it can lead to cluttered and hard-to-maintain code, especially for complex state.\n\nFor complex state logic, consider using useReducer or organizing related state into objects.\n\nState updates in React are batched for performance reasons, which means they don‚Äôt take effect immediately.\n\nUpdating state with the same value it already holds can lead to unnecessary re-renders.\n\nAlways check if the new state is different from the current state before updating.\n\n7. Not Considering the Scope of State\n\nSometimes, developers place state at a higher level than necessary, causing unnecessary re-renders of child components.\n\nKeep state as close to where it‚Äôs used as possible to minimize unnecessary re-renders and improve performance.\n\nWhen using state values in callbacks or effects, be aware of the stale closure problem.\n\nBe mindful of dependencies in useEffect and useCallback to avoid working with stale state values.\n\nBy understanding these nuances and best practices, you can write more robust React components that efficiently manage state and avoid common pitfalls associated with useState."
    },
    {
        "link": "https://stackoverflow.com/questions/55342406/updating-and-merging-state-object-using-react-usestate-hook",
        "document": "One or more options regarding state type can be suitable depending on your usecase\n\nGenerally you could follow the following rules to decide the sort of state that you want\n\nFirst: Are the individual states related\n\nIf the individual state that you have in your application are related to one other then you can choose to group them together in an object. Else its better to keep them separate and use multiple so that when dealing with specific handlers you are only updating the relavant state property and are not concerned about the others\n\nFor instance, user properties such as are related and you can group them together Whereas for maintaining multiple counters you can make use of\n\nSecond: Is the logic to update state complex and depends on the handler or user interaction\n\nIn the above case its better to make use of for state definition. Such kind of scenario is very common when you are trying to create for example and todo app where you want to , and elements on different interactions\n\nstate updates using hooks are also batched and hence whenever you want to update state based on previous one its better to use the callback pattern.\n\nThe callback pattern to update state also comes in handy when the setter doesn't receive updated value from enclosed closure due to it being defined only once. An example of such as case if the being called only on initial render when adds a listener that updates state on an event."
    }
]