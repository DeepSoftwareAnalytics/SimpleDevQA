[
    {
        "link": "https://stackoverflow.com/questions/45157567/how-to-pass-the-values-from-activity-to-another-activity",
        "document": "As I'm learning Kotlin for Android development, I'm now trying the basic programs like hello world and how to navigate from one activity to another activity, there is no issue with this.\n\nWhen I move from one activity to another, it works fine, but I do not know how to pass the values between the activities.\n\nI tried to set the values in one activity and retrieved them in another activity it does not work.\n\nPlease see the code snippet below\n\nThis is my main activity where I take the username and password from edit text and setting to the intent:\n\nThis is my second activity where I have to receive values from the main activity\n\nPlease guide me on how to do this, whether I have some other way to do this in Kotlin if not by intent."
    },
    {
        "link": "https://mujeebkhan1831.medium.com/how-to-pass-object-between-activities-in-android-kotlin-b7bfbfa4a574",
        "document": "We can pass primitive data (Int, Float, Double, String etc.) by using Intent.\n\nYou can pass an object between activities in Android using Parcelable or Serializable interface.\n‚Ä¢ Serializable is a markable interface or we can call as an empty interface. It doesn‚Äôt have any pre- implemented method.\n‚Ä¢ Creation and passing data are very easy but it is slow process as compared to Parcelable.\n‚Ä¢ Serializable is a good choice to use when you want to store the state of an object to a file, a database or over a network.\n\nStep 1-> make sure your object class implement the serializable\n\nStep 2-> In the first activity, put the object in an Intent and start the second activity.\n\nStep 3 -> In Second Activity, get the object from the intent.\n‚Ä¢ Directly marshals and unmarshals the data to and from memory.\n‚Ä¢ Parclable is specific to Android and is the recommended method.\n\nStep 2-> In the first activity, put the object in an Intent and start the second activity.\n\nStep 3 -> In Second Activity, get the object from the intent."
    },
    {
        "link": "https://stackoverflow.com/questions/2091465/how-do-i-pass-data-between-activities-in-android-application",
        "document": "On clicking sign-out , I will be passing the session id of the signed in user to sign-out. Can anyone guide me on how to keep session id available to all activities ?\n\nI have a scenario where, after logging in through a login page, there will be a sign-out button on each activity .\n\nYou just have to send extras while calling your intent. Intent intent = new Intent(getApplicationContext(), SecondActivity.class); intent.putExtra(\"Variable name\", \"Value you want to pass\"); startActivity(intent); Now on the method of your you can fetch the extras like this. If the value you sent was in : long value = getIntent().getLongExtra(\"Variable name which you sent as an extra\", defaultValue(you can give it anything)); If the value you sent was a : String value = getIntent().getStringExtra(\"Variable name which you sent as an extra\"); If the value you sent was a : Boolean value = getIntent().getBooleanExtra(\"Variable name which you sent as an extra\", defaultValue);\n\nUpdated Note that I had mentioned the use of SharedPreference. It has a simple API and is accessible across an application's activities. But this is a clumsy solution and is a security risk if you pass around sensitive data. It's best to use intents. It has an extensive list of overloaded methods that can be used to better transfer many different data types between activities. Have a look at intent.putExtra. This link presents the use of putExtra quite well. In passing data between activities, my preferred approach is to create a static method for the relevant activity that includes the required parameters to launch the intent. Which then provides easy setup and retrieval parameters. So it can look like this public class MyActivity extends Activity { public static final String ARG_PARAM1 = \"arg_param1\"; ... public static getIntent(Activity from, String param1, Long param2...) { Intent intent = new Intent(from, MyActivity.class); intent.putExtra(ARG_PARAM1, param1); intent.putExtra(ARG_PARAM2, param2); return intent; } .... // Use it like this. startActivity(MyActvitiy.getIntent(FromActivity.this, varA, varB, ...)); ... Then you can create an intent for the intended activity and ensure you have all the parameters. You can adapt for fragments too. A simple example above, but you get the idea.\n\nThe actual process of passing data has already been answered, however most of the answers use hard coded strings for the key name in the Intent. This is usually fine when used only within your app. However, the documentation recommends using the constants for standardized data types. Example 2: Defining your own key If one of the Strings does not suit your needs, you can define your own at the beginning of the first activity. Including the package name is just a convention if you are only using the key in your own app. But it is a necessity to avoid naming conflicts if you are creating some sort of service that other apps can call with an Intent. Although not mentioned in the documentation, this answer recommends using a String resource to avoid dependencies between activities.\n\nHere is my best practice and it helps a lot when the project is huge and complex. Suppose that I have 2 activities, and . I want to pass 2 parameters (username & password) from to . public class HomeIntent extends Intent { private static final String ACTION_LOGIN = \"action_login\"; private static final String ACTION_LOGOUT = \"action_logout\"; private static final String ARG_USERNAME = \"arg_username\"; private static final String ARG_PASSWORD = \"arg_password\"; public HomeIntent(Context ctx, boolean isLogIn) { this(ctx); //set action type setAction(isLogIn ? ACTION_LOGIN : ACTION_LOGOUT); } public HomeIntent(Context ctx) { super(ctx, HomeActivity.class); } //This will be needed for receiving data public HomeIntent(Intent intent) { super(intent); } public void setData(String userName, String password) { putExtra(ARG_USERNAME, userName); putExtra(ARG_PASSWORD, password); } public String getUsername() { return getStringExtra(ARG_USERNAME); } public String getPassword() { return getStringExtra(ARG_PASSWORD); } //To separate the params is for which action, we should create action public boolean isActionLogIn() { return getAction().equals(ACTION_LOGIN); } public boolean isActionLogOut() { return getAction().equals(ACTION_LOGOUT); } } Here is how I pass the data in my LoginActivity Final step, here is how I receive the data in public class HomeActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_home); //This is how we receive the data from LoginActivity //Make sure you pass getIntent() to the HomeIntent constructor final HomeIntent homeIntent = new HomeIntent(getIntent()); Log.d(\"HomeActivity\", \"Is action login? \" + homeIntent.isActionLogIn()); Log.d(\"HomeActivity\", \"username: \" + homeIntent.getUsername()); Log.d(\"HomeActivity\", \"password: \" + homeIntent.getPassword()); } } Done! Cool :) I just want to share my experience. If you working on small project this shouldn't be the big problem. But when your working on big project, it really pain when you want to do refactoring or fixing bugs.\n\n1st way: In your current Activity, when you create an object of intent to open a new screen: Then in the nextActivity in the onCreate method, retrieve those values which you pass from the previous activity: if (getIntent().getExtras() != null) { String value = getIntent().getStringExtra(\"key\"); //The key argument must always match that used send and retrieve value from one activity to another. } 2nd way: You can create a bundle object and put values in a bundle and then put the bundle object in intent from your current activity - String value=\"xyz\"; Intent intent = new Intent(CurrentActivity.this, NextActivity.class); Bundle bundle = new Bundle(); bundle.putInt(\"key\", value); intent.putExtra(\"bundle_key\", bundle); startActivity(intent); Then in the nextActivity in the onCreate method, retrieve those values which you pass from the previous activity: if (getIntent().getExtras() != null) { Bundle bundle = getIntent().getStringExtra(\"bundle_key\"); String value = bundle.getString(\"key\"); //The key argument must always match that used send and retrieve value from one activity to another. } You can also use the bean class to pass data between classes using serialization.\n\nI recently released Vapor API, a jQuery flavored Android framework that makes all sorts of tasks like this simpler. As mentioned, is one way you could do this. is implemented as Singleton so that is one option, and in Vapor API it has a heavily overloaded method so you don't have to explicitly worry about the datatype you are committing - providing it is supported. It is also fluent, so you can chain calls: It also optionally autosaves changes, and unifies the reading and writing process under-the-hood so you don't need to explicitly retrieve an Editor like you do in standard Android. Alternatively you could use an . In Vapor API you can also use the chainable overloaded method on a : And pass it as an extra, as mentioned in the other answers. You can retrieve extras from your , and furthermore if you are using this is done for you automatically so you can use: To retrieve them at the other end in the you switch to. Hope that is of interest to some :)"
    },
    {
        "link": "https://digitalocean.com/community/tutorials/android-intent-handling-between-activities-using-kotlin",
        "document": "In this tutorial, we‚Äôll be discussing Android Intents and implement them using Kotlin in our application.\n\nWhat Will You Learn?\n‚Ä¢ Using Parcelable and Serializable to pass objects\n\nAs the name says Intent is something that‚Äôs used to perform some action with respect to the flow of the android application. Intents can be used to:\n‚Ä¢ Starting a new activity and passing some data.\n\nIn this tutorial, we‚Äôll be looking mainly at intents to handle activities. An intent definition mainly consists of an instance of the current activity. We set the component name which can be: The fully qualified class name of the activity to be called. This type of Intent is an explicit intent. An action such as URL, phone number, location. It‚Äôll display all the available applications of those types. This falls under the implicit intent category. In Kotlin, following is the way to create an activity.\n\nwould add on the activity stack and launch it. How does our Application, realise which activity is the first to be invoked? In the AndroidManifest.xml we set the intent filter with the action and category on the first activity to be launched when our application opens. is used to destroy an activity and remove it from the stack.\n\nFlags are like options that can be set on intents to customise the launch process. If you start the same activity everytime, a new instance would be created and added onto the activity stack To prevent this, you can use the flags: - If set, the activity will not be launched if it is already running at the top of the activity stack.\n\nSimilarly using a flag would not launch another instance of the activity if it already exists. This flag would clear all the activities above the activity that‚Äôs called and set it on the top of the stack.\n\nTo pass data onto the new activities we use key value pairs inside the function , etc. putExtra generally passes the basic types such as Int, Float, Char, Double, Boolean, String along with IntArray‚Ä¶ etc.\n\nThese Extras fields are under the hood wrapped into the object which ultimately holds all the data to be passed. To retrieve the data in the other activity, we need to use the property over the . Retrieving Data in the new Activity\n\n, are equivalent to , in Java. We‚Äôve used a nullable type to prevent when not data exists. Similarly, for the data that‚Äôs fetched using the keys, we‚Äôve used the nullable types to prevent NPE that can occur when the key is incorrect.\n\nSometimes we need to pass a complete object from one activity to another. It‚Äôs not possible to do so unless we implement the Parcelable or Serializable interface. Difference between Parcelable and Serializable\n‚Ä¢ Parcelable interface is a part of the Android SDK. Serializable is a standard interface of Java.\n‚Ä¢ In Parcelable you need to set all of the data you need to pass in a Parcel object and also override the writeToParcel() methods etc. In serializable implementing the interface is sufficient to pass the data.\n\nKotlin comes up with some handy annotations to save us from overriding the writeToParcel() method to set the data on the Parcelable. Instead, we can use @Parcelize annotation as shown below:\n\nNote: Currently in your build.gradle you must add the following code for the @Parcelize annotation to work:\n\nIn your Activity you do:\n\nLet‚Äôs use over above knowledge in our Android Studio Project.\n\nThe code for the layout is given below:\n\nThe code for the activity_other.xml layout is given below:\n\nThe code for the MainActivity.kt class is given below:\n\nIn the above code, we‚Äôve used Buttons for each type of Intent. We‚Äôve used Kotlin‚Äôs expression to prevent setting data over the object every time. Besides, we‚Äôve created three different intents apart from the ones already discussed above. A browser intent is used to launch the url present in the intent in the browser app. It uses . A location intent is used to launch the lat,lng location in the maps application. Both of these are implicit intents. Lastly, we‚Äôve used a generic intent in which we use the Kotlin‚Äôs extension functions and lambda expressions to create a shorthand function to launch an intent. For this we use the following functions:\n\nstartActivity is an exension function which looks for a higher order function as it‚Äôs parameter. Thanks to this, we can now launch intents in as few lines as: The code for the OtherActivity.kt class is given below.\n\nWe‚Äôve used and to handle nullable types and prevent doing bundle.field in every line. The output of the above application in action is given below: This brings an end to this tutorial on Android intents in Kotlin. You can download the project from the link below."
    },
    {
        "link": "https://linkedin.com/pulse/how-pass-object-between-activities-android-using-kotlin-arun-aditya-8ssvc",
        "document": "You can pass an object between activities in Android using Parcelable or Serializable interface.\n‚Ä¢ Serializable is a markable interface or we can call as an empty interface. It doesn‚Äôt have any pre- implemented method.\n‚Ä¢ Creation and passing data are very easy but it is slow process as compared to Parcelable.\n‚Ä¢ Serializable is a good choice to use when you want to store the state of an object to a file, a database or over a network.\n\nStep 2-> In the first activity, put the object in an Intent and start the second activity.\n\nStep 3 -> In Second Activity, get the object from the intent.\n‚Ä¢ Directly marshals and unmarshals the data to and from memory.\n‚Ä¢ Parclable is specific to Android and is the recommended method.\n\nStep 2-> In the first activity, put the object in an Intent and start the second activity.\n\nStep 3 -> In Second Activity, get the object from the intent.\n\nIf you need to transfer data between activities in Android, use Parcelable for faster and more efficient data transfer, while if you need to store data in a more general way, you can use Serializable."
    },
    {
        "link": "https://github.com/PhilJay/MPAndroidChart",
        "document": "‚ö° A powerful & easy to use chart library for Android ‚ö°\n\nCharts is the iOS version of this library\n\nSee the documentation for examples and general use of MPAndroidChart.\n\nSee the javadocs for more advanced documentation.\n\nDownload the MPAndroidChart Example App or look at the source code.\n\nThis repository's issue tracker is only for bugs and feature requests. The maintainers ask that you refrain from asking questions about how to use MPAndroidChart through the issue tracker.\n\nPlease read the documentation first, then ask all your questions on stackoverflow.com for the fastest answer.\n\nThis project needs you! If you would like to support this project's further development, the creator of this project or the continuous maintenance of this project, feel free to donate. Your donation is highly appreciated (and I love food, coffee and beer). Thank you!\n‚Ä¢ Donate 5 $: Thank's for creating this project, here's a coffee (or some beer) for you!\n‚Ä¢ Donate 10 $: Wow, I am stunned. Let me take you to the movies!\n‚Ä¢ Donate 15 $: I really appreciate your work, let's grab some lunch!\n‚Ä¢ Donate 25 $: That's some awesome stuff you did right there, dinner is on me!\n‚Ä¢ Or you can also choose what you want to donate, all donations are awesome!\n\nIf you like this library, please tell others about it üíï üíï\n\nIf you like, you can follow me on Twitter @PhilippJahoda.\n\nCombined-Chart (bar- and linechart in this case)\n\nScatterChart (with squares, triangles, circles, ... and more)\n\nBubbleChart (area covered by bubbles indicates the yValue)\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License."
    },
    {
        "link": "https://stackoverflow.com/questions/70322414/mpandroidchart-v3-1-0-could-not-find-on-github",
        "document": "I am trying to implement MPAndroidChart in my android app using java language but Android Studio returns an error when I sync the project.\n\nI have already put the dependencies in my build.gradle(app) file like below:\n\nI have tried also to implement all the solutions proposed here but could not sort it out. So I need help, please."
    },
    {
        "link": "https://reddit.com/r/androiddev/comments/y376ma/does_anyone_know_how_to_use_the_mpandroidcharts",
        "document": "So, I've been trying to build a simple Line Chart for weeks, but nothing seems to work and the only thing I get as a result is an APK that says \"No chart data available\".\n\nIf you have experience with the library and if you have built charts with it, could you please answer/DM me?"
    },
    {
        "link": "https://stackoverflow.com/questions/74030164/no-chart-data-available-mpandroidchart-in-kotlin",
        "document": "I've been trying to make a linechart with the MPAndroidChart library from Github following an old tutorial, so I don't use the newest version (3.1.0) but rather I have to use an older one (2.2.4) as the coding has changed since then and I don't know how to create a linechart according to the newest version.\n\nProblem is, I've been trying everything to get the code working, and don't get me wrong, the code \"Works\", and the build is done correctly, so I'm able to test it on my physical device, but for some reason, after opening the APK to see the result, it tells me that \"No chart data alvailable\". I think the problem is related to the LineChart inside the RelativeLayout that is in the activity_main.xml. I've tried findViewByID and View Binding but I always get the same result.\n\nCould you guys tell me the reason of why I'm wrong? or maybe teach me how to make linecharts based according to the newest verion. Help is appreciated."
    },
    {
        "link": "https://github.com/PhilJay/MPAndroidChart/blob/master/README.md",
        "document": "‚ö° A powerful & easy to use chart library for Android ‚ö°\n\nCharts is the iOS version of this library\n\nSee the documentation for examples and general use of MPAndroidChart.\n\nSee the javadocs for more advanced documentation.\n\nDownload the MPAndroidChart Example App or look at the source code.\n\nThis repository's issue tracker is only for bugs and feature requests. The maintainers ask that you refrain from asking questions about how to use MPAndroidChart through the issue tracker.\n\nPlease read the documentation first, then ask all your questions on stackoverflow.com for the fastest answer.\n\nThis project needs you! If you would like to support this project's further development, the creator of this project or the continuous maintenance of this project, feel free to donate. Your donation is highly appreciated (and I love food, coffee and beer). Thank you!\n‚Ä¢ Donate 5 $: Thank's for creating this project, here's a coffee (or some beer) for you!\n‚Ä¢ Donate 10 $: Wow, I am stunned. Let me take you to the movies!\n‚Ä¢ Donate 15 $: I really appreciate your work, let's grab some lunch!\n‚Ä¢ Donate 25 $: That's some awesome stuff you did right there, dinner is on me!\n‚Ä¢ Or you can also choose what you want to donate, all donations are awesome!\n\nIf you like this library, please tell others about it üíï üíï\n\nIf you like, you can follow me on Twitter @PhilippJahoda.\n\nCombined-Chart (bar- and linechart in this case)\n\nScatterChart (with squares, triangles, circles, ... and more)\n\nBubbleChart (area covered by bubbles indicates the yValue)\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License."
    },
    {
        "link": "https://developer.android.com/develop/ui/views/layout/declaring-layout",
        "document": "Save and categorize content based on your preferences.\n\nA layout defines the structure for a user interface in your app, such as in an activity. All elements in the layout are built using a hierarchy of and objects. A usually draws something the user can see and interact with. A is an invisible container that defines the layout structure for and other objects, as shown in figure 1.\n\nobjects are often called widgets and can be one of many subclasses, such as or . The objects are usually called layouts and can be one of many types that provide a different layout structure, such as or .\n\nYou can declare a layout in two ways:\n‚Ä¢ Declare UI elements in XML. Android provides a straightforward XML vocabulary that corresponds to the classes and subclasses, such as those for widgets and layouts. You can also use Android Studio's Layout Editor to build your XML layout using a drag-and-drop interface.\n‚Ä¢ Instantiate layout elements at runtime. Your app can create and objects and manipulate their properties programmatically.\n\nDeclaring your UI in XML lets you separate the presentation of your app from the code that controls its behavior. Using XML files also makes it easier to provide different layouts for different screen sizes and orientations. This is discussed further in Support different screen sizes.\n\nThe Android framework gives you the flexibility to use either or both of these methods to build your app's UI. For example, you can declare your app's default layouts in XML, and then modify the layout at runtime.\n\nUsing Android's XML vocabulary, you can quickly design UI layouts and the screen elements they contain, in the same way that you create web pages in HTML with a series of nested elements.\n\nEach layout file must contain exactly one root element, which must be a or object. After you define the root element, you can add additional layout objects or widgets as child elements to gradually build a hierarchy that defines your layout. For example, here's an XML layout that uses a vertical to hold a and a :\n\nAfter you declare your layout in XML, save the file with the extension in your Android project's directory so it properly compiles.\n\nFor more information about the syntax for a layout XML file, see Layout resource.\n\nWhen you compile your app, each XML layout file is compiled into a resource. Load the layout resource in your app's callback implementation. Do so by calling , passing it the reference to your layout resource in the form: . For example, if your XML layout is saved as , load it for your as follows:\n\nThe Android framework calls the callback method in your when the launches. For more information about activity lifecycles, see Introduction to activities.\n\nEvery and object supports its own variety of XML attributes. Some attributes are specific to a object. For example, supports the attribute. However, these attributes are also inherited by any objects that extend this class. Some are common to all objects, because they are inherited from the root class, like the attribute. Other attributes are considered layout parameters, which are attributes that describe certain layout orientations of the object, as defined by that object's parent object.\n\nAny object can have an integer ID associated with it to uniquely identify the within the tree. When the app is compiled, this ID is referenced as an integer, but the ID is typically assigned in the layout XML file as a string in the attribute. This is an XML attribute common to all objects, and it is defined by the class. You use it very often. The syntax for an ID inside an XML tag is the following:\n\nThe at symbol (@) at the beginning of the string indicates that the XML parser parses and expands the rest of the ID string and identifies it as an ID resource. The plus symbol (+) means this is a new resource name that must be created and added to your resources in the file.\n\nThe Android framework offers many other ID resources. When referencing an Android resource ID, you don't need the plus symbol, but you must add the package namespace as follows:\n\nThe package namespace indicates that you're referencing an ID from the resources class, rather than the local resources class.\n\nTo create views and reference them from your app, you can use a common pattern as follows:\n‚Ä¢ Define a view in the layout file and assign it a unique ID, as in the following example:\n‚Ä¢ Create an instance of the view object and capture it from the layout, typically in the method, as shown in the following example:\n\nDefining IDs for view objects is important when creating a . In a relative layout, sibling views can define their layout relative to another sibling view, which is referenced by the unique ID.\n\nAn ID doesn't need to be unique throughout the entire tree, but it must be unique within the part of the tree you search. It might often be the entire tree, so it's best to make it unique when possible.\n\nXML layout attributes named define layout parameters for the that are appropriate for the it resides in.\n\nEvery class implements a nested class that extends . This subclass contains property types that define the size and position of each child view, as appropriate for the view group. As shown in figure 2, the parent view group defines layout parameters for each child view, including the child view group.\n\nEvery subclass has its own syntax for setting values. Each child element must define a that is appropriate for its parent, though it might also define a different for its own children.\n\nAll view groups include a width and height, using and , and each view is required to define them. Many include optional margins and borders.\n\nYou can specify width and height with exact measurements, but you might not want to do this often. More often, you use one of these constants to set the width or height:\n‚Ä¢ : tells your view to size itself to the dimensions required by its content.\n‚Ä¢ : tells your view to become as big as its parent view group allows.\n\nIn general, we don't recommend specifying a layout width and height using absolute units such as pixels. A better approach is using relative measurements, such as density-independent pixel units (dp), , or , because it helps your app display properly across a variety of device screen sizes. The accepted measurement types are defined in Layout resource.\n\nA view has rectangular geometry. It has a location, expressed as a pair of left and top coordinates, and two dimensions, expressed as a width and height. The unit for location and dimensions is the pixel.\n\nYou can retrieve the location of a view by invoking the methods and . The former returns the left (x) coordinate of the rectangle representing the view. The latter returns the top (y) coordinate of the rectangle representing the view. These methods return the location of the view relative to its parent. For example, when returns 20, this means the view is located 20 pixels to the right of the left edge of its direct parent.\n\nIn addition, there are convenience methods to avoid unnecessary computations: namely and . These methods return the coordinates of the right and bottom edges of the rectangle representing the view. For example, calling is similar to the following computation: .\n\nThe size of a view is expressed with a width and height. A view has two pairs of width and height values.\n\nThe first pair is known as measured width and measured height. These dimensions define how big a view wants to be within its parent. You can obtain the measured dimensions by calling and .\n\nThe second pair is known as width and height, or sometimes drawing width and drawing height. These dimensions define the actual size of the view on screen, at drawing time and after layout. These values might, but don't have to, differ from the measured width and height. You can obtain the width and height by calling and .\n\nTo measure its dimensions, a view takes into account its padding. The padding is expressed in pixels for the left, top, right and bottom parts of the view. You can use padding to offset the content of the view by a specific number of pixels. For instance, a left padding of two pushes the view's content two pixels to the right of the left edge. You can set padding using the method and query it by calling , , , and .\n\nAlthough a view can define a padding, it doesn't support margins. However, view groups do support margins. See and for more information.\n\nFor more information about dimensions, see Dimension.\n\nBesides setting margins and padding programmatically, you can also set them in your XML layouts, as shown in the following example:\n\nThe preceding example shows margin and padding being applied. The has uniform margins and padding applied all around, and the shows how you can apply them independently to different edges.\n\nEach subclass of the class provides a unique way to display the views you nest within it. The most flexible layout type, and the one that provides the best tools for keeping your layout hierarchy shallow, is .\n\nThe following are some of the common layout types built into the Android platform.\n\nWhen the content for your layout is dynamic or not pre-determined, you can use or a subclass of . is generally the better option, because it uses memory more efficiently than .\n\nCommon layouts possible with and include the following:\n\noffers more possibilities and the option to create a custom layout manager.\n\nYou can populate an such as or by binding the instance to an , which retrieves data from an external source and creates a that represents each data entry.\n\nAndroid provides several subclasses of that are useful for retrieving different kinds of data and building views for an . The two most common adapters are:\n\nIf during the course of your app's life you change the underlying data that is read by your adapter, call . This notifies the attached view that the data has been changed and it refreshes itself.\n\nYou can respond to click events on each item in an by implementing the interface. For example:\n\nSee how layouts are used in the Sunflower demo app on GitHub."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/android-layout-linearlayout-relativelayout",
        "document": "In this tutorial, we will provide an overview of android layout. We will also explore some of the specific layout controls available for organising the screen content namely - Android LinearLayout and Android RelativeLayout.\n\nThe basic building block for user interface is a View object that is created from the View class and occupies a rectangular area on the screen. Views are the base class for UI components like TextView, Button, EditText etc. The ViewGroup is a subclass of View. One or more Views can be grouped together into a ViewGroup. A ViewGroup provides the android layout in which we can order the appearance and sequence of views. Examples of ViewGroup are , , etc.\n\nAndroid provides the following ViewGroups or layouts:\n‚Ä¢ : is a ViewGroup that aligns all children in a single direction, vertically or horizontally\n‚Ä¢ : is a ViewGroup that displays child views in relative positions\n‚Ä¢ : allows us to specify the exact location of the child views and widgets\n‚Ä¢ : is a view that groups its child views into rows and columns\n‚Ä¢ : is a placeholder on screen that is used to display a single view\n‚Ä¢ : is a special type of FrameLayout in that it allows users to scroll through a list of views that occupy more space than the physical display. The ScrollView can contain only one child view or ViewGroup, which normally is a LinearLayout\n‚Ä¢ : is a view group that displays a list of scrollable item\n‚Ä¢ : is a ViewGroup that displays items in two-dimensional scrolling grid. The items in the grid come from the ListAdapter associated with this view\n\nIn this tutorial we‚Äôll focus on the two most used android layout:\n‚Ä¢ android:id : This is the ID which uniquely identifies the view\n‚Ä¢ android:layout_width : This is the width of the layout\n‚Ä¢ android:layout_height : This is the height of the layout\n‚Ä¢ android:layout_margin : This is the extra space outside of the view. For example if you give , then the view will be arranged after 20dp from left\n‚Ä¢ android:layout_padding : This is similar to android:layout_margin except that it specifies the extra space inside the view\n‚Ä¢ android:layout_gravity : This specifies how child Views are positioned\n‚Ä¢ android:layout_weight : This specifies how much of the extra space in the layout should be allocated to the view\n‚Ä¢ android:layout_x : This specifies the x-coordinate of the layout\n‚Ä¢ android:layout_y : This specifies the y-coordinate of the layout\n\nandroid:layout_width=wrap_content tells the view to size itself to the dimensions required by its content. android:layout_width=match_parent tells the view to become as big as its parent view.\n\nThe syntax for an ID, inside an XML tag is:\n‚Ä¢ The at-symbol (@) at the beginning of the string indicates that the XML parser should parse and expand the rest of the ID string and identify it as an ID resource\n‚Ä¢ The plus-symbol (+) means that this is a new resource name that must be created and added to our resources\n\nAndroid LinearLayout organizes elements along a single line. We can specify whether that line is vertical or horizontal using . The orientation is horizontal by default. A vertical LinearLayout will only have one child per row (so it is a column of single elements), and a horizontal LinearLayout will only have one single row of elements on the screen. android:layout_weight attribute depicts the importance of the element. An element with larger weight occupies more screen space. Here is a sample Layout XML using LinearLayout:\n\nIn this layout we have a Parent which has a vertical orientation and contains buttons, textviews and a nested Linear Layout(having a horizontal orientation) as child views. Note: Nested layouts don‚Äôt have to be of one type. We could, for example, have a LinearLayout as one of the children in a RelativeLayout and vice-versa.\n\nAndroid RelativeLayout lays out elements based on their relationships with one another, and with the parent container. This is one of the most complicated layout and we need several properties to actually get the layout we desire. That is, using RelativeLayout we can position a view to be toLeftOf, toRightOf, below or above its siblings. We can also position a view with respect to its parent such as centered horizontally, vertically or both, or aligned with any of the edges of the parent . If none of these attributes are specified on a child view then the view is by default rendered to the top left position.\n\nThe following are the major attributes used across RelativeLayout. They lay across three different categories:\n‚Ä¢ android:layout_alignParentBottom : Places the bottom of the element on the bottom of the container\n‚Ä¢ android:layout_alignParentLeft : Places the left of the element on the left side of the container\n‚Ä¢ android:layout_alignParentRight : Places the right of the element on the right side of the container\n‚Ä¢ android:layout_alignParentTop : Places the element at the top of the container\n‚Ä¢ android:layout_centerHorizontal : Centers the element horizontally within its parent container\n‚Ä¢ android:layout_centerInParent : Centers the element both horizontally and vertically within its container\n‚Ä¢ android:layout_centerVertical : Centers the element vertically within its parent container\n‚Ä¢ android:layout_above : Places the element above the specified element\n‚Ä¢ android:layout_below : Places the element below the specified element\n‚Ä¢ android:layout_toLeftOf : Places the element to the left of the specified element\n‚Ä¢ android:layout_toRightOf : Places the element to the right of the specified element\n\n‚Äú@id/XXXXX‚Äù is used to reference an element by its id. One thing to remember is that referencing an element before it has been declared will produce an error so @+id/ should be used in such cases.\n‚Ä¢ android:layout_alignBaseline : Aligns baseline of the new element with the baseline of the specified element\n‚Ä¢ android:layout_alignBottom : Aligns the bottom of new element in with the bottom of the specified element\n‚Ä¢ android:layout_alignLeft : Aligns left edge of the new element with the left edge of the specified element\n‚Ä¢ android:layout_alignRight : Aligns right edge of the new element with the right edge of the specified element\n‚Ä¢ android:layout_alignTop : Places top of the new element in alignment with the top of the specified element\n\nThe following xml layout uses :\n\nAs you can see we can rearrange elements based on their relative positions. The following xml layout represents a custom layout having nested linear and relative layouts.\n\nThis project consists of three activities and the respective layouts that were discussed above.\n\nThe application launches into the MainActivity which loads the contents by the following code:\n\nThe and load the and layouts respectively as shown below:\n\nThe image outputs of the three layout files are shown below: layout_linear.xml As you can see the Parent LinearLayout consists of 6 child elements in a single vertical column among which one is a nested LinearLayout child view containing 4 components in horizontal orientation. layout_relative.xml The arrows pointing in the image above depict how siblings are positioned relative to each other and relative to the container. layout_mixed.xml This Relative Layout consists of a Vertical LinearLayout within a Nested Horizontal LinearLayout along with a Child RelativeLayout. Note: Components belonging to different layouts are not siblings and hence can‚Äôt be positioned relative to each other. It‚Äôs their container layouts that are siblings and can be positioned relative to each other. If you are wondering about the blue lined rectangles and arrows, it‚Äôs because the images are from xml layouts in graphical view. When you will run the app, these blue lines and rectangles will not be shown. This brings an end to android layout tutorial. We‚Äôll cover the other android layouts in the next tutorials. You can download the final Android Layout Project from the link below."
    },
    {
        "link": "https://stackoverflow.com/questions/56641722/relative-layout-vs-linear-layout-or-a-mix-of-both",
        "document": "I their should be no vs this Because both of them are different and serve different purpose\n\nyou should use linear layout where you have to do lot's off layout changes in view like adding removing or making dynamic because it will not rebuild whole layout just change's the parameter\n\nYou should use where you want to achieve some alignment and don't want widget to render again because any change in child of relative layout it's re arrange / re draw whole widget\n\nHope this give some better picture"
    },
    {
        "link": "https://developer.android.com/develop/ui/views/layout/relative",
        "document": "is a view group that displays child views in relative positions. The position of each view can be specified as relative to sibling elements (such as to the left-of or below another view) or in positions relative to the parent area (such as aligned to the bottom, left or center).\n\nNote: For better performance and tooling support, you should instead build your layout with ConstraintLayout.\n\nA is a very powerful utility for designing a user interface because it can eliminate nested view groups and keep your layout hierarchy flat, which improves performance. If you find yourself using several nested groups, you may be able to replace them with a single .\n\nlets child views specify their position relative to the parent view or to each other (specified by ID). So you can align two elements by right border, or make one below another, centered in the screen, centered left, and so on. By default, all child views are drawn at the top-left of the layout, so you must define the position of each view using the various layout properties available from .\n\nSome of the many layout properties available to views in a include:\n\nThese are just a few examples. All layout attributes are documented at .\n\nThe value for each layout property is either a boolean to enable a layout position relative to the parent or an ID that references another view in the layout against which the view should be positioned.\n\nIn your XML layout, dependencies against other views in the layout can be declared in any order. For example, you can declare that \"view1\" be positioned below \"view2\" even if \"view2\" is the last view declared in the hierarchy. The example below demonstrates such a scenario.\n\nEach of the attributes that control the relative position of each view are emphasized.\n\nFor details about all the layout attributes available to each child view of a , see ."
    },
    {
        "link": "https://stackoverflow.com/questions/31509212/android-linearlayout-relativelayout-alignment",
        "document": "I am attempting to create a simple UI that looks something like this\n\nI am very new to android and have been trying different types of layouts (Linear/Relative) and I believe Linear may be the way to go here (I hope to make the amount of ListViews dynamic at some stage but for now 2 is fine).\n\nShould I be using a Linear Layout or Relative layout, or some combination of both to achieve this.\n\nHere is the XML which I have, I can't seem to get the button to align right, even though its gravity is set to right. I am open to any suggestions on how to fix this, or if there is a better way\n\nedit : here is what the UI currently looks like"
    }
]