[
    {
        "link": "https://javascript.info/promise-error-handling",
        "document": "Promise chains are great at error handling. When a promise rejects, the control jumps to the closest rejection handler. That‚Äôs very convenient in practice.\n\nFor instance, in the code below the URL to is wrong (no such site) and handles the error:\n\nAs you can see, the doesn‚Äôt have to be immediate. It may appear after one or maybe several .\n\nOr, maybe, everything is all right with the site, but the response is not valid JSON. The easiest way to catch all errors is to append to the end of chain:\n\nNormally, such doesn‚Äôt trigger at all. But if any of the promises above rejects (a network problem or invalid json or whatever), then it would catch it.\n\nThe code of a promise executor and promise handlers has an ‚Äúinvisible ‚Äù around it. If an exception happens, it gets caught and treated as a rejection.\n\n‚Ä¶Works exactly the same as this:\n\nThe ‚Äúinvisible ‚Äù around the executor automatically catches the error and turns it into rejected promise.\n\nThis happens not only in the executor function, but in its handlers as well. If we inside a handler, that means a rejected promise, so the control jumps to the nearest error handler.\n\nThis happens for all errors, not just those caused by the statement. For example, a programming error:\n\nThe final not only catches explicit rejections, but also accidental errors in the handlers above.\n\nAs we already noticed, at the end of the chain is similar to . We may have as many handlers as we want, and then use a single at the end to handle errors in all of them.\n\nIn a regular we can analyze the error and maybe rethrow it if it can‚Äôt be handled. The same thing is possible for promises.\n\nIf we inside , then the control goes to the next closest error handler. And if we handle the error and finish normally, then it continues to the next closest successful handler.\n\nIn the example below the successfully handles the error:\n\nHere the block finishes normally. So the next successful handler is called.\n\nIn the example below we see the other situation with . The handler catches the error and just can‚Äôt handle it (e.g. it only knows how to handle ), so it throws it again:\n\nThe execution jumps from the first to the next one down the chain.\n\nWhat happens when an error is not handled? For instance, we forgot to append to the end of the chain, like here:\n\nIn case of an error, the promise becomes rejected, and the execution should jump to the closest rejection handler. But there is none. So the error gets ‚Äústuck‚Äù. There‚Äôs no code to handle it.\n\nIn practice, just like with regular unhandled errors in code, it means that something has gone terribly wrong.\n\nWhat happens when a regular error occurs and is not caught by ? The script dies with a message in the console. A similar thing happens with unhandled promise rejections.\n\nThe JavaScript engine tracks such rejections and generates a global error in that case. You can see it in the console if you run the example above.\n\nIn the browser we can catch such errors using the event :\n\nThe event is the part of the HTML standard.\n\nIf an error occurs, and there‚Äôs no , the handler triggers, and gets the object with the information about the error, so we can do something.\n\nUsually such errors are unrecoverable, so our best way out is to inform the user about the problem and probably report the incident to the server.\n\nIn non-browser environments like Node.js there are other ways to track unhandled errors.\n‚Ä¢ handles errors in promises of all kinds: be it a call, or an error thrown in a handler.\n‚Ä¢ also catches errors in the same manner, if given the second argument (which is the error handler).\n‚Ä¢ We should place exactly in places where we want to handle errors and know how to handle them. The handler should analyze errors (custom error classes help) and rethrow unknown ones (maybe they are programming mistakes).\n‚Ä¢ It‚Äôs ok not to use at all, if there‚Äôs no way to recover from an error.\n‚Ä¢ In any case we should have the event handler (for browsers, and analogs for other environments) to track unhandled errors and inform the user (and probably our server) about them, so that our app never ‚Äújust dies‚Äù."
    },
    {
        "link": "https://joeattardi.dev/understanding-error-handling-in-promise-chains",
        "document": "You can create a chain of s by returning new s from a handler. Here's a simple example that chains 3 promises together:\n\nThe output of this chain will be:\n\nTo handle any errors that may occur in the chain, you can add a call to at the end of the chain. If any of the s are rejected, this handler will run, and the rest of the chain is skipped.\n\nThe output of this chain will be:\n\nIf you add more calls after the , they will run!\n\nWhy does the chain continue after the ? As it turns out, you can return another from a handler. Here, the handler just prints to the console. The handler function, then, returns . This actually returns a new , fulfilled with the value . You can verify this by adding the argument to the last :\n\nThis is a contrived scenario, but consider a function that does some asynchronous work and returns a . Maybe it's a function that wraps the Fetch API, to return the JSON content. It has a for centralized request error logging:\n\nWhat happens if there's an error with the Fetch call? Before reading this post, the result might surprise you!\n\nLogically you might expect that will be printed. But what actually happens is that logs the Fetch error but returns a fulfilled . Your handler will be executed and print:\n\nIn order to get the result you want, the handler inside has to return a rejected . You have to \"re-reject\" it:\n\nYou could also the error, which will implicitly return a rejected as well:\n\nEither way, now when you call and an error occurs, it will correctly return a rejected .\n\nchains actually work a lot like / blocks in JavaScript. If an exception is thrown within a block, it jumps right to the block and skips the rest of the - just like how skips the rest of the chain.\n\nAlso, if you have a function that catches an exception, you'll need to re-throw it if you want it to propagate back up to the calling function."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises",
        "document": "A is an object representing the eventual completion or failure of an asynchronous operation. Since most people are consumers of already-created promises, this guide will explain consumption of returned promises before explaining how to create them. Essentially, a promise is a returned object to which you attach callbacks, instead of passing callbacks into a function. Imagine a function, , which asynchronously generates a sound file given a configuration record and two callback functions: one called if the audio file is successfully created, and the other called if an error occurs. Here's some code that uses : If were rewritten to return a promise, you would attach your callbacks to it instead: This convention has several advantages. We will explore each one.\n\nA common need is to execute two or more asynchronous operations back to back, where each subsequent operation starts when the previous operation succeeds, with the result from the previous step. In the old days, doing several asynchronous operations in a row would lead to the classic callback hell: With promises, we accomplish this by creating a promise chain. The API design of promises makes this great, because callbacks are attached to the returned promise object, instead of being passed into a function. Here's the magic: the function returns a new promise, different from the original: This second promise ( ) represents the completion not just of , but also of the or you passed in ‚Äî which can be other asynchronous functions returning a promise. When that's the case, any callbacks added to get queued behind the promise returned by either or . Note: If you want a working example to play with, you can use the following template to create any function returning a promise: function doSomething() { return new Promise((resolve) => { setTimeout(() => { // Other things to do before completion of the promise console.log(\"Did something\"); // The fulfillment value of the promise resolve(\"https://example.com/\"); }, 200); }); } The implementation is discussed in the Creating a Promise around an old callback API section below. With this pattern, you can create longer chains of processing, where each promise represents the completion of one asynchronous step in the chain. In addition, the arguments to are optional, and is short for ‚Äî so if your error handling code is the same for all steps, you can attach it to the end of the chain: You might see this expressed with arrow functions instead: Note: Arrow function expressions can have an implicit return; so, is short for . and can return any value ‚Äî if they return promises, that promise is first waited until it settles, and the next callback receives the fulfillment value, not the promise itself. It is important to always return promises from callbacks, even if the promise always resolves to . If the previous handler started a promise but did not return it, there's no way to track its settlement anymore, and the promise is said to be \"floating\". doSomething() .then((url) => { // Missing `return` keyword in front of fetch(url). fetch(url); }) .then((result) => { // result is undefined, because nothing is returned from the previous // handler. There's no way to know the return value of the fetch() // call anymore, or whether it succeeded at all. }); By returning the result of the call (which is a promise), we can both track its completion and receive its value when it completes. Floating promises could be worse if you have race conditions ‚Äî if the promise from the last handler is not returned, the next handler will be called early, and any value it reads may be incomplete. const listOfIngredients = []; doSomething() .then((url) => { // Missing `return` keyword in front of fetch(url). fetch(url) .then((res) => res.json()) .then((data) => { listOfIngredients.push(data); }); }) .then(() => { console.log(listOfIngredients); // listOfIngredients will always be [], because the fetch request hasn't completed yet. }); Therefore, as a rule of thumb, whenever your operation encounters a promise, return it and defer its handling to the next handler. const listOfIngredients = []; doSomething() .then((url) => { // `return` keyword now included in front of fetch call. return fetch(url) .then((res) => res.json()) .then((data) => { listOfIngredients.push(data); }); }) .then(() => { console.log(listOfIngredients); // listOfIngredients will now contain data from fetch call. }); Even better, you can flatten the nested chain into a single chain, which is simpler and makes error handling easier. The details are discussed in the Nesting section below. Using / can help you write code that's more intuitive and resembles synchronous code. Below is the same example using / : Note how the code looks exactly like synchronous code, except for the keywords in front of promises. One of the only tradeoffs is that it may be easy to forget the keyword, which can only be fixed when there's a type mismatch (e.g. trying to use a promise as a value). / builds on promises ‚Äî for example, is the same function as before, so there's minimal refactoring needed to change from promises to / . You can read more about the / syntax in the async functions and references. Note: / has the same concurrency semantics as normal promise chains. within one async function does not stop the entire program, only the parts that depend on its value, so other async jobs can still run while the is pending.\n\nIn the examples above involving , the first one has one promise chain nested in the return value of another handler, while the second one uses an entirely flat chain. Simple promise chains are best kept flat without nesting, as nesting can be a result of careless composition. Nesting is a control structure to limit the scope of statements. Specifically, a nested only catches failures in its scope and below, not errors higher up in the chain outside the nested scope. When used correctly, this gives greater precision in error recovery: Note that the optional steps here are nested ‚Äî with the nesting caused not by the indentation, but by the placement of the outer and parentheses around the steps. The inner error-silencing handler only catches failures from and , after which the code resumes with . Importantly, if fails, its error is caught by the final (outer) only, and does not get swallowed by the inner handler. In / , this code looks like: async function main() { try { const result = await doSomethingCritical(); try { const optionalResult = await doSomethingOptional(result); await doSomethingExtraNice(optionalResult); } catch (e) { // Ignore failures in optional steps and proceed. } await moreCriticalStuff(); } catch (e) { console.error(`Critical failure: ${e.message}`); } } Note: If you don't have sophisticated error handling, you very likely don't need nested handlers. Instead, use a flat chain and put the error handling logic at the end.\n\nIf a promise rejection event is not handled by any handler, it bubbles to the top of the call stack, and the host needs to surface it. On the web, whenever a promise is rejected, one of two events is sent to the global scope (generally, this is either the or, if being used in a web worker, it's the or other worker-based interface). The two events are: Sent when a promise is rejected but there is no rejection handler available. Sent when a handler is attached to a rejected promise that has already caused an event. In both cases, the event (of type ) has as members a property indicating the promise that was rejected, and a property that provides the reason given for the promise to be rejected. These make it possible to offer fallback error handling for promises, as well as to help debug issues with your promise management. These handlers are global per context, so all errors will go to the same event handlers, regardless of source. In Node.js, handling promise rejection is slightly different. You capture unhandled rejections by adding a handler for the Node.js event (notice the difference in capitalization of the name), like this: process.on(\"unhandledRejection\", (reason, promise) => { // Add code here to examine the \"promise\" and \"reason\" values }); For Node.js, to prevent the error from being logged to the console (the default action that would otherwise occur), adding that listener is all that's necessary; there's no need for an equivalent of the browser runtime's method. However, if you add that listener but don't also have code within it to handle rejected promises, they will just be dropped on the floor and silently ignored. So ideally, you should add code within that listener to examine each rejected promise and make sure it was not caused by an actual code bug.\n\nThere are four composition tools for running asynchronous operations concurrently: , , , and . We can start operations at the same time and wait for them all to finish like this: If one of the promises in the array rejects, immediately rejects the returned promise and aborts the other operations. This may cause unexpected state or behavior. is another composition tool that ensures all operations are complete before resolving. These methods all run promises concurrently ‚Äî a sequence of promises are started simultaneously and do not wait for each other. Sequential composition is possible using some clever JavaScript: In this example, we reduce an array of asynchronous functions down to a promise chain. The code above is equivalent to: This can be made into a reusable compose function, which is common in functional programming: The function accepts any number of functions as arguments and returns a new function that accepts an initial value to be passed through the composition pipeline: Sequential composition can also be done more succinctly with async/await: let result; for (const f of [func1, func2, func3]) { result = await f(result); } /* use last result (i.e. result3) */ However, before you compose promises sequentially, consider if it's really necessary ‚Äî it's always better to run promises concurrently so that they don't unnecessarily block each other unless one promise's execution depends on another's result.\n\nIn the callback-based API, when and how the callback gets called depends on the API implementor. For example, the callback may be called synchronously or asynchronously: The above design is strongly discouraged because it leads to the so-called \"state of Zalgo\". In the context of designing asynchronous APIs, this means a callback is called synchronously in some cases but asynchronously in other cases, creating ambiguity for the caller. For further background, see the article Designing APIs for Asynchrony, where the term was first formally presented. This API design makes side effects hard to analyze: let value = 1; doSomething(() => { value = 2; }); console.log(value); // 1 or 2? On the other hand, promises are a form of inversion of control ‚Äî the API implementor does not control when the callback gets called. Instead, the job of maintaining the callback queue and deciding when to call the callbacks is delegated to the promise implementation, and both the API user and API developer automatically gets strong semantic guarantees, including:\n‚Ä¢ Callbacks added with will never be invoked before the completion of the current run of the JavaScript event loop.\n‚Ä¢ These callbacks will be invoked even if they were added after the success or failure of the asynchronous operation that the promise represents.\n‚Ä¢ Multiple callbacks may be added by calling several times. They will be invoked one after another, in the order in which they were inserted. To avoid surprises, functions passed to will never be called synchronously, even with an already-resolved promise: Instead of running immediately, the passed-in function is put on a microtask queue, which means it runs later (only after the function which created it exits, and when the JavaScript execution stack is empty), just before control is returned to the event loop; i.e. pretty soon: const wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms)); wait(0).then(() => console.log(4)); Promise.resolve() .then(() => console.log(2)) .then(() => console.log(3)); console.log(1); // 1, 2, 3, 4"
    },
    {
        "link": "https://stackoverflow.com/questions/43076811/how-to-handle-error-properly-in-promise-chain",
        "document": "Say we have 3 asynchronous tasks that return Promises: , and . We want to chain them together (that is, for sake of clarity, taking the value returned by and calling with it), but also want to handle the errors correctly for each, and break out at the first failure. Currently, I see 2 ways of doing this:\n\nHere, the functions handle each of the success of the call to . But in the function, we'd have to handle all of the errors of , and , which may be complex and not easy to read, especially if we had more than 3 async tasks. So the other way takes this into consideration:\n\nHere, we separated out the logic of the original into , and , which seems simple and readable, since all errors are handled right next to its source. However, this does not do what I want.\n\nLet's see if fails (rejected), must not proceed to call , therefore must throw an exception or call reject. But both of these gets caught by and , meaning that and needs to know if we had already failed or not, presumably by keeping state (i.e. a variable).\n\nMoreover, it seems that the more async tasks we have, either our function grows in size (way 1), or more functions gets called (way 2). This brings me to my question:\n\nIs there a better way to do this?\n\nConsideration: Since exceptions in is handled by the rejection method, should there be a method to actually break off the chain?\n\nA possible duplicate, with an answer that adds more scopes inside the handlers. Aren't promises supposed to honor linear chaining of functions, and not passing functions that pass functions that pass functions?"
    },
    {
        "link": "https://dev.to/bhagatparwinder/promises-chaining-error-handling-operators-3ccb",
        "document": "8 Features From ES2020/ES11 You Should Know!\n\nThe last blog post details about what promises are, how to create, how do they resolve, and how we can reject them.\n\nThis time we will be going over chaining in promises along with error handling and operators available.\n\nOne of the most significant drawbacks of callbacks was the nested structure they formed when we would chain them. With the operator's help, we can create a flat structure that is easier to read, understand, and debug.\n\nLet's say we have a function that returns a promise. This function waits two seconds for a friend of yours and then yells (outputs in the console) their name.\n\n\n\nYou have a lot of lazy friends, and you would like to call them all as you are in a hurry. We will call them one by one (chaining the action).\n\n\n\nYou can see how we chained calling names with two-second breaks in between each console log. Every operator returns a promise that is further chained with another while maintaining a flat code structure.\n\nThere are two ways in which you can handle errors in your promise chain, either by passing an error handler to block or using the operator. We discussed the first method in the previous blog post.\n\n\n\nIn the above example, has two callbacks. The first one is a success handler, and the second is an error handler. Using both the handlers is completely fine and works for most cases. It has certain drawbacks:\n‚Ä¢ If the success handler ends in an error, you will not catch/handle it!\n‚Ä¢ If you are using a chain of promises like the one in the chaining example, you will be writing an error handler for each block.\n\nTo come over these drawbacks, we use the operator.\n\n\n\nFor the chain of promises we can use a operator like:\n\n\n\nKeep in mind that when chaining promises and one of the promise gets rejected, it will terminate the rest of the chain. That is why the last two console logs never run.\n\noperator does not always have to be at the very end. It could be in the middle of the chain and catch the chain's errors so far.\n\n\n\nüö® Why not use all the time and ignore the error handler in ?\n\nI mentioned this disadvantage above for error handler in :\n\nThere will be times when you DO want different error handlers for all blocks in your chain (maybe for easier debugging or logging). At that point, the error handler in individual blocks becomes an advantage.\n\nThere are two key operators that promises have, which are suited for specific conditions: and .\n\nPromise chaining comes in handy when you want to do one async operation after another (sequentially). Quite often, you would have to do multiple async operations concurrently without waiting for one to complete. Also, your action (callback) depends on all the async operations completing.\n\nallows us to run multiple async operations simultaneously (saving us time) but still wait for all of them to complete before executing the callback.\n\n\n\nThe example executes all promises together, and once all of them return the , outputs an array of results. This execution will take 2 seconds to output four names vs. the chaining example will take 8 seconds to output all four names.\n\nThe order of output in the array is strictly the same as the order of input promises to .\n\nüö® Even if there is a single failure in , the result will be that rejection or failure.\n\n\n\nIt will ignore all the other successfully resolved promises. If there is more than one rejection, it will output the rejection from a promise that comes first in the input array of promises.\n\n\n\nhandles a unique case. When you would like to run multiple async operations at the same time, but not wait for all to complete. Instead, you want to execute callback as soon as the first one completes (hence the keyword \"race\").\n\n\n\nI have made the time an argument as well. With each name, I am passing the time. \"Lauren\" has the least time of 3 seconds (3000 ms) so she would always win the race, and the console outputs her name."
    },
    {
        "link": "https://ads.yandex.com/helpcenter/en/docs-and-payments/payments",
        "document": "We need your payment details and copies of the required documents in order to transfer payments. To do this, go to Settings ‚Üí Bank details in the Yandex Advertising Network interface and enter your details.\n\nBefore filling out payment details and accepting the Yandex Advertising Network offer, a future partner granted a test period to configure and test the ad code. For more information, see Test period.\n\nFor more information about the documents we need to transfer payments, see:\n\nRemuneration is paid once your revenue reaches a certain threshold. This threshold depends on the partnership type and your country of residence. The threshold and term of remuneration payment are defined in the offer.\n\nRemuneration reports are prepared according to the periods in which the payments were made and are available on the Documents tab of the Yandex Advertising Network interface.\n\nHow the reward is calculated\n\nYou receive remuneration for viewable impressions. An impression is considered viewable if at least one pixel of the ad unit was in the viewable area of the screen.\n\nThe remuneration amount that a partner receives for one viewable impression is calculated using a complex algorithm that involves machine learning and depends on many factors, such as audience parameters or the ad type. This payment method provides a fair assessment of the cost of impressions on a site, regardless of what the advertiser pays for: impressions (CPM), clicks (CPC), or actions (CPA).\n\nTo change bank details to receive remuneration, go to Settings ‚Üí Bank details in the Yandex Advertising Network interface and update the information. You don't need to change the bank name manually: when the BIC/SWIFT is changed, the name automatically changes in the system.\n\nIf you are a Yandex Games partner and need to change your banking details, please contact support.\n\nFor individuals who are residents of the Russian Federation: Yandex withholds and pays personal income tax from remuneration (13%) and pays insurance premiums to the state off-budget funds.\n\nIn all other cases, taxes and fees are paid by the partners themselves.\n\nThis table compares the taxes for individuals, individual entrepreneurs (who use the simplified taxation system and don't have any employees), and those using the professional income tax system for the ‚Äúself-employed‚Äù. Tax rates and other information were last updated on September 2020.\n\nSelf-employed (with an estimated revenue up to 2,400,000 rubles per year) Individual (with an estimated revenue of up to 300,000 rubles per year) Individual entrepreneur (with an estimated revenue of over 300,000 rubles per year) Yandex sends remuneration to the partner in full and doesn't withhold any funds for tax purposes. It's on the partner to pay the tax, which is 6% of the monetization income. The tax is calculated automatically in the ‚ÄúMoi Nalog‚Äù app, which you can also use to pay the tax. Yandex acts as a tax agent (p. 1, article 226 of the Tax Code of the Russian Federation). From the partner's remuneration, the company withholds taxes at a rate of 13% (Personal Income Tax) and transfers it to the budget. If the partner's income exceeds 5,000,000 rubles per year, all income exceeding 5,000,000 rubles is taxed at a rate of 15%. In this case, the partner does not need to pay income tax. Taxes also do not need to be declared, since Yandex keeps a record of payments and reports them to the tax authorities (p. 1, article 230 of the Tax Code of the Russian Federation). If necessary, the company provides partners with a 2-NDFL personal income tax form with information detailing the amount of remuneration paid and tax withheld.\n‚Ä¢ Keep records of the income received from Yandex (article 346.24 of the Tax Code of the Russian Federation).\n‚Ä¢ Calculate and pay taxes quarterly at the rate of 6% of the income received from Yandex (p. 1, article 346.20 of the Tax Code of the Russian Federation). * Other tax rates may apply according to the the relevant laws of individual federal subjects of the Russian Federation.\n‚Ä¢ Submit yearly tax returns (sections 2, p. 1, article 346.23 of the Tax Code of the Russian Federation). The partner's tax is reduced by the amount of the insurance premiums paid as a ‚Äúfixed amount‚Äù (all insurance premiums actually accrued within the period of the past year). Before paying your tax totals, make sure to check for updates issued by the Russian Ministry of Finance at the end of the year regarding this issue. Insurance premiums (to the Pension Fund of Russia and the Mandatory Medical Insurance Fund) The professional income tax does not require you to pay for any mandatory insurance. Yandex pays the partner's insurance premiums from their own funds. The partner must calculate and pay the insurance premiums themselves. If annual revenue is less than 300,000 rubles, then the insurance premiums will total approximately 41,000 rubles. If annual revenue exceeds 300,000 rubles, then an additional 1% of the excess amount is paid. The maximum amount to pay is estimated to be about 260,000 rubles per year (section 1, article 430 of the Tax Code of the Russian Federation). Time and financial costs of register, calculating, declaring, and paying taxes and insurance premiums, as well as monitoring changes in tax legislation. The tax is calculated automatically in the ‚ÄúMoi Nalog‚Äù app. Yandex will issue and register receipts for your remuneration with the tax service to calculate the tax by. The partner is wholly responsible for providing accurate information and keeping it up to date in the ‚ÄúMoi Nalog‚Äù app and paying the tax. Yandex is responsible for keeping track of the partner's income records, as well as calculating, declaring, and paying taxes and insurance premiums. If monetizing site traffic is your main source of income, we recommend keeping track of case law regarding penalties for such activities for those registered as individual entrepreneurs (article 116 of the Tax Code of the Russian Federation, article 171 of the Criminal Code of the Russian Federation). The partner is responsible for registering, keeping track of income records, and declaring and paying taxes and insurance premiums."
    },
    {
        "link": "https://docs.bepaid.by/en/payment_methods/wallets/yandex_pay/integration/mobapp",
        "document": ""
    },
    {
        "link": "https://github.com/yoomoney/yookassa-android-sdk",
        "document": "This SDK allows processing payments using a payment token. It works as an addition to the YooMoney API.\n\nThe general payment process in the app is as follows:\n‚Ä¢ You start the process of tokenization in the SDK;\n‚Ä¢ The user selects the payment method and enters the required data;\n‚Ä¢ The SDK exchanges this data for a payment token ( ) and returns it to you;\n‚Ä¢ After you receive , create a payment using the API method;\n‚Ä¢ If necessary, launch the payment confirmation process in the SDK using 3DS or SberPay.\n\nThe SDK includes ready-made payment interfaces (payment form and everything related to it).\n\nUsing the SDK, you can receive tokens for processing payments from a bank card, Google Pay, Sberbank, or a YooMoney wallet.\n\nThis repository contains the SDK code and a sample app integrating it.\n‚Ä¢ Code of the demo app that integrates the SDK\n\nTo connect the library, add the dependencies to the build.gradle of the module:\n\nYou also need to connect the kotlin plugin. To do so, add the following block of code to the build.gradle file of the root directory:\n\nIn app, add the module to the build.gradle file:\n\nIf your app sells digital goods, you need to exclude Google Pay from the list of payment methods. To do so, add the following code to AndroidManifest:\n\nFor the library to work correctly, you should use the following:\n\nThe tokenization process is the exchange of payment data for a payment token ( ). This token is then used for creating a payment via the API method\n\nThe method is used for starting the tokenization process. The method returns which should be launched in . After that, the process will be controlled by the SDK. The created payment token can be obtained in\n‚Ä¢ testParameters (TestParameters) - parameters for the test mode - enable logging/use mock data (see Logging and mock mode configuration);\n‚Ä¢ amount (Amount) - cost of goods. Accepted payment methods may vary depending on this setting. This option will be displayed on the screen of the selected payment method in the process of tokenization via the selected payment method;\n‚Ä¢ title (String) - product name. This option will be displayed on the screen of the selected payment method in the process of tokenization via the selected payment method;\n‚Ä¢ subtitle (String) - product description. This option will be displayed on the screen of the selected payment method in the process of tokenization via the selected payment method;\n‚Ä¢ clientApplicationKey (String) - key for client apps from the YooMoney Merchant Profile (Settings section ‚Äî API Keys);\n‚Ä¢ shopId (String) - ID of the store in YooMoney (Organization section - copy shopId from the required store);\n‚Ä¢ savePaymentMethod (SavePaymentMethod) - settings for saving the payment method. Saved payment methods can be used for recurring payments, (see Recurring payments).\n‚Ä¢ paymentMethodTypes (Set of PaymentMethodType) - restrictions on payment methods. If you leave the field empty or specify null in it, the library will use all available payment methods, (see Launching tokenization via all methods);\n‚Ä¢ gatewayId (String) - gatewayId for the store, (see Launching Google Pay tokenization);\n‚Ä¢ customReturnUrl (String) - url of the page (only https is supported) that the user should be returned to after completing 3ds. Must be used only when own Activity for the 3ds url is used, (see 3DSecure);\n‚Ä¢ userPhoneNumber (String) - user's phone number for payments via SberPay, (see Launching tokenization via SberPay);\n‚Ä¢ googlePayParameters (GooglePayParameters) - settings for payments via Google Pay, (see Launching Google Pay tokenization);\n‚Ä¢ authCenterClientId (String) - unique ID of the app for tokenization via YooMoney. (See Launching tokenization via YooMoney wallet)\n‚Ä¢ ON - Save the payment method for recurring payments. Only payment methods that support saving will be available to the user. During the first payment, a notification stating that the payment method will be saved will appear on the screen of the selected payment method.\n‚Ä¢ OFF - Do not save the payment method.\n‚Ä¢ USER_SELECTS - The user chooses whether or not to save the payment method. If the method can be saved, a toggle will appear on the selected payment method screen. You can read more about recurring payments in the Recurring payments section.\n‚Ä¢ SBERBANK - payment was made via Sberbank (text message invoicing or SberPay);\n‚Ä¢ allowedCardNetworks (Set of GooglePayCardNetwork) - payment systems that allow for payments via Google Pay.\n\nTo launch tokenization via all available payment methods, call the method with the specified object that contains the set of all payment methods, or do not include this set.\n\nProcessed results of the tokenization process are contained in the Get tokenization results section\n\nIf you have already registered an app for oAuth-authorization, you can find the list of your apps at https://yookassa.ru/oauth/v2/client If you have not yet registered an app for oAuth-authorization, follow the instructions below.\n‚Ä¢ To register a new app, sign in at https://yookassa.ru\n‚Ä¢ After signing in, navigate to the app registration page - https://yookassa.ru/oauth/v2/client\n‚Ä¢ Click the Create app button and set the values for the parameters:\n‚Ä¢ Callback URL (any value; you can specify the link to the website);\n‚Ä¢ Accesses. This includes three sections: , , .\n‚Ä¢ In the section, give permission to view the balance of the user's wallet. To do so, check the box next to the View field in the WALLET BALANCE section;\n‚Ä¢ Open the section and give permission to view the user's phone number, email, name, and avatar. To do so, check the box next to the View field in the USER PHONE NUMBER, EMAIL, NAME, AND AVATAR section;\n‚Ä¢ Click or tap the \"Register\" button and complete the registration;\n‚Ä¢ Information about the registered app will appear in the opened window. You will need to launch tokenization;\n\nProcessed results of the tokenization process are contained in the Get tokenization results section\n\nPayments via SberPay allow for two user scenarios:\n‚Ä¢ Payment by phone number (without the Sberbank Online mobile app);\n\nTo provide the option of paying via the Sberbank Online mobile app to your users, specify the unique scheme from your app's deep link. The unique deep link scheme is what you specify as the scheme in your deep links. For example, in the deep link, is the scheme of your app.\n\nTo add a unique deep link scheme, insert the line to the android.defaultConfig block in your build.gradle file\n\nOr insert a line like this to your strings.xml:\n\nWhere is your app's unique deep link scheme (substitute this example for your scheme). If you are already processing some deep links in your app, you can use the ready-made scheme of your app. If you have not processed deep links in the projec beforet, you can create a unique scheme for your app (it must consist of Latin characters).\n\nLaunching tokenization via SberPay looks like this.\n\nProcessed results of the tokenization process are contained in the Get tokenization results section\n\nTo launch tokenization via just a bank card, specify in :\n\nProcessed results of the tokenization process are contained in the Get tokenization results section\n\nBefore launching Google Pay tokenization, you need to prepare the app and complete integration with the Google Pay API.\n\nFor payments via Google Pay to work properly in the production environment, make sure that:\n‚Ä¢ You have a developer account in the developer console: https://play.google.com/console\n‚Ä¢ An app has been created in the developer console;\n‚Ä¢ Your app is signed with a release key and uploaded to the developer console;\n\nOnce you've completed the steps in the Preparing the Google Play Console section, set up your profile in the Google Pay Business Console:\n‚Ä¢ Fill in all the information required for a company profile;\n‚Ä¢ After filling out the company profile, send it for verification by the Google Pay Business Console team;\n‚Ä¢ Wait until the company profile is verified by the Google Pay Business Console team.\n\nIf you've completed all of the steps listed above, start integrating the Google Pay API:\n‚Ä¢ Find the \"Integration with your Android app\" block;\n‚Ä¢ Find your app that you want to complete integration for in this block and click \"Manage\". If your app is not listed, follow the instructions in the Preparing the Google Play Console section;\n‚Ä¢ In the following window, select the type of integration through the gateway;\n‚Ä¢ Upload screenshots of the purchase process. The process of creating these screenshots is detailed in the Preparing screenshots of the purchase process for the Google Pay API section;\n‚Ä¢ After integration is verified and confirmed, the release-ready app will start working with payments via Google Pay.\n‚Ä¢ If integration was rejected, make corrections in accordance with the comments and resubmit the form.\n\nTo fill out the form in the Integrating the app with the Google Pay API section, you will need screenshots of the payment process. That includes screenshots of several steps, with examples shown below.\n\nWe propose using the sdk mock mode to take screenshots of the entire payment process. This is the mode where the sdk doesn't make any real requests to the server using previously prepared data instead.\n‚Ä¢ To do so, launch tokenization with all the payment methods you're planning to use.\n‚Ä¢ For the parameter, specify and \n\n\n\nis responsible for the environment that Google Pay will work in.\n‚Ä¢ If you specify , a test environment will be used (you can find out more at https://developers.google.com/pay/api/android/guides/test-and-deploy/integration-checklist)\n‚Ä¢ If you specify , or don't specify the parameter at all, the production environment will be used.\n\nBelow are examples of code with the launch of tokenization for taking screenshots of the payment process via Google Pay\n\nProcessed results of the tokenization process are contained in the Get tokenization results section\n\nTo launch tokenization via Google Pay, specify the value in\n\nProcessed results of the tokenization process are contained in the Get tokenization results section\n\nThis tokenization method is used when a bank card is linked to the store (see Linked card) and you need to re-request its CSC from the user. In other cases, the standard tokenization mechanism should be used (see Launching tokenization).\n\nTo start the tokenization process with a payment ID, use the method. The method returns an which should be launched in . The created payment token can be obtained in (see Getting tokenization results)\n‚Ä¢ savedBankCardPaymentParameters (SavedBankCardPaymentParameters) - parameters of the payment via a saved bank card.\n‚Ä¢ testParameters (TestParameters) - parameters for the test mode - enable logging/use mock data (see Logging and mock mode configuration);\n‚Ä¢ amount (Amount) - cost of goods. Accepted payment methods may vary depending on this setting;\n‚Ä¢ clientApplicationKey (String) - key for client apps from the YooMoney Merchant Profile (Settings section ‚Äî API Keys);\n‚Ä¢ shopId (String) - ID of the store in YooMoney (Organization section - copy shopId from the required store);\n‚Ä¢ savePaymentMethod (SavePaymentMethod) - settings for saving the payment method. Saved payment methods can be used for recurring payments, (see Recurring payments).\n‚Ä¢ gatewayId (String) - gatewayId for the store, (see Launching Google Pay tokenization).\n‚Ä¢ ON - Save the payment method for recurring payments. Only payment methods that support saving will be available to the user. During the first payment, a notification stating that the payment method will be saved will appear on the screen of the selected payment method.\n‚Ä¢ OFF - Do not save the payment method.\n‚Ä¢ USER_SELECTS - The user chooses whether to save the payment method or not. If the method can be saved, a toggle will appear on the selected payment method screen. You can read more about recurring payments in the Recurring payments section.\n\nProcessed results of the tokenization process are contained in the Get tokenization results section\n\nThe results of the method can be processed in the method.\n\nIn case of successful tokenization, mSDK will return the entity that contains the token and the type of payment tool used to receive it. Use the method to get the token.\n‚Ä¢ SBERBANK - payment was made via Sberbank (text message invoicing or SberPay);\n\nIf necessary, the system may request a payment confirmation process, where the user confirms the transaction via third-party services. There are two types of payment confirmation: 3Dsecure (for payments via bank card and Google Pay) and push notifications or App2App script (for payments via SberPay).\n\nTo confirm a payment made via SberPay, you must:\n‚Ä¢ process the received result in the onActivityResult method in Activity;\n‚Ä¢ paymentMethodType (PaymentMethodType) - selected type of payment method (the one that was received in the method, (see Getting tokenization results).\n‚Ä¢ testParameters (TestParameters) - parameters for the test mode - enable logging/use mock data (see Logging and mock mode configuration);\n\nPossible types of results of 3DSecure initiation:\n‚Ä¢ Activity.RESULT_OK - indicates that the 3ds process is complete, but does not guarantee that it was successful. After receiving the result, we recommended requesting the payment status;\n‚Ä¢ Activity.RESULT_CANCELED - 3ds authentication was canceled (for example, the user tapped the \"back\" button during the process);\n\nLaunching 3ds and getting the results\n\nTo conduct 3DSecure for a payment made via a bank card, you can use Activity provided by the mSdk library:\n‚Ä¢ during the tokenization process, don't specify the parameter in the method (see Launching tokenization via a bank card);\n‚Ä¢ process the received result in the onActivityResult method in Activity;\n‚Ä¢ paymentMethodType (PaymentMethodType) - selected type of payment method (the one that was received in the method, (see Getting tokenization results).\n‚Ä¢ testParameters (TestParameters) - parameters for the test mode - enable logging/use mock data (see Logging and mock mode configuration);\n\nPossible types of results of 3DSecure initiation:\n‚Ä¢ Activity.RESULT_OK - indicates that the 3ds process is complete, but does not guarantee that it was successful. After receiving the result, we recommended requesting the payment status;\n‚Ä¢ Activity.RESULT_CANCELED - 3ds authentication was canceled (for example, the user tapped the \"back\" button during the process);\n\nLaunching 3ds and getting the results\n\nSpecify the optional parameter in the method for tokenization (see Launching tokenization via a bank card) so that after the tokenization with a bank card, this bank card would be successfully linked and displayed in the list of payment methods available to the user. The card is linked only when the user consents to its linking.\n‚Ä¢ customerId (String) - unique ID of the customer in your system, such as email addres or phone number. Limit by length: no more than 200 characters. Make sure the customerId corresponds to the user who wants to make a purchase. For example, use two-factor authentication. If you specify an incorrect ID, the user will be able to select other people's bank cards for payment.\n\nTherefore, the method for carrying out the tokenization of a bank card with the subsequent linking of this bank card is as follows:\n\nYou can use the test mode to see how the linked card will look on the screen with the list of payment methods. You must set the number of cards in the parameter of the object and call the method. Learn more in the Logging and mock mode configuration section\n\nRecurring payments are payments that are repeated in accordance with a specific schedule. Debits for such payments are made automatically after the consent of the user.\n\nYou can save some payment methods and use them for recurring payments. In this case, the user needs to confirm only the first payment, and subsequent debits will be unconditional. You can learn more here\n\nTo enable autopayments, specify one of the following values to the parameter during the tokenization process:\n‚Ä¢ - save the payment method for recurring payments. Only payment methods that support saving will be available to the user. During the first payment, a notification stating that the payment method will be saved will appear on the screen of the selected payment method.\n‚Ä¢ - the user chooses whether or not to save the payment method. If the method can be saved, a toggle will appear on the selected payment method screen.\n\n\n\nYou may need to include logs in the sdk for the purposes of debugging. To do that, specify the parameter in when launching tokenization\n\nThe library has a mock mode which you can use to see what the SDK would look like with various inputs. This mode does not require Internet access. The received token can't be used for payment.\n‚Ä¢ (Boolean) - whether the user is authorized to pay with a wallet or not;\n‚Ä¢ (Int) - number of cards linked to the user's wallet;\n‚Ä¢ (Amount) - commission that will be displayed on the screen of the selected payment method;\n\nTo run tokenization in mock mode, specify the parameter in\n\nTo customize the SDK interface, you can use the object, namely set the main color of the interface and configure the display of the YooMoney logo on the screen with the list of payment methods (hide or show).\n‚Ä¢ showLogo (Boolean) - show or hide the YooMoney logo on the screen with the list of payment methods;\n‚Ä¢ primaryColor (ColorInt) - the main color of the app. Buttons, switches, input fields, etc. will be switched to this color. We don't recommend making this color too light if your theme is already designed with light colors, as it won't be visible on a white background, or choose a dark color for a dark theme, since it won't be visible either. We also don't recommend using red as it might mix up with color of error messages. : () { () { paymentParameters ( .) uiParameters ( showLogo , colorScheme ( .rgb( , , )) ) specify the true flag so that the YooMoney logo is displayed on the screen with the list of payment methods and specify the ColorScheme that contains the custom color intent createTokenizeIntent( context , paymentParameters paymentParameters, uiParameters uiParameters ) startActivityForResult(intent, ) } } { () { = (...); = ( , ( . ( , , ))); // specify the true flag so that the YooMoney logo is displayed on the screen with the list of payment methods and specify the ColorScheme that contains the custom color = . ( , , , ); ( , ); } }\n\nThe sdk includes the option to connect a library for scanning bank cards with a camera. If you enable scanning, a special button will appear on the bank card number entry form :\n\nWhen the user taps this button, the sdk will launch to launch that implements card scanning.\n\nTo do that, create that will handle the action, then register this in , specifying for the action:\n\nNow when you tap the card scanning button , your will be launched where you will need to implement the card scanning, then complete and specify the resuls using the method.\n\nTo do that, before completing , call the method and specify the card number and optional month/year parameters, and send it to the method. Then call the method\n\nBelow you can find the example of bank card data scanning implemented via the third-party library card.io: https://github.com/card-io/card.io-Android-SDK You can use any other library or solution that suits you."
    },
    {
        "link": "https://github.com/ManCoder/ya-pay-sdk/blob/master/README.md",
        "document": "This library allows you to make payments via Yandex.Money APIv3 easily with our incredible UI.\n‚Ä¢ Register your App at OAuth Yandex and save your ID.\n‚Ä¢ In Capabilities section of you Project enable Associated Domains and add domain: where is ID from first step. For instance if your App ID is 333, the domain is\n\nFirst you need to get client application key and create .\n\nTo start tokenization process you need to create Tokenization View controller from Tokenization assembly and present received view controller.\n\nWhen the payment process is complete you should dismiss received view controller and send token to your back-end:\n\nIf you want to use a scan card, you must implement the protocol CardScanning and pass this object to TokenizationModuleInputData.\n\nNext, implement you scanner delegate for (for example, CardIO):\n\nThen when initialize input data pass to argument.\n\nIf you want to use our implementation of 3D Secure, you don't have to dismiss our UIViewController after receiving the token. Send the token to your server and after successful payment dismiss UIViewController. If your server has reported the need to confirm the payment, call the method\n\nAfter successful completion of the 3D secure process, the method will be called which is specified in the protocol\n‚Ä¢ Show 3DSecure if need to confirm payment\n‚Ä¢ After success 3DSecure process will be called\n\nFollow the steps described in the official documentation from Apple."
    },
    {
        "link": "https://git.yoomoney.ru/projects/SDK/repos/yookassa-payments-api-swift/raw/docs/Classes/PaymentOptionYandexMoneyInstrument.html?at=refs%2Ftags%2F1.5.0",
        "document": "Type of the source of funds for the payment.\n\nList of possible methods of payment confirmation. If payment confirmation is not required, the field is missing. Read more about the scenarios of confirmation of payment by the buyer."
    }
]