[
    {
        "link": "https://react.dev/learn/creating-a-react-app",
        "document": "If your app has constraints not well-served by existing frameworks, you prefer to build your own framework, or you just want to learn the basics of a React app, you can build a React app from scratch.\n\nThese recommended frameworks support all the features you need to deploy and scale your app in production. They have integrated the latest React features and take advantage of React‚Äôs architecture.\n\nAll the frameworks on this page support client-side rendering (CSR), single-page apps (SPA), and static-site generation (SSG). These apps can be deployed to a CDN or static hosting service without a server. Additionally, these frameworks allow you to add server-side rendering on a per-route basis, when it makes sense for your use case. This allows you to start with a client-only app, and if your needs change later, you can opt-in to using server features on individual routes without rewriting your app. See your framework‚Äôs documentation for configuring the rendering strategy.\n\nNext.js‚Äôs App Router is a React framework that takes full advantage of React‚Äôs architecture to enable full-stack React apps.\n\nNext.js is maintained by Vercel. You can deploy a Next.js app to any Node.js or serverless hosting, or to your own server. Next.js also supports static export which doesn‚Äôt require a server. Vercel additionally provides opt-in paid cloud services.\n\nReact Router is the most popular routing library for React and can be paired with Vite to create a full-stack React framework. It emphasizes standard Web APIs and has several ready to deploy templates for various JavaScript runtimes and platforms.\n\nExpo is a React framework that lets you create universal Android, iOS, and web apps with truly native UIs. It provides an SDK for React Native that makes the native parts easier to use. To create a new Expo project, run:\n\nIf you‚Äôre new to Expo, check out the Expo tutorial.\n\nExpo is maintained by Expo (the company). Building apps with Expo is free, and you can submit them to the Google and Apple app stores without restrictions. Expo additionally provides opt-in paid cloud services.\n\nThere are other up-and-coming frameworks that are working towards our full stack React vision:\n‚Ä¢ TanStack Start (Beta): TanStack Start is a full-stack React framework powered by TanStack Router. It provides a full-document SSR, streaming, server functions, bundling, and more using tools like Nitro and Vite.\n‚Ä¢ RedwoodJS: Redwood is a full stack React framework with lots of pre-installed packages and configuration that makes it easy to build full-stack web applications.\n\nWhich features make up the React team‚Äôs full-stack architecture vision? Next.js‚Äôs App Router bundler fully implements the official React Server Components specification. This lets you mix build-time, server-only, and interactive components in a single React tree. For example, you can write a server-only React component as an function that reads from a database or from a file. Then you can pass data down from it to your interactive components: Next.js‚Äôs App Router also integrates data fetching with Suspense. This lets you specify a loading state (like a skeleton placeholder) for different parts of your user interface directly in your React tree: Server Components and Suspense are React features rather than Next.js features. However, adopting them at the framework level requires buy-in and non-trivial implementation work. At the moment, the Next.js App Router is the most complete implementation. The React team is working with bundler developers to make these features easier to implement in the next generation of frameworks.\n\nIf your app has constraints not well-served by existing frameworks, you prefer to build your own framework, or you just want to learn the basics of a React app, there are other options available for starting a React project from scratch.\n\nStarting from scratch gives you more flexibility, but does require that you make choices on which tools to use for routing, data fetching, and other common usage patterns. It‚Äôs a lot like building your own framework, instead of using a framework that already exists. The frameworks we recommend have built-in solutions for these problems.\n\nIf you want to build your own solutions, see our guide to build a React app from Scratch for instructions on how to set up a new React project starting with a built tool like Vite, Parcel, or RSbuild.\n\nIf you‚Äôre a framework author interested in being included on this page, please let us know."
    },
    {
        "link": "https://react.dev/learn",
        "document": "Welcome to the React documentation! This page will give you an introduction to 80% of the React concepts that you will use on a daily basis.\n‚Ä¢ How to create and nest components\n‚Ä¢ How to add markup and styles\n‚Ä¢ How to render conditions and lists\n‚Ä¢ How to respond to events and update the screen\n‚Ä¢ How to share data between components React apps are made out of components. A component is a piece of the UI (user interface) that has its own logic and appearance. A component can be as small as a button, or as large as an entire page. Now that you‚Äôve declared , you can nest it into another component: Welcome to my app\n\n Notice that starts with a capital letter. That‚Äôs how you know it‚Äôs a React component. React component names must always start with a capital letter, while HTML tags must be lowercase. Have a look at the result:\n\nThe keywords specify the main component in the file. If you‚Äôre not familiar with some piece of JavaScript syntax, MDN and javascript.info have great references. The markup syntax you‚Äôve seen above is called JSX. It is optional, but most React projects use JSX for its convenience. All of the tools we recommend for local development support JSX out of the box. JSX is stricter than HTML. You have to close tags like . Your component also can‚Äôt return multiple JSX tags. You have to wrap them into a shared parent, like a or an empty wrapper: Hello there. How do you do?\n\n If you have a lot of HTML to port to JSX, you can use an online converter. In React, you specify a CSS class with . It works the same way as the HTML attribute: Then you write the CSS rules for it in a separate CSS file: React does not prescribe how you add CSS files. In the simplest case, you‚Äôll add a tag to your HTML. If you use a build tool or a framework, consult its documentation to learn how to add a CSS file to your project. JSX lets you put markup into JavaScript. Curly braces let you ‚Äúescape back‚Äù into JavaScript so that you can embed some variable from your code and display it to the user. For example, this will display : You can also ‚Äúescape into JavaScript‚Äù from JSX attributes, but you have to use curly braces instead of quotes. For example, passes the string as the CSS class, but reads the JavaScript variable value, and then passes that value as the attribute: You can put more complex expressions inside the JSX curly braces too, for example, string concatenation:\n\nIn the above example, is not a special syntax, but a regular object inside the JSX curly braces. You can use the attribute when your styles depend on JavaScript variables. In React, there is no special syntax for writing conditions. Instead, you‚Äôll use the same techniques as you use when writing regular JavaScript code. For example, you can use an statement to conditionally include JSX: If you prefer more compact code, you can use the conditional operator. Unlike , it works inside JSX: When you don‚Äôt need the branch, you can also use a shorter logical syntax: All of these approaches also work for conditionally specifying attributes. If you‚Äôre unfamiliar with some of this JavaScript syntax, you can start by always using . You will rely on JavaScript features like loop and the array function to render lists of components. For example, let‚Äôs say you have an array of products: Inside your component, use the function to transform an array of products into an array of items: Notice how has a attribute. For each item in a list, you should pass a string or a number that uniquely identifies that item among its siblings. Usually, a key should be coming from your data, such as a database ID. React uses your keys to know what happened if you later insert, delete, or reorder the items.\n\nYou can respond to events by declaring event handler functions inside your components: Notice how has no parentheses at the end! Do not call the event handler function: you only need to pass it down. React will call your event handler when the user clicks the button. Often, you‚Äôll want your component to ‚Äúremember‚Äù some information and display it. For example, maybe you want to count the number of times a button is clicked. To do this, add state to your component. Now you can declare a state variable inside your component: You‚Äôll get two things from : the current state ( ), and the function that lets you update it ( ). You can give them any names, but the convention is to write . The first time the button is displayed, will be because you passed to . When you want to change state, call and pass the new value to it. Clicking this button will increment the counter: React will call your component function again. This time, will be . Then it will be . And so on. If you render the same component multiple times, each will get its own state. Click each button separately:\n\nNotice how each button ‚Äúremembers‚Äù its own state and doesn‚Äôt affect other buttons. Functions starting with are called Hooks. is a built-in Hook provided by React. You can find other built-in Hooks in the API reference. You can also write your own Hooks by combining the existing ones. Hooks are more restrictive than other functions. You can only call Hooks at the top of your components (or other Hooks). If you want to use in a condition or a loop, extract a new component and put it there. In the previous example, each had its own independent , and when each button was clicked, only the for the button clicked changed: The first updates its to However, often you‚Äôll need components to share data and always update together. To make both components display the same and update together, you need to move the state from the individual buttons ‚Äúupwards‚Äù to the closest component containing all of them. In this example, it is : Initially, ‚Äôs state is and is passed down to both children On click, updates its state to and passes it down to both children Now when you click either button, the in will change, which will change both of the counts in . Here‚Äôs how you can express this in code. First, move the state up from into : Then, pass the state down from to each , together with the shared click handler. You can pass information to using the JSX curly braces, just like you previously did with built-in tags like : The information you pass down like this is called props. Now the component contains the state and the event handler, and passes both of them down as props to each of the buttons. Finally, change to read the props you have passed from its parent component: When you click the button, the handler fires. Each button‚Äôs prop was set to the function inside , so the code inside of it runs. That code calls , incrementing the state variable. The new value is passed as a prop to each button, so they all show the new value. This is called ‚Äúlifting state up‚Äù. By moving state up, you‚Äôve shared it between components."
    },
    {
        "link": "https://freecodecamp.org/news/best-practices-for-react",
        "document": "Two years ago, I started to learn and use React. And today I'm still using it at my day job as a Software Developer and in my own side projects.\n\nDuring that time I've come across a lot of \"typical\" issues. So I searched around and found some best practices that I've integrated into my workflow, and I've come up with things that have made my life or my team members' lives easier.\n\nI also faced challenges along the way that I didn't solve in the best way at the time, and I want to approach them in a better way in the future.\n\nThat's the reason I wrote this guide. I think of it like a collection of tips I'd have given myself two years ago when I started out.\n‚Ä¢ None Learn How to Build Clean, Performant and Maintainable React Components\n‚Ä¢ None Tips to Help You Write Better React Code ‚Äì The Cherries on Top\n\nFirst and foremost, you'll get to know the three major challenges every React developer has to face. This is important because when you are aware of potential challenges, you'll understand the reasons behind these best practices in a deeper way. Having this mindset from the beginning also helps you when designing your components or organizing your project.\n\nAfter that first important step, I'll introduce you to the three best practices. They're a mixture of theoretical and practical tips with code examples. I try to minimize hello world problems and come up with code I've seen in the real world.\n\nDuring my two years of using React on a daily basis, I've recognized three major challenges that React developers face when building their apps. Ignoring these challenges might bring hard times that harm the growth of your app.\n\nSo keep these challenges in mind when orchestrating your app, as it'll save you time and energy.\n\nThis goes hand in hand with reusability. At the beginning when the application and the components are very lightweight, they're easy to maintain. But once the requirements start growing, components tend to become very complex and therefore less maintainable.\n\nI've often seen a component that has many different cases, each representing a different outcome. The JSX is flooded with conditional renderings (ternary operators and simple operators), classnames are applied conditionally, or the component uses a huge statement. There are many possible prop and state values, each responsible for a different outcome.\n\nThere's nothing wrong with those techniques in and of themselves, in my opinion. But I think everyone should develop a feeling for when a component starts to become less maintainable and when these techniques become overused. We'll learn how to control this better later on in the article.\n\nThe problem (and I've been guilty of this as well) is that the more complexity and different outcomes a component has (polymorphism), the more difficult it becomes to maintain.\n\nTo be honest, the root cause is often laziness, not enough experience, or time pressure to refactor a component properly in order to make it more maintainable and cleaner.\n\nAnother key factor I've seen is no or little testing. I know, testing is not a type of work many developers love, but it can really help you on the long run. Testing itself won't be a major topic in this post, so keep your eyes open for another blog post of mine about it.\n\nAnother root cause for problems React devs have is a poor basic understanding of how React works under the hood. I've been there, too.\n\nI've seen many people jumping too fast into intermediate or advanced concepts without having a solid foundation. But this isn't only particular to React. It's a general problem in programming.\n\nNot having a solid understanding of React can also cause issues for you as a developer. I remember having headaches when I wanted to use different component lifecycles but didn't know how to actually use them. So I had to take a few steps back and go deeper into that topic.\n\nBecause I think it's one of the most important things, I've dedicated a whole chapter to it in this blog post below.\n\nThis challenge goes hand in hand with maintainability. It is not only specific to React, but applies generally in software.\n\nI've learned that crafting excellent software is not only about UX, clean code patterns, or clever architecture, for example. For me, the quality of a software also rises or falls with its ability to scale.\n\nTo me, many things come into play that increase the scalability of software. You'll learn my most important tips in this article.\n\nI think when you keep maintainability and scalability in mind when orchestrating your components and organizing your project structure, you'll less likely end up with a mess of source code that needs major refactoring.\n\nAlright, now let's dive deeper into some best practices for learning React.\n\nAs we discussed briefly above, manifesting the building blocks is not only relevant to learning React, but to other technologies or programming languages as well. You can't build a skyscraper on a sandy foundation and expect it to be solid.\n\nThis might seem obvious to many of you, but I've seen developers who jumped into the intermediate or advanced concepts of React without really understanding the basics.\n\nThis also true for Javascript in general. I'm a huge believer that learning React doesn't make sense if you don't have a solid foundation in Vanilla Javascript.\n\nSo, if that sounds familiar to you and you're thinking about learning React but not feeling very comfortable with Vanilla Javascript already, spend some more time on strengthening Javascript first. It will save you a lot of headaches and time in the future.\n\nHere's a helpful guide to the top JavaScript concepts you need to know before diving into React if you want to review.\n\nBut knowing the basics alone is not enough for me. It's kind of mandatory to know how React works under the hood. If you want to become a good React developer (which I assume you do, because you're reading this article), you have to know the tool you're using. This is beneficial for you as a developer and for your clients as well.\n\nOn the one hand it can save you a lot of time debugging your application. On the other hand it makes you more efficient because you don't have to take some steps back to re-learn the basics again and again. You basically know what you're talking about.\n\nOf course, you can't know it all and you shouldn't stress yourself out on that topic. You'll learn more and more as you go through practical problems and build more projects. But with a good solid knowledge you are equipped well from the beginning.\n\nOkey, that makes sense. But you might be wondering what exactly you need to know in order to have a solid foundation in React?\n\nAs a bare minimum, you should understand all the topics inside the Main Concepts Chapter inside the official React Docs.\n\nAnother chapter you should be very familiar with is the one on Hooks because they've become a convention and are used everywhere, especially in third party React packages.\n\nOf course there are some you might use more often like and , but understanding the other ones like , or is also essential.\n\nThere's also another chapter called Advanced Guides that I wouldn't consider to be mandatory at the beginning, but I'd highly recommend that you grasp those concepts during your React journey.\n\nAs always, it's often easier to understand advanced topics when you already have some practical experience. But the more of those things you understand early on, the better.\n\nOf course you shouldn't limit yourself to just only following the React docs. Working through an online course that covers those building blocks, watching tutorials or reading other blog posts is also part of building a solid foundation. So, test what works best for you.\n\nIf I had to choose the most important concepts to know at a bare minimum, I'd suggest these:\n‚Ä¢ None ups and downs of class and functional components\n‚Ä¢ None what are component re-renderings and how do they work?\n‚Ä¢ None different component lifecycles and how to interact with them\n‚Ä¢ None Benefits of CSR (Client Side Rendering) and SSR (Server Side Rendering) in general and in React\n‚Ä¢ None at least one global state management technology (Context API, Redux/Toolkit, Recoil)\n‚Ä¢ None Component Patterns (especially how to choose the right pattern)\n\nLearn How to Build Clean, Performant and Maintainable React Components\n\nI know ‚Äì this is the dream of every programmer (or at least I hope it is). And for me, this ability separates a good programmer from a great programmer. The fun part is that it's never really completed because there's always something to learn and to improve.\n\nFollowing these best practices won't only make it easier for you, but also for your teammates. I've seen development teams who created a style guide where they defined important cornerstones about how they're writing code. Very smart idea if you'd ask me.\n\nSome of them were:\n\nAnd so on.\n\nOf course you can get very detailed about it. This depends on your team. I personally don't like very detailed style guides because I think you should have some type of freedom as a skilled developer and shouldn't be restricted too much.\n\nBut a style guide in general is a good way to outline and keep up best practices and makes sure your team is on the same page regarding some important areas. I think this increases teamwork and output tremendously.\n\nLet's take a look what those best practices actually are to create components that are clean, performant, and maintainable. Make yourself comfortable, grab something to take a notes with, and enjoy!\n\nOrganizing your files and folders inside your React application is mandatory for maintainability and scalability.\n\nA good folder structure depends on the size of your application and your team. So there's no general answer to that. Especially because this is a highly opinionated topic and depends also on personal preferences.\n\nBut over the time, some best practices for different sizes of an application have evolved.\n\nThis great blog post goes through five different application sizes and introduces good ideas of how to organize your files and folders. Having this in mind when planning or starting your application can make a huge difference on the long run.\n\nDon't over-engineer it, but try your best maintain a proper structure that is best suited for your current application and your team size.\n\nIf you've already got some experience in React, you might have seen files that are bloated with a lot of import statements. They might also be mixed up with external imports from third-party packages and internal imports like other components, util functions, styles and many more.\n\nYou probably recognize the deal here. It's difficult to distinguish what are all the third-party and the local (internal) imports. They are not grouped and seem to be all over the place.\n\nThe structure is clearer and it's very easy to distinguish where the external and internal imports are. Of course you can optimize it more if you are using more named imports (if that's possible! :) ). That allows you to import all the components that are coming from material-ui all on one line.\n\nI've seen other developers who like to split the import structure up in three different parts:\n\nYou can manage it every time by yourself or let a linter do the job. Here's a great article about how to configure your linter for your React app to maintain a proper import structure.\n\nTo ensure you don't end up with unmaintainable and unscalable spaghetti code, learning different component patterns is essential as you become more experienced in React.\n\nBut this is not all. Knowing the different patterns is a good foundation. But the most important aspect about it is that you know when to use which pattern for your problem.\n\nEvery pattern serves a certain purpose. For example the compound component pattern avoids unnecessary prop-drilling of many component levels. So, the next time you begin to do pass props through five component levels to finally reach the component that is interested in the props, you start to orchestrate the components differently.\n\nOne quick side note here about props-drilling, because I've had many discussions about it in the past. There're many opinions out there as to whether it's bad or not. As for me, I like to try to think about a different way / pattern if I start to pass props through more than two component levels.\n\nThis fact makes you more efficient as a developer and makes the components you write more maintainable or scalable. Having those patterns in your toolkit makes you also stand out from other React developers. I highly encourage you to do your own research, but this Udemy course helped me very much.\n\nA linter doesn't only help you in terms of maintaining a distinguishable import order of your dependencies. It helps you write better code in general.\n\nWhen you're using create-react-app, there's already ESLint configured, but you can also set it up completely on your own or extend the rules of a pre-configured ruleset.\n\nA linter basically observes the JavaScript code you're writing and reminds you of errors you'd more likely catch when executing the code. It took a while for me to really value the use of a linter, but today I can't imagine working without it.\n\nHaving the linter is one thing, but following its rules is another. Of course you can disable it. Either for a specific line of code or for the whole file itself. There may be cases where this makes sense, but from my experience they're pretty rare.\n\nAnother great benefit is that you can also adjust style checking. This is especially helpful for teams. Once you agreed upon certain conventions of how you write your code and how it should be formatted, you can easily combine ESLint with something like JSPrettify.\n\nI know, testing is likely not your favorite task as a developer. I used to be like that. At the beginning it seemed to be an unnecessary and disturbing task. This might be true for the short run. But in the long run ‚Äì and when the application grows ‚Äì it is vital.\n\nFor me, testing has become a practice that ensures I'm doing my job more professionally and delivering higher quality software.\n\nBasically there's nothing wrong with manual testing by a human and that shouldn't be avoided completely. But imagine you're integrating a new feature and want to make sure that nothing is broken. This can be a time consuming task and is prone to human error.\n\nDuring the time you're writing tests you're already in the thinking process of how to organize your code in order to pass this test. For me this is always helpful because I recognize what pitfalls might arise and that I have to keep an eye on them.\n\nYou're not directly jumping into writing your code either (which I wouldn't recommend at all), but you're thinking first about the goal.\n\nFor example \"What should that particular component do? What important edge cases might arise that I have to test? Can I make the component more pure that it only serves one purpose? ...\"\n\nHaving a vision for the code you're about to write also helps you to maintain a sharp focus on serving that vision.\n\nTests can also serve as a kind of documentation, because for a new developer who is new to the codebase it can be very helpful to understand the different parts of the software and how they're expected to work.\n\nSo, don't avoid testing because it seems to be extra work. The reality is that it can save you extra work in the future when you set it up properly.\n\nTake a look at the \"Testing\" chapter inside the React Docs, go through a few tutorials on testing in React, and just start writing your first small TDD application or implement tests into an app you're currently working on.\n\nüß∞ Integrate Typescript (or at least use default props and prop types)\n\nI remember my first React project as a software developer where our team received a project that was already basically written by another company. Then we had to build the client's project upon it, and Typescript had already been integrated.\n\nUp to that point, my teammates and I hadn't had much experience in TypeScript since we all came from a vanilla JavaScript background.\n\nAfter a few weeks of working with that project, we felt that TypeScript wasn't a benefit, but more an obstacle that blocked us in our workflow. We also weren't really using the benefits of it because we defined everything with type any to suppress the Typescript warnings.\n\nThat led us to the decision to remove TypeScript from the project and to work on our known terrain with vanilla JavaScript. This went well at first, but the more complex our project became, the more type errors emerged. So we doubted our decision a lot of getting completely rid of TypeScript. But those things can happen and gave us valuable experiences for the future.\n\nThis circumstance led me to give TypeScript another chance, and I learned it in my spare time. After building some side projects with it, I can't imagine a life without it anymore.\n\nUsing TypeScript has many upsides like static type checking, better code completion in your IDE (intellisense), improved developer experience, and catching type errors while you write the code ‚Äì just to name a few.\n\nOn the other hand it can have some challenges of course, because if you're not coming from a background with strongly typed languages (like Java or C#) it might be harder at the beginning to grasp it.\n\nBut I can say that it's really worth it to learn and to integrate it. Here's a nice article that can help you out of getting an overview of the ups and downs using Typescript in React applications. And here's a tutorial on how to code your React apps in TypeScript.\n\nThere may be reasons you don't want to use TypeScript inside your React application. That's fine. But at a bare minimum I'd recommend that you use prop-types and default-props for your components to ensure you don't mess up your props.\n\nIf you've spent some time in the JavaScript and React universe, you've most likely stumbled across bundling. For those of you who are hearing this term for the first time, let's see what the official React docs say:\n\nBasically this is a great technique, but with the growth of your app comes a challenge. Your bundle starts growing as well. Especially when you're using big third-party libraries like three.js.\n\nThe pitfall is that this bundle needs to be always loaded completely, even when the user needs only a fraction of the code. This leads to performance issues because it can take an unnecessarily long time to load up your app.\n\nTo avoid this, there's a technique called code splitting where you split up your bundle into the pieces of the code your user needs. This is supported by the most common bundlers like Webpack, Rollup, and Browserify. The great benefit of it is that you can create multiple bundles and load them dynamically.\n\nSplitting up your bundle helps you to lazy load only the things that are needed by the user.\n\nTo illustrate this, imagine you're going into a grocery store and just want to grab some bananas, apples, and bread. In that case you aren't buying the whole range of the store and then grab your bananas, apples and bread out of it. You're just interested in a fraction of the range. So why would you buy everything? It would take way longer and is of course more expensive.\n\nI think it's important to be aware of the potential challenges that can arise as your app grows, and that there are certain techniques at hand to get rid of those issues. For further reading checkout the React docs.\n\nAccording to the React docs,\n\nBasically they're a better solution to the techniques that were used before in combination with class components. If you've been coding for a while, you might remember the use of Higher Order Components or render props.\n\nWhenever you find yourself in a situation where you have to reuse the same stateful logic that is already used in another functional component, that's a great time to create a custom hook. Inside it you encapsulate the logic and just have to call the hook as a function inside your components.\n\nLet's take a look at a quick example where we need to update our UI according to the screen size and want to keep track of the current window size when resizing the browser window manually.\n\nAs you can see, the solution is pretty straightforward and there's nothing wrong with defining it like this.\n\nNow comes the tricky part. Imagine we'd like to use the exact logic in another component, where we'll render a different UI (one for smartphones and one for desktops) based on the current screen size.\n\nOf course we could just copy the logic, paste it in and we're done. But this is not a good practice, as you might know from the DRY principle.\n\nIf we'd like to adjust our logic, we have to do it in both components. And when we paste our logic in even more components, it becomes less maintainable and more error prone.\n\nSo, what would you normally do in a vanilla JavaScript project? You'd most likely define a function that encapsulates the logic and can be used in many different places. That's exactly what we'll achieve with hooks. They are nothing more than JavaScript functions but with some React specialities because they're using React hooks.\n\nLet's see how our custom hook would look:\n\nNow let's simply call it inside our ScreenDimensions component:\n\nThis enables us to just call the custom hook in any other component and save the return value (which is the current window size) in a variable that we can use inside the component.\n\nHandling errors effectively is often overlooked and underestimated by many developers. Like many other best practices this seems to be an afterthought at the beginning. You want to make the code work and don't want to \"waste\" time thinking much about errors.\n\nBut once you've become more experienced and have been in nasty situations where better error handling could have saved you a lot of energy (and valuable time of course), you realize that it's mandatory in the long run to have a solid error handling inside your application. Especially when the application is deployed to production.\n\nBut what exactly does error handling mean in the React world? There are some different parts that play a role. One is to catch errors, another one to handle the UI accordingly, and the last one to log them properly.\n\nThis is a custom class component that is used as a wrapper of your entire application. Of course you can wrap the ErrorBoundary component also around components that are deeper in the component tree to render a more specific UI, for example. Basically it's also a best practice to wrap the ErrorBoundary around a component that is error prone.\n\nWith the lifecycle method you're able to catch errors during the rendering phase or any other lifecycles of the child components. So when an error arises during that phase, it bubbles up and gets caught by the ErrorBoundary component.\n\nIf you're using a logging service (which I also highly recommend), this is a great place to connect to it.\n\nThe static function is called during the render phase and is used to update the state of your ErrorBoundary Component. Based on your state, you can conditionally render an error UI.\n\nThe big drawback of this approach is that it doesn't handle errors in asynchronous callbacks, on server-side-rendering, or in event-handlers because they're outside the boundary.\n\nUse try-catch to handle errors beyond boundaries\n\nThis technique is effective to catch errors that might occur inside asynchronous callbacks. Let's imagine we're fetching a user's profile data from an API and want to display it inside a Profile Component.\n\nWhen the component gets mounted, it starts a GET request to our API to receive the user data for the corresponding userId that we'll get from the props.\n\nUsing try-catch helps us catch any error that might occur during that API call. For example this could be a 404 or a 500 response from the API.\n\nOnce an error gets caught, we're inside the catch block and receive the error as a parameter. Now we're able to log it in our logging service and update the state accordingly to display a custom error UI.\n\nThis library basically melts those two techniques from above together. It simplifies error handling in React and overcomes the limitations of the ErrorBoundary component we've seen above.\n\nThe library exports a component that is made up of the ErrorBoundary functionality we already know and adds some nuances to it. It allows you to pass a as a prop that should be rendered once an error got caught.\n\nIt also exposes a prop which provides a callback function when an error arises. It's great for using it to log the error to a logging service.\n\nThere are some other props that are quite useful. If you'd like to know more, feel free to checkout the docs.\n\nThis library also provides a hook called that is meant to catch any errors that are outside the boundaries like event-handlers, in asynchronous code and in server-side-rendering.\n\nCatching and handling errors effectively is one part, logging them properly is another. Once you've set up your error handling inside your application, you need to log them persistently.\n\nThe most frequently used way is the good old console.log. This might be good during development when you want a quick log, but once your application is deployed to production it becomes useless. This is because you only see the error inside the user's browser, which is not effective at all.\n\nWhen logging errors in production, you as the developer want to see the errors in one dedicated place in order to fix them.\n\nFor that reason we need a logging service created by our own or a third-party one.\n\nWhen using third-party logging services my personal recommendations is definitely Sentry. So I highly encourage you to check it out.\n\n‚òùÔ∏è Keep your key prop unique across your whole app\n\nWhen mapping over an Array to render its data, you always have to define a key property for each element. A common practice I've seen and used myself as well is to use simply the index of each element as the key prop.\n\nUsing the key prop is important because it helps React to identify the exact element that has changed, is added or is removed. Imagine the state of your component changes and the UI needs to be re-rendered with the new state. React needs to figure out the differences between the previous UI and new UI in order to update it.\n\n\"What elements are added/removed or have changed?\"\n\nTherefore the key prop has to be unique. Using the index of the current element makes sure that it is only unique in this particular map function.\n\nIt could look like this, if we'd pretend to show a score history of a football team from the current season:\n\nWhile this is only unique inside this map function here, this could lead to potential issues. It's pretty common to have more than one map function inside your React application or even in one component.\n\nLet's assume we've got another map-function in our component to display the current roster:\n\nNow we end up in the situation where we used many keys twice inside our component. Let's assume we got 14 elements inside and 30 in . We have used the numbers 0-13 two times as a key prop. Now we're not serving the purpose anymore to have unique key props.\n\nThis could lead to potential problems because React might only re-render only one item and omit the other one. Or it can lead to inefficiencies with updating the UI tree. Check out the recommended blog post at the end of this tip to get a more in depth example.\n\nTo avoid this unwanted behavior, make sure to always use unique keys across your whole application. Ideally each item in the Array has got its own unique id that you can use. But this isn't always the case, so you can use an external library like uuidv4 for generating unique id's.\n\nWith that in mind and with the assumption that every item in both Arrays has an id property, the component would look like this:\n\nIf you want to go into more depth, feel free to check out this great post about that topic.\n\nTips to Help You Write Better React Code ‚Äì The Cherries on Top\n\nI'd like to compare this guide to the process of building a house. The first part, Learn the Building Blocks of React, is the solid foundation you build your application on. The second one, How to Build Clean, Performant and Maintainable React Components, is for building the walls.\n\nThis section is basically the roof that comes on top to complete the house. That's the reason I'd like to call it Cherries on Top. These tips here are more granular.\n\nMost of these practices are more optional than those before, but can make a difference if you use them properly.\n\nProbably one of the most frequently used hooks in React is useState. I've created and seen components over the time that have got a lot of different states. So it's natural that they become flooded with a lot of useState hooks.\n\nHaving a lot of different useState hooks is always a great sign that the size and therefore the complexity of your component is growing.\n\nIf you can create some smaller sub components where you can transfer some state and JSX in, then this is a great way to go. So you're cleaning up your useState hooks and your JSX in one step.\n\nIn our example above, we could put the last two states into a separate component that handles all state and JSX that has to do with a form.\n\nBut there are scenarios where this doesn't make sense, and you have to keep those many different states inside one component. To increase the legibility of your component, there is the useReducer hook.\n\nThe official React docs say this about it:\n\nWith that in mind, the component would like this when using :\n\nThe component itself looks cleaner and comes along with some great benefits as you can see inside the docs. If you're used to Redux, the concept of a reducer and how it is built isn't new to you.\n\nMy personal rule is to implement the useReducer hook if my component exceeds four useState hooks, or if the state itself is more complex than just a boolean, for example. It might be an object for a form with some deeper levels inside.\n\nOften there are scenarios where you pass boolean props to a component. I've seen a lot of developers doing it like this:\n\nBut you don't need to do it necessarily like this because the occasion of the prop itself is either truthy (if the prop is passed) or falsy (if the prop is missing).\n\nA similar use case like we've seen in the tip before is using string props:\n\nYou don't need the curly braces in that case because you're allowed to directly use strings inside your props. When you want to attach a className to a JSX Element you're most likely using it also directly as a string.\n\nWhen you'd like use a JavaScript expression different from a string, you need to use the curly braces. For example if you want to use a number or an object. This is also true for template strings (don't get caught up like I did many times, haha).\n\nWith plain strings, like in the example, it would look like this:\n\nLet's take a look at a quick example:\n\nWe've just created a component that will render a h1 tag, extracted some props, and spread out all other potential props on the h1 tag. So far, so good.\n\nNow, we're able to use it in other components and can trigger manually if the h1 should be bold or not:\n\nUp to now, everything works perfectly without any errors or warnings. The interesting part starts now when we're using other props that are directly spread onto the h1 tag.\n\nWhen you're using valid HTML attributes like id or a class, everything works without any error (remember --> \"className\" will become \"class\"):\n\nSo all props above will be added as an attribute to the h1 because we're using {...restProps} on it. No matter what, props we are adding and NOT extracting will be added to the h1 tag.\n\nThis is great for many use cases but can be a problem at the same time:\n\nIn the code above we were adding a new prop called to the component, that is optional. Inside the component we are not extracting it from the props and call it via .\n\nThe code works, but when you open your browser you'll receive a warning that is a non-HTML attribute you're trying to apply on the h1 tag. This is because of on the h1 tag and not extracting like for example.\n\nTo avoid this, always extract all non-HTML attributes from the props first, to make sure that there are only valid HTML attributes in that you're spreading onto a JSX element.\n\nIn our example it would look like this:\n\nMany of those warnings can unnecessary flood your browser's console, which can be very nasty. Especially when you're debugging.\n\nTo get more information about this topic and some other ways to solve this, check out this part of the React docs.\n\nIn Visual Studio Code, for example, there are certain extensions available that increase your productivity a lot. One type of these extensions are snippet extensions.\n\nThe great benefit about them is that you don't have to write all that boilerplate code again. Imagine you're building many new components and have to type it all out again and again:\n\nWith these snippets you just have to type , for example, hit tab and you have the same boilerplate code. It is a real time saver and makes development faster.\n\nBut use them with caution! I wouldn't recommend using snippets to all developers. In my opinion, beginners shouldn't use any snippets and should type the boilerplate out by hand. When you're doing that, you'll get muscle memory which manifests the stuff you learn.\n\nIf you have done it so often that you can type it out in your sleep and it becomes boring, that's the right time to use snippets.\n\nHere are my recommendations:\n\n‚ùå Write a fragment when a div is not needed\n\nA React component can only render one single HTML tag at its root. So if you'd like to render two adjacent elements, you'll get the famous error called Adjacent JSX elements must be wrapped in an enclosing tag.\n\nSo, what can you do? You just wrap the rendered output into a fragment, which satisfies React and doesn't render an extra HTML element in the browser.\n\nOf course you could have solved this with a div tag as well. But using div after div will create something I like to call div hell in the browser where you got many deep nested div tags without any sense.\n\nSo whenever you have to use a wrapper tag in React but don't necessarily need an HTML tag, then simply use a fragment.\n\nFrom my experience, this tip right here is often overlooked, but could make your code so much cleaner with little effort.\n\nIn React you've got the opportunity to pass children elements to a component, which are then available to the component via its children property. Those components are often called composite components.\n\nIn that case you have to use an opening tag and a closing tag of course:\n\nBut when there are no children needed, there isn't any sense in using an opening and closing tag, right?\n\nInstead of doing this, I recommend that you just use the component as a self closing element like the input tag in HTML, that doesn't take children as well.\n\nLooks much cleaner right away, doesn't it?\n\nThe sense behind naming conventions is to more easily recognize what type of element you're dealing with and to have something in your code that is common in the community.\n\nFrom my standpoint, there are two major naming conventions involved in React and JavaScript that you should follow:\n\nUse PascalCase in components, interfaces, or type aliases\n\nUse camelCase for JavaScript data types like variables, arrays, objects, functions, and so on\n\nNaming React components in PascalCase is especially important. Because when you've got a linter configured for React, but you named the component in camelCase and you're using hooks inside it, you'll get a warning message all the time that hooks are only allowed in components. That's because the linter recognizes a React components if it's written in PascalCase or not.\n\nThis can be nasty, but is fixed quickly with sticking to the established naming conventions.\n\nMaybe you've found yourself in a scenario where you have to use the property on an element in React. Basically it's React's equivalent to you might know from Javascript.\n\nSo using it, you can set HTML directly from React.\n\nLet's consider the following example, where we'd like to render an HTML string inside a div. The string could come from a rich text editor where it's already formatted HTML.\n\nThe term dangerously is chosen with intention. Using this property can open you up to a cross-site-scripting (XSS) attack. So it's mandatory that the code that gets set is sanitized first.\n\nA great library is dompurify that can help you out with this.\n\nWow, that was fun right? I tried my best to let everything out that got piled up over the past in my head. My motivation behind this guide is to share my experience with you so you can avoid some harder times during your React learning and development.\n\nOf course there might be best practices you consider more important that I've missed here. That's great. I'd love to hear what you'd like to add to this guide.\n\nRemember, it's always all about adapting what's useful for you. So, don't take it all for granted and think about what might be helpful in your situation. Then you can just add it to your own stack of best practices.\n\nYou can also follow my developer journey and get many more useful insights about the life of a developer on my Instagram Profile. I'm always there to help you and happy about every feedback I can get. So, feel free to reach out."
    },
    {
        "link": "https://reddit.com/r/reactjs/comments/11k19tf/what_would_you_guys_say_are_some_of_the_best",
        "document": "If you don't know any, I ask you to still consider dropping an upvote! Hopefully that way this post will rise to the top and become a mini knowledge exchange hub so that we can learn from each other! :)"
    },
    {
        "link": "https://uxpin.com/studio/blog/react-best-practices",
        "document": "React, the popular JavaScript library for building user interfaces, has revolutionized web development. Most of you are no stranger to its power and flexibility. But, how can you elevate your React game and ensure your projects are easy to maintain and scale? That‚Äôs where this article with React best practices comes into play.\n\nIn this guide, we‚Äôll delve into ten essential React best practices to help you create efficient, maintainable, and error-free code. From mastering React components to employing the latest techniques, we‚Äôll equip you with the knowledge you need to excel in building new features for your React projects.\n\nAre you about to design a React app? You don‚Äôt need a designer to make it happen! Drag and drop React components from top open-source libraries like MUI, Fluent UI to build responsive layouts in minutes. Discover UXPin Merge.\n\nThe first React best practice that we recommend implementing is practicing nesting and parent-child relationship.\n\nIf you‚Äôve been building React applications for a while, you‚Äôre no stranger to component nesting. But have you ever explored just how deep this rabbit hole goes? Understanding the intricate parent-child relationships within React components is essential.\n\nParent components, also known as container components, are at the top of the component hierarchy in React. They act as the guardians of state and serve as the glue that binds together smaller components called child components. While child components handle specific functionalities or UI elements, parent components manage the overall structure and data flow of your application.\n\nExample of Parent and Child Components in React\n\nTo better understand parent-child relationships, let‚Äôs look at a simple example involving a parent component called and a child component called .\n\nThis is the parent or container component. It holds the state ( ) and a function ( ) that updates this state. The state is used to manage the data that might be passed down to the child components or used within the parent component itself.\n\nThis is the child component. It receives a function ( ) as a prop from the parent component. When the button in the is clicked, it calls this function, which in turn updates the state in the .\n\nBy diving deep into this structure, you gain the power to design applications that are not just functional but elegant in their architecture.\n\nIn React, optimizing re-renders is crucial for enhancing performance. Two key components, PureComponent and React.memo, aid in this optimization process by preventing unnecessary re-renders.\n\nBoth PureComponent and React.memo are powerful tools for optimizing re-renders in React applications. While they differ in their implementation‚ÄîPureComponent for class components and React.memo for functional components‚Äîthey both aim to prevent unnecessary re-renders by efficiently comparing props and state. Understanding their nuances and considering the nature of your data can significantly contribute to a smoother and more performant React application.\n\nPureComponent is a class component that comes with a built-in shouldComponentUpdate method, automatically performing a shallow comparison of props and state before deciding to re-render. If there‚Äôs no change detected in the props or state, it prevents the component from re-rendering, thus optimizing performance.\n\nHowever, it‚Äôs important to note that PureComponent performs a shallow comparison, so for deeply nested data structures or complex objects, it might not efficiently detect changes, potentially leading to unexpected re-renders.\n\nReact.memo is a higher-order component (HOC) in functional components, offering similar optimization capabilities. It works by memoizing the rendered output of a component based on its props. When the component is re-rendered, React.memo compares the previous and new props. If they remain the same, it avoids re-rendering, optimizing performance.\n\nLike PureComponent, React.memo also uses a shallow comparison, so caution is necessary when dealing with deeply nested objects or complex data structures to ensure accurate optimization.\n\nProp drilling is a common technique in React. But to truly master it, you need to explore the nuances. Learn how to pass data efficiently between deeply nested components without making your code unwieldy. And when it comes to state management, don‚Äôt stop at basic state or prop passing ‚Äì take the leap into the world of Context API. Unlock its potential to streamline state management and make your codebase more elegant and maintainable.\n\nReact hooks have changed the game when it comes to managing state and side effects in functional components. As an experienced software developer, you should embrace this modern approach.\n\nWhile class components have been the traditional home for managing state, functional components with hooks have proven to be more concise and readable. The useState hook is your gateway to efficient state management. It allows you to declare state variables and set their initial values, all within the function body. Gone are the days of constructor methods and this.setState() calls.\n\nWith useState, you not only simplify your code but also gain a deeper understanding of the state‚Äôs lifecycle, ensuring that your components behave predictably. Whether you‚Äôre working on a small project or a large-scale application, the useState hook becomes your go-to tool for handling component state.\n\nUse case: for handling side effects, like data fetching and DOM manipulation\n\nManaging side effects, such as data fetching and DOM manipulation, is a fundamental part of many React applications. The useEffect hook provides an elegant solution to this common challenge. It allows you to perform these actions within your functional components without compromising on readability or maintainability.\n\nDive into the power of useEffect by understanding its lifecycle and dependencies. With it, you can orchestrate a symphony of asynchronous requests and fine-tuned updates, ensuring that your application responds seamlessly to user interactions. As an experienced developer, your ability to wield useEffect effectively is your ticket to crafting smooth, responsive user experiences.\n\nFor complex state management, React hooks like useContext and useReducer offer a lifeline. These hooks simplify the management of shared state and the handling of intricate application logic.\n\nuseContext empowers you to access context values from a higher-level component without the need for prop drilling. This results in cleaner, more maintainable code. As an experienced developer, you can harness the full potential of useContext to create a more intuitive and collaborative development process.\n\nWhen faced with complex state transitions, useReducer comes to the rescue. It streamlines state updates and provides a structured approach to managing more intricate application logic. By implementing useReducer, you enhance your ability to manage complex state flows and improve the predictability and reliability of your applications.\n\nIn the world of React development, code consistency stands as a guiding principle that experienced developers understand is not to be taken lightly. Whether you‚Äôre working on a solo project or collaborating within a team, adhering to a uniform code style is more than just a best practice ‚Äì it‚Äôs a cornerstone of efficient collaboration and enhanced code readability.\n\nWhy is Code Consistency Important in React?\n\nImagine you‚Äôre part of a team working on a complex React project. In this scenario, code consistency acts as the unifying force that keeps everyone on the same page. It ensures that no matter who is working on which part of the codebase, the overall structure and formatting remain consistent.\n\nAs your React project grows, consistent coding standards facilitate easier maintenance and debugging. It means you can confidently navigate through the codebase, swiftly locate issues, and make changes without constantly adjusting to different coding styles.\n\nFor the experienced developer, two indispensable tools come to the forefront: Prettier and ESLint. These tools automate the process of code formatting and style checking, respectively. Prettier, with its ability to automatically format your code, eliminates the need for debates on code formatting during code reviews. It‚Äôs your virtual code stylist, ensuring that your code looks clean and polished.\n\nESLint, on the other hand, is your code quality guardian. It enforces coding standards, identifies potential issues, and helps maintain a consistent coding style. These tools work in harmony to not only enhance your code quality but also make the entire development process more streamlined.\n\nIn a team environment, the establishment and enforcement of coding standards are paramount. Experienced developers recognize that creating and adhering to a set of coding guidelines is a fundamental aspect of maintaining consistency throughout the project.\n\nThese standards encompass everything from naming conventions for component names and indentation to how to handle comments and spacing. It‚Äôs a collective agreement that ensures all team members are speaking the same coding language.\n\nComplexity often goes hand in hand with the number of components involved. As a seasoned developer, you understand that managing numerous components within your project requires a systematic approach. The cornerstone of this approach lies in a well-structured component hierarchy, which greatly enhances the manageability of your codebase.\n\nThe first step in achieving a well-organized React project is to define a clear folder structure. Picture your project as a library, and these folders as neatly arranged bookshelves. Each folder serves as a dedicated space for specific categories of components, ensuring that you can swiftly locate and keep clean code.\n\nWithin these folders, the grouping of related components is where the magic happens. By categorizing your components logically, you create an easily navigable code landscape. This approach allows you to access, modify, and extend different parts of your React project with ease, even when dealing with a multitude of React components. This systematic grouping not only simplifies your component management but also provides a clear framework for your development team, promoting effective collaboration.\n\nNow, consider the impact of this organization, especially in the context of large-scale applications. With a well-structured component hierarchy and a clear folder structure, you can seamlessly handle the complexities of expansive projects. The ability to maintain, troubleshoot, and scale your application becomes not just achievable but straightforward.\n\nFor the experienced developer, the practice of organizing components isn‚Äôt a mere technicality; it‚Äôs a strategic move. It‚Äôs a commitment to efficient code management and collaboration within your team. By maintaining an organized component hierarchy and implementing a systematic folder structure, you‚Äôre ensuring that your complex React projects are not just functional but also elegantly structured and highly maintainable.\n\nConsistency in naming conventions is more than just a formality in React development ‚Äì it‚Äôs the keystone of code readability and collaboration. To ensure your React projects are easy to understand and work on, follow the naming guidelines listed below.\n\nStart by exploring the most prevalent naming conventions used in the React community. Commonly, you‚Äôll encounter conventions for components, variables, and files. Understanding these conventions provides a foundation for creating code that others can easily comprehend.\n\nLearn When and How to Use Different Casing Styles\n\nNaming conventions often involve casing styles, including camelCase, PascalCase, and kebab-case. Each of these styles has a distinct purpose and use case. Dive into when and how to employ each style:\n‚Ä¢ camelCase: Typically used for variable and function names. It starts with a lowercase letter and uses uppercase for subsequent words (e.g., myVariableName).\n‚Ä¢ PascalCase: Commonly used for naming React components and classes. It starts with an uppercase letter and capitalizes the first letter of each subsequent word (e.g., MyComponent).\n‚Ä¢ kebab-case: Frequently used for file and directory names. It employs hyphens to separate words (e.g., my-component.js).\n\nWhile adhering to conventions is essential, it‚Äôs equally crucial to prioritize names that convey the purpose and function of the component, variable, or file. The goal is to make your code as self-explanatory as possible, reducing the need for extensive comments or documentation.\n\nIn the dynamic realm of React development, performance optimization is key, and lazy loading emerges as a valuable technique to achieve just that. Lazy loading, a concept that experienced developers embrace, involves deferring the loading of components until they‚Äôre actually needed. This approach holds a myriad of benefits for React applications, from improved initial load times to efficient resource allocation.\n\nExperienced React developers recognize that one of the primary advantages of lazy loading is its ability to optimize initial load times. By loading only the most critical components required for the initial view, your application can start faster and provide users with a more responsive experience. This strategic resource allocation ensures that your application conserves bandwidth and minimizes the initial page load, particularly beneficial for applications with extensive component hierarchies.\n\nTo implement lazy loading in your React applications, the combination of React‚Äôs Suspense and React.lazy() proves to be a powerful duo. By suspending the rendering of specific components until they‚Äôre actually needed, you can significantly enhance the efficiency of your application, reducing the load on the client-side and improving the overall user experience. As a seasoned developer, incorporating lazy loading into your React projects is a step toward building applications that are not just functional but exceptionally responsive and resource-efficient, catering to the demands of modern web development.\n\nFunctional components have gained prominence in React development. They have numerous advantages over class components.\n\nClass components, which were the conventional way of building React applications, can become verbose and harder to follow as a project grows. They often require more boilerplate code, making it challenging to quickly grasp the core functionality of a component.\n\nIn contrast, functional components with hooks offer a cleaner and more straightforward approach. Learn when and how to refactor class components into functional components. Also, choose the right component type based on your project requirements.\n\nHandling errors gracefully is essential for creating robust applications. Experienced frontend developers understand that while preventing errors is ideal, preparing for them is equally essential. This preparation involves exploring the concept of error boundaries in React, a practice that not only safeguards your application from unexpected crashes but also ensures a seamless user experience.\n\nTo begin, delving into the realm of error boundaries is crucial. It involves understanding the architecture of React components that can gracefully intercept errors and prevent them from affecting the entire application. This level of control allows you to implement error boundaries strategically, enhancing your application‚Äôs stability.\n\nExperienced developers recognize that this process involves wrapping specific components or sections of your application in error boundary components. By doing so, you gain the ability to capture and handle errors gracefully, preventing them from cascading throughout the entire application and potentially crashing it.\n\nAs you progress in your React development journey, implementing error boundaries in various components becomes second nature. These boundaries act as safety nets, ensuring that even if an error occurs, your application can continue to function and provide valuable feedback to users. Beyond safeguarding your application, well-implemented error boundaries offer valuable insights into the root causes of errors, enabling you to troubleshoot and fine-tune your code for even greater reliability. This approach extends to not only the React code itself but also to other crucial elements of your application, such as CSS and JavaScript, ensuring a comprehensive and robust solution.\n\nWhat are other React tips?\n\nHere‚Äôs a list of lesser-known React tips that can help improve your development workflow and code quality:\n‚Ä¢ Use React Fragments for Cleaner JSX:\n‚Ä¢ React Fragments ( or the shorthand ) allow you to group multiple elements without adding extra nodes to the DOM. They are useful for rendering lists or components without unnecessary wrapper divs.\n‚Ä¢ Use Memoization for Expensive Calculations:\n‚Ä¢ React provides the higher-order component and hook for memoizing the results of expensive calculations. This can improve performance by preventing unnecessary re-renders of components.\n‚Ä¢ Avoid Arrow Functions in JSX Props:\n‚Ä¢ Avoid using arrow functions directly in JSX props, as this can create a new function instance on each render. Instead, define the function outside of the render method and pass it as a prop.\n‚Ä¢ Use the React DevTools Extension:\n‚Ä¢ Install the React DevTools browser extension for Chrome or Firefox. It provides a set of debugging tools specifically designed for React applications, allowing you to inspect component hierarchies, view props and state, and analyze performance.\n‚Ä¢ Use Conditional Rendering with Null or Fragment:\n‚Ä¢ Instead of using ternary operators for conditional rendering, you can use null or React Fragments to conditionally render components. This can result in cleaner and more readable code.\n‚Ä¢ Optimize Component Re-renders with PureComponent:\n‚Ä¢ Use React‚Äôs PureComponent class for components that only re-render when their props or state change. PureComponent performs a shallow comparison of props and state to determine if a re-render is necessary, potentially improving performance.\n‚Ä¢ Avoid Using Index as Key in Lists:\n‚Ä¢ Avoid using the array index as the prop when rendering lists of components. Instead, use a unique identifier from your data, such as an ID or slug. Using the index as a key can lead to unexpected behavior when reordering or modifying the list.\n‚Ä¢ Use React.forwardRef for Higher-Order Components:\n‚Ä¢ When creating higher-order components that need to pass refs to their wrapped components, use the function. This allows the higher-order component to forward refs to the underlying DOM elements.\n‚Ä¢ Leverage Context API for Global State Management:\n‚Ä¢ Instead of using prop drilling to pass data down through multiple layers of components, consider using React‚Äôs Context API for global state management. Context allows you to share data across components without explicitly passing props.\n‚Ä¢ Use React.memo() for Functional Components:\n‚Ä¢ Similar to PureComponent for class components, React.memo() can be used to memoize functional components and prevent unnecessary re-renders. Wrap your functional components with React.memo() to optimize performance.\n\nBuild React Applications with our Best Practices\n\nBy deepening your understanding of React components, employing hooks, maintaining code consistency, and following best practices, you‚Äôll be better equipped to tackle any React project with confidence. Combine these practices with a well-structured component hierarchy, naming conventions, lazy loading, functional components, and error boundaries, and you‚Äôll be well on your way to becoming a React virtuoso.\n\nReady to build apps with React? Before you jump into development, create your app‚Äôs layout with UXPin Merge, a drag-and-drop UI builder that will help you design a responsive layout 10x faster. Discover UXPin Merge."
    },
    {
        "link": "https://stackoverflow.com/questions/49896594/is-it-good-to-use-package-json-file-in-react-component-file",
        "document": "I have to use version mentioned in package.json file in front-end(react js) file.\n\nI'd gone through above post and found two ways for the same. but none of them I was asked to implement.\n\nSo I want to know the approach below is valid/good or not ?\n\nLet me know if this approach is fine."
    },
    {
        "link": "https://stackoverflow.com/questions/54595674/one-package-json-to-manage-node-react-dependencies",
        "document": "You can use one to manage both, the reason folks don't is because it it's easier to be sure of which dependencies belong to which application. Further, depending on how you're building your clientside app, you may need to expose your node_modules as a publicly servable location. Neither of these are insurmountable, and are more a matter of preference.\n\nSome developers have a strong opinion about directory structure and what is \"clean\". It's becoming more common to split server and client code into different code repositories for independently versioning them, in which case it's much easier to track one package.json for each repository."
    },
    {
        "link": "https://medium.com/@adityasrivast/reactjs-understanding-package-json-e8cdf408a3df",
        "document": "package.json is used to store the metadata associated with the project as well as to store the list of dependency packages. In order to add dependency packages to your projects, you need to create package.json file. The file makes it easy for others to manage and install the packages associated with the project.\n‚Ä¢ lists the packages your project depends on\n‚Ä¢ specifies versions of a package that your project can use.\n‚Ä¢ makes your build reproducible, and therefore easier to share with other developers.\n\nA package.json file may look similar to this:\n\nThis file outlines all the settings for the React app.\n\nEach of the attributes in the file has its importance in some way or the other. Where some of these are basic and clear from their names, some are not. This article is aimed at simplifying and developing a better understanding of the same.\n‚Ä¢ is the name of your app, which you give while executing . You can give any name of your choice to the app, the only condition being is that it should be in lowercase. It may also contain hyphens and underscores.\n‚Ä¢ is the current version of your app. The version field must be of the form x.x.x. By default, create-react-app initializes it as 0.1.0\n‚Ä¢ is one of the most crucial attributes. The use is that if you set private as true in your package.json, then npm will refuse to publish it within npm ecosystem. This is a way to prevent the accidental publication of private repositories.\n‚Ä¢ contains all the required node modules and versions required for the application in production. In the snapshot above, it contains three dependencies, which allows us to use , and in our JavaScript. provide a set of useful development scripts for working with React.\n\nIn the screenshot above, the react version is specified as , which means that npm will install the most recent major version matching . In contrast if you see something like in package.json, it means that it will install the most recent minor version matching .\n\nIn order to add a package under , while installing, use .\n\nThis lists the package by default under with its version number.\n‚Ä¢ though is not there in the screenshot above, forms an important part of package.json. It lists out the packages required for development and testing.\n\nIn order to add a package to this list, while installing, use .\n\nThis way, it is added to the list of .\n‚Ä¢ specifies aliases that you can use to access some of the react-scripts commands in a more efficient manner. For example, running in your command line will run behind the scenes. Similar is true for other attributes: , , etc.\n\nBy default, takes care of all the basic scripts for these operations. If not using it, you need to write of your own.\n\nThere can be other scripts as well, such as , , , , etc. Each has their own set of commands.\n\nFor example, when using , you can write\n\nHere the command specifies which branch and directory to deploy.\n\nThe above set of attributes form the basic set of attributes for package.json file of a basic React application. There can be other attributes as well, for example,\n‚Ä¢ specifies the url to your project homepage. This becomes handy in react applications, when you use , where it deploys your build directory to your homepage.\n‚Ä¢ specifies the location of the code for your project. This is helpful for people who want to contribute.\n‚Ä¢ You should specify a license for your project so that people know how they are permitted to use it, and any restrictions you‚Äôre placing on it.\n\nThe screenshot shown above also contains two more attributes, and . Both of these are node modules having their own set of values. They have been recently added to . On one hand, where provides information about browser compatibility of the app, takes care of the code linting. For more information, please refer browserslist and eslintConfig"
    },
    {
        "link": "https://docs.npmjs.com/files/package.json",
        "document": ""
    },
    {
        "link": "https://jahed.github.io/react-dojo/session-1/managing-dependencies.html",
        "document": "Project dependencies are managed using the Node Package Manager (npm) and are saved in the .\n\nThere are multiple types of depedencies defined in the :\n‚Ä¢ are packages you‚Äôll be including in your own build.\n‚Ä¢ are packages that are part of your development process but not part of the final build.\n‚Ä¢ are packages your package depends on but doesn‚Äôt include. This allows projects that require your package to use their own dependencies instead of every package including their own.\n\nIn our case, things like Webpack and Babel will be in and React will be in . We won‚Äôt be using , but the packages we use might.\n\nBy default, when saving dependencies, npm saves it in the as a minor version requirement as according to the rules of Semantic Versioning. You can change this to be more strict by using the flag when running .\n\nI won‚Äôt be including the flag when referring to in this dojo but I recommend using it to avoid future difficulties when packages update and introduced changes different from those mentioned in this dojo.\n\nYou can find a list of representations npm uses for version dependencies in their documentation.\n\nWe can install any package from npm‚Äôs repository using one of the following commands in our project directory:\n\nThe files for these dependencies are saved in the directory at the root of your project. You‚Äôll want to add this directory to your .\n\nYou can run to update your local dependencies based on your version requirements. Of course, if you‚Äôre using , won‚Äôt achieve anything.\n\nSo, to make sure we‚Äôre not falling behind versions, we can use third-party tools like to check and update our dependencies. This is especially useful when using as it gives up more control on when to update.\n\nFor this dojo, we won‚Äôt be referring back to but it‚Äôs worth mentioning."
    }
]