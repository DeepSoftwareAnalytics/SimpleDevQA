[
    {
        "link": "https://superuser.com/questions/868998/how-can-i-find-a-list-of-macs-ciphers-and-kexalgorithms-that-my-openssh-client",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://serverfault.com/questions/735176/how-can-i-list-macs-ciphers-and-kexalgorithms-supported-by-my-ssh-server",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://stackoverflow.com/questions/59506608/ssh-client-to-show-server-supported-algorithms",
        "document": "In order to check that all the servers across a fleet aren't supporting deprecated algorithms, I'm (programmatically) doing this:\n\nWhich is supposed to be a list of supported algorithms for the various phases of setting up a connection. (kex, host key, etc). Every time I run, I get a different piece of odd data at the start - always a different length.\n\nThere's an nmap plugin - ssh2-enum-algos - which returns the data in it's complete form, but I don't want to run nmap; I have a go program which opens the port, and sends the query, but it gets the same as telnet. What am I missing, and how do I fix it?\n\nFor comparison, here's the top few lines from the output of nmap script:"
    },
    {
        "link": "https://unix.stackexchange.com/questions/223276/how-do-i-list-available-host-key-algorithms-for-an-ssh-client",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://my.f5.com/manage/s/article/K51509935",
        "document": ""
    },
    {
        "link": "https://ssh.com/academy/ssh/command",
        "document": "Practically every Unix and Linux system includes the command. This command is used to start the SSH client program that enables secure connection to the SSH server on a remote machine. The command is used from logging into the remote machine, transferring files between the two machines, and for executing commands on the remote machine.\n\nThe command provides a secure encrypted connection between two hosts over an insecure network. This connection can also be used for terminal access, file transfers, and for tunneling other applications. Graphical X11 applications can also be run securely over SSH from a remote location.\n\nThere are other SSH commands besides the client . Each has its own page.\n• ssh-add - tool to add a key to the agent\n\nLinux typically uses the OpenSSH client. The ssh command to log into a remote machine is very simple. To log in to a remote computer called sample.ssh.com, type the following command at a shell prompt:\n\nIf this is the first time you use ssh to connect to this remote machine, you will see a message like:\n\nType to continue. This will add the server to your list of known hosts ( ) as seen in the following message:\n\nEach server has a host key, and the above question related to verifying and saving the host key, so that next time you connect to the server, it can verify that it actually is the same server.\n\nOnce the server connection has been established, the user is authenticated. Typically, it asks for a password. For some servers, you may be required to type in a one-time password generated by a special hardware token.\n\nOnce authentication has been accepted, you will be at the shell prompt for the remote machine.\n\nSpecifying a different user name\n\nIt is also possible to use a different username at the remote machine by entering the command as:\n\nThe above can also be expressed with the syntax:\n\nThe ssh command is often also used to remotely execute commands on the remote machine without logging in to a shell prompt. The syntax for this is:\n\nFor example, to execute the command:\n\non host sample.ssh.com, type the following command at a shell prompt:\n\nAfter authenticating to the remote server, the contents of the remote directory will be displayed, and you will return to your local shell prompt. -x Disables X11 forwarding.\n\nThe command reads its configuration from the SSH client configuration file . For more information, see the page on SSH client configuration file.\n\nTo configure passwordless public key authentication, you may want to create an SSH key and set up an authorized_keys file. See the pages on ssh-keygen and ssh-copy-id for more information.\n\nCommand-line options can be used to set up port forwarding. Local fowarding means that a local port (at the client computer) is tunneled to an IP address and port from the server. Remote forwarding means that a remote port (at the server computer) is forwarded to a given IP address and port from the client machine. See the page on configuring port forwarding on how to configure them.\n\nOpenSSH also supports forwarding Unix domain sockets and IP packets from a tunnel device to establish a VPN (Virtual Private Network).\n\nSome of the most important command-line options for the OpenSSH client are:\n\n-c cipher_spec Selects the cipher specification for encrypting the session.\n\n-D port Dynamic application-level port forwarding. This allocates a socket to listen to port on the local side. When a connection is made to this port, the connection is forwarded over the secure channel, and the application protocol is then used to determine where to connect to from the remote machine.\n\n-E log_file Append debug logs to log_file instead of standard error.\n\n-F configfile Specifies a per-user configuration file. The default for the per-user configuration file is ~/.ssh/config.\n\n-g Allows remote hosts to connect to local forwarded ports.\n\n-i identity_file A file from which the identity key (private key) for public key authentication is read.\n\n-J host Connect to the target host by first making a ssh connection to the pjump host[(/iam/jump-host) and then establishing a TCP forwarding to the ultimate destination from there.\n\n-l login_name Specifies the user to log in as on the remote machine.\n\n-p port Port to connect to on the remote host.\n\nSSH replaced several older commands and protocols in Unix and Linux the 1990s. The include telnet, rlogin, and rsh.\n\nSSH runs at TCP/IP port 22. This is right between ftp and telnet, which are 20 years older. Read the story of how SSH got port 22.\n\nThe following video summarizes how and why SSH was originally developed."
    },
    {
        "link": "https://man7.org/linux/man-pages/man1/ssh.1.html",
        "document": "Pages that refer to this page: stap-jupyter(1), systemd-ssh-proxy(1), systemd-stdio-bridge(1), tar(1), sd_bus_default(3), environment.d(5), proc_sys_vm(5), user@.service(5), pty(7), pam_systemd(8), systemd-machined.service(8), systemd-ssh-generator(8)"
    },
    {
        "link": "https://microfocus.com/documentation/rsit-server-client-unix/8-4-0/unix-guide/ssh_options_ap.html",
        "document": "Specifies one or more (comma-separated) encryption algorithms supported by the client. The cipher used for a given session is the cipher highest in the client's order of preference that is also supported by the server. Allowed values are 'aes128-ctr', 'aes128-cbc', 'aes192-ctr', 'aes192-cbc', 'aes256-ctr', 'aes256-cbc', 'blowfish-cbc', 'arcfour', 'arcfour128', 'arcfour256', 'cast128-cbc', and '3des-cbc'. You can also set this value to 'none'. When 'none' is the agreed on cipher, data is not encrypted. Note that this method provides no confidentiality protection, and is not recommended. The following values are provided for convenience: 'aes' (all supported aes ciphers), 'blowfish' (equivalent to 'blowfish-cbc'), 'cast' (equivalent to 'cast128-cbc'), '3des' (equivalent to '3des-cbc'), 'Any' or 'AnyStd' (all available ciphers plus 'none'), and 'AnyCipher' or 'AnyStdCipher' (all available ciphers). You can also configure encryption algorithms in the configuration file using the Ciphers keyword; the default is 'AnyStdCipher'.\n\nSets the debug level. Increasing the value increases the amount of information displayed. Use 1, 2, 3, or 99. (Values 4-98 are accepted, but are equivalent to 3.) Note: Setting logging to 99 can increase your security risk. At this level, information leakage is a concern, as unencrypted protocol information may be written out. Also, the volume of information written may fill up disk space rapidly, potentially causing the host or Reflection for Secure IT to stop responding.\n\nEnables gateway ports. Remote hosts are allowed to connect to local forwarded ports. You can also configure this in the configuration file using the GatewayPorts keyword. Caution: This option should be used with extreme caution (and never with Internet-facing network adapters), because the client performs no authentication of remote host connections. If the application to which this connection is forwarded does not perform its own authentication, then all remote hosts connections are allowed unrestricted access to that application.\n\nRedirects data from the specified local port, through the secure tunnel to the specified destination host and port. When a Secure Shell connection is established, the Secure Shell client opens a socket on the Secure Shell client host using the designated local port (listening_port). (On client hosts with multiple interfaces, use listening_host to specify which interface.) Configure your application client (the one whose data you want to forward) to send data to the forwarded socket (rather than directly to the destination host and port). When that client establishes a connection, all data sent to the forwarded port is redirected through the secure tunnel to the Secure Shell server, which decrypts it and then directs it to the destination socket (host,hostport). Unless the gateway ports option is enabled, the forwarded local port is available only to clients running on the same computer as the Secure Shell client. The optional protocol can be tcp or ftp. Multiple client applications can use the forwarded port, but the forward is active only while ssh is running. Note: If the final destination host and port are not on the Secure Shell server host, data is sent in the clear between the Secure Shell host and the application server host. You can also configure local forwarding in the configuration file using the LocalForward keyword.\n\nSpecifies, in order of preference, which MACs (message authentication codes) are supported by the client. Allowed values are 'hmac-sha256', 'hmac-sha1', 'hmac-sha1-96', 'hmac-md5', 'hmac-md5-96', 'hmac-sha512', and 'hmac-ripemd160'. Use 'AnyMac' to support all of these. Use 'AnyStdMac' to specify 'hmac-sha256, hmac-sha1,hmac-sha1-96,hmac-md5,hmac-md5-96, hmac-sha512'. Specifying hmac-sha256 also enables hmac-sha2-256. Specifying hmac-sha512 also enables hmac-sha2-512. Multiple MACs can also be specified as a comma-separated list. Additional options are 'none', 'any' (equivalent to AnyMac plus 'none'), and 'AnyStd' (equivalent to 'AnyStdMac' plus 'none'). When 'none' is the agreed on MAC, no message authentication code is used. Because this provides no data integrity protection, options that include 'none' are not recommended. You can also configure MACs in the configuration file using the MACs keyword; the default is 'AnyStdMac'.\n\nRedirects data from the specified remote port (on the computer running the Secure Shell server), through the secure tunnel to the specified destination host and port. When the Secure Shell connection is established, the Secure Shell server opens a socket on its host (the computer running the Secure Shell server) using the designated remote port (listening_port). (On server hosts with multiple interfaces, use listening_host to specify which interface.) Configure your client application (the one whose data you want to forward) to send data to the forwarded socket (rather than directly to the destination host and port). When that client establishes a connection, all data sent to the forwarded port is redirected through the secure tunnel to the Secure Shell client, which decrypts it and then directs it to the destination socket (host,hostport). The optional protocol can be tcp or ftp. You can also configure remote forwarding in the configuration file using the RemoteForward keyword.\n\nSpecifies a file containing the password to use for the connection. Set permissions on the password file to 600; the file is not accepted if it has read or write permissions for group or other. Also, for a non-root user, the file is not accepted if there has been a change in identity (userid). This option applies only to password authentication. If AllowedAuthentications is configured to attempt keyboard-interactive before password authentication (the default), users will receive a password prompt even if a valid password file is present. To prevent this, modify the allowed authentications list to support only password authentication or to attempt password authentication before keyboard-interactive. Note: Passphraseless public keys provide a more secure way to configure authentication without requiring user interaction, because private keys are not transmitted over the encrypted connection like passwords are."
    },
    {
        "link": "https://openssh.com/legacy.html",
        "document": "OpenSSH implements all of the cryptographic algorithms needed for compatibility with standards-compliant SSH implementations, but since some of the older algorithms have been found to be weak, not all of them are enabled by default. This page describes what to do when OpenSSH refuses to connect with an implementation that only supports legacy algorithms.\n\nWhen an SSH client connects to a server, each side offers lists of connection parameters to the other. These are, with the corresponding ssh_config keyword:\n• : the key exchange methods that are used to generate per-connection keys\n• : the public key algorithms accepted for an SSH server to authenticate itself to an SSH client\n• : the ciphers to encrypt the connection\n• : the message authentication codes used to detect traffic modification\n\nFor a successful connection, there must be at least one mutually-supported choice for each parameter.\n\nIf the client and server are unable to agree on a mutual set of parameters then the connection will fail. OpenSSH (7.0 and greater) will produce an error message like this:\n\nIn this case, the client and server were unable to agree on the key exchange algorithm. The server offered only a single method . OpenSSH supports this method, but does not enable it by default because it is weak and within theoretical range of the so-called Logjam attack.\n\nSeveral related options come into play later during user authentication.\n\nA mismatch between the client and server during authentication will cause authentication to fail, despite it appearing to be configured. For example, an user key may be listed in but may not pass authentication because, by default, sshd does not accept this key type.\n\nThe best resolution for these failures is to upgrade the software at the other end and/or replace the weak key types with safer modern types. OpenSSH only disables algorithms that we actively recommend against using because they are known to be weak. This might not be immediately possible in some cases, so you may need to temporarily re-enable the weak algorithms to retain access.\n\nFor the case of the above error message, OpenSSH can be configured to enable the key exchange algorithm (or any other that is disabled by default) using the option, either on the command line:\n\nor in the file:\n\nThe '+' before the list instructs ssh to append the algorithm to the client's default set rather than replacing the default. By appending, you will automatically upgrade to the best supported algorithm when the server starts supporting it.\n\nAnother example, this time where the client and server fail to agree on a public key algorithm for host authentication:\n\nOpenSSH 7.0 and greater similarly disable the (DSA) public key algorithm. It too is weak and we recommend against its use. It can be re-enabled using the configuration option:\n\nor in the file:\n\nDepending on the server configuration, it's possible for other connection parameters to fail to negotiate. You might find the and/or configuration options useful for enabling these. It's also possible to query which algorithms ssh supports:\n\nFinally, it's also possible to query the configuration that ssh is actually using when attempting to connect to a specific host, by using the option:\n\nwhich will list all the configuration options, including the chosen values for the , , and parameters."
    },
    {
        "link": "https://ssh.com/academy/ssh/config",
        "document": "The ssh program on a host receives its configuration from either the command line or from configuration files and .\n\nCommand-line options take precedence over configuration files. The user-specific configuration file is used next. Finally, the global file is used. The first obtained value for each configuration parameter will be used.\n\nThere are many configuration options available. In practice, only a few of them are ever changed, and user-specific configuration files are rarely used. In most cases, just is edited.\n\nDevelopers, students, and researchers often want to enable X11 forwarding and SSH agent forwarding. These allow running graphical applications remotely and eliminate the need for typing a password whenever moving from one server to another, respectively. Setting these options in makes life easier for end users, saves overhead, and reduces support load. However, they increase the risk of an attack spreading from a compromised server to a user's desktop, so the most security-critical environments may want to leave them disabled. There is generally no reason to enable them on production servers in enterprises.\n\nLocal and remote port forwarding can be used for tunneling applications, accessing intranet web services from home, tunneling database access, and many other purposes. For instructions on configuring port forwarding, see the port forwarding configuration page. Note, however, that port forwarding can also be used to tunnel traffic from the external Internet into a corporate intranet. Employees sometimes do this to be able to work from home even when company policy does not permit it. Hackers use it to leave permanent backdoor. See the page on SSH tunneling for more information.\n\nPublic authentication is used for passwordless logins between systems. It is often used for automated processes, such as backups, configuration management, and file transfers. It is also used by sophisticated end users and system administrators for single sign-on. See the public key authentication for configuring it.\n\nWhen a user has created more than one SSH key for authentication, the command line option may be helpful for specifying which key to use. In the client configuration file, this can be specified using the options.\n\nOpenSSH certificates can be used for authentication either using ssh-agent or by specifying the option in the client configuration file. See SSH certificates for more information.\n\nThe client configuration file has the following format. Both the global and per-user have the same format.\n• Empty lines and lines starting with '#' are comments.\n• Each line begins with a keyword, followed by argument(s).\n• Configuration options may be separated by whitespace or optional whitespace and exactly one =.\n• Arguments may be enclosed in double quotes (\") in order to specify arguments that contain spaces.\n\nThe following keywords can be used in SSH client configuration files. Keywords are case-insensitive and arguments are case-sensitive. Any algorithm or method names that include an at sign (@) are for experimental use only and not recommended for production.\n\nRestricts the following declarations to be only for those hosts that match one of the patterns given after the keyword. The pattern is matched against the host name given on the command line.\n\nRestricts the following declarations to apply only for hosts that match the specified criteria. For detailed information, see SSH man page.\n\nSpecifies which address family to use when connecting. Valid arguments are: , , .\n\nIf set to , passphrase/password querying will be disabled. This is useful for running the ssh client from shell script that do not have an interactive user, and prevents accidentally blocking on a password prompt.\n\nSpecifies to use the specified address on the local machine as the source address of the connection.\n\nSpecifies whether to use challenge-response authentication. This is mostly a legacy method and has been replaced by .\n\nDirects ssh to additionally check the host IP address in the file.\n\nSpecifies the cipher to use for encrypting the session in protocol version 1. Note that use of protocol 1 is not recommended.\n\nSpecifies the ciphers allowed for protocol version 2 in order of preference. Multiple ciphers must be comma-separated. The command can be used to query supported ciphers. The following list is supported in OpenSSH 6.7:\n\nSpecifies that all local, remote, and dynamic port forwardings specified in the configuration files or on the command line be cleared.\n\nSpecifies whether to use compression. enables compression.\n\nSpecifies the compression level to use if compression is enabled.\n\nSpecifies the number of attempts to make before exiting.\n\nSpecifies the timeout (in seconds) used when connecting to the SSH server, instead of using the default system TCP timeout.\n\nEnables the sharing of multiple sessions over a single network connection.\n\nSpecify the path to the control socket used for connection sharing as described in the ControlMaster section above or the string to disable connection sharing.\n\nSpecifies that a TCP port on the local machine be forwarded over the secure channel, and the application protocol is then used to determine where to connect to from the remote machine.\n\nSpecifies whether ssh should terminate the connection if it cannot set up all requested dynamic, tunnel, local, and remote port forwardings.\n\nSpecifies whether the connection to the authentication agent will be forwarded to the remote machine.\n\nSpecifies whether X11 connections will be automatically redirected over the secure channel and DISPLAY set.\n\nIf this option is set to , remote X11 clients will have full access to the original X11 display.\n\nSpecifies whether remote hosts are allowed to connect to local forwarded ports.\n\nSpecifies a file to use for the global host key database instead of .\n\nSpecifies whether user authentication based on GSSAPI is allowed. GSSAPI is typically used for Kerberos authentication, e.g., with Active Directory.\n\nSpecifies whether key exchange based on GSSAPI may be used.\n\nIf set, specifies the GSSAPI client identity that ssh should use when connecting to the server.\n\nIf set to then renewal of the client's GSSAPI credentials will force the rekeying of the ssh connection.\n\nSet to to indicate that the DNS is trusted to securely canonicalize the name of the host being connected to. If , the hostname entered on the command line will be passed untouched to the GSSAPI library.\n\nIndicates that ssh should hash host names and addresses when they are added to . These hashed names may be used normally by ssh and sshd, but they do not reveal identifying information should the file's contents be disclosed.\n\nSpecifies whether to try rhosts based authentication with public key authentication, using the or files in the user's home directory and and in global configuration.\n\nSpecifies the protocol version 2 host key algorithms that the client wants to use in order of preference. The following values are supported in OpenSSH 6.7:\n\nSpecifies an alias that should be used instead of the real host name when looking up or saving the host key in the host key database files.\n\nSpecifies the real host name to log into. This can be used to specify nicknames or abbreviations for hosts. The default is the name given on the command line. Numeric IP addresses are also permitted (both on the command line and in HostName specifications).\n\nSpecifies that ssh should only use the identity keys configured in the files, even if ssh-agent offers more identities.\n\nSpecifies a file from which the user's identity key is read when using public key authentication. The default for protocol version 1 is ; and or for protocol version 2.\n\nSpecifies whether to use keyboard-interactive authentication. This is a common method for password authentication, one-time passwords, and multi-factor authentication.\n\nSpecifies the list of methods to use in keyboard-interactive authentication.\n\nSpecifies a command to execute on the local machine after successfully connecting to the server.\n\nSpecifies that a TCP port on the local machine be forwarded over the secure channel to the specified host and port from the remote machine. The first argument must be and the second argument must be .\n\nSpecifies the verbosity level of logging messages from ssh. The possible values are: , , , , , , , , and .\n\nSpecifies the MAC (message authentication code) algorithms in order of preference. The command can be used to query supported MAC algorithms. The following list is supported in OpenSSH 6.7:\n\nThis option can be used if the home directory is shared across machines. In this case localhost will refer to a different machine on each of the machines and the user will get many warnings about changed host keys.\n\nSpecifies the order in which the client should try protocol 2 authentication methods.\n\nSpecifies the protocol versions in order of preference. The possible values are '1' and '2'. Multiple versions must be comma-separated. Use of protocol version 1 is NOT RECOMMENDED for security reasons. There is reason to believe it may be susceptible to man-in-the-middle attacks.\n\nSpecifies the command to use to connect to the server. The SSH client communicates with the proxy command using its standard input and standard output, and the proxy command should pass the communication to an SSH server.\n\nSpecifies whether to try public key authentication using SSH keys. Valid values are and . When public key authentication is used in a production environment, a proper SSH key management system should also be put in place.\n\nSpecifies that a TCP port on the remote machine be forwarded over the secure channel to the specified host and port from the local machine. The first argument must be: and the second argument must be . SSH tunneling is a powerful tool, but see security considerations on SSH tunneling.\n\nSpecifies whether to try rhosts based authentication with RSA host authentication. This is for protocol version 1 only and is deprecated.\n\nSpecifies whether to try RSA authentication. This is for protocol version 1 only and is deprecated.\n\nSpecifies what environment variables should be sent to the server.\n\nSets the number of keepalive messages that may be sent by the client without the client receiving any messages back from the server. When this threshold is reached the client will terminate the session.\n\nSpecifies interval for sending keepalive messages to the server. The messages are sent through the encrypted channel, and serve to detect if the server has crashed or the network has gone down.\n\nSpecifies which smartcard device to use.\n\nSpecifies if ssh should never automatically add host keys to the file, and refuses to connect to hosts whose host key has changed.\n\nSpecifies whether to send TCP keepalives to the other side. These operate on the level of the TCP protocol. Sending keepalives helps properly close the socket when the network or server goes down. On the other hand, without it, the connection may stay alive and any windows open, even if the network is down for a while.\n\nIf , request device forwarding between the client and the server. This used for implementing a VPN over SSH.\n\nSpecifies the tun devices to open on the client (local_tun) and the server (remote_tun).\n\nSpecifies whether or not to use a privileged port for outgoing connections. The client must run as root to use a privileged port. A privileged port is required for host-based authentication.\n\nSpecifies a file to use for per-user known host key database instead of the default .\n\nSpecifies whether to verify the remote key using DNS and SSHFP resource records.\n\nSpecifies whether an ASCII art representation of the remote host key fingerprint is printed in addition to the hex fingerprint string at login and for unknown host keys."
    }
]