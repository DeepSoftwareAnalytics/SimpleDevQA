[
    {
        "link": "https://developer.android.com/reference/java/net/HttpURLConnection",
        "document": "A URLConnection with support for HTTP-specific features. See the spec for details.\n\nUses of this class follow a pattern:\nâ€¢ Obtain a new by calling and casting the result to .\nâ€¢ Prepare the request. The primary property of a request is its URI. Request headers may also include metadata such as credentials, preferred content types, and session cookies.\nâ€¢ Optionally upload a request body. Instances must be configured with if they include a request body. Transmit data by writing to the stream returned by .\nâ€¢ Read the response. Response headers typically include metadata such as the response body's content type and length, modified dates and session cookies. The response body may be read from the stream returned by . If the response has no body, that method returns an empty stream.\nâ€¢ Disconnect. Once the response body has been read, the should be closed by calling . Disconnecting releases the resources held by a connection so they may be closed or reused.\n\nFor example, to retrieve the webpage at :\n\nCallingon a URL with the \"https\" scheme will return an, which allows for overriding the defaultand. An application-suppliedcreated from ancan provide a customfor verifying certificate chains and a customfor supplying client certificates. Seefor more details.will follow up to five HTTP redirects. It will follow redirects from one origin server to another. This implementation doesn't follow redirects from HTTPS to HTTP or vice versa.\n\nIf the HTTP response indicates that an error occurred, will throw an . Use to read the error response. The headers can be read in the normal way using ,\n\nTo upload data to a web server, configure the connection for output using\n\nFor best performance, you should call either when the body length is known in advance, or when it is not. Otherwise will be forced to buffer the complete request body in memory before it is transmitted, wasting (and possibly exhausting) heap and increasing latency.\n\nFor example, to perform an upload:\n\nThe input and output streams returned by this class are. Most callers should wrap the returned streams withor. Callers that do only bulk reads or writes may omit buffering.\n\nWhen transferring large amounts of data to or from a server, use streams to limit how much data is in memory at once. Unless you need the entire body to be in memory at once, process it as a stream (rather than storing the complete body as a single byte array or string).\n\nTo reduce latency, this class may reuse the same underlying for multiple request/response pairs. As a result, HTTP connections may be held open longer than necessary. Calls to may return the socket to a pool of connected sockets.\n\nBy default, this implementation of requests that servers use gzip compression and it automatically decompresses the data for callers of . The Content-Encoding and Content-Length response headers are cleared in this case. Gzip compression can be disabled by setting the acceptable encodings in the request header:\n\nSetting the Accept-Encoding request header explicitly disables automatic decompression and leaves the response headers intact; callers must handle decompression as needed, according to the Content-Encoding header of the response.\n\nreturns the number of bytes transmitted and cannot be used to predict how many bytes can be read from for compressed streams. Instead, read that stream until it is exhausted, i.e. when returns -1.\n\nSome Wi-Fi networks block Internet access until the user clicks through a sign-on page. Such sign-on pages are typically presented by using HTTP redirects. You can useto test if your connection has been unexpectedly redirected. This check is not valid untilthe response headers have been received, which you can trigger by callingor. For example, to check that a response was not redirected to an unexpected host:supports HTTP basic authentication . Useto set the VM-wide authentication handler:Unless paired with HTTPS, this isa secure mechanism for user authentication. In particular, the username, password, request and response are all transmitted over the network without encryption.To establish and maintain a potentially long-lived session between client and server,includes an extensible cookie manager. Enable VM-wide cookie management usingandBy default,accepts cookies from the origin server only. Two other policies are included:and. Implementto define a custom policy.\n\nThe default keeps all accepted cookies in memory. It will forget these cookies when the VM exits. Implement to define a custom cookie store.\n\nIn addition to the cookies set by HTTP responses, you may set cookies programmatically. To be included in HTTP request headers, cookies must have the domain and path properties set.\n\nBy default, new instances of work only with servers that support RFC 2965 cookies. Many web servers support only the older specification, RFC 2109. For compatibility with the most web servers, set the cookie version to 0.\n\nFor example, to receive in French:\n\nuses the method by default. It will use if has been called. Other HTTP methods ( , , , and ) can be used with .\n\nBy default, this class will connect directly to the origin server . It can also connect via anorproxy. To use a proxy, usewhen creating the connection.\n\nThis class includes transparent support for IPv6. For hosts with both IPv4 and IPv6 addresses, it will attempt to connect to each of a host's addresses until a connection is established.\n\nAndroid 4.0 (Ice Cream Sandwich, API level 15) includes a response cache. Seefor instructions on enabling HTTP caching in your application.Prior to Android 2.2 (Froyo), this class had some frustrating bugs. In particular, callingon a readablecould poison the connection pool . Work around this by disabling connection pooling:\n\nEach instance of may be used for one request/response pair. Instances of this class are not thread safe.\n\nIndicates that other requests to the server are unlikely in the near future. Returns the error stream if the connection failed but the server sent useful data nonetheless. Returns a indicating whether or not HTTP redirects (3xx) should be automatically followed. Returns the value for the th header field. Returns the value of the named field parsed as date. Returns the key for the th header field. Returns the value of this 's field. Returns a object representing the permission necessary to connect to the destination host and port. Gets the status code from an HTTP response message. Gets the HTTP response message, if any, returned along with the response code from a server. This method is used to enable streaming of a HTTP request body without internal buffering, when the content length is not known in advance. This method is used to enable streaming of a HTTP request body without internal buffering, when the content length is known in advance. This method is used to enable streaming of a HTTP request body without internal buffering, when the content length is known in advance. Sets whether HTTP redirects (requests with response code 3xx) should be automatically followed by this class. Sets whether HTTP redirects (requests with response code 3xx) should be automatically followed by this instance. Set the method for the URL request, one of: are legal, subject to protocol restrictions. Indicates if the connection is going through a proxy.\n\nOpens a communications link to the resource referenced by this URL, if such a connection has not already been established. Returns the value of the field for this object. Retrieves the contents of this URL connection. Retrieves the contents of this URL connection. Returns the value of the header field. Returns the value of the header field. Returns the value of the header field as a long. Returns the value of the header field. Returns the value of the header field. Returns the default value of the field. This method was deprecated in API level 15. The instance specific getRequestProperty method should be used after an appropriate instance of URLConnection is obtained. Returns the default value of a 's flag. Returns the value of this 's flag. Returns the value of this 's flag. Returns the value of the header field. Returns the value of the named header field. Returns the value for the th header field. Returns the value of the named field parsed as date. Returns the value of the named field parsed as a number. Returns the key for the th header field. Returns the value of the named field parsed as a number. Returns an unmodifiable Map of the header fields. Returns the value of this object's field. Returns an input stream that reads from this open connection. Returns the value of the header field. Returns an output stream that writes to this connection. Returns a permission object representing the permission necessary to make the connection represented by this object. Returns an unmodifiable Map of general request properties for this connection. Returns the value of the named general request property for this connection. Returns the value of this 's field. Returns the value of this 's field. Tries to determine the content type of an object, based on the specified \"file\" component of a URL. Tries to determine the type of an input stream based on the characters at the beginning of the input stream. Set the value of the field of this . Sets a specified timeout value, in milliseconds, to be used when opening a communications link to the resource referenced by this URLConnection. Sets the of an application. Sets the default value of the field for all future objects to the specified value. This method was deprecated in API level 15. The instance specific setRequestProperty method should be used after an appropriate instance of URLConnection is obtained. Invoking this method will have no effect. Sets the default value of the field to the specified value. Sets the value of the field for this to the specified value. Sets the value of the field for this to the specified value. Sets the value of the field of this to the specified value. Sets the read timeout to a specified timeout, in milliseconds. Sets the value of the field of this to the specified value. Creates and returns a copy of this object. Indicates whether some other object is \"equal to\" this one. Called by the garbage collector on an object when garbage collection determines that there are no more references to the object. Returns the runtime class of this . Returns a hash code value for the object. Wakes up a single thread that is waiting on this object's monitor. Wakes up all threads that are waiting on this object's monitor. Causes the current thread to wait until it is awakened, typically by being notified or interrupted, or until a certain amount of real time has elapsed. Causes the current thread to wait until it is awakened, typically by being notified or interrupted, or until a certain amount of real time has elapsed. Causes the current thread to wait until it is awakened, typically by being notified or interrupted."
    },
    {
        "link": "https://stackoverflow.com/questions/8654876/http-get-using-android-httpurlconnection",
        "document": "I'm new to Java and Android development and try to create a simple app which should contact a web server and add some data to a database using a http get.\n\nWhen I do the call using the web browser in my computer it works just fine. However, when I do the call running the app in the Android emulator no data is added.\n\nI have added Internet permission to the app's manifest. Logcat does not report any problems.\n\nCan anyone help me to figure out what's wrong?\n\nHere is the source code:"
    },
    {
        "link": "https://digitalocean.com/community/tutorials/java-httpurlconnection-example-java-http-request-get-post",
        "document": "The class from package can be used to send a Java HTTP Request programmatically. In this article, you will learn how to use in a Java program to send and requests and then print the response.\n\nFor this example, you should have completed the Spring MVC Tutorial because it has URLs for and HTTP methods.\n\nThe HTML of the login page contains the following form:\n\nYou can construct a request to:\n\nThis will serve as the basis for the example.\n\nHere are the steps for sending Java HTTP requests using class:\nâ€¢ Create a object from the or URL String.\nâ€¢ Call the method on the URL object that returns an instance of .\nâ€¢ Set the request method in instance (default value is ).\nâ€¢ Call method on instance to set request header values (such as , , etc).\nâ€¢ We can call to get the response HTTP code. This way, we know if the request was processed successfully or if there was any HTTP error message thrown.\nâ€¢ For , use and to read the response and process it accordingly.\nâ€¢ For , before the code handles the response, it needs to get the from the instance and write parameters into it.\n\nHere is an example program that uses to send Java and requests:\n\nCompile and run the code. It will produce the following output:\n\nCompare this output to the browser HTTP response.\n\nIf you have to send and requests over HTTPS protocol, then you need to use instead of . will handle the SSL handshake and encryption.\n\nIn this article, you learned how to use in a Java program to send and requests and then print the response.\n\nContinue your learning with more Java tutorials."
    },
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/net/HttpURLConnection.html",
        "document": "A URLConnection with support for HTTP-specific features. See the spec for details.\n\nEach HttpURLConnection instance is used to make a single request but the underlying network connection to the HTTP server may be transparently shared by other instances. Calling the close() methods on the InputStream or OutputStream of an HttpURLConnection after a request may free network resources associated with this instance but has no effect on any shared persistent connection. Calling the disconnect() method may close the underlying socket if a persistent connection is otherwise idle at that time.\n\nThe HTTP protocol handler has a few settings that can be accessed through System Properties. This covers Proxy settings as well as various other settings.\n\nIf a security manager is installed, and if a method is called which results in an attempt to open a connection, the caller must possess either:-\nâ€¢ a \"connect\" to the host/port combination of the destination URL or\n\nIf automatic redirection is enabled, and this request is redirected to another destination, then the caller must also have permission to connect to the redirected host/URL."
    },
    {
        "link": "https://blog.codavel.com/how-to-integrate-httpurlconnection",
        "document": "Most of internet content distribution it is still done through HTTP, which means that anyone building a mobile app will be obviously dealing with HTTP Libs. Since we are working to improve the performance of content distribution on mobile apps (find more about it here), there was no doubt that our Bolina SDK would have to be seamlessly integrated with, at least, the most popular HTTP Libs out there. That was how I decided to start exploring the HTTP Libs landscape (all tutorials and performance-related articles, here).\n\nHttpURLConnection was one of the first libs Iâ€™ve decided to integrate, and it is easy to know why: ever since Android API 9, HttpURLConnection has become the recommended HTTP library for Android applications. Hereâ€™s what Iâ€™ve learned, how to integrate it and some caveats that every developer should take into consideration.\n\nI am integrating it into a clean, straight out of the Android Studio new project wizard. This tutorial will create 2 HTTP calls, a GET and a POST to a publicly available RESTful API, hosted by reqres.in, a service â€œthat allows us to test our front-end against a real APIâ€.\n\nStarting integrating HttpURLConnection is simple, given that the HTTP library is included in the Android API since API 1. However, we must take into consideration the fact that the library is not prepared for native asynchronous calls, requiring us to make use of workers, such as AsyncTasks, to perform HTTP network calls outside the main UI thread.\n\nFirst, add the permission to the applicationâ€™s manifest to allow the application to access the Internet:\n\nNow letâ€™s create an AsyncTask to perform an HTTP GET call:\n\nIf you are familiar with Android development, this class is pretty straightforward. The main logic of the worker is located inside the doInBackground method. First, I set the desired URL, followed by establishing an HTTP connection, via the openConnection method. After checking if the connection was successful, I read the connectionâ€™s data from a BufferedReader, in this case, reading it, line by line. And thatâ€™s it!\n\nTo call this HTTP GET worker, just start the AsyncTask, for instance on the onCreate method of the main activity:\n\nTo perform a POST call, just create the following AsyncTask:\n\nThe first thing I do is create JSON data to post to the service. To create JSON data, we need to include the gradle dependency:\n\nThen create the URL of the post to be performed, followed by establishing the HTTP connection. Next, I set the HttpURLConnection options to perform the POST and write the JSON data into the connection. Finally, I just check if the post was successfully received by the server and check the server's reply. Again, simple!\n\nAs previously, to run this worker, just call it from anywhere in your project, via:\n\nThe full code used is available at Github. Feel free to adapt the code according to your specific needs. I hope this helped you integrating HttpURLConnection into an Android project, performing GET and POST calls, and understanding how to properly used it outside the main UI thread, via an AsyncTask.\n\nIn the end, HttpURLConnection is a mature HTTP library that can be integrated with relative ease, even though I have to admit that I prefer approaches like the more modern OkHttp library (Integration Tutorial). Since it provides native asynchronous methods, it significantly simple to integrate it on a project. However, I canâ€™t deny that performance is my main concern (and interest), so I had to find out which one was faster. Would you bet on HttpURLConnection or OkHttp? Check my results here and find out!"
    },
    {
        "link": "https://geeksforgeeks.org/json-parsing-in-android-using-retrofit-library",
        "document": "JSON is also known as (JavaScript Object Notation) is a format to exchange the data from the server. The data stored in JSON format is lightweight and easy to handle. With the help of JSON, we can access the data in the form of JsonArray, JsonObject, and JsonStringer. In this article, we will specifically take a look at the implementation of JsonObject using the Retrofit library in Android.\n\nWhat we are going to build in this article?\n\nWe will be building a simple application in which we will be displaying a simple CardView in which we will display a single course that is available on Geeks for Geeks. A sample video is given below to get an idea about what we are going to do in this article. Note that we are going to implement this project using the Java language.\n\nBelow is the JSON object from which we will be displaying the data in our Android App.\n\nTo create a new project in Android Studio please refer to How to Create/Start a New Project in Android Studio . Note that select Java as the programming language.\n\nStep 2: Add the below dependency in your build.gradle file\n\nBelow is the dependency for Volley which we will be using to get the data from API. For adding this dependency navigate to the app > Gradle Scripts > build.gradle(app) and add the below dependency in the dependencies section. We have used the Picasso dependency for image loading from the URL.\n\nAfter adding this dependency sync your project and now move towards the AndroidManifest.xml part.\n\nStep 3: Adding permissions to the internet in the AndroidManifest.xml file\n\nNavigate to the app > AndroidManifest.xml and add the below code to it.\n\nNavigate to the app > res > layout > activity_main.xml and add the below code to that file. Below is the code for the activity_main.xml file.\n\nNavigate to the app > java > your appâ€™s package name > Right-click on it > New > Java class and name it as RecyclerData and add the below code to it. Comments are added inside the code to understand the code in more detail.\n\nStep 6: Creating an Interface class for our API Call\n\nNavigate to the app > java > your appâ€™s package name > Right-click on it > New > Java class select it as Interface and name the file as RetrofitAPI and add below code to it. Comments are added inside the code to understand the code in more detail.\n\nGo to the MainActivity.java file and refer to the following code. Below is the code for the MainActivity.java file. Comments are added inside the code to understand the code in more detail.\n\nNow run your app and see the output of the app."
    },
    {
        "link": "https://medium.com/@samueljumawrites/fetching-data-from-an-api-using-retrofit-in-your-android-app-5ceddd1030b8",
        "document": "Retrofit is a popular type-safe HTTP client for Android and Java that makes it easier to consume RESTful web services. Developed by Square, it allows you to define your REST API as a series of interfaces and methods, abstracting away the underlying HTTP calls. This makes it easier to manage API calls and responses with minimal boilerplate code.\n\nWhy is Retrofit Powerful for Kotlin Developers?\nâ€¢ Type Safety: Retrofit uses annotations to describe the HTTP requests, ensuring type safety at compile time.\nâ€¢ Coroutines Support: With Retrofit, you can easily integrate Kotlin coroutines to handle asynchronous operations, providing a more concise and manageable codebase.\nâ€¢ Scalability: Retrofit allows for modular and scalable code, supporting dynamic URL endpoints and query parameters.\nâ€¢ Customizable: You can customize requests and responses with interceptors, converters, and adapters.\n\nWhat are we building?\n\nFor this tutorial we will build a simple comments app that fetches comments data from a free API Faker {JSON} Placeholder. Here is the endpoint: https://jsonplaceholder.typicode.com/comments. While getting data from the internet using Retrofit is the primary focus for this project, we will use other libraries including\nâ€¢ Add the following in file\n\nI prefer dependencies, so I can just provide them as a group rather than having to provide individual dependencies in my gradle file. Below is how I have bundled the dependencies. The idea is to have related dependencies in one group. create this below plugins in the file.\n\nNow, add plugins and dependencies to the gradle files.\nâ€¢ Add the following in project-level file\nâ€¢ Add the following in app-level file\nâ€¢ Notice we only needed to provide the we created earlier and as such we didn't need to provide individual dependencies. Just three lines! That's the beauty of using in .\nâ€¢ Be sure to your project after adding dependencies to check that there are no issues with your dependencies.\n\nNow you need an entity class to hold your data. For our demo project we are getting data from a free API Faker . Create a package called , inside it create a file named with the following code.\n\nNotice the @Serializable annotation â€” it helps us serialize our entity object and represent it in other formats such as\nâ€¢ You need a for your API service to help you get data from the internet. Inside your file create an object of the client like below.\nâ€¢ Notice that our client uses a object from and from (helps us specifiy the MediaType). More can be done but for brevity we will keep ours just simple.\nâ€¢ Now, we need an . Inside , below the create an API Service interface as follows\nâ€¢ We use the to keep things clean and organized. Besides, the helps to abstract the data access layer, providing a clean separation between the application's business logic and how it interacts with data sources.\nâ€¢ First, we need a custom generic sealed class to hold the network responses. Create the sealed class inside the package\nâ€¢ Now Create a package, inside the package create the and the as follows\nâ€¢ We parse an to help us get data and the to help us with switching tasks to background threads.\nâ€¢ Create a new package called . Inside create a new file and declare your dependencies as follows\nâ€¢ Next, create an class that extends the . We start from this class.\nâ€¢ Next, in the manifest file, add the Application class inside the application tags.\nâ€¢ Also, explicitly declare your network permissions. Without this your app wont be able to get data from the internet.\nâ€¢ Now, we need the UI from where we will be displaying our comments. Here, we display specific UI for different UIStates as shown in the code below.\nâ€¢ In your root package, create a new package called , inside it create a file that has the as follows:-\nâ€¢ At this point, all we need to do is run the project and see what we have created.\nâ€¢ You should get a nice Comments App like this one here.ðŸ‘‡\n\nIn this journey, we covered a lot of ground, from understanding what Retrofit is and why itâ€™s a powerful tool for Kotlin developers, to setting up the necessary dependencies and building out the core components of our app step by step. We also explored how Retrofitâ€™s seamless integration with other libraries like Koin, Kotlinx-serialization, okHttp3 etc. These ,you can delve into deeper, later.\n\nBut this is just the beginning! ðŸš€\n\nWhile itâ€™s pretty basic, this tutorial builds a solid foundation for working with Retrofit. Feel free to explore more advanced features and build complex apps that require complex business logics in fetching remote data.\n\nIf you enjoyed this tutorial and found it helpful, donâ€™t hesitate to share it with others who might benefit from it. For any questions, feedback, or suggestions for future articles, feel free to leave a comment below or reach out to me directly."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/retrofit-android-example-tutorial",
        "document": "Welcome to Retrofit Android Example Tutorial. Today weâ€™ll use the Retrofit library developed by Square to handle REST API calls in our android application.\n\nRetrofit is type-safe REST client for Android and Java which aims to make it easier to consume RESTful web services. Weâ€™ll not go into the details of Retrofit 1.x versions and jump onto Retrofit 2 directly which has a lot of new features and a changed internal API compared to the previous versions. Retrofit 2 by default leverages OkHttp as the networking layer and is built on top of it. Retrofit automatically serialises the JSON response using a POJO(Plain Old Java Object) which must be defined in advanced for the JSON Structure. To serialise JSON we need a converter to convert it into Gson first. We need to add the following dependencies in our file.\n\nOkHttp dependency is already shipped with Retrofit 2 dependency. If you wish to use a separate OkHttp dependency, you should exclude the OkHttp dependency from Retrofit 2 as:\nâ€¢ The logging-interceptor generates a log string of the entire response thatâ€™s returned.\nâ€¢ There are other converters to parse the JSON to the necessary type. A few of them are listed below.\n\nAdd the permission to access internet in the AndroidManifest.xml file.\n\nInterceptors are a powerful mechanism present in OkHttp that can monitor, rewrite, and retry calls. Interceptors can be majorly divided into two categories:\nâ€¢ Application Interceptors : To register an application interceptor, we need to call on\nâ€¢ Network Interceptors : To register a Network Interceptor, invoke instead of\n\nThe method in the above code will be called every time while setting up a Retrofit interface. Retrofit provides with a list of annotations for each of the HTTP methods: . Letâ€™s see how our class looks like.\n\nIn the above class, weâ€™ve defined some methods that perform HTTP requests with annotation. calls . is the method name. is a Model POJO class for our response object thatâ€™s used to map the response parameters to their respective variables. These POJO class act as the method return type. A simple POJO class for is given below.\n\nannotation is used to specify the name of the field thatâ€™s in the JSON Response. Preview the POJO class and copy it into your Android Studio Project Structure. The POJO classes are wrapped into a typed Retrofit class. Note: A JSONArray is serialised a List of Objects in the POJO classes Method Parameters : There are a wide variety of possible options of parameters to pass inside a method:\nâ€¢ - We can simply add a method parameter with @Query and a query parameter name, describing the type. To URL encode a query use the form:\nâ€¢ - send data as form-urlencoded. This requires a annotation attached with the method. The parameter works only with a POST\n\nNote: @Field requires a mandatory parameter. In cases when @Field is optional, we can use @Query instead and pass a null value.\n\nThe pojo package defines four model classes for each of the API endpoint responses defined in the APIInterface.java class.\n\nThe above class is used to create the Response Body for the method\n\nThe is where we call each of the API endpoints defined in the Interface class and display each of the fields in a Toast/TextView.\n\nis used to instantiate the APIClient. To map the Model class to the response we use: Running the application would call each of the endpoints and display a Toast message for them accordingly. This brings an end to Retrofit android example tutorial. You can download the Android Retrofit example project from the link below."
    },
    {
        "link": "https://stackoverflow.com/questions/46495406/android-fetch-the-very-first-value-in-json-data-using-retrofit-library",
        "document": "You can use as retrofit result obj and get the keys.\n\nor just get it with string then cast it to hasmap\n\nthen you can iterate trough the keys."
    },
    {
        "link": "https://developer.android.com/codelabs/basic-android-kotlin-compose-getting-data-internet",
        "document": "Most Android apps in the market connect to the internet to perform network operations, such as retrieving emails, messages, or other information from a backend server. Gmail, YouTube, and Google Photos are example apps that connect to the internet to display the user data. In this codelab, you will use open source and community-driven libraries to build a data layer and get data from a backend server. This greatly simplifies fetching the data and also helps the app follow Android best practices, such as perform operations on a background thread. You will also display an error message if the internet is slow or unavailable, which will keep the user informed about any network connectivity issues.\nâ€¢ Basic knowledge of how to create Composable functions.\nâ€¢ Basic knowledge of how to use Android architecture components .\nâ€¢ Basic knowledge of how to use coroutines for long-running tasks.\nâ€¢ Basic knowledge of how to add dependencies in .\nâ€¢ How to use the Retrofit library to connect to a REST web service on the internet and get a response.\nâ€¢ How to use the Serialization (kotlinx.serialization) library to parse the JSON response into a data object.\nâ€¢ Modify a starter app to make a web service API request and handle the response.\nâ€¢ Implement a data layer for your app using the Retrofit library.\nâ€¢ Parse the JSON response from the web service into your app's list of data objects with the kotlinx.serialization library, and attach it to the UI state.\nâ€¢ Use Retrofit's support for coroutines to simplify the code. What you need\n\nYou work with the app named Mars Photos, which shows images of the Mars surface. This app connects to a web service to retrieve and display Mars photos. The images are real-life photos from Mars, captured from NASA's Mars rovers. The following image is a screenshot of the final app, which contains a grid of images. Note: The preceding image is a screenshot of the final app that you will build at the end of this unit, after additional updates in later codelabs. The screenshot is shown in this codelab to give you a better idea of the overall app functionality. The version of the app you build in this codelab won't have a lot of visual flash. This codelab focuses on the data layer part of the app to connect to the internet and download the raw property data using a web service. To ensure that the app correctly retrieves and parses this data, you can print the number of photos received from the backend server in a composable.\n\nThe Mars photos data is stored on a web server. To get this data into your app, you need to establish a connection and communicate with the server on the internet. Note: In this codelab, you only retrieve the number of records (URLs), not the Mars photos. In a later codelab, you retrieve the Mars photos and display them in a grid. Most web servers today run web services using a common stateless web architecture known as REST, which stands for REpresentational State Transfer. Web services that offer this architecture are known as RESTful services. Requests are made to RESTful web services in a standardized way, via Uniform Resource Identifiers (URIs). A URI identifies a resource in the server by name, without implying its location or how to access it. For example, in the app for this lesson, you retrieve the image URLs using the following server URI. (This server hosts both Mars real estate and Mars photos): Note: The aforementioned server is being accessed by a different sample app where it showcases Mars real estate, so this server has two different endpoints: one for Mars real estate and one for photos. For this course, you use the server to retrieve Mars photos. A URL (Uniform Resource Locator) is a subset of a URI that specifies where a resource exists and the mechanism for retrieving it. The following URL gets a list of available real estate properties on Mars: The following URL gets a list of Mars photos: These URLs refer to an identified resource, such as /realestate or /photos, that is obtainable via the Hypertext Transfer Protocol (http:) from the network. You are using the /photos endpoint in this codelab. An endpoint is a URL that allows you to access a web service running on a server. Note: The familiar web URL is actually a type of URI. This course uses both URL and URI interchangeably. Each web service request contains a URI and is transferred to the server using the same HTTP protocol that's used by web browsers, like Chrome. HTTP requests contain an operation to tell the server what to do.\nâ€¢ POST for creating new data on the server.\nâ€¢ PUT for updating existing data on the server.\nâ€¢ DELETE for deleting data from the server. Your app makes an HTTP GET request to the server for the Mars photos information, and then the server returns a response to your app, including the image URLs. The response from a web service is formatted in one of the common data formats, like XML (eXtensible Markup Language) or JSON (JavaScript Object Notation). The JSON format represents structured data in key-value pairs. An app communicates with the REST API using JSON, which you learn more about in a later task. In this task, you establish a network connection to the server, communicate with the server, and receive a JSON response. You will be using a backend server that is already written for you. In this codelab, you use the Retrofit library, a third-party library, to communicate with the backend server. External libraries, or third-party libraries, are like extensions to the core Android APIs. The libraries you use in this course are open source, community-developed, and maintained by the collective contributions from the huge Android community around the world. These resources help Android developers like you to build better apps. Warning: Using community-developed and maintained libraries can be a huge timesaver. However, you must choose these libraries wisely because your app is ultimately responsible for what the code does in these libraries. The Retrofit library that you use in this codelab to talk to the RESTful Mars web service is a good example of a well-supported and maintained library. You can tell this by looking at its GitHub page and reviewing the open and closed issues (some are feature requests). If the developers are regularly resolving the issues and responding to the feature requests, the library is likely well-maintained and a good candidate to use in the app. You can also refer to Retrofit documentation to learn more about the library. The Retrofit library communicates with the REST backend. It generates the code, but you need to provide the URIs for the web service based on the parameters we pass to it. You learn more about this topic in later sections. Android Gradle lets you add external libraries to your project. In addition to the library dependency, you also need to include the repository where the library is hosted.\nâ€¢ In the section, add the following lines for the Retrofit libraries: The two libraries work together. The first dependency is for the Retrofit2 library itself, and the second dependency is for the Retrofit scalar converter. Retrofit2 is the updated version of the Retrofit library. This scalar converter enables Retrofit to return the JSON result as a . JSON is a format for storing and transporting data between client and server. You will learn about JSON in a later section.\nâ€¢ Click Sync Now to rebuild the project with the new dependencies.\n\nYou use the Retrofit library to talk to the Mars web service and display the raw JSON response as a . The placeholder either displays the returned JSON response string or a message indicating a connection error. Retrofit creates a network API for the app based on the content from the web service. It fetches data from the web service and routes it through a separate converter library that knows how to decode the data and return it in the form of objects, like . Retrofit includes built-in support for popular data formats, such as XML and JSON. Retrofit ultimately creates the code to call and consume this service for you, including critical details, such as running the requests on background threads. In this task, you add a data layer to your Mars Photos project that your uses to communicate with the web service. You implement the Retrofit service API with the following steps:\nâ€¢ Create a Retrofit object with the base URL and the converter factory to convert strings.\nâ€¢ Create an interface that explains how Retrofit talks to the web server.\nâ€¢ Create a Retrofit service and expose the instance to the api service to the rest of the app.\nâ€¢ Right-click on the package com.example.marsphotos in your Android project pane and select New > Package.\nâ€¢ In the popup, append network to the end of the suggested package name.\nâ€¢ Create a new Kotlin file under the new package. Name it .\nâ€¢ Add the following constant for the base URL for the web service.\nâ€¢ Add a Retrofit builder just below that constant to build and create a Retrofit object. Retrofit needs the base URI for the web service and a converter factory to build a web services API. The converter tells Retrofit what to do with the data it gets back from the web service. In this case, you want Retrofit to fetch a JSON response from the web service and return it as a . Retrofit has a that supports strings and other primitive types.\nâ€¢ Call on the builder with an instance of .\nâ€¢ Add the base URL for the web service using the method.\nâ€¢ Below the call to the Retrofit builder, define an interface called that defines how Retrofit talks to the web server using HTTP requests.\nâ€¢ Add a function called to the interface to get the response string from the web service.\nâ€¢ Use the annotation to tell Retrofit that this is a GET request and specify an endpoint for that web service method. In this case, the endpoint is . As mentioned in the previous task, you will use the /photos endpoint in this codelab. When the method is invoked, Retrofit appends the endpoint to the base URLâ€”which you defined in the Retrofit builderâ€”used to start the request.\nâ€¢ Add a return type of the function to . In Kotlin, object declarations are used to declare singleton objects. Singleton pattern ensures that one, and only one, instance of an object is created and has one global point of access to that object. Object initialization is thread-safe and done at first access. Following is an example of an object declaration and its access. Object declaration always has a name following the keyword. // Example for Object declaration, do not copy over // To refer to the object, use its name directly. Warning: Singleton pattern is not a recommended practice. Singletons represent global states that are hard to predict, particularly in tests. Objects should define which dependencies they need, instead of describing how to create them. Use Dependency injection over singleton pattern, you will learn how to implement Dependency injection in a later codelab. The call to function on a Retrofit object is expensive in terms of memory, speed, and performance. The app needs only one instance of the Retrofit API service, so you expose the service to the rest of the app using object declaration.\nâ€¢ Outside the interface declaration, define a public object called to initialize the Retrofit service. This object is the public singleton object that the rest of the app can access.\nâ€¢ Inside the object declaration, add a lazily initialized retrofit object property named of the type . You make this lazy initialization to make sure it is initialized at its first usage. Ignore the error, which you fix in the next steps. Note: Remember \"lazy initialization\" is when object creation is purposely delayed, until you actually need that object, to avoid unnecessary computation or use of other computing resources. Kotlin has first-class support for lazy instantiation.\nâ€¢ Initialize the variable using the method with the interface. The Retrofit setup is done! Each time your app calls , the caller accesses the same singleton Retrofit object that implements , which is created on the first access. In the next task, you use the Retrofit object you implemented. In this step, you implement the method that calls the REST service and then handles the returned JSON string. Note: The recommended approach is to call webservice from a repository, which isolates the data layer from the rest of the app. In a later codelab, you add a repository to your app. A is the built-in coroutine scope defined for each in your app. Any coroutine launched in this scope is automatically canceled if the is cleared. You can use to launch the coroutine and make the web service request in the background. Since the belongs to the , the request continues even if the app goes through a configuration change.\nâ€¢ In the file, make a suspend function to make it asynchronous and not block the calling thread. You call this function from inside a .\nâ€¢ Open the file. Scroll down to the method. Delete the line that sets the status response to so that the method is empty.\nâ€¢ Inside , use the singleton object to call the method from the interface. Save the returned response in a called .\nâ€¢ Assign the result just received from the backend server to the . The is a mutable state object that represents the status of the most recent web request.\nâ€¢ Run the app. Notice that the app closes immediately, and it may or may not display an error popup. This is an app crash.\nâ€¢ Click the Logcat tab in Android Studio and note the error in the log, which starts with a line like this: \" \" This error message indicates the app might be missing the permissions. The next task describes how to add internet permissions to the app and resolve this issue.\n\nThe purpose of permissions on Android is to protect the privacy of an Android user. Android apps must declare or request permissions to access sensitive user data, such as contacts, call logs, and certain system features, such as camera or internet. In order for your app to access the Internet, it needs the permission. Connecting to the internet introduces security concerns, which is why apps do not have internet connectivity by default. You need to explicitly declare that the app needs access to the internet. This declaration is considered a normal permission. To learn more about Android permissions and its types, please refer to the Permissions on Android. In this step, your app declares the permission(s) it requires by including tags in the file.\nâ€¢ Open . Add this line just before the tag:\nâ€¢ Compile and run the app again. If you have a working internet connection, you see the JSON text containing data related to the Mars photos. Observe how the and are repeated for every image record. You learn more about the JSON format later in the codelab.\nâ€¢ Tap the Back button in your device or emulator to close the app. There is a bug in your code. Perform the following steps to see it:\nâ€¢ Put your device or emulator into Airplane Mode to simulate a network connection error.\nâ€¢ Reopen the app from the Recents menu, or run the app from Android Studio.\nâ€¢ Click the Logcat tab in Android Studio and note the fatal exception in the log, which looks like the following: This error message indicates the application tried to connect and timed out. Exceptions like this one are very common in real time. Unlike the permission issue, this error is not something you can fix, but you can handle it. In the next step, you learn how to handle such exceptions. Exceptions are errors that can occur during runtime, not compile time, and they terminate the app abruptly without notifying the user. This can result in a poor user experience. Exception handling is a mechanism by which you prevent the app from terminating abruptly and handle the situation in a user-friendly way. The reason for exceptions could be as simple as division by zero or an error with the network connection. These exceptions are similar to the that a previous codelab discusses. Examples of potential issues while connecting to a server include the following:\nâ€¢ The URL or URI used in the API is incorrect.\nâ€¢ The server is unavailable, and the app could not connect to it.\nâ€¢ Poor or no internet connection on the device. These exceptions can't be handled during compile time, but you can use a block to handle the exception in runtime. For further learning, refer to Exceptions. // some code that can cause an exception. Inside the block, you add the code where you anticipate an exception. In your app, this is a network call. In the block, you need to implement the code that prevents abrupt termination of the app. If there is an exception, then the block executes to recover from the error instead of terminating the app abruptly.\nâ€¢ In , inside the block, add a block around the call to handle exceptions.\nâ€¢ Run the app one more time. Notice that the app does not crash this time. In the class, the status of the most recent web request, , is saved as a mutable state object. However, this class lacks the ability to save the different status: loading, success, and failure.\nâ€¢ Loading status indicates the app is waiting for data.\nâ€¢ Success status indicates the data was successfully retrieved from the web service.\nâ€¢ Error status indicates any network or connection errors. To represent these three states in your application, you use a sealed interface. A makes it easy to manage state by limiting the possible values. In the Mars Photos app, you restrict the web response to three states (data class objects): loading, success, and error, which looks like the following code: In the above code snippet, in the case of a successful response, you receive Mars photo information from the server. In order to store the data, add a constructor parameter to the data class. In the case of and states, you don't need to set new data and create new objects; you are just passing the web response. Change the class to to create the objects for the web responses.\nâ€¢ Open the file. After the import statements, add the sealed interface. This addition makes the values object can have exhaustive.\nâ€¢ Inside the class, update the definition. Change the type to and as its default value. Make the setter private to protect writes to the .\nâ€¢ Scroll down to the method. Update the value to and pass the .\nâ€¢ Inside the block, handle the failure response. Set to .\nâ€¢ You can lift the assignment out of the block. Your completed function should look like the following code:\nâ€¢ In the file, add a expression on the . If the is , call and pass in . Ignore the errors for now. Note: The property is not a string any longer. You changed it to a sealed interface, which can have three different object values: , , and .\nâ€¢ Inside the block, add checks for and . Have the app display the , , and composables, which you implement later. Note: If you implement without a keyword, it requires you to add a Success, Error, Loading and branch. Since there is no fourth option (else), you use a interface to tell the compiler that there are only three options (thus making the conditionals exhaustive).\nâ€¢ Open . This drawable is an animation that rotates an image drawable, , around the center point. (You don't see the animation in the preview.)\nâ€¢ In the file, below the composable, add the following composable function to display the loading animation. The drawable resource is included in the starter code.\nâ€¢ Below the composable, add the following composable function so the app can display the error message.\nâ€¢ Run the app again with Airplane Mode turned on. The app does not close abruptly this time, and it displays the following error message:\nâ€¢ Turn off Airplane Mode on your phone or emulator. Run and test your app to make sure everything works correctly and you are able to see the JSON string.\n\nThe requested data is typically formatted in one of the common data formats like XML or JSON. Each call returns structured data, and your app needs to know what that structure is in order to read the data from the response. For example, in this app, you are retrieving the data from the https:// android-kotlin-fun-mars-server.appspot.com/photos server. When you enter this URL in the browser, you see a list of IDs and image URLs of the surface of Mars in a JSON format! The structure of a JSON response has the following features:\nâ€¢ JSON response is an array, indicated by the square brackets. The array contains JSON objects.\nâ€¢ Each JSON object contains a set of key-value pairs separated by a comma.\nâ€¢ A colon separates the key and value in a pair.\nâ€¢ Values can be numbers, strings, a boolean, an array, an object (JSON object), or null. For example, the is a URL, which is a string. When you paste the URL into a web browser, you see a Mars surface image. In your app, now you're getting a JSON response from the Mars web service, which is a great start. But what you really need to display the images are Kotlin objects, not a big JSON string. This process is called deserialization. Serialization is the process of converting data used by an application to a format that can be transferred over a network. As opposed to serialization, deserialization is the process of reading data from an external source (like a server) and converting it into a runtime object. They are both essential components of most applications that exchange data over the network. The provides sets of libraries that convert a JSON string into Kotlin objects. There is a community developed third party library that works with Retrofit, Kotlin Serialization Converter. In this task, you use the library, to parse the JSON response from the web service into useful Kotlin objects that represent Mars photos. You change the app so that instead of displaying the raw JSON, the app displays the number of Mars photos returned.\nâ€¢ In the section, add the following code to include the dependency. This dependency provides JSON serialization for Kotlin projects.\nâ€¢ Locate the lines for the Retrofit scalar converter in the block and change it to use :\nâ€¢ Click Sync Now to rebuild the project with the new dependencies. Note: The project may show compiler errors related to the removed Retrofit scalar dependency. You fix those in the next steps. A sample entry of the JSON response you get from the web service looks something like the following, similar to what you saw earlier: In the example above, notice that each Mars photo entry has the following JSON key and value pairs:\nâ€¢ : the ID of the property, as a string. Since it is wrapped in quotes ( ), it is of the type , not . kotlinx.serialization parses this JSON data and converts it into Kotlin objects. To do this, kotlinx.serialization needs to have a Kotlin data class to store the parsed results. In this step, you create the data class .\nâ€¢ Right-click on the network package and select New > Kotlin File/Class.\nâ€¢ In the dialog, select Class and enter as the name of the class. This action creates a new file called in the package.\nâ€¢ Make a data class by adding the keyword before the class definition.\nâ€¢ Change the curly braces to parentheses . This change gives you an error because data classes must have at least one property defined.\nâ€¢ Add the following properties to the class definition.\nâ€¢ To make class serializable annotating it with . Notice that each of the variables in the class corresponds to a key name in the JSON object. To match the types in our specific JSON response, you use objects for all the values. When parses the JSON, it matches the keys by name and fills the data objects with appropriate values. Sometimes the key names in a JSON response can make confusing Kotlin properties or may not match recommended coding style. For example, in the JSON file, the key uses an underscore, whereas Kotlin convention for properties uses upper and lowercase letters (camel case). To use variable names in your data class that differ from the key names in the JSON response, use the annotation. In the following example, the name of the variable in the data class is . The variable can be mapped to the JSON attribute using .\nâ€¢ Replace the line for the key with the line shown below. In this task, you will use the converter to convert the JSON object to Kotlin objects.\nâ€¢ Notice the unresolved reference errors for . These errors are a result of the Retrofit dependency change in a previous section.\nâ€¢ Delete the import for . You fix the other error later.\nâ€¢ In the object declaration, change the Retrofit builder to use the instead of the . Note: If Android Studio shows you any warning regarding ignore it for now. You don't have to worry about this warning. It will be resolved in the later versions of Kotlin. Now that you have the in place, you can ask Retrofit to return a list of objects from the JSON array, instead of returning a JSON string.\nâ€¢ Update the interface for Retrofit to return a list of objects instead of returning a .\nâ€¢ Make similar changes to the . Open and scroll down to the method. In the method, is a and not a anymore. The size of that list is the number of photos that were received and parsed.\nâ€¢ To print the number of photos retrieved, update as follows:\nâ€¢ Make sure Airplane Mode is turned off on your device or emulator. Compile and run the app. This time, the message should show the number of properties returned from the web service, and not a big JSON string: Note: If your internet connection is not working, make sure that you turn off Airplane Mode on your device or emulator."
    },
    {
        "link": "https://stackoverflow.com/questions/29404729/android-best-practice-for-handling-json-data",
        "document": "I've been researching how to query JSON data from a server and parse it for use in my application. However, I've found a number of different ways to do the same thing. I realize there are different JSON parsers out there, so let's assume I'm sticking with the standard one. The main question I have has to do with the server requests. Here is my current code for my MapActivity\n\nIf the structure of my JSON data looks weird, it's because it's stored in an unnamed array so I don't have to create an object first. Anyway... I essentially based this off of this tutorial. However, they have soooo much more code. Is that all really necessary? I didn't think so. I searched around more and found other examples that used half the code and essentially did the same thing. So my question, as a beginning Android programmer, is what is the best practice for handling JSON data? Thanks!"
    },
    {
        "link": "https://stackoverflow.com/questions/19758077/perform-asynctask-on-android-posting-json",
        "document": "I understand that you cannot connect to the network on the main thread and have created an HttpClient class that uses AsnycTask (although probably not correctly).\n\nYou are right you have not implemented it the right way.\n\nIn your events (still on Main thread) you performed a network activity causing the error:\n\nInstead you should run the network operation inside of the AsnycTask\n\nThen you call your async in onclik method like this:"
    },
    {
        "link": "https://quora.com/Is-AsyncTask-the-best-way-to-download-JSON-data-to-an-Android-app",
        "document": "Something went wrong. Wait a moment and try again."
    },
    {
        "link": "https://developer.android.com/reference/android/os/AsyncTask",
        "document": "This class was deprecated in API level 30.\n\n Use the standard or Kotlin concurrency utilities instead.\n\nAsyncTask was intended to enable proper and easy use of the UI thread. However, the most common use case was for integrating into UI, and that would cause Context leaks, missed callbacks, or crashes on configuration changes. It also has inconsistent behavior on different versions of the platform, swallows exceptions from , and does not provide much utility over using s directly.\n\nAsyncTask is designed to be a helper class around and and does not constitute a generic threading framework. AsyncTasks should ideally be used for short operations (a few seconds at the most.) If you need to keep threads running for long periods of time, it is highly recommended you use the various APIs provided by the package such as , and .\n\nAn asynchronous task is defined by a computation that runs on a background thread and whose result is published on the UI thread. An asynchronous task is defined by 3 generic types, called , and , and 4 steps, called , , and .\n\nAsyncTask must be subclassed to be used. The subclass will override at least one method ( ), and most often will override a second one ( .)\n\nHere is an example of subclassing:\n\nOnce created, a task is executed very simply:\n\nThe three types used by an asynchronous task are the following:\nâ€¢ , the type of the parameters sent to the task upon execution.\nâ€¢ , the type of the progress units published during the background computation.\nâ€¢ , the type of the result of the background computation.\n\nNot all types are always used by an asynchronous task. To mark a type as unused, simply use the type :\n\nWhen an asynchronous task is executed, the task goes through 4 steps:\nâ€¢ , invoked on the UI thread before the task is executed. This step is normally used to setup the task, for instance by showing a progress bar in the user interface.\nâ€¢ , invoked on the background thread immediately after finishes executing. This step is used to perform background computation that can take a long time. The parameters of the asynchronous task are passed to this step. The result of the computation must be returned by this step and will be passed back to the last step. This step can also use to publish one or more units of progress. These values are published on the UI thread, in the step.\nâ€¢ , invoked on the UI thread after a call to . The timing of the execution is undefined. This method is used to display any form of progress in the user interface while the background computation is still executing. For instance, it can be used to animate a progress bar or show logs in a text field.\nâ€¢ , invoked on the UI thread after the background computation finishes. The result of the background computation is passed to this step as a parameter.\n\nA task can be cancelled at any time by invoking . Invoking this method will cause subsequent calls to to return true. After invoking this method, , instead of will be invoked after returns. To ensure that a task is cancelled as quickly as possible, you should always check the return value of periodically from , if possible (inside a loop for instance.)\n\nThere are a few threading rules that must be followed for this class to work properly:\nâ€¢ The AsyncTask class must be loaded on the UI thread. This is done automatically as of .\nâ€¢ The task instance must be created on the UI thread.\nâ€¢ must be invoked on the UI thread.\nâ€¢ The task can be executed only once (an exception will be thrown if a second execution is attempted.)\n\nAsyncTask guarantees that all callback calls are synchronized to ensure the following without explicit synchronizations.\nâ€¢ The memory effects of , and anything else executed before the call to , including the construction of the AsyncTask object, are visible to .\nâ€¢ The memory effects of are visible to .\nâ€¢ Any memory effects of preceding a call to are visible to the corresponding call. (But continues to run, and care needs to be taken that later updates in do not interfere with an in-progress call.)\nâ€¢ Any memory effects preceding a call to are visible after a call to that returns true as a result, or during and after a resulting call to .\n\nWhen first introduced, AsyncTasks were executed serially on a single background thread. Starting with , this was changed to a pool of threads allowing multiple tasks to operate in parallel. Starting with , tasks are executed on a single thread to avoid common application errors caused by parallel execution.\n\nIf you truly want parallel execution, you can invoke with .\n\nAttempts to cancel execution of this task. This attempt will fail if the task has already completed, already been cancelled, or could not be cancelled for some other reason. If successful, and this task has not started when is called, this task should never run. If the task has already started, then the parameter determines whether the thread executing this task should be interrupted in an attempt to stop the task. Calling this method will result in being invoked on the UI thread after returns. Calling this method guarantees that onPostExecute(Object) is never subsequently invoked, even if returns false, but has not yet run. To finish the task as early as possible, check periodically from . This only requests cancellation. It never waits for a running background task to terminate, even if is true. : if the thread executing this task should be interrupted; otherwise, in-progress tasks are allowed to complete. if the task could not be cancelled, typically because it has already completed normally; otherwise\n\nExecutes the task with the specified parameters. The task returns itself (this) so that the caller can keep a reference to it. Note: this function schedules the task on a queue for a single background thread or pool of threads depending on the platform version. When first introduced, AsyncTasks were executed serially on a single background thread. Starting with , this was changed to a pool of threads allowing multiple tasks to operate in parallel. Starting , tasks are back to being executed on a single thread to avoid common application errors caused by parallel execution. If you truly want parallel execution, you can use the version of this method with ; however, see commentary there for warnings on its use. This method must be invoked on the UI thread. \n\n This method must be called from the main thread of your app. : The parameters of the task. If returns either or .\n\nExecutes the task with the specified parameters. The task returns itself (this) so that the caller can keep a reference to it. This method is typically used with to allow multiple tasks to run in parallel on a pool of threads managed by AsyncTask, however you can also use your own for custom behavior. Warning: Allowing multiple tasks to run in parallel from a thread pool is generally not what one wants, because the order of their operation is not defined. For example, if these tasks are used to modify any state in common (such as writing a file due to a button click), there are no guarantees on the order of the modifications. Without careful work it is possible in rare cases for the newer version of the data to be over-written by an older one, leading to obscure data loss and stability issues. Such changes are best executed in serial; to guarantee such work is serialized regardless of platform version you can use this function with . This method must be invoked on the UI thread. \n\n This method must be called from the main thread of your app. : The executor to use. is available as a convenient process-wide thread pool for tasks that are loosely coupled. : The parameters of the task. If returns either or ."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/android-jsonobject-json-parsing",
        "document": "Android JSONObject is used for JSON parsing in android apps. In this tutorial weâ€™ll discuss and implement a in our android application to parse JSON data. JSON stands for JavaScript Object Notation.\n\nJSON is used for data interchange (posting and retrieving) from the server. Hence knowing the syntax and itâ€™s usability is important. JSON is the best alternative for XML and its more readable by human. JSON is language independent. Because of language in-dependency we can program JSON in any language (Java/C/C++). A JSON response from the server consists of many fields. An example JSON response/data is given below. Weâ€™ll use it as a reference and implement it in our application.\n\nWeâ€™ve create a random JSON data string from this page. Itâ€™s handy for editing JSON data. A JSON data consists of 4 major components that are listed below:\nâ€¢ Array: A JSONArray is enclosed in square brackets ([). It contains a set of objects\nâ€¢ Object: Data enclosed in curly brackets ({) is a single JSONObject. Nested JSONObjects are possible and are very commonly used\nâ€¢ Keys: Every JSONObject has a key string thatâ€™s contains certain value\nâ€¢ Value: Every key has a single value that can be of any type string, double, integer, boolean etc\n\nWeâ€™ll create a JSONObject from the static JSON data string given above and display the JSONArray in a ListView. Weâ€™ll change the application name to the title string in the JSON data.\n\nBelow image shows the android studio project for json parsing example. The project consists of the default activity and layout (with a ListView).\n\nThe is given below.\n\nThe is given below.\n\nWeâ€™ve iterated through the object and fetched the strings present in each child and added them to a ArrayList thatâ€™s displayed in the ListView. The application name is changed using :\n\nThe output of the application is given below. You can see the title name changed in the ToolBar at the top. Google has released a Volley Library for JSON Parsing. Weâ€™ll implement that in later tutorials. GSON is a Java library that converts Java Objects into JSON and vice versa. This brings an end to android JSONObject tutorial. Our aim was to give a overview of JSON Parsing in android since JSON is the accepted standard these days for transmitting data between servers/web applications. Android JSON parsing will be very handy when we develop applications that send and receive data from the server. You can download the Android JSON Parsing Project from the below link."
    }
]