[
    {
        "link": "https://vuejs.org/guide/essentials/lifecycle",
        "document": "Each Vue component instance goes through a series of initialization steps when it's created - for example, it needs to set up data observation, compile the template, mount the instance to the DOM, and update the DOM when data changes. Along the way, it also runs functions called lifecycle hooks, giving users the opportunity to add their own code at specific stages.\n\nFor example, the hook can be used to run code after the component has finished the initial rendering and created the DOM nodes:\n\nThere are also other hooks which will be called at different stages of the instance's lifecycle, with the most commonly used being , , and . , , and .\n\nAll lifecycle hooks are called with their context pointing to the current active instance invoking it. Note this means you should avoid using arrow functions when declaring lifecycle hooks, as you won't be able to access the component instance via if you do so.\n\nWhen calling , Vue automatically associates the registered callback function with the current active component instance. This requires these hooks to be registered synchronously during component setup. For example, do not do this: Do note this doesn't mean that the call must be placed lexically inside or . can be called in an external function as long as the call stack is synchronous and originates from within .\n\nBelow is a diagram for the instance lifecycle. You don't need to fully understand everything going on right now, but as you learn and build more, it will be a useful reference.\n\nConsult the Lifecycle Hooks API referenceLifecycle Hooks API reference for details on all lifecycle hooks and their respective use cases."
    },
    {
        "link": "https://vuejs.org/api/composition-api-lifecycle",
        "document": "Registers a callback to be called after the component has been mounted.\nâ€¢ None\nâ€¢ None All of its synchronous child components have been mounted (does not include async components or components inside trees).\nâ€¢ None Its own DOM tree has been created and inserted into the parent container. Note it only guarantees that the component's DOM tree is in-document if the application's root container is also in-document. This hook is typically used for performing side effects that need access to the component's rendered DOM, or for limiting DOM-related code to the client in a server-rendered application. This hook is not called during server-side rendering.\n\nRegisters a callback to be called after the component has updated its DOM tree due to a reactive state change.\nâ€¢ None A parent component's updated hook is called after that of its child components. This hook is called after any DOM update of the component, which can be caused by different state changes, because multiple state changes can be batched into a single render cycle for performance reasons. If you need to access the updated DOM after a specific state change, use nextTick() instead. This hook is not called during server-side rendering. Do not mutate component state in the updated hook - this will likely lead to an infinite update loop!\nâ€¢ None // text content should be the same as current `count.value`\n\nRegisters a callback to be called after the component has been unmounted.\nâ€¢ None\nâ€¢ None All of its child components have been unmounted.\nâ€¢ None All of its associated reactive effects (render effect and computed / watchers created during ) have been stopped. Use this hook to clean up manually created side effects such as timers, DOM event listeners or server connections. This hook is not called during server-side rendering.\n\nRegisters a hook to be called right before the component is to be mounted.\nâ€¢ None When this hook is called, the component has finished setting up its reactive state, but no DOM nodes have been created yet. It is about to execute its DOM render effect for the first time. This hook is not called during server-side rendering.\n\nRegisters a hook to be called right before the component is about to update its DOM tree due to a reactive state change.\nâ€¢ None This hook can be used to access the DOM state before Vue updates the DOM. It is also safe to modify component state inside this hook. This hook is not called during server-side rendering.\n\nRegisters a hook to be called right before a component instance is to be unmounted.\nâ€¢ None When this hook is called, the component instance is still fully functional. This hook is not called during server-side rendering.\n\nRegisters a hook to be called when an error propagating from a descendant component has been captured.\nâ€¢ None Errors can be captured from the following sources: The hook receives three arguments: the error, the component instance that triggered the error, and an information string specifying the error source type. In production, the 3rd argument ( ) will be a shortened code instead of the full information string. You can find the code to string mapping in the Production Error Code Reference. You can modify component state in to display an error state to the user. However, it is important that the error state should not render the original content that caused the error; otherwise the component will be thrown into an infinite render loop. The hook can return to stop the error from propagating further. See error propagation details below.\nâ€¢ None By default, all errors are still sent to the application-level if it is defined, so that these errors can still be reported to an analytics service in a single place.\nâ€¢ None If multiple hooks exist on a component's inheritance chain or parent chain, all of them will be invoked on the same error, in the order of bottom to top. This is similar to the bubbling mechanism of native DOM events.\nâ€¢ None If the hook itself throws an error, both this error and the original captured error are sent to .\nâ€¢ None An hook can return to prevent the error from propagating further. This is essentially saying \"this error has been handled and should be ignored.\" It will prevent any additional hooks or from being invoked for this error.\n\nRegisters a debug hook to be called when a reactive dependency has been tracked by the component's render effect.\n\nThis hook is development-mode-only and not called during server-side rendering.\nâ€¢ None See also Reactivity in Depth\n\nRegisters a debug hook to be called when a reactive dependency triggers the component's render effect to be re-run.\n\nThis hook is development-mode-only and not called during server-side rendering.\nâ€¢ None See also Reactivity in Depth\n\nRegisters a callback to be called after the component instance is inserted into the DOM as part of a tree cached by .\n\nThis hook is not called during server-side rendering.\nâ€¢ None See also Guide - Lifecycle of Cached Instance\n\nRegisters a callback to be called after the component instance is removed from the DOM as part of a tree cached by .\n\nThis hook is not called during server-side rendering.\nâ€¢ None See also Guide - Lifecycle of Cached Instance\n\nRegisters an async function to be resolved before the component instance is to be rendered on the server.\nâ€¢ None If the callback returns a Promise, the server renderer will wait until the Promise is resolved before rendering the component. This hook is only called during server-side rendering can be used to perform server-only data fetching.\nâ€¢ None // component is rendered as part of the initial request // pre-fetch data on server as it is faster than on the client // if data is null on mount, it means the component // is dynamically rendered on the client. Perform a"
    },
    {
        "link": "https://vuejs.org/api/options-lifecycle.html",
        "document": "Called when the instance is initialized.\nâ€¢ None Called immediately when the instance is initialized and props are resolved. Then the props will be defined as reactive properties and the state such as or will be set up. Note that the hook of Composition API is called before any Options API hooks, even .\n\nCalled after the instance has finished processing all state-related options.\nâ€¢ None When this hook is called, the following have been set up: reactive data, computed properties, methods, and watchers. However, the mounting phase has not been started, and the property will not be available yet.\n\nCalled right before the component is to be mounted.\nâ€¢ None When this hook is called, the component has finished setting up its reactive state, but no DOM nodes have been created yet. It is about to execute its DOM render effect for the first time. This hook is not called during server-side rendering.\n\nCalled after the component has been mounted.\nâ€¢ None\nâ€¢ None All of its synchronous child components have been mounted (does not include async components or components inside trees).\nâ€¢ None Its own DOM tree has been created and inserted into the parent container. Note it only guarantees that the component's DOM tree is in-document if the application's root container is also in-document. This hook is typically used for performing side effects that need access to the component's rendered DOM, or for limiting DOM-related code to the client in a server-rendered application. This hook is not called during server-side rendering.\n\nCalled right before the component is about to update its DOM tree due to a reactive state change.\nâ€¢ None This hook can be used to access the DOM state before Vue updates the DOM. It is also safe to modify component state inside this hook. This hook is not called during server-side rendering.\n\nCalled after the component has updated its DOM tree due to a reactive state change.\nâ€¢ None A parent component's updated hook is called after that of its child components. This hook is called after any DOM update of the component, which can be caused by different state changes. If you need to access the updated DOM after a specific state change, use nextTick() instead. This hook is not called during server-side rendering. Do not mutate component state in the updated hook - this will likely lead to an infinite update loop!\n\nCalled right before a component instance is to be unmounted.\nâ€¢ None When this hook is called, the component instance is still fully functional. This hook is not called during server-side rendering.\n\nCalled after the component has been unmounted.\nâ€¢ None\nâ€¢ None All of its child components have been unmounted.\nâ€¢ None All of its associated reactive effects (render effect and computed / watchers created during ) have been stopped. Use this hook to clean up manually created side effects such as timers, DOM event listeners or server connections. This hook is not called during server-side rendering.\n\nCalled when an error propagating from a descendant component has been captured.\nâ€¢ None Errors can be captured from the following sources: The hook receives three arguments: the error, the component instance that triggered the error, and an information string specifying the error source type. In production, the 3rd argument ( ) will be a shortened code instead of the full information string. You can find the code to string mapping in the Production Error Code Reference. You can modify component state in to display an error state to the user. However, it is important that the error state should not render the original content that caused the error; otherwise the component will be thrown into an infinite render loop. The hook can return to stop the error from propagating further. See error propagation details below.\nâ€¢ None By default, all errors are still sent to the application-level if it is defined, so that these errors can still be reported to an analytics service in a single place.\nâ€¢ None If multiple hooks exist on a component's inheritance chain or parent chain, all of them will be invoked on the same error, in the order of bottom to top. This is similar to the bubbling mechanism of native DOM events.\nâ€¢ None If the hook itself throws an error, both this error and the original captured error are sent to .\nâ€¢ None An hook can return to prevent the error from propagating further. This is essentially saying \"this error has been handled and should be ignored.\" It will prevent any additional hooks or from being invoked for this error.\nâ€¢ None In components with async function (with top-level ) Vue will always try to render component template, even if throwed error. This will likely cause more errors because during render component's template might try to access non-existing properties of failed context. When capturing errors in such components, be ready to handle errors from both failed async (they will always come first) and failed render process.\nâ€¢ None Replacing errored child component in parent component deep inside will cause hydration mismatches in SSR. Instead, try to separate logic that can possibly throw from child into separate function and execute it in the parent component's , where you can safely the execution process and make replacement if needed before rendering the actual child component.\n\nCalled when a reactive dependency has been tracked by the component's render effect.\n\nThis hook is development-mode-only and not called during server-side rendering.\nâ€¢ None See also Reactivity in Depth\n\nCalled when a reactive dependency triggers the component's render effect to be re-run.\n\nThis hook is development-mode-only and not called during server-side rendering.\nâ€¢ None See also Reactivity in Depth\n\nCalled after the component instance is inserted into the DOM as part of a tree cached by .\n\nThis hook is not called during server-side rendering.\nâ€¢ None See also Guide - Lifecycle of Cached Instance\n\nCalled after the component instance is removed from the DOM as part of a tree cached by .\n\nThis hook is not called during server-side rendering.\nâ€¢ None See also Guide - Lifecycle of Cached Instance\n\nAsync function to be resolved before the component instance is to be rendered on the server.\nâ€¢ None If the hook returns a Promise, the server renderer will wait until the Promise is resolved before rendering the component. This hook is only called during server-side rendering can be used to perform server-only data fetching.\nâ€¢ None // component is rendered as part of the initial request // pre-fetch data on server as it is faster than on the client // if data is null on mount, it means the component // is dynamically rendered on the client. Perform a"
    },
    {
        "link": "https://medium.com/@emperorbrains/exploring-vue-3-lifecycle-hooks-a-hands-on-guide-with-real-time-examples-cccff27f76d3",
        "document": "In the vast landscape of JavaScript frameworks, one name stands out as a favorite among developers â€” Vue.js, the framework that has captured the hearts of many with its simplicity and flexibility. And at the core of Vue.js lies a powerful feature: Lifecycle Hooks.\n\nLifecycle hooks in Vue.js provide developers with the ability to perform specific actions at crucial moments in a componentâ€™s existence. As a Vue component, essentially a view file in Vue.js, takes shape, it undergoes a sequence of essential initialization steps. These steps involve processes such as data observation, template compilation, mounting the instance to the DOM, and updating the DOM dynamically as the underlying data changes.\n\nEvery Vue component is, in essence, a Vue instance, and understanding how to leverage lifecycle hooks allows developers to tailor the componentâ€™s behavior at distinct stages of its lifecycle.\n\nIn this blog post, we will unravel the intricacies of Vue 3 lifecycle hooks, accompanied by a real-time example that will shed light on their practical application.\n\nTo add a touch of relatability to this exploration, letâ€™s draw a parallel between the workings of Vue 3 lifecycle hooks and Bobâ€™s morning routine. By comparing the meticulous steps Bob takes each morning with the meticulous treatment each lifecycle hook bestows upon our Vue component instances, we aim to demystify and simplify the understanding of these hooks.\n\nSo, buckle up as we dive deep into the world of Vue 3 lifecycle hooks and embark on a journey to comprehend how they sculpt the behavior of our Vue components.\n\nThe hook is a lifecycle hook in Vue.js that is triggered immediately when a component instance is initialized. This occurs after the resolution of props but before the execution of other lifecycle hooks such as or . This hook provides an early entry point to perform actions or setups before the component fully initializes.\n\nItâ€™s important to note that in the Composition API, specifically in the function, hooks are executed even before the hook. This means that any logic or operations defined in the function will run before the hook is triggered. Below is an example to illustrate this sequencing:\n\nIn this example, the code within the function is executed before the hook. This demonstrates the order of execution and emphasizes the role of in the component's lifecycle.\n\nThe hook is a lifecycle hook in Vue.js that is called after the component instance has finished processing all state-related options, including the and hooks. At this point, the component has been fully initialized, and reactive data, computed properties, and methods are available for use.\n\nThis hook is commonly used to perform actions that require access to the componentâ€™s state and configurations, making it a suitable place for additional setup, data fetching, or any logic that depends on the initialized state of the component.\n\nHereâ€™s an example illustrating the use of the hook:\n\nIn this example, the hook is used to log information about the reactive data and computed properties, as well as initiate a data fetching operation. This showcases how the hook can be employed for post-initialization tasks in a Vue.js component.\n\nThe hook is a lifecycle hook in Vue.js that is called right before the component is about to be mounted to the DOM. At this stage, the component has completed the setup of its reactive state, including data, computed properties, and methods. However, no DOM nodes associated with the component have been created yet. The hook provides an opportunity to perform actions or setup tasks just before the component's initial render.\n\nWhen the hook is triggered, the component is on the verge of executing its DOM render effect for the first time. This makes it a suitable point to make final adjustments or execute logic that needs to be performed prior to the component becoming visible in the DOM.\n\nHereâ€™s an example demonstrating the use of the hook:\n\nIn this example, the hook is used to log information about the reactive data and to initialize a chart library just before the component is mounted. This illustrates the role of the hook in facilitating pre-mount setup tasks.\n\nThe hook is a lifecycle hook in Vue.js that is called after the component or instance has been successfully mounted to the DOM. At this stage, the component's template has been rendered, and its associated DOM elements are now part of the document. The hook is commonly used for performing side effects, initialization tasks, or any operations that require access to the component's rendered DOM.\n\n1. DOM Accessibility: Since the hook is called after the component is attached to the DOM, it provides a suitable point for accessing and manipulating the DOM elements associated with the component.\n\n2 . Initialization Tasks: It is often used to trigger actions that should occur once the component is fully visible in the document. This includes setting up event listeners, fetching additional data, or initializing third-party libraries.\n\nHereâ€™s an example illustrating the use of the hook:\n\nIn this example, the hook is utilized to access the DOM elements after the component has been mounted and to set up an event listener on a button. This demonstrates how the hook is commonly used for tasks that require interaction with the rendered DOM.\n\nThe hook is a lifecycle hook in Vue.js that is called right before the component is about to update its DOM tree due to a reactive state change. It provides a useful opportunity to access and modify the component's state or the DOM state before the actual update takes place.\nâ€¢ DOM State Access: This hook allows you to access both the componentâ€™s state and the DOM state just before Vue updates the DOM. It is particularly useful for making modifications or performing actions that should occur before the visual representation of the component is updated.\nâ€¢ Safe State Modification: Unlike some lifecycle hooks, it is safe to modify the componentâ€™s state within the hook. This makes it a suitable place to adjust data or perform calculations based on the current state before the update.\nâ€¢ Conditional Updates: Use cases include conditional updates, where certain modifications to the DOM or component state need to happen based on specific conditions before the update is applied.\n\nHereâ€™s an example demonstrating the use of the hook:\n\nIn this example, the hook is used to access and modify the image width before the component updates. This demonstrates how the hook can be valuable for scenarios where pre-update adjustments are necessary.\n\nThe hook is a lifecycle hook in Vue.js that is called after the component has successfully updated its DOM tree due to a reactive state change. It signals that the component's state and the corresponding DOM elements have been synchronized.\nâ€¢ DOM Synchronization: This hook is triggered after any DOM update caused by reactive state changes in the component. It provides confirmation that the componentâ€™s template has been re-rendered to reflect the updated state.\nâ€¢ No Information on Cause: While the hook informs you that an update has occurred, it doesn't provide specific details about what caused the update. For understanding the cause of changes, watchers are more appropriate.\nâ€¢ Caution on DOM Updates: It is generally not recommended to perform direct DOM updates within the hook, as this hook can be triggered multiple times during the component's lifecycle. For DOM manipulations, it's often more appropriate to use other lifecycle hooks or directives.\n\nHereâ€™s an example illustrating the use of the hook:\n\nIn this example, the hook is utilized to log a message indicating that the component has been updated. It emphasizes the caution against performing direct DOM updates inside this hook, redirecting such operations to more appropriate lifecycle hooks or directives.\n\nThe hook is a lifecycle hook in Vue.js that is called right before a component instance is about to be unmounted, providing an opportunity for cleanup tasks before the component is destroyed.\nâ€¢ Cleanup Operations: This hook is particularly useful for performing cleanup operations, such as clearing intervals, deregistering event listeners, or releasing resources, before the component is permanently removed from the DOM.\nâ€¢ Replacement for Vue 2â€™s : In Vue 2, the equivalent hook was named . In Vue 3, the naming was changed to to better align with the updated component lifecycle terminology.\n\nHereâ€™s an example demonstrating the use of the hook:\n\nIn this example, the hook is used to clean up resources (clearing an interval) before the component is unmounted. This illustrates the importance of this hook in managing cleanup tasks just before the component is removed from the DOM.\n\nThe hook is the final lifecycle hook in Vue.js, called after the component has been successfully unmounted and destroyed. At this stage, the component's DOM elements have been removed, and any resources or event listeners associated with the component should be released.\nâ€¢ Final Cleanup: The hook provides a final opportunity for cleanup operations that should be performed after the component is no longer part of the DOM. This is the last stop in the component's lifecycle.\nâ€¢ No Access to Component State: Itâ€™s important to note that variables or state initialized within the component are not accessible within the hook. Any resources or data specific to the component should be handled and cleaned up in earlier hooks, such as .\n\nHereâ€™s an example illustrating the use of the hook:\n\nIn this example, the hook is used to log a message indicating that the component has been successfully unmounted. The cleanup operations are handled in the hook, emphasizing the separation of concerns between cleanup and the final acknowledgment of unmounting.\n\nEmperor Brains stands as a beacon of innovation and expertise in the realm of technology solutions. Through a deep dive into the intricacies of Vue.js 3 lifecycle hooks, weâ€™ve demonstrated not only a commitment to understanding cutting-edge technologies but also a dedication to simplifying complex concepts for developers.\n\nEmperor Brains recognizes the pivotal role that Vue.js lifecycle hooks play in shaping dynamic and responsive web applications. Our exploration, coupled with real-time examples, serves as a testament to our mission of empowering developers with practical insights and knowledge.\n\nAs a technology-focused company, Emperor Brains encourages developers to harness the potential of Vue.js and its lifecycle hooks for efficient and tailored web development. We take pride in our ability to bridge the gap between intricate technical details and real-world applications.\n\nFor more information, resources, and to explore how Emperor Brains can elevate your technological endeavors, visit our website at Emperor Brains At Emperor Brains, we are not just navigating the tech landscape; we are shaping it, pushing boundaries, and redefining what is possible. Join us in this journey of innovation and discover the limitless possibilities that technology holds under the guidance of Emperor Brains."
    },
    {
        "link": "https://dev.to/sucodelarangela/vue3-components-lifecycle-en-10e",
        "document": "If you have recently started learning about a framework or Front-End library, you may have already come across the term \"lifecycle\" of a component and may have wondered what exactly it means.\n\nIn this article, we will understand the main lifecycle methods that Vue.js offers us and their implementations with Options API and Composition API!\n\nIn Vue, each component goes through several steps: basically, it is created, it observes data, it mounts its elements in the and updates them when any data is modified until, eventually, it is destroyed. Throughout this process, the component uses several functions called lifecycle methods or lifecycle hooks.\n\nThe lifecycle hooks are predefined methods that are executed at specific times during the useful life of a component, i.e. the period of time in which a component exists, is active and performs its functions in an application or software system.\n\nThese methods can also be used by us, developers, and allow us to control the component's behavior, perform operations at specific times and interact with the DOM or other components.\n\nWith the Options API we have access to eight main lifecycle methods (which we will call hooks from here on): , , , , , , and .\n\nThe moment at which each hook is executed in the component instance is demonstrated by the diagram below, taken from the official Vue.js documentation:\n\nTo facilitate the study of this article, we'll categorize them into groups: creation, mounting, update, and unmounting hooks.\n\nThe creation hooks are the first hooks to run in a component. They allow you to perform actions before your component is added to the DOM and are also the only ones that work with server-side rendering.\n\nHere we will learn about the hooks beforeCreate and created.\n\nis executed as soon as a component is initialized. At this time, computed states and properties have not yet been processed.\n\n\n\nIn the code above, is executed before the component is rendered.\n\nThis hook is very useful, for example, to make an authentication request. Depending on the result of the request, the global state (Vuex or Pinia) is configured accordingly, allowing you to handle authentication before any content is displayed on the screen.\n\nis also executed before the component is mounted in the DOM, however, at this stage all states, computed properties, methods and watchers have already been processed and are ready to be accessed.\n\n\n\nIn the code above, is executed before the component is rendered, but we already have access to the property processed in our .\n\nThis is a very useful hook to make a request to an and update the component state with these data, which will be rendered in the DOM.\n\nMounting hooks allow you to access the component immediately before or after inserting the component into the DOM (first render), typically to access or modify elements.\n\nHere we will learn about the hooks beforeMount and mounted.\n\nis very similar to , with the key distinction lying in the timing of their execution::\nâ€¢ is triggered after component creation and allows access to data options, but before the DOM is mounted;\nâ€¢ is triggered immediately before mounting the DOM, right after a pre-compilation of the component's and .\n\nIn the code above, we simulate an API call that takes two seconds to update the page title. The same effect would be achieved using .\n\nis executed immediately after the component is mounted. At this stage, the component becomes functional: properties from are injected into the template, elements are rendered, and DOM manipulation becomes possible.\n\n\n\nIn the example above, we created a dynamic list in the template, but the click events for each in the list were only inserted after the component's hook is executed.\n\nUpdate hooks are executed whenever a reactive property used in your component changes , forcing it to re-render. This execution can be immediately before or after this change.\n\nHere we will learn about the hooks beforeUpdate and updated.\n\nruns immediately after a reactive property is changed, but immediately before the component is re-rendered on screen.\n\n\n\nIn the code above, for example, whenever is updated, we will save its new value in the array before this data is updated on screen. is also widely used for debugging operations to identify when component rendering is activated, for example.\n\nis executed immediately after a re-render of the component caused by a reactive data change, being very useful for creating side effects related to the DOM.\n\n\n\nIn the code above, whenever a new item is added to the list using the method, the component is updated, and the hook is called. Inside the hook, we implement an auto-scroll functionality so that the list scrolls to the last item whenever new items are added to the list.\n\nUnmounting hooks, also called destruction hooks (a bit dramatic, right?) are executed immediately before or after a component is unmounted.\n\nHere we will learn about the hooks beforeUnmount and unmounted.\n\nis executed immediately before the component is unmounted. Importantly, at this point the component is still fully functional, so it's a great step to perform clean up functions such as removing event listeners, deleting variables, performing logout actions, etc.\n\n\n\nIn this example, the component creates a WebSocket connection when it is mounted and adds a listener for WebSocket messages. In , it checks if this connection is open ( ) and, if so, closes the connection using . This ensures that the connection is properly closed before the component is destroyed, preventing resource leaks and unexpected behavior.\n\nhappens immediately after the component is unmounted from the DOM tree, so practically everything that existed in relation to that component is considered \"destroyed\", as emphasized by the documentation itself:\n\nWe can conclude that, at this stage, there is not much that can be done to a component. In general, is also used for clean up functions.\n\nThe Composition API, which represents the latest syntax for a Vue component, has introduced alterations to the lifecycle methods. The most noticeable changes include the removal of the hooks beforeCreate and created, along with subtle modifications to their names and syntax.\n\nThese changes came to boost the performance of our Vue application, in addition to providing better compatibility with TypeScript. All of this was possible thanks to the new hook .\n\nLet's understand a bit more about this.\n\nThe hook in Vue 3 is an essential part of the Composition API, which is a more flexible, functional, and modular approach to creating components compared to the Vue 2 syntax. It is used to configure and initialize the state, props, methods and other options of a Vue component.\n\nHowever, despite being a feature of the Composition API, it is entirely possible to use within the Options API as a facilitator for your code. See what the hook syntax looks like in both cases:\n\n\n\nIf we go back to the lifecycle diagram we saw at the beginning of this article, we can see that is the first creation method executed in a Vue component. It occurs even before beforeCreate and created are executed!\n\nThis way, any code that could be used within these hooks can simply be inserted into . Do you remember the API request simulation we exemplified earlier? See how it would look using :\n\n\n\nWith the code above, we will have the same effect as with !\n\nAlthough we no longer have beforeCreate and created, the other hooks are still present in the Composition API, but with a slightly different syntax from what we have seen earlier, as we will now be calling each of them within .\n\nIt is important to keep in mind that the moment of execution for each of these hooks within the component remains the same! Therefore, we will focus here only on their syntax, starting with the change in names, which are now: , , , , and .\n\nTo grasp the new syntax more effectively, it's essential to recognize that within the Composition API, every hook works as a function that takes a callback function as its parameter. For example, here is the typing:\n\n\n\nBased on this, we can use our hooks in the following ways:\n\n\n\nLetâ€™s understand the subtle differences between each of them:\n\nThis way, you are directly passing the function as an argument to . The function will be called directly when is executed. This is useful when the function does not need additional arguments.\n\nHere you wrap the call in an anonymous callback function. The callback function will be executed when is triggered and then it will call . This method is useful when you need to pass arguments to .\n\nThis way is similar to Method 2, but you are using an anonymous callback function with a block of code enclosed in curly braces . This is useful when you need to perform multiple actions or logic within in addition to calling .\n\nThe main difference between methods 2 and 3 is that Method 3 allows you to include multiple lines of code and perform multiple actions within . Method 2 is more concise and direct, while Method 3 is more expandable when you need more complexity.\n\nThe above syntax can be used with any Composition API hook, not just . Furthermore, you can use the same lifecycle hook multiple times within a single component! Also note that for the hooks you intend to utilize in your component, it's crucial to import them within the :\n\n\n\nThis is another particularity of the Composition API: by importing from the API only what is necessary for each component, we improve the performance of our application, unlike what happens in the Options API, where the entire API is already completely imported into the components behind the scenes.\n\nIn this article, we delved into the different lifecycle methods provided by Vue.JS and explored how they can enhance our applications.\n\nI trust you found the information enjoyable and that it added to your understanding of Vue. Until next time!"
    },
    {
        "link": "https://stackoverflow.com/questions/53572459/how-can-i-generate-unique-ids-in-vue-js-from-attributes-in-a-json-file",
        "document": "I am using Vue.js to generate divs and I would like to use data from a JSON file to do so.\n\nIt doesn't necessarily have to be from the JSON but that would be preferable, I just need to create a unique id for each instance of the div in the html below.\n\nWhat is the best way to create unique ID's for each of the divs?"
    },
    {
        "link": "https://reddit.com/r/vuejs/comments/muihtf/how_to_create_persisting_unique_ids_for_components",
        "document": "So I do know how to generate UUIDs or simple counters so that I can give each component in my app (using Vue JS plus TypeScript) a unique ID. The problem is however, that if I define the logic within the component, it will always change with each reload, even though the components are the same.\n\nI want IDs that will still persist after a reload of the webpage. How would that be possible? Any help is much appreciated, thanks! :D"
    },
    {
        "link": "https://stackoverflow.com/questions/34950867/how-to-set-a-unique-id-for-each-component-instance",
        "document": "How can I set a unique ID for each component instance?\n\nI want to create a component with Vue.js containing a label and an input . For example :\n\nEach component has a unique id which can be accessed as . If you want more control over the ids you can for example, generate them inside a parent component.\n\nEvan You has advised against using _uid: The vm _uid is reserved for internal use and it's important to keep it private (and not rely on it in user code) so that we keep the flexibility to change its behavior for potential future use cases. ... I'd suggest generating UIDs yourself [using a module, a global mixin, etc.] Using the suggested mixin in this GitHub issue to generate the UID seems like a better approach:\n\nI published the vue-unique-id Vue plugin for this on npm. None of the other solutions address the requirement of having more than one form element in your component. Here's my take on a plugin that builds on previously given answers: Vue.use((Vue) => { // Assign a unique id to each component let uidCounter = 0; Vue.mixin({ beforeCreate: function() { this.uidCounter = uidCounter.toString(); uidCounter += 1; }, }); // Generate a component-scoped id Vue.prototype.$id = function(id) { return \"uid-\" + this.uidCounter + \"-\" + id; }; }); This doesn't rely on the internal property which is reserved for internal use. Use it like this in your component: To produce something like this:\n\nUpdate: Code will throw an error if property does not exist in the instance so that you can update it to use something custom or new unique id property if provided by Vue. Although zxzak's answer is great; is not a published api property. To save a headache in case it changes in the future, you can update your code with just one change with a plugin solution like below. Vue.use({ install: function(Vue, options) { Object.defineProperty(Vue.prototype, \"uniqId\", { get: function uniqId() { if ('_uid' in this) { return this._uid; } throw new Error(\"_uid property does not exist\"); } }); } });\n\nThe simplest way I found was to create a UUID ( ) manually through a global mixin. That way you won't rely on anything that can potentially change or become deprecated in the future like . You first have to install the package: Then, in your file create a global mixin: // rest of imports import { v4 as uuidv4 } from 'uuid'; const app = Vue.createApp(App); app.mixin({ data() { return { componentId: uuidv4() } }, }); app.use(store).use(router).mount('#app'); And here is how you can us it in a component:\n\nThis package seems to be a good solution for the underlying issue of having non-unique IDs in your DOM across multiple components: It is a trend to use components. Components are cool, they are small, obvious, easy to use and modular. Untill it comes to the id property. Some HTML tag attributes requires using an id property, like label[for], input[form] and many of aria-* attributes. And the problem with the id is that it is not modular. If several id properties on the page will has the same value they can affect each other. VueUniqIds helps you to get rid of this problem. It provides the set of id-related directives which value is automatically modified by adding unique string while keeping the attrbitue easy to read."
    },
    {
        "link": "https://geeksforgeeks.org/how-to-set-a-unique-id-for-each-component-instance-in-vuejs",
        "document": "How to Set a Unique ID for Each Component Instance in VueJS ?\n\nIn Vue.js we can assign the unique ID to each of the component instances for properly managing the components in the application. In this article, we will see the different approaches to setting the unique ID for each component instance in VueJS.\n\nThese are the following approaches:\n\nIn this approach, we are using the _uid property which is used to automatically assign to each component instance. This is like a unique identifier. By accessing the value of this._id in the mounted hook of the component, we can set the unique ID for each instance.\n\nExample: Below is the implementation of the above-discussed approach.\n\nIn this approach, we are using the global mixin to generate unqiueIDs with custom prefixes and length. We have applied the mixin globally to all the components and each time when the Add Component button is clicked, a new instance of the component is created with the unique ID generated by the idFn method.\n\nExample: Below is the implementation of the above-discussed approach."
    },
    {
        "link": "https://javascript.plainenglish.io/unlocking-the-power-of-vue-js-3-5-mastering-the-useid-api-631e93190feb",
        "document": "Unlocking the Power of Vue.js 3.5: Mastering the useId API ðŸ”‘\n\nIn the ever-evolving world of front-end development, Vue.js has long been celebrated for its simplicity and efficiency. With the release of Vue 3.5, a new API has quietly joined this powerful framework: . This seemingly simple function packs a punch, offering developers unprecedented convenience in handling list rendering, form elements, and accessibility attributes.\n\nIn this article, weâ€™ll dive deep into the inner workings of , explore its practical applications, and discover how it can help us build more robust and maintainable web applications. ðŸš€\n\nThe Birth and Mission of useId ðŸŒ±\n\nThe introduction of the function in Vue 3.5 marks a significant stride in Vue's journey towards enhanced componentization and accessibility. Its primary mission? To generate unique IDs, ensuring that each element within a Vue application has a distinct identifier. This is crucial for improving application accessibility and reducing potential errors in DOM manipulation."
    }
]