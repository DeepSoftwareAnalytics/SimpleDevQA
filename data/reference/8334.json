[
    {
        "link": "https://legacy.reactjs.org/docs/hooks-effect.html",
        "document": "Hooks are a new addition in React 16.8. They let you use state and other React features without writing a class.\n\nThe Effect Hook lets you perform side effects in function components:\n\nThis snippet is based on the counter example from the previous page, but we added a new feature to it: we set the document title to a custom message including the number of clicks.\n\nData fetching, setting up a subscription, and manually changing the DOM in React components are all examples of side effects. Whether or not you‚Äôre used to calling these operations ‚Äúside effects‚Äù (or just ‚Äúeffects‚Äù), you‚Äôve likely performed them in your components before.\n\nThere are two common kinds of side effects in React components: those that don‚Äôt require cleanup, and those that do. Let‚Äôs look at this distinction in more detail.\n\nSometimes, we want to run some additional code after React has updated the DOM. Network requests, manual DOM mutations, and logging are common examples of effects that don‚Äôt require a cleanup. We say that because we can run them and immediately forget about them. Let‚Äôs compare how classes and Hooks let us express such side effects.\n\nIn React class components, the method itself shouldn‚Äôt cause side effects. It would be too early ‚Äî we typically want to perform our effects after React has updated the DOM.\n\nThis is why in React classes, we put side effects into and . Coming back to our example, here is a React counter class component that updates the document title right after React makes changes to the DOM:\n\nNote how we have to duplicate the code between these two lifecycle methods in class.\n\nThis is because in many cases we want to perform the same side effect regardless of whether the component just mounted, or if it has been updated. Conceptually, we want it to happen after every render ‚Äî but React class components don‚Äôt have a method like this. We could extract a separate method but we would still have to call it in two places.\n\nNow let‚Äôs see how we can do the same with the Hook.\n\nWe‚Äôve already seen this example at the top of this page, but let‚Äôs take a closer look at it:\n\nWhat does do? By using this Hook, you tell React that your component needs to do something after render. React will remember the function you passed (we‚Äôll refer to it as our ‚Äúeffect‚Äù), and call it later after performing the DOM updates. In this effect, we set the document title, but we could also perform data fetching or call some other imperative API.\n\nWhy is called inside a component? Placing inside the component lets us access the state variable (or any props) right from the effect. We don‚Äôt need a special API to read it ‚Äî it‚Äôs already in the function scope. Hooks embrace JavaScript closures and avoid introducing React-specific APIs where JavaScript already provides a solution.\n\nDoes run after every render? Yes! By default, it runs both after the first render and after every update. (We will later talk about how to customize this.) Instead of thinking in terms of ‚Äúmounting‚Äù and ‚Äúupdating‚Äù, you might find it easier to think that effects happen ‚Äúafter render‚Äù. React guarantees the DOM has been updated by the time it runs the effects.\n\nNow that we know more about effects, these lines should make sense:\n\nWe declare the state variable, and then we tell React we need to use an effect. We pass a function to the Hook. This function we pass is our effect. Inside our effect, we set the document title using the browser API. We can read the latest inside the effect because it‚Äôs in the scope of our function. When React renders our component, it will remember the effect we used, and then run our effect after updating the DOM. This happens for every render, including the first one.\n\nExperienced JavaScript developers might notice that the function passed to is going to be different on every render. This is intentional. In fact, this is what lets us read the value from inside the effect without worrying about it getting stale. Every time we re-render, we schedule a different effect, replacing the previous one. In a way, this makes the effects behave more like a part of the render result ‚Äî each effect ‚Äúbelongs‚Äù to a particular render. We will see more clearly why this is useful later on this page.\n\nEarlier, we looked at how to express side effects that don‚Äôt require any cleanup. However, some effects do. For example, we might want to set up a subscription to some external data source. In that case, it is important to clean up so that we don‚Äôt introduce a memory leak! Let‚Äôs compare how we can do it with classes and with Hooks.\n\nIn a React class, you would typically set up a subscription in , and clean it up in . For example, let‚Äôs say we have a module that lets us subscribe to a friend‚Äôs online status. Here‚Äôs how we might subscribe and display that status using a class:\n\nNotice how and need to mirror each other. Lifecycle methods force us to split this logic even though conceptually code in both of them is related to the same effect.\n\nLet‚Äôs see how we could write this component with Hooks.\n\nYou might be thinking that we‚Äôd need a separate effect to perform the cleanup. But code for adding and removing a subscription is so tightly related that is designed to keep it together. If your effect returns a function, React will run it when it is time to clean up:\n\nWhy did we return a function from our effect? This is the optional cleanup mechanism for effects. Every effect may return a function that cleans up after it. This lets us keep the logic for adding and removing subscriptions close to each other. They‚Äôre part of the same effect!\n\nWhen exactly does React clean up an effect? React performs the cleanup when the component unmounts. However, as we learned earlier, effects run for every render and not just once. This is why React also cleans up effects from the previous render before running the effects next time. We‚Äôll discuss why this helps avoid bugs and how to opt out of this behavior in case it creates performance issues later below.\n\nWe‚Äôve learned that lets us express different kinds of side effects after a component renders. Some effects might require cleanup so they return a function:\n\nOther effects might not have a cleanup phase, and don‚Äôt return anything.\n\nThe Effect Hook unifies both use cases with a single API.\n\nIf you feel like you have a decent grasp on how the Effect Hook works, or if you feel overwhelmed, you can jump to the next page about Rules of Hooks now.\n\nWe‚Äôll continue this page with an in-depth look at some aspects of that experienced React users will likely be curious about. Don‚Äôt feel obligated to dig into them now. You can always come back to this page to learn more details about the Effect Hook.\n\nOne of the problems we outlined in the Motivation for Hooks is that class lifecycle methods often contain unrelated logic, but related logic gets broken up into several methods. Here is a component that combines the counter and the friend status indicator logic from the previous examples:\n\nNote how the logic that sets is split between and . The subscription logic is also spread between and . And contains code for both tasks.\n\nSo, how can Hooks solve this problem? Just like you can use the State Hook more than once, you can also use several effects. This lets us separate unrelated logic into different effects:\n\nHooks let us split the code based on what it is doing rather than a lifecycle method name. React will apply every effect used by the component, in the order they were specified.\n\nIf you‚Äôre used to classes, you might be wondering why the effect cleanup phase happens after every re-render, and not just once during unmounting. Let‚Äôs look at a practical example to see why this design helps us create components with fewer bugs.\n\nEarlier on this page, we introduced an example component that displays whether a friend is online or not. Our class reads from , subscribes to the friend status after the component mounts, and unsubscribes during unmounting:\n\nBut what happens if the prop changes while the component is on the screen? Our component would continue displaying the online status of a different friend. This is a bug. We would also cause a memory leak or crash when unmounting since the unsubscribe call would use the wrong friend ID.\n\nIn a class component, we would need to add to handle this case:\n\nForgetting to handle properly is a common source of bugs in React applications.\n\nNow consider the version of this component that uses Hooks:\n\nIt doesn‚Äôt suffer from this bug. (But we also didn‚Äôt make any changes to it.)\n\nThere is no special code for handling updates because handles them by default. It cleans up the previous effects before applying the next effects. To illustrate this, here is a sequence of subscribe and unsubscribe calls that this component could produce over time:\n\nThis behavior ensures consistency by default and prevents bugs that are common in class components due to missing update logic.\n\nIn some cases, cleaning up or applying the effect after every render might create a performance problem. In class components, we can solve this by writing an extra comparison with or inside :\n\nThis requirement is common enough that it is built into the Hook API. You can tell React to skip applying an effect if certain values haven‚Äôt changed between re-renders. To do so, pass an array as an optional second argument to :\n\nIn the example above, we pass as the second argument. What does this mean? If the is , and then our component re-renders with still equal to , React will compare from the previous render and from the next render. Because all items in the array are the same ( ), React would skip the effect. That‚Äôs our optimization.\n\nWhen we render with updated to , React will compare the items in the array from the previous render to items in the array from the next render. This time, React will re-apply the effect because . If there are multiple items in the array, React will re-run the effect even if just one of them is different.\n\nThis also works for effects that have a cleanup phase:\n\nIn the future, the second argument might get added automatically by a build-time transformation.\n\nCongratulations! This was a long page, but hopefully by the end most of your questions about effects were answered. You‚Äôve learned both the State Hook and the Effect Hook, and there is a lot you can do with both of them combined. They cover most of the use cases for classes ‚Äî and where they don‚Äôt, you might find the additional Hooks helpful.\n\nWe‚Äôre also starting to see how Hooks solve problems outlined in Motivation. We‚Äôve seen how effect cleanup avoids duplication in and , brings related code closer together, and helps us avoid bugs. We‚Äôve also seen how we can separate effects by their purpose, which is something we couldn‚Äôt do in classes at all.\n\nAt this point you might be questioning how Hooks work. How can React know which call corresponds to which state variable between re-renders? How does React ‚Äúmatch up‚Äù previous and next effects on every update? On the next page we will learn about the Rules of Hooks ‚Äî they‚Äôre essential to making Hooks work."
    },
    {
        "link": "https://react.dev/reference/react/useEffect",
        "document": "In this example, a cleanup function is not needed because the class manages only the DOM node that was passed to it. After the React component is removed from the tree, both the DOM node and the class instance will be automatically garbage-collected by the browser JavaScript engine. You can use an Effect to fetch data for your component. Note that if you use a framework, using your framework‚Äôs data fetching mechanism will be a lot more efficient than writing Effects manually. If you want to fetch data from an Effect manually, your code might look like this: Note the variable which is initialized to , and is set to during cleanup. This ensures your code doesn‚Äôt suffer from ‚Äúrace conditions‚Äù: network responses may arrive in a different order than you sent them.\n\nWriting data fetching directly in Effects gets repetitive and makes it difficult to add optimizations like caching and server rendering later. It‚Äôs easier to use a custom Hook‚Äîeither your own or maintained by the community. What are good alternatives to data fetching in Effects? Writing calls inside Effects is a popular way to fetch data, especially in fully client-side apps. This is, however, a very manual approach and it has significant downsides:\n‚Ä¢ Effects don‚Äôt run on the server. This means that the initial server-rendered HTML will only include a loading state with no data. The client computer will have to download all JavaScript and render your app only to discover that now it needs to load the data. This is not very efficient.\n‚Ä¢ Fetching directly in Effects makes it easy to create ‚Äúnetwork waterfalls‚Äù. You render the parent component, it fetches some data, renders the child components, and then they start fetching their data. If the network is not very fast, this is significantly slower than fetching all data in parallel.\n‚Ä¢ Fetching directly in Effects usually means you don‚Äôt preload or cache data. For example, if the component unmounts and then mounts again, it would have to fetch the data again.\n‚Ä¢ It‚Äôs not very ergonomic. There‚Äôs quite a bit of boilerplate code involved when writing calls in a way that doesn‚Äôt suffer from bugs like race conditions. This list of downsides is not specific to React. It applies to fetching data on mount with any library. Like with routing, data fetching is not trivial to do well, so we recommend the following approaches:\n‚Ä¢ If you use a framework, use its built-in data fetching mechanism. Modern React frameworks have integrated data fetching mechanisms that are efficient and don‚Äôt suffer from the above pitfalls.\n‚Ä¢ Otherwise, consider using or building a client-side cache. Popular open source solutions include React Query, useSWR, and React Router 6.4+. You can build your own solution too, in which case you would use Effects under the hood but also add logic for deduplicating requests, caching responses, and avoiding network waterfalls (by preloading data or hoisting data requirements to routes). You can continue fetching data directly in Effects if neither of these approaches suit you. Notice that you can‚Äôt ‚Äúchoose‚Äù the dependencies of your Effect. Every reactive value used by your Effect‚Äôs code must be declared as a dependency. Your Effect‚Äôs dependency list is determined by the surrounding code: If either or change, your Effect will reconnect to the chat using the new values. Reactive values include props and all variables and functions declared directly inside of your component. Since and are reactive values, you can‚Äôt remove them from the dependencies. If you try to omit them and your linter is correctly configured for React, the linter will flag this as a mistake you need to fix: To remove a dependency, you need to ‚Äúprove‚Äù to the linter that it doesn‚Äôt need to be a dependency. For example, you can move out of your component to prove that it‚Äôs not reactive and won‚Äôt change on re-renders: Now that is not a reactive value (and can‚Äôt change on a re-render), it doesn‚Äôt need to be a dependency. If your Effect‚Äôs code doesn‚Äôt use any reactive values, its dependency list should be empty ( ): An Effect with empty dependencies doesn‚Äôt re-run when any of your component‚Äôs props or state change. If you have an existing codebase, you might have some Effects that suppress the linter like this: When dependencies don‚Äôt match the code, there is a high risk of introducing bugs. By suppressing the linter, you ‚Äúlie‚Äù to React about the values your Effect depends on. Instead, prove they‚Äôre unnecessary.\n\nNow that you create the object inside the Effect, the Effect itself only depends on the string. With this fix, typing into the input doesn‚Äôt reconnect the chat. Unlike an object which gets re-created, a string like doesn‚Äôt change unless you set it to another value. Read more about removing dependencies. If your Effect depends on an object or a function created during rendering, it might run too often. For example, this Effect re-connects after every render because the function is different for every render: By itself, creating a function from scratch on every re-render is not a problem. You don‚Äôt need to optimize that. However, if you use it as a dependency of your Effect, it will cause your Effect to re-run after every re-render. Avoid using a function created during rendering as a dependency. Instead, declare it inside the Effect:"
    },
    {
        "link": "https://w3schools.com/react/react_useeffect.asp",
        "document": "The Hook allows you to perform side effects in your components.\n\nSome examples of side effects are: fetching data, directly updating the DOM, and timers.\n\naccepts two arguments. The second argument is optional.\n\nLet's use a timer as an example.\n\nBut wait!! It keeps counting even though it should only count once!\n\nruns on every render. That means that when the count changes, a render happens, which then triggers another effect.\n\nThis is not what we want. There are several ways to control when side effects run.\n\nWe should always include the second parameter which accepts an array. We can optionally pass dependencies to in this array.\n\nSo, to fix this issue, let's only run this effect on the initial render.\n\nHere is an example of a Hook that is dependent on a variable. If the variable updates, the effect will run again: import { useState, useEffect } from \"react\"; import ReactDOM from \"react-dom/client\"; function Counter() { const [count, setCount] = useState(0); const [calculation, setCalculation] = useState(0); useEffect(() => { setCalculation(() => count * 2); }, [count]); // <- add the count variable here return ( <> <p>Count: {count}</p> <button onClick={() => setCount((c) => c + 1)}>+</button> <p>Calculation: {calculation}</p> </> ); } const root = ReactDOM.createRoot(document.getElementById('root')); root.render(<Counter />);\n\nIf there are multiple dependencies, they should be included in the dependency array.\n\nTimeouts, subscriptions, event listeners, and other effects that are no longer needed should be disposed.\n\nWe do this by including a return function at the end of the Hook."
    },
    {
        "link": "https://devonblog.com/frontend/reactjs/mastering-side-effects-in-functional-components-with-reacts-useeffect-hook",
        "document": "Welcome to another blog on React Hooks. In this article, we will discuss about which is used for handling side effects in functional components\n\nWhat are the Side Effects?\n\nIn React, a side effect is any operation that interacts with the world outside the confines of a React component. This includes actions that can alter the state of the application, interact with the browser, or perform asynchronous tasks. Here are some common examples:\n‚Ä¢ API Calls: Fetching or sending data to an external server. These actions are asynchronous and not part of React‚Äôs internal state management or rendering process, making them side effects.\n‚Ä¢ Direct DOM Manipulations: Directly manipulating the DOM using JavaScript, such as changing an element‚Äôs style or attributes with methods like . These actions bypass React‚Äôs virtual DOM, which is designed to efficiently update the web page.\n‚Ä¢ Timers: Implementing delays or repeated actions with or . These functions schedule future changes that are executed outside the usual flow of React‚Äôs component rendering, thus constituting side effects.\n‚Ä¢ Subscriptions: Establishing connections to external data sources, such as setting up web sockets or subscribing to data streams with observables. These connections persist beyond the lifecycle of individual renders and need to be managed to prevent issues like memory leaks.\n\nAs discussed above is a special function provided by React that allows us to handle side effects that happen beyond the React component and helps us to synchronize with external systems.\n\nLet‚Äôs look at the syntax\n‚Ä¢ \n‚Ä¢ \n‚Ä¢ \n‚Ä¢ This is the function where you put the code that has side effects.\n‚Ä¢ The function can optionally return another function, known as the cleanup function, which is used to clean up the side effects (like removing event listeners, canceling subscriptions, or clearing timers) before the effect runs again.\n‚Ä¢ \n‚Ä¢ \n‚Ä¢ \n‚Ä¢ This is an optional array that determines when the should run.\n‚Ä¢ The will run after every render by default if no dependency array is provided.\n‚Ä¢ If an empty array is provided, the will run only once after the initial render, mimicking the behavior of in-class components.\n‚Ä¢ If you include values (usually props or state) in the array, the will run after the initial render and then after every render where the included dependencies have changed since the last render.\n\nLet‚Äôs review a simple counter application in which we increment a state on button click, and log the current count in a state, which updates on every component render.\n\nDefault: In this example, the console.log(‚ÄúRender‚Äù) and setLog(`Current count is ${count}`) will display output on every button click as the state changes and the component is re-rendered.\n\n\n\n Empty Array ([]): In this example, the console.log(‚ÄúRender‚Äù) and setLog(Current count is ${count}) will display output only on the initial render, regardless of the number of times the button is clicked.\n\nWith Values: In this example, the console.log(‚ÄúRender‚Äù) and setLog(Button is clicked ${count} time(s)) will display output whenever the state is updated for the count and vehicleManufacturer.\n\nMultiple useEffect in a Component: When it comes to managing side effects in React components, multiple hooks are your secret weapon. Not only do they keep your code clean and organized, but they also give you ninja-level control over the dependencies.\n\nA simple example would be to showcase a product and its stock at regular intervals; in this case, we would separate the effects for handling the API call to get the product details and for showcasing the stock.\n\nCleanup functions are essential for preventing memory leaks and unwanted behavior when components unmount, which typically occurs when they are removed from the DOM due to various scenarios such as state changes, navigation, or routing.\n\nThe cleanup function is executed before the component unmounts and after the effect runs, including after the initial render.\n\nExample of cleanup function for removing event listener.\n\nis typically used directly inside a functional component, however, if we find ourselves repeating the same logic in multiple components we can consider creating a custom hook that encapsulates the logic. This helps us make the code more modular and easier to maintain.\n\nLet‚Äôs take the basic counter-example we showcased previously, which involves dependent arrays, and demonstrate how to transform it into a custom hook for utilization.\n\nIn this article, we‚Äôve explored the hook, an essential tool for managing side effects in React‚Äôs functional components. We examined the basic syntax and various dependencies with practical examples and discussed the common mistakes that can occur when adding dependencies. We also covered the concepts of cleanup functions and with custom hooks.\n\nis a pivotal tool used in the React ecosystem, alongside . As we continue our series on React hooks, remember that each hook offers distinct benefits that enhance the capabilities of your React applications. Stay tuned for further explorations of React hooks, which will equip you with the knowledge to build more dynamic and robust applications. Keep learning and experimenting ‚Äî your journey through React‚Äôs capabilities is just beginning. Happy coding!"
    },
    {
        "link": "https://legacy.reactjs.org/docs/hooks-overview.html",
        "document": "Hooks are a new addition in React 16.8. They let you use state and other React features without writing a class.\n\nHooks are backwards-compatible. This page provides an overview of Hooks for experienced React users. This is a fast-paced overview. If you get confused, look for a yellow box like this:\n\n‚Üë‚Üë‚Üë Each section ends with a yellow box like this. They link to detailed explanations.\n\nThis example renders a counter. When you click the button, it increments the value:\n\nHere, is a Hook (we‚Äôll talk about what this means in a moment). We call it inside a function component to add some local state to it. React will preserve this state between re-renders. returns a pair: the current state value and a function that lets you update it. You can call this function from an event handler or somewhere else. It‚Äôs similar to in a class, except it doesn‚Äôt merge the old and new state together. (We‚Äôll show an example comparing to in Using the State Hook.)\n\nThe only argument to is the initial state. In the example above, it is because our counter starts from zero. Note that unlike , the state here doesn‚Äôt have to be an object ‚Äî although it can be if you want. The initial state argument is only used during the first render.\n\nYou can use the State Hook more than once in a single component:\n\nThe array destructuring syntax lets us give different names to the state variables we declared by calling . These names aren‚Äôt a part of the API. Instead, React assumes that if you call many times, you do it in the same order during every render. We‚Äôll come back to why this works and when this is useful later.\n\nBut what is a Hook?\n\nHooks are functions that let you ‚Äúhook into‚Äù React state and lifecycle features from function components. Hooks don‚Äôt work inside classes ‚Äî they let you use React without classes. (We don‚Äôt recommend rewriting your existing components overnight but you can start using Hooks in the new ones if you‚Äôd like.)\n\nReact provides a few built-in Hooks like . You can also create your own Hooks to reuse stateful behavior between different components. We‚Äôll look at the built-in Hooks first.\n\nYou‚Äôve likely performed data fetching, subscriptions, or manually changing the DOM from React components before. We call these operations ‚Äúside effects‚Äù (or ‚Äúeffects‚Äù for short) because they can affect other components and can‚Äôt be done during rendering.\n\nThe Effect Hook, , adds the ability to perform side effects from a function component. It serves the same purpose as , , and in React classes, but unified into a single API. (We‚Äôll show examples comparing to these methods in Using the Effect Hook.)\n\nFor example, this component sets the document title after React updates the DOM:\n\nWhen you call , you‚Äôre telling React to run your ‚Äúeffect‚Äù function after flushing changes to the DOM. Effects are declared inside the component so they have access to its props and state. By default, React runs the effects after every render ‚Äî including the first render. (We‚Äôll talk more about how this compares to class lifecycles in Using the Effect Hook.)\n\nEffects may also optionally specify how to ‚Äúclean up‚Äù after them by returning a function. For example, this component uses an effect to subscribe to a friend‚Äôs online status, and cleans up by unsubscribing from it:\n\nIn this example, React would unsubscribe from our when the component unmounts, as well as before re-running the effect due to a subsequent render. (If you want, there‚Äôs a way to tell React to skip re-subscribing if the we passed to didn‚Äôt change.)\n\nJust like with , you can use more than a single effect in a component:\n\nHooks let you organize side effects in a component by what pieces are related (such as adding and removing a subscription), rather than forcing a split based on lifecycle methods.\n\nHooks are JavaScript functions, but they impose two additional rules:\n‚Ä¢ Only call Hooks at the top level. Don‚Äôt call Hooks inside loops, conditions, or nested functions.\n‚Ä¢ Only call Hooks from React function components. Don‚Äôt call Hooks from regular JavaScript functions. (There is just one other valid place to call Hooks ‚Äî your own custom Hooks. We‚Äôll learn about them in a moment.)\n\nWe provide a linter plugin to enforce these rules automatically. We understand these rules might seem limiting or confusing at first, but they are essential to making Hooks work well.\n\nSometimes, we want to reuse some stateful logic between components. Traditionally, there were two popular solutions to this problem: higher-order components and render props. Custom Hooks let you do this, but without adding more components to your tree.\n\nEarlier on this page, we introduced a component that calls the and Hooks to subscribe to a friend‚Äôs online status. Let‚Äôs say we also want to reuse this subscription logic in another component.\n\nFirst, we‚Äôll extract this logic into a custom Hook called :\n\nIt takes as an argument, and returns whether our friend is online.\n\nNow we can use it from both components:\n\nThe state of each component is completely independent. Hooks are a way to reuse stateful logic, not state itself. In fact, each call to a Hook has a completely isolated state ‚Äî so you can even use the same custom Hook twice in one component.\n\nCustom Hooks are more of a convention than a feature. If a function‚Äôs name starts with ‚Äù ‚Äù and it calls other Hooks, we say it is a custom Hook. The naming convention is how our linter plugin is able to find bugs in the code using Hooks.\n\nYou can write custom Hooks that cover a wide range of use cases like form handling, animation, declarative subscriptions, timers, and probably many more we haven‚Äôt considered. We are excited to see what custom Hooks the React community will come up with.\n\nThere are a few less commonly used built-in Hooks that you might find useful. For example, lets you subscribe to React context without introducing nesting:\n\nAnd lets you manage local state of complex components with a reducer:\n\nPhew, that was fast! If some things didn‚Äôt quite make sense or you‚Äôd like to learn more in detail, you can read the next pages, starting with the State Hook documentation.\n\nYou can also check out the Hooks API reference and the Hooks FAQ.\n\nFinally, don‚Äôt miss the introduction page which explains why we‚Äôre adding Hooks and how we‚Äôll start using them side by side with classes ‚Äî without rewriting our apps."
    },
    {
        "link": "https://klinecharts.com/en-US/api/chart/init",
        "document": "üîî v9 will be maintained until March 2025. It is recommended to migrate to the new version as soon as possible.\n\nWhen calling, you need to wait until the container is ready.\n‚Ä¢ Container, which can be a DOM element or an element id.\n‚Ä¢ Optional configuration item.\n‚Ä¢ Custom layout, an array.\n‚Ä¢ Pane configuration.\n‚Ä¢ Whether the height can be adjusted by dragging.\n‚Ä¢ Axis configuration.\n‚Ä¢ The name of the axis.\n‚Ä¢ Whether it is inside.\n‚Ä¢ Whether to allow scrolling and zooming.\n‚Ä¢ Locale, with built-in support for and .\n‚Ä¢ Timezone name, such as . If not set, the local time zone will be automatically obtained. For a list of time zone names, please refer to the Timezone List .\n‚Ä¢ It can be a style name registered by or . For details about , see Styles. Incremental values ‚Äã‚Äãare supported.\n‚Ä¢ Customize some APIs.\n‚Ä¢ Format big numbers, such as 1000 is converted to 1k, 1000000 is converted to 1M, etc."
    },
    {
        "link": "https://v9.klinecharts.com/en-US/guide/chart-api",
        "document": "\n‚Ä¢ container, can be dom element or element id.\n‚Ä¢ optional configuration items.\n‚Ä¢ custom layout, and refer to the input parameters and in the instance api createIndicator.\n‚Ä¢ time zone name, such as 'Asia/Shanghai', if not set, it will automatically get the local time zone, please refer to timezone list.\n‚Ä¢ It can be the style name registered through , or it can be an object, a list of styles, see styles for details, and supports increments.\n‚Ä¢ customize some APIs.\n‚Ä¢ format big numbers, such as 1000 into 1k, 1000000 into 1M, etc.\\\n\nDestroys a chart, once destroyed the chart will no longer be available.\n‚Ä¢ can be a dom element, element id or chart instance.\n\nGet chart's overlay attributes by overlay name.\n\nGet the localized language types supported by the chart.\n‚Ä¢ style configuration, refer to style for the type, support increment.\n‚Ä¢ Basic figure information, see figure for details\n‚Ä¢ checks if the event is on the graph\n\nGet the basic graph type supported by the graph.\n‚Ä¢ technical indicator information\n‚Ä¢ indicator name, unique identifier for creation and operation\n‚Ä¢ should format large numbers. For example, 1000 is converted to 1k, 1000000 is converted to 1M, etc.\n‚Ä¢ overlay information, see overlay for details\n‚Ä¢ mode sensitivity, only valid when mode is weak_magnet\n\nGet the current version number of the chart.\n\nMerge one object into another.\n\nChecks if a value is a string.\n\nChecks if a value is a number.\n\nChecks if a value is valid.\n\nChecks if a value is an object.\n\nChecks if a value is a method.\n\nChecks if a value is a bool value.\n\nGet the corresponding value from a certain value, support nesting, such as , takes the value of .\n\nFormat large numbers, such as 1000 into 1k, 1000000 into 1M, etc.\n\nAccording to two coordinate points, get the slope and constant term of the line composed of points, namely and in .\n\nGet the y-axis coordinate value of a point on the line formed by two other coordinate points.\n\nGet the y-coordinate value of a point on the line formed by the slope and the constant term.\n\nCheck whether a certain coordinate point is on the arc.\n‚Ä¢ arc parameter\n‚Ä¢ the x-axis value of the center of the circle\n‚Ä¢ the y-axis value of the center of the circle\n\nChecks whether a certain coordinate point is on a circle.\n‚Ä¢ circle parameter\n‚Ä¢ the x-axis value of the center of the circle\n‚Ä¢ the y-axis value of the center of the circle\n\nCheck if a certain coordinate point is on the line.\n\nChecks whether a certain coordinate point is on a polygon.\n\nChecks whether a certain coordinate point is on a rectangle.\n\nCheck if a certain coordinate point is on the text.\n‚Ä¢ arc parameter\n‚Ä¢ the x-axis value of the center of the circle\n‚Ä¢ the y-axis value of the center of the circle\n‚Ä¢ circle parameter\n‚Ä¢ the x-axis value of the center of the circle\n‚Ä¢ the y-axis value of the center of the circle\n\nSame as , it is deprecated and will be deleted after v10. Please use instead."
    },
    {
        "link": "https://npmjs.com/package/klinecharts",
        "document": "\n‚Ä¢ üì¶ Out of the box: Simple and fast integration, basically zero cost to get started.\n‚Ä¢ üöÄ Lightweight and smooth: Zero dependencies, only 40k under gzip compression.\n‚Ä¢ üé® Highly scalable: With rich style configuration and API, the function can be extended as you like.\n\nComparison of time consumption from initialization to full rendering:\n\nAfter successful startup, open in the browser http://localhost:8888 .\n\nThe generated files are in the dist folder.\n\nKLineChart is available under the Apache License V2."
    },
    {
        "link": "https://github.com/klinecharts/KLineChart",
        "document": "\n‚Ä¢ üì¶ Out of the box: Simple and fast integration, basically zero cost to get started.\n‚Ä¢ üöÄ Lightweight and smooth: Zero dependencies, only 40k under gzip compression.\n‚Ä¢ üé® Highly scalable: With rich style configuration and API, the function can be extended as you like.\n\nComparison of time consumption from initialization to full rendering:\n\nAfter successful startup, open in the browser http://localhost:8888 .\n\nThe generated files are in the dist folder.\n\nKLineChart is available under the Apache License V2."
    },
    {
        "link": "https://github.com/klinecharts/KLineChart/discussions/295",
        "document": "To see all available qualifiers, see our documentation .\n\nSaved searches Use saved searches to filter your results more quickly\n\nWe read every piece of feedback, and take your input very seriously.\n\nYou signed in with another tab or window. Reload to refresh your session.\n\nYou signed out in another tab or window. Reload to refresh your session.\n\nYou switched accounts on another tab or window. Reload to refresh your session."
    }
]