[
    {
        "link": "https://stackoverflow.com/questions/4311034/managing-collision-detection-in-games",
        "document": "So my question isn't about the how-to of collision detection, but is more of a broad 'what code should own collision detection'. I've written some game in the past(relatively simple 2D Flash games) and it got me thinking of which code should own collision detection?\n\nLet me clarify - say in a game I have a group of enemies and a group of projectiles the player has fired. So in the past I've had say an EnemyManager class, that every frame updates the positions of the enemies and likewise for the player projectiles had a PlayerProjectilesManager class that moved around the bullets. That's cool - everything is fine and dandy. But then, I decide I want the bullets to affect the enemies(crazy I know!). So that means somewhere in the code I need to:\nâ€¢ Figure out which bullets and enemies are colliding(I don't care how for this question)\nâ€¢ Figure out the response to each collision\n\nSo basically what I've done in the past is just have the EnemyManager class take 'ownership' of the collisions, and during its update loop it finds the player bullets that collide with enemy bullets(i.e. Step 1) and also calls code for both objects to handle the collision (e.g. the enemy losses health, the bullet disappears) (i.e. Step 2). So I've given control of the collision detection and collision 'reaction' to the EnemyManager.\nâ€¢ It feels vary arbitrary to me that the EnemyManager is in 'control' instead of the PlayerProjectilesManager\nâ€¢ Both collision detection and collision 'reaction' are handled by the same owner, this isn't a requirement from my point of view\n\nWhat's forming in my mind is a 3rd party entity managing collision detection. For instance have a CollisionManager which has code that know's which other Managers need to have collisions detected. That leads to other questions like what interfaces do the 'Managers' need to expose for efficient collision detection without exposing too many innards to the CollisionManager. Then I suppose the CollisionManager what broadcast some sort of an event, containing which 2 objects collided etc... and perhaps the EnemyManager/PlayerProjectilesManager could separately listen for these events and react accordingly and separately. Starting to make sense in my mind. :)\n\nThoughts? Almost every game has collision detection, so I'm sure this has been discussed before. :)"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Games/Techniques/2D_collision_detection",
        "document": "Algorithms to detect collision in 2D games depend on the type of shapes that can collide (e.g. Rectangle to Rectangle, Rectangle to Circle, Circle to Circle). Generally you will have a simple generic shape that covers the entity known as a \"hitbox\" so even though collision may not be pixel perfect, it will look good enough and be performant across multiple entities. This article provides a review of the most common techniques used to provide collision detection in 2D games.\n\nOne of the simpler forms of collision detection is between two rectangles that are axis aligned â€” meaning no rotation. The algorithm works by ensuring there is no gap between any of the 4 sides of the rectangles. Any gap means a collision does not exist. <div id=\"cr-stage\"></div> <p> Move the rectangle with arrow keys. Green means collision, blue means no collision. </p> <script src=\"https://cdnjs.cloudflare.com/ajax/libs/crafty/0.5.4/crafty-min.js\"></script> Crafty.init(200, 200); const dim1 = { x: 5, y: 5, w: 50, h: 50 }; const dim2 = { x: 20, y: 10, w: 60, h: 40 }; const rect1 = Crafty.e(\"2D, Canvas, Color\").attr(dim1).color(\"red\"); const rect2 = Crafty.e(\"2D, Canvas, Color, Keyboard, Fourway\") .fourway(2) .attr(dim2) .color(\"blue\"); rect2.bind(\"EnterFrame\", function () { if ( rect1.x < rect2.x + rect2.w && rect1.x + rect1.w > rect2.x && rect1.y < rect2.y + rect2.h && rect1.y + rect1.h > rect2.y ) { // Collision detected! this.color(\"green\"); } else { // No collision this.color(\"blue\"); } }); Note: Another example without Canvas or external libraries.\n\nAnother simple shape for collision detection is between two circles. This algorithm works by taking the center points of the two circles and ensuring the distance between the center points are less than the two radii added together. <div id=\"cr-stage\"></div> <p> Move the circle with arrow keys. Green means collision, blue means no collision. </p> <script src=\"https://cdnjs.cloudflare.com/ajax/libs/crafty/0.5.4/crafty-min.js\"></script> Note: Here is another example without Canvas or external libraries.\n\nWhile some of these algorithms for collision detection are simple enough to calculate, it can be a waste of cycles to test every entity with every other entity. Usually games will split collision into two phases, broad and narrow.\n\nBroad phase should give you a list of entities that could be colliding. This can be implemented with a spatial data structure that will give you a rough idea of where the entity exists and what exist around it. Some examples of spatial data structures are Quad Trees, R-Trees or a Spatial Hashmap.\n\nWhen you have a small list of entities to check you will want to use a narrow phase algorithm (like the ones listed above) to provide a certain answer as to whether there is a collision or not."
    },
    {
        "link": "https://gamedev.stackexchange.com/questions/161814/how-to-optimize-collisions",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://reddit.com/r/incremental_games/comments/mwx2xd/performance_tips_for_javascript_game_developers",
        "document": "This post originally started out as a comment to this thread, but the content ended up being too large to post as a comment, so I decided to post it as it's own thread.\n\nThis post details all of the performance tips I've been exposed to over my years as a software developer working primarily in JavaScript and on the web.\n\nI'll just get straight into it...\n\nThis is a very low-hanging fruit with a low impact. It doesn't do much when you have just a few elements, but it makes a noticeable difference when there are 1000s of elements on the page.\n\nDo this instead:\n\nWhen you use code like the following, you are checking the entire document for a particular element.\n\nIf you are looking for an element that you know is inside another element, and you already have that element's reference cached somewhere, you can limit the amount of elements the browser needs to compare to your query to just those elements inside the parent, like so:\n\nIf you do not have a parent element reference, but you do know that the element you're looking for is at the same level of heirarchy as another element which you do have a reference for, then you can jump up a level to the common parent like so:\n\nAnimation frames are generally far more performant than timers that simulate repaints.\n\nDon't do this (this supposedly runs 60 frames per second):\n\nDo this instead:\n\nThis has the added benefit of running at a guaranteed 60+ fps. Higher monitor refreshrates actually run this at a higher frame rate, for example my ASUS VG248QE will run this game loop at 144 fps. Just bare in mind that in order to save system resources, browsers will \"pause\" the execution of an animation frame if focus is lost. This can happen when the user tabs out, minimizes the window or idles for a few minutes. Be sure to accommodate this behavior in your calculations, for example you might want to check how much time has passed since the last \"tick\" on each new \"tick\", and calculate your player's profits based on that.\n\nDo not rely on time calculations derived from the `Date` object\n\nThere is a far more precise time API accurate down to microseconds - look at Performance.now().\n\nDo this instead:\n\nOr better yet, use the timestamp passed to the callback - it is the same high-precision time object type as `()`, but the origin of the time starts when rAF first begins executing callbacks:\n\nOf course, if you actually need to use dates - for example calculating per day numbers or just rendering a calendar or whatever, then by all means use the Date object.\n\nYou won't know when performance tanks if you don't know what numbers to reasonably expect. Most browser developer consoles have a function to show an FPS counter on the page. In Chrome, it's in developer tools -> command palette (ctrl+p on win, cmd+p on mac) -> show frames. This will show you frames per second rendering for the entire page, but if you want to measure the FPS of a single game loop, say, for a single canvas element, then you can derive that from the parameter:\n\nLet's say you encounter a performance issue. How do you begin to analyze it, find out where it's coming from, all that nonsense? It's not as simple as looking at your game and thinking, \"Well, it happened when I jumped, so obviously it's my jump code.\"\n\nWhat you can do instead, is record a performance profile. You can then generate a heapmap from that profile, and jump into the callstack to see exactly how many milliseconds were spent running particular functions and methods.\n\nHow is this done?\n\nIt's quite an involved process, with far too much information for me to condense into a section of a Reddit comment/post, so unfortunately you will have to click on a link for this one. Here you go: https://blog.appsignal.com/2020/02/20/effective-profiling-in-google-chrome.html\n\nExecute DOM Reads and Writes in different phases\n\nDid you know that most browsers optimise for the case when reads and writes exist in separate animation frames/phases? Let me demonstrate.\n\nTake this code, for example.\n\nThis code will cause a few repaints in the browser, because all of the reads and writes happen in an interleaved manner. If we \"schedule\" our reads and writes into separate animation frames, we can basically achieve the same amount of rendering with much fewer repaints - which is done (in concept) like so:\n\nOf course, this would become a pain to maintain, so we could write a scheduler that basically turns every DOM access task into an asynchronous one, by queing read and write tasks separately and flushing the queues periodically - this way the reads and writes are executed in ordered batches:\n\nJust note that the above calls to and are asynchronous - regular DOM reads and writes are synchronous, so these will not behave as you might expect. If you want to make it a little easier, you can extend it into a promisified version:\n\nFor more information on how and why this works, and a more robust and complete implementation, check out the FastDom library: https://github.com/wilsonpage/fastdom - note that you might not need this particular optimization if you're using a rendering framework, which should already be doing these sorts of optimisations for you.\n\nTry to look for areas in your code where you make use of asynchronous methods, especially if those areas deal with fetching remote resources in a serial manner.\n\nFor example, here is some code to load different sound effects into an AudioContext:\n\nThere is a problem with this code. It will load each sound asset one by one, one after the other. None of the sounds depend on one another in order to load, and we can take advantage of this to gain a substantial performance boost.\n\nInstead of loading one sound at a time, we can load them simultaneously using .\n\nDo not create too many event listeners\n\nThis is another one of those \"don't bother if you're using a framework\" tips, as a good framework should already be doing this for you. However, if you're not using a framework, then adding a bunch of event listeners to your game can cause quite a lot of cascading performance bottlenecks.\n\nTake this code for example, which adds three event listeners - one for a click on three different buttons.\n\nAt first glance, this code looks fine. Nothing's really wrong with it, aside from the fact that there are three separate functions taking up memory, which isn't a big deal.\n\nWhat if we introduce more buttons, though? Well, we will want to make maintenance easier on us, so...\n\n...and this code works, nicely. Except now 3 months have passed and there are now 400 buttons in our game, each with their own event listener, and this starts becoming an issue. First off, now we have to move the function out of the loop, so we aren't creating new instances of it on each iteration:\n\nThis is an improvement, but we still have 400 event listeners. We could do things like check if the buttons are actually actively displayed in our game, and conditionally apply the event listeners, that's one possible optimisation, but I won't get into that. It's just more branching complexity.\n\nA couple of weeks pass, and we add a feature that lets a user add their own buttons. And we somehow forget to update the button code and for some reason any button the user adds doesn't register any clicks - this is because we're only iterating over the buttons that already existed when we registered the event listeners. So, we have to make sure that new buttons get their event listeners somehow... I won't get into this either.\n\nAs you can see, this is spiralling out of control. How do we fix it? The answer is to just register one event listener for a click on the entire document, and check the event target to see if it's something we should be interested in.\n\nHow many event listeners is this? Just one. Not two, not 400, but one.\n\nWill this event listener respond to elements created as a result of user input? Yes, yes it will.\n\nIt even lets us listen for clicks on things other than buttons!\n\nTake advantage of CSS animations and their ability to utilize hardware acceleration\n\nAnimating with JS is nice, you can get a lot of precise control that you can't get with CSS. But for simple animations like fades, color changes, etc. it's better to use CSS.\n\nBecause CSS animations can take advantage of GPU acceleration. When you use properties like , , , , etc in your animations, CSS will shift the painting of those animations from the CPU over to the GPU. This is something that is not really possible in JS (unless you use something like GPU.js, but a whole dependency just for some silly animations? kek)\n\nPlus, not only do you get GPU acceleration, but you can simplify your code as well. Instead of slowly incrementing/decrementing an opacity value over time via JS, you can just toggle a class on activation/deactivation. Simple. Easy. You can even bind it to your state.\n\nAlthough a bit outdated, this article gives a good outline of this concept: https://www.smashingmagazine.com/2016/12/gpu-animation-doing-it-right/\n\nMost games are full of static resources like images, sprite sheets, audio files, fonts, etc. These are all assets that need to be sent to the browser over the network.\n\nIf the player lacks an internet connection, some of these assets may be broken.\n\nOne can cache these assets in the browser so that they load even while the user is offline, and this has the added benefit of decreasing loading times for these assets.\n\nThis used to be done via the HTML5 ApplicationCache, which has been deprecated in favor of the Cache API, which requires Service Workers. Thankfully, the Cache API is currently supported in all modern browsers.\n\nHere is a tutorial on how to get started with the Cache API: https://web.dev/cache-api-quick-guide/\n\nUtilize Web Workers to offload heavy computations to another thread\n\nWeb Workers can do quite a lot for gains in performance. Think of web workers as threads, but in the browser.\n\nAny JS script can spawn a new web worker that it has exclusive access to, or a shared worker that other scripts can share access to.\n\nWeb workers are an isolated execution context that executes code in a limited environment - they have access to a number of APIs, but do not have access to the DOM.\n\nThey are also very easy to use. You simply pass messages around and react to messages to communicate between your workers and your main script, like so:\n\nNote that in the worker, and aren't attached to anything, since the worker itself is basically the global scope.\n\nOf course, using a whole thread for something as simple as an incrementing counter is a little bit overkill, but it makes a big difference when you have expensive math calculations to perform and you can perform them on a separate thread.\n\nOffloading computationally expensive code like this to a separate thread allows you to keep your main thread for just rendering purposes, keeping your user interface snappy and performant.\n\nSee more information here: https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers\n\nDon't act on entities the player cannot see\n\nIf you have objects that are out-of-view, (whether a spaceship in a game off to the side of the screen or a resource counter hidden behind a tab in a component), do not bother updating their views. They might exist in the document at the time that the player is playing a game, but just because they exist in the document, that doesn't mean the player can actually see them.\n\nPerforming calculations to update all of these hidden things could cost quite a bit of resources and cause a number of unnecessary browser repaints.\n\nInstead, simply ignore them. Be sure to keep your game's state updated, and only update these elements or objects with their new state when they come back into view.\n\nYou can use the IntersectionObserver API to detect if document elements are currently in view. For canvas objects, just check if their x and y coordinates exceed the canvas width / height or are less than 0.\n\nUsing the IntersectionObserver API is nice, but if you can get away with not using it, even better. It is less necessary if you derive your view from your state and only render elements/objects if the state requires that they be rendered.\n\nIf your game has complex objects that have their own \"intelligence\" and produce events on their own, you still don't need to update their views if they exist off screen. Simply attach these objects to a State Machine and update the state machine instead. If their state requires that they be rendered (for example a sheep has walked within view of the player), then by all means, render it.\n\nReduce the number of logical branching pathes via polymorphism\n\nIn programming, we make use of all sorts of syntax constructs, like conditional statements, ternary operators, functions, loops, binary / logical operators, etc.\n\nSome of these constructs result in what we call \"logical branches\". A logical branch is essentially a point during a program's execution where the program must inspect some state and then choose between two or more \"paths\" of execution. These are found typically in conditional statements:\n\nWhen the interpreter (or compiler) comes to these sections of code, it performs a little calculation to determine where in the code to go next. Though almost entirely negligible, this little calculation does take a little bit of time, and in larger more complex programs, with many potential users, this time can add up.\n\nThere is a concept known as a \"polymorphism\" in functional programming, where we can take advantage of the type to remove some of this branching complexity.\n\nTake a Result union type, for example. It can be one of two possible unions:\n\nWe have both a and a type, that both belong to the same union - . If we get a and want to act upon it (for example, transform it's value), we first have to inspect which of the two types we're working with. Let's do that with a simple utility:\n\nThis utility could be used in many places in our projects, and each time we use it, we are creating a branching path.\n\nThere's an optimization we can make here, to remove this branching, via a polymorphism of the utility on each type. All we have to do is adjust the implementations of our types to implement this interface:\n\nNow, we just adjust our utility to call this interface:\n\nThus, we can use our utility, and it won't ever create any logical branches. It just defers to the interface of the type.\n\nOf course, this can be achieved without using union types. A realistic example would be an event handler that responds to different actions, or anywhere a switch case might be used. let's say we have an event handler that receives a message object, and we do different things according to the message's property (much like we would do in Redux or in our button event handler we saw earlier).\n\nNormally we would inspect this property via a switch/case statement, which could have many potential logical branches (based on how many different types we have), but instead of doing that, we could simply use a dictionary:\n\nAs you can see, there are no logical branches in this code, yet we are still able to perform different functions based on different inputs. This scales to however many different types our message handler deals with.\n\nOf course, care needs to be taken here. There are certainly cases where deferring logic to a function via polymorphism could in fact be more computationally expensive than just checking a condition, depending on what the function is doing and how computationally expensive it is to call. Be sure to routinely profile your code to be sure you're seeing improvements. Don't just optimise for the sake of it.\n\nAs your idea develops more and fleshes itself out, you might add a lot of code for lots of different parts of your game. You might start seeing areas where code performs calculations that are not strictly necessary.\n\nSince we're in a game sub, I will give a perfect game-related example: collision detection.\n\nLet's assume we have a bunch of objects on our game's canvas, and we want to check if two objects are colliding:\n\nThis code is straightforward, and it works. We loop through each game object, reset it's collision status to false, then loop through each game object again to check if our current object from the outer loop is colliding with an object in the inner loop. We be sure to ignore the case where both the inner and outer objects reference the same object, because we know that an object will always be colliding with itself.\n\nHowever, there is a major issue here. If we've checked if an object is colliding, we don't need to check it again, because we know it's colliding already, so we can actually start our collision check with only the remaining objects:\n\nThis is already much better, we're not performing any unnecessary calculations anymore, but there's still one more optimisation we can make. We know that the index references the current object, which means that the first object that is inspected in our inner loop corresponds to the object in our outer loop - so we can simply shift the index by 1 to ignore it, and remove our conditional branch that deals with ignoring the case where both objects reference the same thing:\n\nNow, our code for doing collision detection doesn't perform any unnecessary checks. Since collision detection is quite a computationally heavy task, especially if there are hundreds our thousands of objects in our game, this little optimisation could have saved us potentially a lot of execution time.\n\nThere's actually more optimisations we can make here - we don't exactly need to check every object in our game for collisions, like this code is doing.\n\nFor a simple 2D game, we could divide the \"game world\" into a grid of tiles, and only check the objects that exist in the same tile as the object that we're currently inspecting.\n\nFor a 3D game, we could use an algorithm that puts the entire game world into a giant invisible cube, then divides that cube into 8 smaller invisible cubes, and each of those cubes into 8 smaller invisible cubes, etc. Then we can take an object, find out which \"cube\" it is in by checking it's coordinates against the coordinates of the lowest level of cubes - if it exists inside two cubes simultaneously, then we move \"up\" a level to get a bigger cube - and only check for collisions on objects that exist inside the same cube.\n\nWe could also adjust our collision detection function to check a boxed area around the object we're checking (known as a \"hitbox\"), so we don't match on each and every pixel.\n\nThis is an involved example, but this sort of problem arises almost anywhere in a program, not just in things like collision detection, so you should definitely keep an eye out for optimisations you can make that reduce unnecessary computations, as these optimisations will generally net you the most performance gains.\n\nHopefully all of these tips are useful to some of you, as this post took me a lot longer to write than I thought it would ðŸ˜…."
    },
    {
        "link": "https://stackoverflow.com/questions/41317549/collision-detection-in-javascript-game",
        "document": "I think this is the behaviour you're looking for. The following code does all the magic:\n\n (see the code snippet below for a working demo)\n\nBut in order for this to work, I had to change some other things too:\nâ€¢ Instead of directly updating and , I had to create variables and at the start of draw, and only at the and update .\n\n So the whole function should be copied I think to be save.\n\nBut don't blindly copy it, I also made some other changes, mostly for my own understanding and readability of your script. Do with that what you want.. you like it, copy it, you don't, leave it:\nâ€¢ I changed into and . These properties are also used in , so be careful with that.\nâ€¢ I added variables and , to restrict the ball from leaving the canvas.\nâ€¢ I changed the value to the gravity value on earth.\nâ€¢ I changed to , an object containing all rectangular shapes. If you want to place a new rectangle, just add a new one in the object and that's it.\n\n In I changed to for (key in rect) {if (rect.hasOwnProperty(key)) {drawRect(rect[key]);}} , a loop that draws all the objects that are inside the object.\nâ€¢ is an array that contains all the objects that should trigger a collision with the player.\n\n As you can see in the demo, the yellow doesn't trigger a collision, because it is not in the array.\n\n (If you do add the to the collisionObjects-array, the ball still falls through after about half a second, I haven't figured out why. I thought it had to do with the width ( in code), but that's not it. For some reason, if the object doesn't touch the floor, the ball will eventually fall through.)"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API",
        "document": "The Canvas API provides a means for drawing graphics via JavaScript and the HTML element. Among other things, it can be used for animation, game graphics, data visualization, photo manipulation, and real-time video processing. The Canvas API largely focuses on 2D graphics. The WebGL API, which also uses the element, draws hardware-accelerated 2D and 3D graphics.\n\nThe method gets a reference to the HTML element. Next, the method gets that element's contextâ€”the thing onto which the drawing will be rendered. The actual drawing is done using the interface. The property makes the rectangle green. The method places its top-left corner at (10, 10), and gives it a size of 150 units wide by 100 tall.\n\nThe Canvas API is extremely powerful, but not always simple to use. The libraries listed below can make the creation of canvas-based projects faster and easier.\nâ€¢ EaselJS is an open-source canvas library that makes creating games, generative art, and other highly graphical experiences easy.\nâ€¢ Fabric.js is an open-source canvas library with SVG parsing capabilities.\nâ€¢ heatmap.js is an open-source library for creating canvas-based data heat maps.\nâ€¢ Konva.js is a 2D canvas library for desktop and mobile applications.\nâ€¢ p5.js has a full set of canvas drawing functionality for artists, designers, educators, and beginners.\nâ€¢ Paper.js is an open-source vector graphics scripting framework that runs on top of the HTML Canvas.\nâ€¢ Phaser is a fast, free and fun open source framework for Canvas and WebGL powered browser games.\nâ€¢ Pts.js is a library for creative coding and visualization in canvas and SVG.\nâ€¢ Rekapi is an animation key-framing API for Canvas.\nâ€¢ Scrawl-canvas is an open-source JavaScript library for creating and manipulating 2D canvas elements.\nâ€¢ The ZIM framework provides conveniences, components, and controls for coding creativity on the canvas â€” includes accessibility and hundreds of colorful tutorials.\nâ€¢ Sprig is a beginner-friendly, open-source, tile-based game development library that uses Canvas. Note: See the WebGL API for 2D and 3D libraries that use WebGL."
    },
    {
        "link": "https://w3schools.com/tags/ref_canvas.asp",
        "document": "You can add a canvas element anywhere in an HTML page with the tag:\n\nYou can access a element with the HTML DOM method .\n\nTo draw in the canvas you need to create a 2D context object:\n\nAfter you have created a 2D context, you can draw on the canvas.\n\nThe fillRect() method draws a black rectangle with a top-left corner at position 20,20. The rectangle is 150 pixel wide and 100 pixels high.\n\nThe fillStyle property sets the fill color of the drawing object:\n\nYou can also create a new element with the method, and add the element to an existing HTML page:\n\nThe common way to draw on the canvas is to:\n\nThere are only 3 methods to draw directly on the canvas:\n\nThe canvas object also supports the standard properties and events.\n\nThe element is an HTML5 standard (2014).\n\nis supported in all modern browsers:"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Basic_animations",
        "document": "Since we're using JavaScript to control elements, it's also very easy to make (interactive) animations. In this chapter we will take a look at how to do some basic animations. Probably the biggest limitation is, that once a shape gets drawn, it stays that way. If we need to move it we have to redraw it and everything that was drawn before it. It takes a lot of time to redraw complex frames and the performance depends highly on the speed of the computer it's running on.\n\nShapes are drawn to the canvas by using the canvas methods directly or by calling custom functions. In normal circumstances, we only see these results appear on the canvas when the script finishes executing. For instance, it isn't possible to do an animation from within a loop. That means we need a way to execute our drawing functions over a period of time. There are two ways to control an animation like this.\n\nFirst there's the , , and functions, which can be used to call a specific function over a set period of time. Starts repeatedly executing the function specified by every milliseconds. Executes the function specified by in milliseconds. Tells the browser that you wish to perform an animation and requests that the browser call a specified function to update an animation before the next repaint. If you don't want any user interaction you can use the function, which repeatedly executes the supplied code. If we wanted to make a game, we could use keyboard or mouse events to control the animation and use . By setting listeners using , we catch any user interaction and execute our animation functions. Note: In the examples below, we'll use the method to control the animation. The method provides a smoother and more efficient way for animating by calling the animation frame when the system is ready to paint the frame. The number of callbacks is usually 60 times per second and may be reduced to a lower rate when running in background tabs. For more information about the animation loop, especially for games, see the article Anatomy of a video game in our Game development zone."
    },
    {
        "link": "https://davidmatthew.ie/the-canvas-api-part-1-the-background",
        "document": "What is the Canvas API?\n\nThe Canvas API, or the â€˜HTML5 Canvasâ€™, allows for the creation of dynamic, interactive graphics for the web using JavaScript and the HTML element. Just as a physical canvas captures paint, the element captures pixels. These pixels are â€˜paintedâ€™ with JavaScript (which we might think of as the brush) using the palette of functions provided by the Canvas API (or just Canvas, as Iâ€™ll henceforth call the API).\n\nThis palette includes a full suite of shape-rendering and pixel-manipulation functions, and popular applications of it include games, animations, annoying advertisements and data visualisations. A lesser-known application, and one which Iâ€™ll be leaning towards throughout this series, is generative art (examples of which I include below).\n\nAlthough technically capable of 3D graphics (via WebGL, which also renders to the canvas element), most discussions online of Canvas assume that we are referring to its 2D rendering capabilities, or its 2D â€˜contextâ€™. Iâ€™ll explain more about this context later in this series, but for now, itâ€™s generally safe to assume that Canvas is roughly synonymous with 2D web graphics.\n\nThe element began its life in 2004 as an addition to Appleâ€™s OS X WebKit component, the engine behind their Safari browser. Upon its release, this fledgling element was met with some backlash from the web development community, due in part to Appleâ€™s apparent lack of concern for pursuing an open, consensus-driven approach to the evolution of the web. As Ian Hickson put it at the time:\n\nCanvas was however soon adopted by other browsers, and what began as a proprietary extension eventually became open and standardized. In 2014 â€“ ten years later â€“ it was incorporated into the official W3C HTML5 specification.\n\nWhat made Canvas such an attractive addition to the web technology stack was its promise of performant, low-level procedural graphics, native to the web. Before this, if you wanted to develop games or other graphics-intensive applications online, Flash was your weapon of choice. And Flash, developed in-house at Adobe, required a plugin to work, was notoriously slow (particularly on mobile), and security-wise it was about as watertight as a spaghetti strainer.\n\nCanvas has suffered from none of these drawbacks, and has certainly helped dethrone Flash as the go-to choice for the development of online games, animations and other interactive media. It isnâ€™t, however, the only game in town when it comes to 2D web graphics.\n\nSVG, which stands for Scalable Vector Graphics, was a specification released by the W3C all the way back in 2001, and it was, in some respects at least, arguably a more appropriate replacement for Flash than was Canvas. SVG, like Flash, is vector-based, and offers several possibilities with regards to animation. So why, you might ask, did we need Canvas at all?\n\nWell, it turns out that releasing a well-thought-out web specification doesnâ€™t mean that browser vendors will automatically adopt it. Browsers have been a long time dragging their feet where SVG support is concerned, and it was only with the rise of high-resolution and high-density (a.k.a. â€˜retinaâ€™) displays that SVG began to come into its own and get the adoption it deserved.\n\nThis should give us a clue as to one of the main differentiators between SVG and Canvas; SVG, because it is vector-based, allows for resolution-independent rendering. Canvas, on the other hand, is bitmap-based, and thus resolution dependent. Zooming in on (i.e. scaling) a canvas element will result in pixelation, whereas SVG elements will remain crisp and clear no matter the scale factor.\n\nBefore we rush to any judgement as to which one is â€˜betterâ€™, we need to bear in mind that SVG and Canvas take very different approaches to how they handle graphics, and thus have their own strengths and weaknesses. I wonâ€™t go into a detailed comparison here (thereâ€™s a nice and readable one over at CSS Tricks if you fancy diving deeper); suffice to say, SVG is great for graphics that need to remain crisp at higher resolutions and donâ€™t have a thousand moving parts. Canvas on the other hand is great at programming graphics of the latter variety (think particle systems or complex music visualisations), but wouldnâ€™t be your go-to choice for a high-resolution logo.\n\nIn the next part of the series, weâ€™ll get started using , showing you how to declare and use its 2D context and create some basic shapes."
    },
    {
        "link": "https://stackoverflow.com/questions/9791904/animating-images-in-html5-and-canvas",
        "document": "I need help with making an image float onto the canvas in HTML5 and JavaScript. I have been googling around and have not found anything. I can draw shapes on the screen but I dont know how to animate them. I want couple of different images to float in on the canvas from different directions. Can someone please help me with this? after 4 hours of googling all I could do was this\n\nThere seem to be plenty of tutorials on animating shapes but I want to load up my own pictures and have them fly in onto the canvas."
    }
]