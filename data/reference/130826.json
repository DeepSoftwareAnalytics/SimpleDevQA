[
    {
        "link": "https://developer.android.com/guide/fragments/lifecycle",
        "document": "Each instance has its own lifecycle. When a user navigates and interacts with your app, your fragments transition through various states in their lifecycle as they are added, removed, and enter or exit the screen.\n\nTo manage lifecycle, implements , exposing a object that you can access through the method.\n\nEach possible state is represented in the enum.\n\nBy building on top of , you can use the techniques and classes available for Handling Lifecycles with Lifecycle-Aware Components. For example, you might display the device's location on the screen using a lifecycle-aware component. This component could automatically start listening when the fragment becomes active and stop when the fragment moves to an inactive state.\n\nAs an alternative to using a , the class includes callback methods that correspond to each of the changes in a fragment's lifecycle. These include , , , , , and .\n\nA fragment's view has a separate that is managed independently from that of the fragment's . Fragments maintain a for their view, which can be accessed using or . Having access to the view's is useful for situations where a Lifecycle-aware component should only perform work while a fragment's view exists, such as observing that is only meant to be displayed on the screen.\n\nThis topic discusses the lifecycle in detail, explaining some of the rules that determine a fragment's lifecycle state and showing the relationship between the states and the fragment lifecycle callbacks.\n\nWhen a fragment is instantiated, it begins in the state. For a fragment to transition through the rest of its lifecycle, it must be added to a . The is responsible for determining what state its fragment should be in and then moving them into that state.\n\nBeyond the fragment lifecycle, is also responsible for attaching fragments to their host activity and detaching them when the fragment is no longer in use. The class has two callback methods, and , that you can override to perform work when either of these events occur.\n\nThe callback is invoked when the fragment has been added to a and is attached to its host activity. At this point, the fragment is active, and the is managing its lifecycle state. At this point, methods such as return this fragment.\n\nis always called before any Lifecycle state changes.\n\nThe callback is invoked when the fragment has been removed from a and is detached from its host activity. The fragment is no longer active and can no longer be retrieved using .\n\nis always called after any Lifecycle state changes.\n\nNote that these callbacks are unrelated to the methods and . For more information on these methods, see Fragment transactions.\n\nWhen determining a fragment's lifecycle state, considers the following:\n‚Ä¢ A fragment's maximum state is determined by its . A fragment cannot progress beyond the state of its .\n‚Ä¢ As part of a , you can set a maximum lifecycle state on a fragment using .\n‚Ä¢ A fragment's lifecycle state can never be greater than its parent. For example, a parent fragment or activity must be started before its child fragments. Likewise, child fragments must be stopped before their parent fragment or activity.\n\nFigure 1 shows each of the fragment's states and how they relate to both the fragment's lifecycle callbacks and the fragment's view .\n\nAs a fragment progresses through its lifecycle, it moves upward and downward through its states. For example, a fragment that is added to the top of the back stack moves upward from to to . Conversely, when a fragment is popped off of the back stack, it moves downward through those states, going from to to and finally .\n\nWhen moving upward through its lifecycle states, a fragment first calls the associated lifecycle callback for its new state. Once this callback is finished, the relevant is emitted to observers by the fragment's , followed by the fragment's view , if it has been instantiated.\n\nWhen your fragment reaches the state, it has been added to a and the method has already been called.\n\nThis would be the appropriate place to restore any saved state associated with the fragment itself through the fragment's . Note that the fragment's view has not been created at this time, and any state associated with the fragment's view should be restored only after the view has been created.\n\nThis transition invokes the callback. The callback also receives a argument containing any state previously saved by . Note that has a value the first time the fragment is created, but it is always non-null for subsequent recreations, even if you do not override . See Saving state with fragments for more details.\n\nThe fragment's view is created only when your provides a valid instance. In most cases, you can use the fragment constructors that take a , which automatically inflates the view at the appropriate time. You can also override to programmatically inflate or create your fragment's view.\n\nIf and only if your fragment's view is instantiated with a non-null , that is set on the fragment and can be retrieved using . The is then updated with the newly corresponding with the fragment's view. The lifecycle callback is also called at this time.\n\nThis is the appropriate place to set up the initial state of your view, to start observing instances whose callbacks update the fragment's view, and to set up adapters on any or instances in your fragment's view.\n\nAfter the fragment's view has been created, the previous view state, if any, is restored, and the view's is then moved into the state. The view lifecycle owner also emits the event to its observers. Here you should restore any additional state associated with the fragment's view.\n\nThis transition also invokes the callback.\n\nIt is strongly recommended to tie Lifecycle-aware components to the state of a fragment, as this state guarantees that the fragment's view is available, if one was created, and that it is safe to perform a on the child of the fragment. If the fragment's view is non-null, the fragment's view is moved to immediately after the fragment's is moved to .\n\nWhen the fragment becomes , the callback is invoked.\n\nWhen the fragment is visible, all and effects have finished, and the fragment is ready for user interaction. The fragment's moves to the state, and the callback is invoked.\n\nThe transition to is the appropriate signal to indicate that the user is now able to interact with your fragment. Fragments that are not should not manually set focus on their views or attempt to handle input method visibility.\n\nWhen a fragment moves downward to a lower lifecycle state, the relevant is emitted to observers by the fragment's view , if instantiated, followed by the fragment's . After a fragment's lifecycle event is emitted, the fragment calls the associated lifecycle callback.\n\nAs the user begins to leave the fragment, and while the fragment is still visible, the s for the fragment and for its view are moved back to the state and emit the event to their observers. The fragment then invokes its callback.\n\nOnce the fragment is no longer visible, the s for the fragment and for its view are moved into the state and emit the event to their observers. This state transition is triggered not only by the parent activity or fragment being stopped, but also by the saving of state by the parent activity or fragment. This behavior guarantees that the event is invoked before the fragment's state is saved. This makes the event the last point where it is safe to perform a on the child .\n\nAs shown in figure 2, the ordering of the callback and the saving of the state with differs based on API level. For all API levels prior to API 28, is invoked before . For API levels 28 and higher, the calling order is reversed.\n\nAfter all of the exit animations and transitions have completed, and the fragment's view has been detached from the window, the fragment's view is moved into the state and emits the event to its observers. The fragment then invokes its callback. At this point, the fragment's view has reached the end of its lifecycle and returns a value.\n\nAt this point, all references to the fragment's view should be removed, allowing the fragment's view to be garbage collected.\n\nIf the fragment is removed, or if the is destroyed, the fragment's is moved into the state and sends the event to its observers. The fragment then invokes its callback. At this point, the fragment has reached the end of its lifecycle.\n\nFor more information related to the fragment lifecycle, see the following additional resources."
    },
    {
        "link": "https://developer.android.com/guide/fragments/create",
        "document": "A fragment represents a modular portion of the user interface within an activity. A fragment has its own lifecycle, receives its own input events, and you can add or remove fragments while the containing activity is running.\n\nThis document describes how to create a fragment and include it in an activity.\n\nFragments require a dependency on the AndroidX Fragment library. You need to add the Google Maven repository to your project's file in order to include this dependency.\n\nTo include the AndroidX Fragment library to your project, add the following dependencies in your app's file:\n\nTo create a fragment, extend the AndroidX class, and override its methods to insert your app logic, similar to the way you would create an class. To create a minimal fragment that defines its own layout, provide your fragment's layout resource to the base constructor, as shown in the following example:\n\nThe Fragment library also provides more specialized fragment base classes:\n\nGenerally, your fragment must be embedded within an AndroidX to contribute a portion of UI to that activity's layout. is the base class for , so if you're already subclassing to provide backward compatibility in your app, then you do not need to change your activity base class.\n\nYou can add your fragment to the activity's view hierarchy either by defining the fragment in your activity's layout file or by defining a fragment container in your activity's layout file and then programmatically adding the fragment from within your activity. In either case, you need to add a that defines the location where the fragment should be placed within the activity's view hierarchy. It is strongly recommended to always use a as the container for fragments, as includes fixes specific to fragments that other view groups such as do not provide.\n\nTo declaratively add a fragment to your activity layout's XML, use a element.\n\nHere's an example activity layout containing a single :\n\nThe attribute specifies the class name of the to instantiate. When the activity's layout is inflated, the specified fragment is instantiated, is called on the newly instantiated fragment, and a is created to add the fragment to the .\n\nTo programmatically add a fragment to your activity's layout, the layout should include a to serve as a fragment container, as shown in the following example:\n\nUnlike the XML approach, the attribute isn't used on the here, so no specific fragment is automatically instantiated. Instead, a is used to instantiate a fragment and add it to the activity's layout.\n\nWhile your activity is running, you can make fragment transactions such as adding, removing, or replacing a fragment. In your , you can get an instance of the , which can be used to create a . Then, you can instantiate your fragment within your activity's method using , passing in the ID of the container in your layout and the fragment class you want to add and then commit the transaction, as shown in the following example:\n\nIn the previous example, note that the fragment transaction is only created when is . This is to ensure that the fragment is added only once, when the activity is first created. When a configuration change occurs and the activity is recreated, is no longer , and the fragment does not need to be added a second time, as the fragment is automatically restored from the .\n\nIf your fragment requires some initial data, arguments can be passed to your fragment by providing a in the call to , as shown below:\n\nThe arguments can then be retrieved from within your fragment by calling , and the appropriate getter methods can be used to retrieve each argument.\n\nFragment transactions and the are covered in more detail in the Fragment manager guide."
    },
    {
        "link": "https://stackoverflow.com/questions/43588197/fragment-lifecycle-while-navigating-between-fragments",
        "document": "Android fragments have their own life cycle very similar to an android activity.\n\nonAttach() The fragment instance is associated with an activity instance.In this method you get the reference of the activity which called the fragment.\n\nonCreate() The system calls this method when creating the fragment.\n\nonCreateView() The system calls this callback when it's time for the fragment to draw its user interface for the first time.\n\nonStart() This method is called once the fragment gets visible.\n\nonDestroyView() Fragment view will destroy after call this method\n\nSee this tutorial for better understanding of life cycle."
    },
    {
        "link": "https://geeksforgeeks.org/fragment-lifecycle-in-android",
        "document": "In Android, the fragment is the part of the Activity that represents a portion of the User Interface(UI) on the screen. It is the modular section of the Android activity that is very helpful in creating UI designs that are flexible in nature and auto-adjustable based on the device screen size. The UI flexibility on all devices improves the user experience and adaptability of the application. that can exist only inside an activity as its lifecycle is dependent on the lifecycle of the host activity. For example, if the host activity is paused, then all the methods and operations of the fragment related to that activity will stop functioning, the fragment is also termed a sub-activity. Fragments in Android can be added, removed, or replaced dynamically i.e., while the activity is running.\n\nBelow is the pictorial representation of fragment interaction with the activity:\n‚Ä¢ Single Fragment: Display only one single view on the device screen. This type of fragment in android is mostly used for mobile phones.\n‚Ä¢ List Fragment: This Fragment is used to display a list-view from which the user can select the desired sub-activity. The menu drawer of apps like Gmail is the best example of this kind of android fragment.\n‚Ä¢ Fragment Transaction: This kind of fragments in android supports the transition from one fragment in android to another at run time. Users can switch between multiple fragments like switching tabs.\n\nThe very first method to be called when the fragment has been associated with the activity. This method executes only once during the lifetime of a fragment. \n\n When we attach fragment(child) to Main(parent) activity then it call first and then not call this method any time(like you run an app and close and reopen) simple means that this method call only one time. This method initializes the fragment by adding all the required attributes and components. System calls this method to create the user interface of the fragment. The root of the fragment‚Äôs layout is returned as the View component by this method to draw the UI. \n\n You should inflate your layout in onCreateView but shouldn‚Äôt initialize other views using findViewById in onCreateView. It indicates that the activity has been created in which the fragment exists. View hierarchy of the fragment also instantiated before this function call. The system invokes this method to make the fragment visible on the user‚Äôs device. This method is called to make the visible fragment interactive. It indicates that the user is leaving the fragment. System call this method to commit the changes made to the fragment. Method to terminate the functioning and visibility of fragment from the user‚Äôs screen. System calls this method to clean up all kinds of resources as well as view hierarchy associated with the fragment. It will call when you can attach new fragment and destroy existing fragment Resoruce It is called to perform the final clean up of fragment‚Äôs state and its lifecycle. The system executes this method to disassociate the fragment from its host activity. \n\n It will call when your fragment Destroy(app crash or attach new fragment with existing fragment)\n\nConsider Fragment-1 is A and Fragment-2 is B and A is attached to the Main Activity\n\n 1. If you can replace B with A.\n\n A‚Äôs call back:\n\n onDestroyView()\n\n onDestroy()\n\n onDetach()\n\n2. If you can replace B with A without Losing resources.\n\n A‚Äôs call back:\n\n onDestroy()\n\n onDetach()\n\nFragments in android are always embedded in Activities i.e., they are added to the layout of activity in which they reside. Multiple fragments can be added to one activity. This task can be carried out in 2 ways:\n‚Ä¢ None Statically: Explicitly mention the fragment in the XML file of the activity. This type of fragment can not be replaced during the run time.\n‚Ä¢ FragmentManager is used to embed fragments with activities that enable the addition, deletion, or replacement of fragments at run time.\n\nAlmost all android app uses dynamic addition of fragments as it improves the user experience. Below is the step-by-step implementation of adding 2 fragments in one activity. A default fragment will be visible when the activity appears on the screen and the user can switch between the 2 fragments at the run time.\n‚Ä¢ None Click on File, then New => New Project.\n‚Ä¢ None Select the minimum SDK as per your need.\n\nAll the strings which are used in the activity are listed in this file\n\nOpen the activity_main.xml file and add 2 buttons to it which will be used to switch between the 2 fragments. Further, add the fragment element in the activity layout. It is the area in which the fragments in android will be displayed.\n\nThese files contain only the onCreateView() method to inflate the UI of the fragment and returns the root of the fragment layout. If the fragment does not have any UI, it will return null.\n\nStep 5: Creating Layouts for both the fragments\n\nCreate two Layout Resource Files for both the fragments. Fragment displays a text on the screen and have a background color to differentiate their area in the Activity layout. Below is the code to implement this layout.\n\nNow, the functionality of the button to perform operations on clicking will be defined in the MainActivity class. Moreover, the code for the replacement of fragments during run time is also mentioned in this file. Below is the code to implement this step."
    },
    {
        "link": "https://stackoverflow.com/questions/58438949/how-to-get-lifecycleowner-in-a-fragment",
        "document": "I need to get the LifecycleOwner to pass it in my FirestoreRecyclerViewOption but Fragment doesn't implement Lifecycle.\n\nSo, how to get that?\n\nMy Fragment implements LifecycleOnwer as shown in the following code example,\n\nafter in the onCreateMethod,\n\nI follow this example but it doesn't work\n\nI need it to edit My FirestoreRecyclerViewOption and setLifeCycleOwner because it is always null and I have an NullPointer everytime."
    },
    {
        "link": "https://developer.android.com/topic/libraries/view-binding",
        "document": "Save and categorize content based on your preferences.\n\nView binding is a feature that makes it easier to write code that interacts with views. Once view binding is enabled in a module, it generates a binding class for each XML layout file present in that module. An instance of a binding class contains direct references to all views that have an ID in the corresponding layout.\n\nView binding is enabled on a module-by-module basis. To enable view binding in a module, set the build option to in the module-level file, as shown in the following example:\n\nIf you want a layout file to be ignored while generating binding classes, add the attribute to the root view of that layout file:\n\nIf view binding is enabled for a module, a binding class is generated for each XML layout file that the module contains. Each binding class contains references to the root view and all views that have an ID. The name of the binding class is generated by converting the name of the XML file to Pascal case and adding the word \"Binding\" to the end.\n\nFor example, consider a layout file called that contains the following:\n\nThe generated binding class is called . This class has two fields: a called and a called . The in the layout has no ID, so there is no reference to it in the binding class.\n\nEvery binding class also includes a method, providing a direct reference for the root view of the corresponding layout file. In this example, the method in the class returns the root view.\n\nThe following sections demonstrate the use of generated binding classes in activities and fragments.\n\nTo set up an instance of the binding class for use with an activity, perform the following steps in the activity's method:\n‚Ä¢ Call the static method included in the generated binding class. This creates an instance of the binding class for the activity to use.\n‚Ä¢ Get a reference to the root view by either calling the method or using Kotlin property syntax.\n‚Ä¢ Pass the root view to to make it the active view on the screen.\n\nThese steps are shown in the following example:\n\nYou can now use the instance of the binding class to reference any of the views:\n\nTo set up an instance of the binding class for use with a fragment, perform the following steps in the fragment's method:\n‚Ä¢ Call the static method included in the generated binding class. This creates an instance of the binding class for the fragment to use.\n‚Ä¢ Get a reference to the root view by either calling the method or using Kotlin property syntax.\n‚Ä¢ Return the root view from the method to make it the active view on the screen.\n\nYou can now use the instance of the binding class to reference any of the views:\n\nWhen you declare views across multiple configurations, it occasionally makes sense to use a different view type depending on the particular layout. The following code snippet shows an example of this:\n\nIn this case, you might expect the generated class to expose a field of type , because is the common base class. Due to technical limitations, the view binding code generator can't determine this and generates a field instead. This requires casting the field later with .\n\nTo work around this limitation, view binding supports a attribute, letting you tell the compiler what type to use in the generated code. In the previous example, you can use this attribute to make the compiler generate the field as a :\n\nIn another example, suppose you have two layouts, one that contains a and another that contains a . Both classes extend , which contains most of the implementation details. If your code doesn't need to know exactly which subclass is present in the current layout, you can use to set the generated type to in both layouts:\n\nView binding can't validate the value of this attribute when generating code. To avoid compile-time and runtime errors, the value must meet the following conditions:\n‚Ä¢ The value must be a class that inherits from .\n‚Ä¢ None The value must be a superclass of the tag it is placed on. For example, the following values don't work: <TextView tools:viewBindingType=\"ImageView\" /> <!-- ImageView is not related to TextView. --> <TextView tools:viewBindingType=\"Button\" /> <!-- Button is not a superclass of TextView. -->\n‚Ä¢ None The final type must resolve consistently across all configurations.\n\nView binding has important advantages over using :\n‚Ä¢ Null safety: since view binding creates direct references to views, there's no risk of a null pointer exception due to an invalid view ID. Additionally, when a view is only present in some configurations of a layout, the field containing its reference in the binding class is marked with .\n‚Ä¢ Type safety: the fields in each binding class have types matching the views they reference in the XML file. This means there's no risk of a class cast exception.\n\nThese differences mean incompatibilities between your layout and your code result in your build failing at compile time rather than at runtime.\n\nView binding and data binding both generate binding classes that you can use to reference views directly. However, view binding is intended to handle simpler use cases and provides the following benefits over data binding:\n‚Ä¢ Faster compilation: view binding requires no annotation processing, so compile times are faster.\n‚Ä¢ Ease of use: view binding doesn't require specially tagged XML layout files, so it's faster to adopt in your apps. Once you enable view binding in a module, it applies to all of that module's layouts automatically.\n\nOn the other hand, view binding has the following limitations compared to data binding:\n‚Ä¢ View binding doesn't support layout variables or layout expressions, so it can't be used to declare dynamic UI content straight from XML layout files.\n\nBecause of these considerations, in some cases it's best to use both view binding and data binding in a project. You can use data binding in layouts that require advanced features and use view binding in layouts that don't.\n\nTo learn more about view binding, see the following additional resources:"
    },
    {
        "link": "https://developer.android.com/topic/libraries/data-binding",
        "document": "Save and categorize content based on your preferences.\n\nThe Data Binding Library is a support library that allows you to bind UI components in your layouts to data sources in your app using a declarative format rather than programmatically.\n\nLayouts are often defined in activities with code that calls UI framework methods. For example, the code below calls to find a widget and bind it to the property of the variable:\n\nThe following example shows how to use the Data Binding Library to assign text to the widget directly in the layout file. This removes the need to call any of the Java code shown above. Note the use of syntax in the assignment expression:\n\nBinding components in the layout file lets you remove many UI framework calls in your activities, making them simpler and easier to maintain. This can also improve your app's performance and help prevent memory leaks and null pointer exceptions.\n\nUse the following pages to learn how to use the Data Binding Library in your Android apps.\n\nThe expression language allows you to write expressions that connect variables to the views in the layout. The Data Binding Library automatically generates the classes required to bind the views in the layout with your data objects. The library provides features such as imports, variables, and includes that you can use in your layouts. These features of the library coexist seamlessly with your existing layouts. For example, the binding variables that can be used in expressions are defined inside a element that is a sibling of the UI layout's root element. Both elements are wrapped in a tag, as shown in the following example:"
    },
    {
        "link": "https://medium.com/@rchaitanya/android-view-binding-9aed11f2796f",
        "document": "View binding feature enables you to write code that interacts with views. Once view binding is enabled in a module, it generates a binding class for each XML layout file present in that module. An instance of a binding class contains direct references to all views that have an ID in the corresponding layout.\n\nAdd below setup in app module build.gradle file. If you are using multi module then you need to add this in all the modules gradle files\n\nAfter above declaration, sync the project\n\nHow to use\n\nIf view binding is enabled for a module, a binding class is generated for each XML layout file that the module contains.\n\nFor example, if you have below layout with file name activity_main.xml\n\nThe name of the binding class is generated by converting the name of the XML file to Pascal case and adding the word ‚ÄúBinding‚Äù to the end.\n\nFor this layout, generated class name will be ActivityMainBinding\n\nThis class has two fields: a called and a called . The in the layout has no ID, so there is no reference to it in the binding class.\n\nYou can now use the instance of the binding class to reference any of the views:\n\nWhen you have different configurations\n\nSometimes you may have to use different views with same id in different configuration\n\nTo handle above cases, you need to provide viewBindingType in XML\n\nFor more use cases and limitations, refer official documentation\n\nView binding has important advantages over using :\n‚Ä¢ Null safety: since view binding creates direct references to views, there‚Äôs no risk of a null pointer exception due to an invalid view ID. Additionally, when a view is only present in some configurations of a layout, the field containing its reference in the binding class is marked with .\n‚Ä¢ Type safety: the fields in each binding class have types matching the views they reference in the XML file. This means there‚Äôs no risk of a class cast exception.\n\nView binding and data binding both generate binding classes that you can use to reference views directly. However, view binding is intended to handle simpler use cases and provides the following benefits over data binding:\n‚Ä¢ Faster compilation: view binding requires no annotation processing, so compile times are faster.\n‚Ä¢ Ease of use: view binding doesn‚Äôt require specially tagged XML layout files, so it‚Äôs faster to adopt in your apps. Once you enable view binding in a module, it applies to all of that module‚Äôs layouts automatically.\n\nOn the other hand, view binding has the following limitations compared to data binding:\n‚Ä¢ View binding doesn‚Äôt support layout variables or layout expressions, so it can‚Äôt be used to declare dynamic UI content straight from XML layout files.\n\nBecause of these considerations, in some cases it‚Äôs best to use both view binding and data binding in a project. You can use data binding in layouts that require advanced features and use view binding in layouts that don‚Äôt."
    },
    {
        "link": "https://dev.to/slowburn404/how-to-implement-view-binding-in-android-45p9",
        "document": "On the 23rd of November 2020, Google announced that Kotlin Synthetics had been deprecated where the method was used to find an existing view in your XML layout by it's attribute. Enter View Binding.\n\nIf you're like me, you often have to go back to the official documentation and read on how to integrate this into your project. I wrote this article as a quick reference for future me and probably youüòâ.\n\nIn your tool window bar, switch to Project View and under Gradle Scripts, in the app module, select the build.gradle file and set the to as shown below:\n\n\n\nBehind the scenes, a binding class is generated for all the XML layout files. Each binding class holds references to the root view and all views that possess an ID. The name of the binding class comes from the name of the XML file. The name is changed to a special format called Pascal case and the word \"Binding\" is added to the end.\n\n Suppose you have a layout file named ;\n\n\n\nThe generated class will be named with a named .\n\nIn the file, add the following code or adjust accordingly:\n\n\n\nYou can use the binding class to access any of the views now.\n\n\n\nSuppose you have a fragment named with a layout file . Add the following code or adjust accordingly:\n\n\n\nThat's just about it, you can get an in depth look in the official documentation and a practical tutorial here."
    },
    {
        "link": "https://developer.android.com/topic/libraries/data-binding/generated-binding",
        "document": "The Data Binding Library generates binding classes you can use to access the layout's variables and views. This documentation shows how to create and customize generated binding classes.\n\nThe generated binding class links the layout variables with the views within the layout. You can customize the name and package of the binding. All generated binding classes inherit from the class.\n\nA binding class is generated for each layout file. By default, the name of the class is the name of the layout file converted to Pascal case with the Binding suffix added to it. So, for example, if the layout filename is , the corresponding generated class is . This class holds all the bindings from the layout properties to the layout's views and knows how to assign values for the binding expressions.\n\nThe binding object is created immediately after inflating the layout to make sure the view hierarchy isn't modified before it binds to the views with expressions within the layout. The most common method to bind the object to a layout is to use the static methods on the binding class. You can inflate the view hierarchy and bind the object to it by using the method of the binding class, as shown in the following example:\n\nThere is an alternate version of the method that takes a object in addition to the object , as shown in the following example:\n\nIf the layout is inflated using a different mechanism, you can bind it separately, as follows:\n\nSometimes you don't know the binding type in advance. In such cases, you can create the binding using the class, as demonstrated in the following code snippet:\n\nIf you are using data binding items inside a , , or adapter, you might prefer to use the methods of the bindings classes or the class, as shown in the following code example:\n\nThe Data Binding Library creates an immutable field in the binding class for each view that has an ID in the layout. For example, the Data Binding Library creates the and fields of type from the following layout:\n\nThe library extracts the views, including the IDs, from the view hierarchy in a single pass. This mechanism can be faster than calling the method for every view in the layout.\n\nIDs aren't as necessary as they are without data binding, but there are still some instances where access to views is necessary from code.\n\nThe Data Binding Library generates accessor methods for each variable declared in the layout. For example, the following layout generates setter and getter methods in the binding class for the , , and variables:\n\nUnlike normal views, objects start as invisible views. When they are made visible or are explicitly inflated, they replace themselves in the layout by inflating another layout.\n\nBecause the disappears from the view hierarchy, the view in the binding object must also disappear to let it be claimed by garbage collection. Because the views are final, a object takes the place of the in the generated binding class, giving you access to the when it exists and access to the inflated view hierarchy when the is inflated.\n\nWhen inflating another layout, a binding must establish for the new layout. Therefore, the must listen to the and establish the binding when required. Since only one listener can exist at a time, the lets you set an , which it calls after establishing the binding.\n\nWhen a variable or observable object changes, the binding is scheduled to change before the next frame. There are times, however, when binding must be executed immediately. To force execution, use the method.\n\nAt times, the specific binding class is unknown. For example, a operating against arbitrary layouts doesn't know the specific binding class. It must assign the binding value during the call to the method.\n\nIn the following example, all layouts that the binds to have an variable. The object has a method returning the base class.\n\nYou can change your data model in a background thread as long as it isn't a collection. Data binding localizes each variable or field during evaluation to avoid any concurrency issues.\n\nBy default, a binding class is generated based on the name of the layout file, starting with an uppercase letter, removing underscores ( _ ), capitalizing the following letter, and suffixing the word Binding. For example, the layout file generates the class. The class is placed in a package under the module package. For example, if the module package is , then the binding class is placed in the package.\n\nBinding classes can be renamed or placed in different packages by adjusting the attribute of the element. For example, the following layout generates the binding class in the package in the current module:\n\nYou can generate the binding class in a different package by prefixing the class name with a period. The following example generates the binding class in the module package:\n\nYou can also use the full package name where you want the binding class to be generated. The following example creates the binding class in the package:\n\nTo learn more about data binding, see the following additional resources."
    }
]